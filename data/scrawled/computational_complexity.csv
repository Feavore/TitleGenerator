URL,Title,Abstract,Introduction
https://arxiv.org/html/2411.04953v1,Quantum Threshold is Powerful,"In 2005, HÃ¸yer and Å palek showed that constant-depth quantum circuits augmented with multi-qubit Fanout gates are quite powerful, able to compute a wide variety of Boolean functions as well as the quantum Fourier transform. They also asked what other multi-qubit gates could rival Fanout in terms of computational power, and suggested that the quantum Threshold gate might be one such candidate. Threshold is the gate that indicates if the Hamming weight of a classical basis state input is greater than some target value.We prove that Threshold is indeed powerfulâ€”there are polynomial-size constant-depth quantum circuits with Threshold gates that compute Fanout to high fidelity. Our proof is a generalization of a proof by Rosenthal that exponential-size constant-depth circuits with generalized Toffoli gates can compute Fanout. Our construction reveals that other quantum gates able to â€œweakly approximateâ€ Parity can also be used as substitutes for Fanout.","To what extent are large multi-qubit gates useful for quantum computation? On the one hand, it is well-known that every multi-qubit gate can be decomposed into a circuit of simpler 1111- and 2222-qubit gates. On the other hand, this decomposition may introduce large overheads both in terms of gate count and circuit depth. Given that some multi-qubit gates might be experimentally feasible [22, 14, 16], itâ€™s natural to ask what kinds of computational powers they unlock. Specifically, we focus on the power of these large multi-qubit gates in constant depth. Such shallow circuits are experimentally appealing due to the possibility for less decoherence. Moreover, even shallow quantum circuits with 1111- and 2222-qubit gates are known to be surprisingly powerful, exhibiting quantum advantage in a variety of settings [4, 9, 25, 11]. Given the inherent complexity of simulating such circuits, there is the exciting possibility that augmenting these circuit models with large multi-qubit gates might lead to constant-depth implementations of practical quantum algorithms. Much of the excitement about such circuit models is driven by a single gateâ€”the multi-qubit Fanout gateâ€”which is the quantum operation that copies classical information: ğ–¥nâ¢\ketâ¢b,x1,â€¦,xn:=\ketâ¢b,x1âŠ•b,â€¦,xnâŠ•bformulae-sequenceassignsubscriptğ–¥ğ‘›\ketğ‘subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›\ketğ‘direct-sumsubscriptğ‘¥1ğ‘â€¦direct-sumsubscriptğ‘¥ğ‘›ğ‘\mathsf{F}_{n}\ket{b,x_{1},\ldots,x_{n}}:=\ket{b,x_{1}\oplus b,\ldots,x_{n}% \oplus b}sansserif_F start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT italic_b , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT := italic_b , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŠ• italic_b , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT âŠ• italic_b for all b,x1,â€¦,xnâˆˆ{0,1}ğ‘subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›01b,x_{1},\ldots,x_{n}\in\{0,1\}italic_b , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT âˆˆ { 0 , 1 }. This seemingly innocuous gate (which is included for free in almost every classical circuit model) turns out to be quite powerful. For starters, it is locally equivalent via conjugation by Hadamard gates to the quantum Parity gate [17], ğ–¯nâ¢\ketâ¢b,x1,â€¦,xn:=\ketâ¢bâŠ•(x1âŠ•â‹¯âŠ•xn),x1,â€¦,xn,formulae-sequenceassignsubscriptğ–¯ğ‘›\ketğ‘subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›direct-sum\ketğ‘direct-sumsubscriptğ‘¥1â‹¯subscriptğ‘¥ğ‘›subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›\mathsf{P}_{n}\ket{b,x_{1},\ldots,x_{n}}:=\ket{b\oplus(x_{1}\oplus\cdots\oplus x% _{n}),x_{1},\ldots,x_{n}},sansserif_P start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT italic_b , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT := italic_b âŠ• ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŠ• â‹¯ âŠ• italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , which is a duality that has no classical counterpart [1]. Moreover, there are constant-depth quantum circuits with Fanout (and arbitrary single-qubit gates) for a wide variety of other symmetric Boolean operations such as And/Or and Majority [13, 24]. Perhaps most impressively, constant-depth quantum circuits with Fanout gates can factor integers with polynomial-time classical post-processing [13]. Given the centrality of Fanout to the story of low-depth circuits with multi-qubit gates, there has been significant work in trying to understand if other multi-qubit gates are similarly powerful. Most notably, it is widely believed that the multi-qubit generalization of the Toffoli gate is fundamentally less powerful than the Fanout gate in constant depth, and there is long line of work giving evidence that these generalized Toffoli gates cannot compute Fanout [3, 6, 21, 19, 18, 2]. In some sense, all of these results are grappling with a fundamental tension in the study of these low-depth circuit modelsâ€”the high entanglement in the states produced by these circuits is an obstacle to proving lower bounds, but it is simultaneously unclear how one could leverage this complexity to implement a useful quantum algorithm. There is a surprising dearth of low-depth circuit models with multi-qubit gates that are as powerful as Fanout. One natural111This candidate looks considerably more natural after considering the analogous landscape of classical circuits, which we discuss in Section 1.1. candidate for a gate that could be as powerful as Fanout is the quantum Threshold gate, a multi-qubit gate parameterized by some value kâˆˆâ„•ğ‘˜â„•k\in\mathbb{N}italic_k âˆˆ blackboard_N: ğ–³ğ—knâ¢\ketâ¢b,x1,â€¦,xn:=\ketâ¢bâŠ•ğ•€|x|â‰¥k,x1,â€¦,xnformulae-sequenceassignsubscriptsuperscriptğ–³ğ—ğ‘›ğ‘˜\ketğ‘subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›direct-sum\ketğ‘subscriptğ•€ğ‘¥ğ‘˜subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›\mathsf{Th}^{n}_{k}\ket{b,x_{1},\ldots,x_{n}}:=\ket{b\oplus\mathbb{I}_{|x|\geq k% },x_{1},\ldots,x_{n}}sansserif_Th start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT italic_b , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT := italic_b âŠ• blackboard_I start_POSTSUBSCRIPT | italic_x | â‰¥ italic_k end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT where ğ•€|x|â‰¥ksubscriptğ•€ğ‘¥ğ‘˜\mathbb{I}_{|x|\geq k}blackboard_I start_POSTSUBSCRIPT | italic_x | â‰¥ italic_k end_POSTSUBSCRIPT indicates if the Hamming weight of the input bit string x=x1â¢â‹¯â¢xnâˆˆ{0,1}nğ‘¥subscriptğ‘¥1â‹¯subscriptğ‘¥ğ‘›superscript01ğ‘›x=x_{1}\cdots x_{n}\in\{0,1\}^{n}italic_x = italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â‹¯ italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is at least the target value kğ‘˜kitalic_k. In fact, HÃ¸yer and Å palek asked almost 20 years ago about the power of Threshold in constant depth [13]: â€œCan we simulate unbounded fan-out in constant depth using unbounded fan-in gates, e.g. thresholdâ¡[t]thresholdğ‘¡\operatorname{threshold}[t]roman_threshold [ italic_t ] or exactâ¡[t]exactğ‘¡\operatorname{exact}[t]roman_exact [ italic_t ]?â€ This question was reiterated more pointedly by Takahashi and Tani in 2011 [24]: â€œDoes there exist a fundamental gate that is as powerful as an unbounded fan-out gate?â€ We directly answer both of these questions in the affirmative by giving explicit constructions for Fanout using quantum Threshold gates: Theorem 1. There are poly-size constant-depth quantum circuits consisting of Threshold gates and arbitrary single-qubit gates that compute Fanout with high fidelity. Formally, \ComplexityFontâ¢Bâ¢Qâ¢Tâ¢C0=\BQNCwâ¢f0\ComplexityFontğµğ‘„ğ‘‡superscriptğ¶0subscriptsuperscript\BQNC0ğ‘¤ğ‘“\ComplexityFont{BQTC}^{0}=\BQNC^{0}_{wf}italic_B italic_Q italic_T italic_C start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT = start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_w italic_f end_POSTSUBSCRIPT. The construction from this theorem actually reveals a number of other gates that are as fundamentally powerful as the Fanout gate. As it turns out, the salient feature of Threshold for our purposes is that it can be used to construct a sort of â€œweakâ€ Parity gateâ€”a gate that only acts non-trivially on inputs of the same parity. Based on this idea, we introduce a class of multi-qubit phase gates that exhibit a generalization of this behavior. Formally, these gates are defined with respect to a set SâŠ‚{0,1}nğ‘†superscript01ğ‘›S\subset\{0,1\}^{n}italic_S âŠ‚ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT in the following way: USâ¢\ketâ¢x1,â€¦,xn:=(âˆ’1)ğ•€xâˆˆSâ¢\ketâ¢x1,â€¦,xn.formulae-sequenceassignsubscriptğ‘ˆğ‘†\ketsubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›superscript1subscriptğ•€ğ‘¥ğ‘†\ketsubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›U_{S}\ket{x_{1},\ldots,x_{n}}:=(-1)^{\mathbb{I}_{x\in S}}\ket{x_{1},\ldots,x_{% n}}.italic_U start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT := ( - 1 ) start_POSTSUPERSCRIPT blackboard_I start_POSTSUBSCRIPT italic_x âˆˆ italic_S end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT . Crucially, we restrict our attention to â€œparity-restrictedâ€ sets Sğ‘†Sitalic_S, that is, sets where all elements have the same parity (i.e., x,yâˆˆSâŸ¹|x|â‰¡|y|(mod2)ğ‘¥ğ‘¦ğ‘†ğ‘¥annotatedğ‘¦pmod2x,y\in S\implies|x|\equiv|y|\pmod{2}italic_x , italic_y âˆˆ italic_S âŸ¹ | italic_x | â‰¡ | italic_y | start_MODIFIER ( roman_mod start_ARG 2 end_ARG ) end_MODIFIER). We show that these weak parity gates can be bootstrapped in constant depth into true Parity gates (which, recall, are locally-equivalent to Fanout) albeit with the help of a few generalized Toffoli gates: Theorem 2. Let {Sn}nsubscriptsubscriptğ‘†ğ‘›ğ‘›\{S_{n}\}_{n}{ italic_S start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT be a family of parity-restricted sets with size |Sn|=Î˜â¢(2n/\polyâ¢(n))subscriptğ‘†ğ‘›Î˜superscript2ğ‘›\polyğ‘›|S_{n}|=\Theta(2^{n}/\poly(n))| italic_S start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT | = roman_Î˜ ( 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT / ( italic_n ) ). There are poly-size constant-depth quantum circuits consisting of USnsubscriptğ‘ˆsubscriptğ‘†ğ‘›U_{S_{n}}italic_U start_POSTSUBSCRIPT italic_S start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT gates, generalized Toffoli gates, and arbitrary single-qubit gates that compute Fanout with high fidelity. Since it is widely believed that multi-qubit Toffoli gates are not themselves sufficient to implement Fanout, the power of this construction likely derives from the weak parity gates. In fact, the reason these Toffoli gates were not required for Theorem 1 is due to the fact that Threshold can directly simulate Toffoli. In that vein, we also give conditions under which the USnsubscriptğ‘ˆsubscriptğ‘†ğ‘›U_{S_{n}}italic_U start_POSTSUBSCRIPT italic_S start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT gates alone suffice to simulate Parity; namely, when |Sn|â‰¥2nâˆ’Oâ¢(1)subscriptğ‘†ğ‘›superscript2ğ‘›ğ‘‚1|S_{n}|\geq 2^{n-O(1)}| italic_S start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT | â‰¥ 2 start_POSTSUPERSCRIPT italic_n - italic_O ( 1 ) end_POSTSUPERSCRIPT or |Sn|â‰¤2(1âˆ’Ïµ)â¢nsubscriptğ‘†ğ‘›superscript21italic-Ïµğ‘›|S_{n}|\leq 2^{(1-\epsilon)n}| italic_S start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT | â‰¤ 2 start_POSTSUPERSCRIPT ( 1 - italic_Ïµ ) italic_n end_POSTSUPERSCRIPT. Though, the later condition will result in circuits of super-polynomial size. While it has long been thought that Fanout/Parity gates were morally equivalent to other quantum modular arithmetic gates, those constructions seem to also require these generalized Toffoli gates [8]. By a careful inspection of the original construction presented in [8] we find that generalized Toffoli gates are in fact not necessary. Formally, the quantum Mod-pğ‘pitalic_p gates is defined as ğ–¬ğ–®ğ–£pnâ¢\ketâ¢b,x1,â€¦,xn:=\ketâ¢bâŠ•\Modpnâ¢(x),x1,â€¦,xn,formulae-sequenceassignsuperscriptsubscriptğ–¬ğ–®ğ–£ğ‘ğ‘›\ketğ‘subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›direct-sum\ketğ‘superscriptsubscript\Modğ‘ğ‘›ğ‘¥subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›\mathsf{MOD}_{p}^{n}\ket{b,x_{1},\ldots,x_{n}}:=\ket{b\oplus\Mod_{p}^{n}(x),x_% {1},\ldots,x_{n}},sansserif_MOD start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_b , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT := italic_b âŠ• start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_x ) , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , where \Modpnâ¢(x)superscriptsubscript\Modğ‘ğ‘›ğ‘¥\Mod_{p}^{n}(x)start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_x ) is 1111 when pğ‘pitalic_p divides the Hamming weight of x=x1,â‹¯,xnâˆˆ{0,1}nformulae-sequenceğ‘¥subscriptğ‘¥1â‹¯subscriptğ‘¥ğ‘›superscript01ğ‘›x=x_{1},\cdots,x_{n}\in\{0,1\}^{n}italic_x = italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â‹¯ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. For example, the Mod-2222 gate is essentially the Parity gate (up to a single-qubit Xğ‘‹Xitalic_X gate). It is implicit in [8] that Fanout can be computed by a circuit consisting of Mod-pğ‘pitalic_p gates and one- and two-qubit gates, yielding \QNCwâ¢f0=\QNC0â¢[2]âŠ†\QNC0â¢[q]subscriptsuperscript\QNC0ğ‘¤ğ‘“superscript\QNC0delimited-[]2superscript\QNC0delimited-[]ğ‘\QNC^{0}_{wf}=\QNC^{0}[2]\subseteq\QNC^{0}[q]start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_w italic_f end_POSTSUBSCRIPT = start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ 2 ] âŠ† start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_q ] for all qâ‰¥2ğ‘2q\geq 2italic_q â‰¥ 2, but not necessarily that \QNC0â¢[p]=\QNC0â¢[q]superscript\QNC0delimited-[]ğ‘superscript\QNC0delimited-[]ğ‘\QNC^{0}[p]=\QNC^{0}[q]start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_p ] = start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_q ] for distinct pğ‘pitalic_p and qğ‘qitalic_q. The result they make explicit is that when Toffoli gates are allowed, any Mod-qğ‘qitalic_q gate can be obtained using any other Mod-pğ‘pitalic_p gate (by first implementing Fanout with Mod-qğ‘qitalic_q gates and then computing Mod-pğ‘pitalic_p with Fanout and generalized Toffoli gates). Concretely; \QAC0â¢[p]=\QAC0â¢[q]superscript\QAC0delimited-[]ğ‘superscript\QAC0delimited-[]ğ‘\QAC^{0}[p]=\QAC^{0}[q]start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_p ] = start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_q ] for p,qâ‰¥2ğ‘ğ‘2p,q\geq 2italic_p , italic_q â‰¥ 2. Only later was it shown that generalized Toffoli gates can be implemented using Fanout and single- and two-qubit gates i.e. that \QNCwâ¢f0=\QACwâ¢f0subscriptsuperscript\QNC0ğ‘¤ğ‘“subscriptsuperscript\QAC0ğ‘¤ğ‘“\QNC^{0}_{wf}=\QAC^{0}_{wf}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_w italic_f end_POSTSUBSCRIPT = start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_w italic_f end_POSTSUBSCRIPT [13, 24]. In light of these results we observe the following: Theorem 3. For all p,qâ‰¥2ğ‘ğ‘2p,q\geq 2italic_p , italic_q â‰¥ 2, there are poly-size constant-depth quantum circuits consisting of Mod-pğ‘pitalic_p gates and single-qubit gates that compute the Mod-qğ‘qitalic_q operation. Formally, \QNC0â¢[p]=\QNC0â¢[q]superscript\QNC0delimited-[]ğ‘superscript\QNC0delimited-[]ğ‘\QNC^{0}[p]=\QNC^{0}[q]start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_p ] = start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_q ]. 1.1 Comparison to the classical setting Our focus on shallow circuits draws considerable inspiration from the analogous study of classical constant-depth circuit classes with large fan-in gates, which has been hugely influential in classical complexity theory. For instance, initial work in Boolean circuits saw the development of techniques for proving unconditional lower bounds such as random restrictions [1, 7, 27, 12], Fourier analytic methods [15], and polynomial methods [20, 23]. So how do we compare the quantum and classical settings? And what does this comparison tell us about the power of quantum circuits in constant depth? To start, classical circuits classes (e.g., \NC0superscript\NC0\NC^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, \AC0superscript\AC0\AC^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, \TC0superscript\TC0\TC^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, â€¦) typically assume that the output of any gate can be used as input for any number of other other gates (i.e., a gateâ€™s output can be â€œfanned outâ€ to other gates). Of course, this is exactly the kind of fanout that immediately becomes so powerful when given to a constant-depth quantum circuit. In fact, because of this fanout, the classical Threshold gate reigns supreme amongst similar classical circuit complexity classes. This is due to the fact that constant-depth classical circuits with Fanout and Threshold can compute any Boolean function where the output depends only on the Hamming weight of the input.222To see this, first notice that for any kğ‘˜kitalic_k, there is a constant-depth circuit with two Threshold gates that computes whether or not the input has Hamming weight exactly kğ‘˜kitalic_k. Since any symmetric Boolean function can be expressed as a disjunction over these â€œexact-kğ‘˜kitalic_kâ€ clauses, the claim immediately follows due to the fact that a threshold of 1111 is equivalent to the Or function. Formally, the complexity class \TC0superscript\TC0\TC^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, which contains all languages computed by constant-depth classical circuits with Threshold, contains all other similarly defined classical circuit classes with other large fan-in gates: \NC0â¢[p]superscript\NC0delimited-[]ğ‘\NC^{0}[p]start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_p ], \AC0superscript\AC0\AC^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, \AC0â¢[p]superscript\AC0delimited-[]ğ‘\AC^{0}[p]start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_p ], and \ACC\ACC\ACC.333See Definition 14 for precise definitions. In many cases, Threshold is provably more powerful, e.g., \AC0âŠŠ\TC0superscript\AC0superscript\TC0\AC^{0}\subsetneq\TC^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT âŠŠ start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [1, 7] and \AC0â¢[p]âŠŠ\TC0superscript\AC0delimited-[]ğ‘superscript\TC0\AC^{0}[p]\subsetneq\TC^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [ italic_p ] âŠŠ start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [20, 23]. This is why the Threshold gate was a tantalizing target for quantum exploration. Prior to our work, it was not known whether the quantum version of \TC0superscript\TC0\TC^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPTâ€”i.e., \ComplexityFontâ¢Bâ¢Qâ¢Tâ¢C0\ComplexityFontğµğ‘„ğ‘‡superscriptğ¶0\ComplexityFont{BQTC}^{0}italic_B italic_Q italic_T italic_C start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPTâ€”was as powerful as the quantum versions of the other classical complexity classes. In fact, given the surprising power of Fanout in the quantum world, the exact opposite was known: \BQNCwâ¢f0âŠ‡\ComplexityFontâ¢Bâ¢Qâ¢Tâ¢C0\ComplexityFontğµğ‘„ğ‘‡superscriptğ¶0subscriptsuperscript\BQNC0ğ‘¤ğ‘“\BQNC^{0}_{wf}\supseteq\ComplexityFont{BQTC}^{0}start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_w italic_f end_POSTSUBSCRIPT âŠ‡ italic_B italic_Q italic_T italic_C start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [13]. That is, constant-depth quantum circuits with Fanout could simulate constant-depth circuits with Threshold. Our work restores order to the usually classical hierarchy, placing Threshold alongside Fanout as one of the most powerful quantum gates in constant depth: \ComplexityFontâ¢Bâ¢Qâ¢Tâ¢C0=\BQNCwâ¢f0\ComplexityFontğµğ‘„ğ‘‡superscriptğ¶0subscriptsuperscript\BQNC0ğ‘¤ğ‘“\ComplexityFont{BQTC}^{0}=\BQNC^{0}_{wf}italic_B italic_Q italic_T italic_C start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT = start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_w italic_f end_POSTSUBSCRIPT. 1.2 Proof techniques and overview The constructions in Theorem 1 and Theorem 2 follow a general outline pioneered by Rosenthal [21]. There, it is shown that constant-depth quantum circuits can compute Fanout using generalized Toffoli gates provided exponential-sized circuits are allowed. While not phrased in this language, Rosenthalâ€™s construction shows a proof-of-principle technique for taking a very â€œweakâ€ Parity gate (indeed, Toffoli non-trivially computes Parity for exactly one input!) and boosting it to a full Parity gate. We show that when we start with a gate (like Threshold) which is closer to Parity, this construction can be altered to yield circuits of polynomial size. The proof goes in two steps. First, define a certain cat-like state called a â€œnekomataâ€ [21]: \ketâ¢0nâŠ—\ketâ¢Ïˆ0+\ketâ¢1nâŠ—\ketâ¢Ïˆ12tensor-product\ketsuperscript0ğ‘›\ketsubscriptğœ“0tensor-product\ketsuperscript1ğ‘›\ketsubscriptğœ“12\frac{\ket{0^{n}}\otimes\ket{\psi_{0}}+\ket{1^{n}}\otimes\ket{\psi_{1}}}{\sqrt% {2}}divide start_ARG 0 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT âŠ— italic_Ïˆ start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT + 1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT âŠ— italic_Ïˆ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG where \ketâ¢Ïˆ0\ketsubscriptğœ“0\ket{\psi_{0}}italic_Ïˆ start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT and \ketâ¢Ïˆ1\ketsubscriptğœ“1\ket{\psi_{1}}italic_Ïˆ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT are arbitrary states. Following a similar idea to that of Green et al. [8], such states can be used to compute Parity in constant depth using the the relative phase between the \ketâ¢0n\ketsuperscript0ğ‘›\ket{0^{n}}0 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT and \ketâ¢1n\ketsuperscript1ğ‘›\ket{1^{n}}1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT part of the state. Second, show there is an explicit constant-depth construction for a nekomata state. Here, we show the key ingredient is the ability to create a â€œnoisyâ€ version of a usual cat state, where the all-zeroes and all-ones outcomes have noticeably larger amplitudes than those on the other outcomes. Threshold gates are significantly better at this task than the Toffoli gates in Rosenthalâ€™s original construction. Finally, these states can be combined together (using Toffoli or Threshold gates) to form a high-fidelity nekomata state, completing the construction. 1.3 Related work Our work shares some similarity to that of [10], where the authors explore quantum advantage with constant-depth quantum circuits. They also make a similar claim suggesting that \ComplexityFontâ¢Qâ¢Tâ¢C0=\QNCwâ¢f0\ComplexityFontğ‘„ğ‘‡superscriptğ¶0subscriptsuperscript\QNC0ğ‘¤ğ‘“\ComplexityFont{QTC}^{0}=\QNC^{0}_{wf}italic_Q italic_T italic_C start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT = start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_w italic_f end_POSTSUBSCRIPT, but crucially, their results hold in a circuit model with intermediate measurements and classical fanout. The classical fanout in their circuit model allows them to bootstrap the poor manâ€™s cat state construction of Bene Watts et al. [26] to construct an actual cat state, an idea that was also explored in [5]. To be clear, our circuit model and definition of \ComplexityFontâ¢Bâ¢Qâ¢Tâ¢C0\ComplexityFontğµğ‘„ğ‘‡superscriptğ¶0\ComplexityFont{BQTC}^{0}italic_B italic_Q italic_T italic_C start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT follows in a traditional line of work (e.g, [17, 8, 13, 24, 19, 21, 18]), where no such intermediate measurements or classical fanout is allowed. Therefore, we must use entirely different techniques. 1.4 Future directions One immediate open question left open by our work is whether the approximation error inherent in the construction used to prove Theorem 1 can be eliminated without incurring a size or depth blow-up. More generally, we ask which other conditions on a family of multi-qubit gates lead to powerful shallow circuits. One explicit approach would be to ask what properties of the sets Sğ‘†Sitalic_S parameterizing our phase gates USsubscriptğ‘ˆğ‘†U_{S}italic_U start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT are sufficient to compute Fanout. Is there something beyond being parity restricted? Another interesting question concerns the circuit complexity of restricted families of threshold functions. Specifically, consider the Exact-kğ‘˜kitalic_k gate, which indicates if the Hamming weight of the input is exactly kğ‘˜kitalic_k. Notice that Exact-kğ‘˜kitalic_k can be constructed from two Threshold gates. Moreover, for kâ‰ˆn/2ğ‘˜ğ‘›2k\approx n/2italic_k â‰ˆ italic_n / 2, Exact-kğ‘˜kitalic_k can be used to compute Threshold. This latter statement is not obvious and follows from the fact that our proof of Theorem 1 actually uses Exact gates rather than Threshold gates. However, for other values of kâ‰ªn/2much-less-thanğ‘˜ğ‘›2k\ll n/2italic_k â‰ª italic_n / 2, it is not simple to see how Exact-kğ‘˜kitalic_k could be used to simulate Exact-(k+1)ğ‘˜1(k+1)( italic_k + 1 )."
https://arxiv.org/html/2411.04874v1,Hardness of approximation for ground state problems,"After nearly two decades of research, the question of a quantum PCP theorem for quantum Constraint Satisfaction Problems (CSPs) remains wide open. As a result, proving QMA-hardness of approximation for ground state energy estimation, analogous to hardness of approximation for MAX-kğ‘˜kitalic_k-CSP, has remained elusive. (QMA is Quantum Merlin-Arthur, a quantum generalization of NP with a quantum proof and quantum verifier.) Recently, it was shown [Bittel, Gharibian, Kliesch, CCC 2023] that a natural problem involving variational quantum circuits is QCMA-hard to approximate within ratio N1âˆ’Ïµsuperscriptğ‘1italic-ÏµN^{1-\epsilon}italic_N start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT for any Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0 and Nğ‘Nitalic_N the input size. (Quantum Classical Merlin-Arthur is QMA, but with a classical proof.) Unfortunately, this problem was not related to quantum CSPs, leaving the question of hardness of approximation for quantum CSPs open.In this work, we show that if instead of focusing on ground state energies (analogous to the optimal number of satisfied clauses), one considers computing properties of the ground space (analogous to computing properties of the MAX-kğ‘˜kitalic_k-CSP solution space), QCMA-hardness of computing ground space properties can be shown. In particular, we show that it is (1) QCMA-complete within ratio N1âˆ’Ïµsuperscriptğ‘1italic-ÏµN^{1-\epsilon}italic_N start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT to approximate the Ground State Connectivity problem (GSCON), and (2) QCMA-hard within the same ratio to estimate the amount of entanglement of a local Hamiltonianâ€™s ground state, denoted Ground State Entanglement (GSE). As a bonus, a simplification of our construction yields NP-completeness of approximation for a natural kğ‘˜kitalic_k-SAT reconfiguration problem, to be contrasted with the recent PCP-based PSPACE-hardness of approximation results for a different definition of kğ‘˜kitalic_k-SAT reconfiguration [Karthik C.S. and Manurangsi, 2023, and Hirahara, Ohsaka, STOC 2024].","Boolean constraint satisfaction problems (CSPs) and their quantum generalization, local Hamiltonian problems, have enjoyed a close relationship over the last decade, both in terms of relevance and complexity. For starters, just as MAX-kğ‘˜kitalic_k-SAT is the canonical NP-complete problem for kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2, the kğ‘˜kitalic_k-local Hamiltonian problem (kğ‘˜kitalic_k-LH) is the canonical Quantum Merlin-Arthur (QMA)-complete problem for kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2 [KSV02, KR03, KKR06]. Likewise, whereas 2222-SAT can be solved in linear time and 3333-SAT is NP-complete, its analogous local Hamiltonian problem, dubbed Quantum kğ‘˜kitalic_k-SAT [Bra06], is linear-time solvable for k=2ğ‘˜2k=2italic_k = 2 [ASSZ16, BG16] and QMA1subscriptQMA1\textup{QMA}_{1}QMA start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-complete333QMA1subscriptQMA1\textup{QMA}_{1}QMA start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT is QMA with perfect completeness. for kâ‰¥3ğ‘˜3k\geq 3italic_k â‰¥ 3 [Bra06, GN13]. Fancy a quantum generalization of Schaefferâ€™s dichotomy theorem, which says that Boolean constraint satisfaction problems are either in P or NP-complete [Sch78]? Quantum CSPs have one of those too, stating that kğ‘˜kitalic_k-LH is either in P, NP-complete, StoqMA-complete, or QMA-complete [CM16]. Of course, the stars have not always aligned between classical and quantum CSPs â€” for example, while Max-2222-SAT on a 1D chain is efficiently solvable, 2222-LH on the line remains QMA-complete (for sufficiently large, but constant, local dimension) [AGIK09, HNN13], even when all constraints on the chain are identical (i.e. the translationally invariant setting) [GI09, BCO17]. But by and large, life in the world of classical versus quantum CSPs has been arguablyâ€¦peachy. That is, of course, until one brings up the topic of PCP theorems, or the closely related question of hardness of approximation. An infamous 2006 blog post issued the community a challenge: To establish a potential quantum PCP theorem. The blog also stated that the problem was expected to be hard, and this has indeed proven true. For it was not until 2022 that the field celebrated arguably its first major victory against the quantum PCP conjecture with the establishment of the No Low-Energy Trivial States (NLTS) theorem [FH14, ABN23]. For the first time, this gave (explicit) local Hamiltonians whose ground state energy could not be approximated by constant depth quantum circuits. This, in turn, is important, because if one believes NPâ‰ QMANPQMA\textup{NP}\neq\textup{QMA}NP â‰  QMA, then local Hamiltonians Hğ»Hitalic_H arising from any candidate quantum PCP theorem should not have â€œgoodâ€ NP witnesses, and constant-depth quantum circuits constitute one possible family of NP witnesses444This follows from a straightforward light-cone argument, since the local terms of Hğ»Hitalic_H each act only on kâˆˆOâ¢(1)ğ‘˜ğ‘‚1k\in O(1)italic_k âˆˆ italic_O ( 1 ) qubits.. With this said, it is unfortunately not clear how current NLTS constructions can be used to encode hard computational problems, leaving the question of hardness of approximation for QMA via a quantum PCP theorem open. Quantum hardness of approximation without a quantum PCP theorem. In this paper, we thus study the question â€” can one nevertheless obtain hardness of approximation for quantum complexity classes without a quantum PCP theorem? The answer is known to be yes. In 1999, Umans showed how to obtain classical hardness of approximation for the second level of the Polynomial Hierarchy, Î£2psuperscriptsubscriptÎ£2ğ‘\Sigma_{2}^{p}roman_Î£ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_p end_POSTSUPERSCRIPT, without utilizing a PCP theorem; rather, the construction utilized dispersers [Uma99]. By extending this approach to the quantum setting, the first quantum hardness of approximation result for a quantum complexity class was shown: The quantum SUCCINCT SET COVER problem is hard to approximate for a quantum generalization of the second level of the Polynomial Hierarchy, cq-â¢Î£2cq-subscriptÎ£2\textup{cq-}\Sigma_{2}cq- roman_Î£ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT [GK12b]. (cq-â¢Î£2cq-subscriptÎ£2\textup{cq-}\Sigma_{2}cq- roman_Î£ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is a bounded-error quantum generalization of Î£2psuperscriptsubscriptÎ£2ğ‘\Sigma_{2}^{p}roman_Î£ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_p end_POSTSUPERSCRIPT, where the existentially quantified proof is classical, and the universally quantified proof is quantum.) The shortcoming of this was that, unlike in the classical setting, quantum polynomial hierarchies (the plural is not a typo!) have not yet risen to the level of prominence of their classical cousin, PH; indeed, the area is in its infancy [Yam02, LG17, GSS+18, FGN23, GY24, AGKR24, agarwalOracleSeparationsQuantumClassical2024]. As a result, hardness of approximation for a more established class like QMA or one if its many variants (e.g. QCMA, QMA(2), etcâ€¦; see [Gha24] for a survey) would be preferable. Here, we focus on Quantum Classical Merlin-Arthur (QCMA) [AN02], arguably second in prominence behind QMA, and defined as QMA but with a classical proof. In [GK12b], it was observed that a simple modification to the cq-â¢Î£2cq-subscriptÎ£2\textup{cq-}\Sigma_{2}cq- roman_Î£ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-hardness results therein also yields QCMA-hardness of approximation for an artificial problem, Quantum Monotone Minimum Satisfying Assignment (QMSA, Definition 5). Building on this, the first natural hardness of approximation result for QCMA was given [BGK23], namely for the problem of estimating the optimal depth of a variational quantum circuit (MIN-VQA). Local Hamiltonians, ground spaces, and GSCON. This brings us full circle to the starting theme of this paper â€” CSPs. Specifically, MIN-VQA is not related to a quantum CSP. So, can one show QCMA-hardness of approximation for a natural computational problem for quantum CSPs? To answer this, recall first that a kğ‘˜kitalic_k-local Hamiltonian is an nğ‘›nitalic_n-qubit 2nÃ—2nsuperscript2ğ‘›superscript2ğ‘›2^{n}\times 2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT Ã— 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT complex Hermitian matrix Hğ»Hitalic_H with a succinct representation H=âˆ‘iHiğ»subscriptğ‘–subscriptğ»ğ‘–H=\sum_{i}H_{i}italic_H = âˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_H start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, where analogous to a MAX-kğ‘˜kitalic_k-SAT clause acting on kğ‘˜kitalic_k out of n bits, each Hisubscriptğ»ğ‘–H_{i}italic_H start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is a Hermitian matrix or clause acting non-trivially on some subset of kğ‘˜kitalic_k out of nğ‘›nitalic_n qubits. The problem kğ‘˜kitalic_k-LH then asks, given Hğ»Hitalic_H, to estimate the ground state energy, i.e. the smallest eigenvalue Î»minâ¢(H)subscriptğœ†ğ»\lambda_{\min}(H)italic_Î» start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT ( italic_H ). The corresponding set of optimal quantum assignments then form the ground space, i.e. the span of eigenvectors |ÏˆâŸ©âˆˆâ„‚2nketğœ“superscriptâ„‚superscript2ğ‘›|\psi\rangle\in{\mathbb{C}}^{2^{n}}| italic_Ïˆ âŸ© âˆˆ blackboard_C start_POSTSUPERSCRIPT 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT with eigenvalue Î»minâ¢(H)subscriptğœ†ğ»\lambda_{\min}(H)italic_Î» start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT ( italic_H ). The quantum CSP formulation of the quantum PCP conjecture [AAV13] then posits555For clarity, in this formulation we are assuming that Hğ»Hitalic_H is rescaled so that â€–Hâ€–â‰¤1normğ»1\left\|\,H\,\right\|\leq 1âˆ¥ italic_H âˆ¥ â‰¤ 1, for âˆ¥â‹…âˆ¥\left\|\,\cdot\,\right\|âˆ¥ â‹… âˆ¥ the spectral norm. that it is QMA-hard to decide if for positive semidefinite Hğ»Hitalic_H, Î»minâ¢(H)=0subscriptğœ†ğ»0\lambda_{\min}(H)=0italic_Î» start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT ( italic_H ) = 0 or Î»minâ‰¥csubscriptğœ†ğ‘\lambda_{\min}\geq citalic_Î» start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT â‰¥ italic_c for some fixed constant c>0ğ‘0c>0italic_c > 0, under the promise that one of these cases holds. As stated above, however, resolving this conjecture remains a difficult challenge. Here, we show that by instead focusing on the natural problem of computing properties of the ground space (i.e. the space of optimal solutions), as opposed to the ground state energy (i.e the value attained by all optimal solutions), QCMA-hardness of approximation can be achieved. Results. We now introduce the two and a â€œhalfâ€ computational problems we study, and state our results. The first of these, GSCON, also has a natural classical counterpart from the classical study of reconfiguration problems [GKMP09], for which we show an analogous NP-hardness of approximation result; this is the â€œhalfâ€ we refer to above. Result 1: Ground State Connectivity (GSCON). Introduced in [GS15], Ground State Connectivity (Definition 2) is the physically motivated problem of deciding if the ground space of Hğ»Hitalic_H has an energy barrier. The input is a kğ‘˜kitalic_k-local Hamiltonian Hğ»Hitalic_H, two ground states |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© and |Ï•âŸ©ketitalic-Ï•|\phi\rangle| italic_Ï• âŸ© (specified via quantum circuits), and natural number mğ‘šmitalic_m. The output is whether there exists a sequence of at most mğ‘šmitalic_m 2222-local unitary gates (U1,U2,â€¦â¢Um)subscriptğ‘ˆ1subscriptğ‘ˆ2â€¦subscriptğ‘ˆğ‘š(U_{1},U_{2},\ldots U_{m})( italic_U start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_U start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , â€¦ italic_U start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT ), such that two properties hold: 1. (the unitary sequence maps |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© to |Ï•âŸ©ketitalic-Ï•|\phi\rangle| italic_Ï• âŸ©) Umâ¢â‹¯â¢U2â¢U1â¢|ÏˆâŸ©â‰ˆ|Ï•âŸ©subscriptğ‘ˆğ‘šâ‹¯subscriptğ‘ˆ2subscriptğ‘ˆ1ketğœ“ketitalic-Ï•U_{m}\cdots U_{2}U_{1}|\psi\rangle\approx|\phi\rangleitalic_U start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT â‹¯ italic_U start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_U start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | italic_Ïˆ âŸ© â‰ˆ | italic_Ï• âŸ©, and 2. (all intermediate states are ground states) for all iâˆˆ[m]ğ‘–delimited-[]ğ‘ši\in[m]italic_i âˆˆ [ italic_m ], |ÏˆiâŸ©:=Uiâ¢â‹¯â¢U1â¢|ÏˆâŸ©assignketsubscriptğœ“ğ‘–subscriptğ‘ˆğ‘–â‹¯subscriptğ‘ˆ1ketğœ“|\psi_{i}\rangle:=U_{i}\cdots U_{1}|\psi\rangle| italic_Ïˆ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âŸ© := italic_U start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‹¯ italic_U start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | italic_Ïˆ âŸ© is a ground state of Hğ»Hitalic_H. Originally shown QCMA-complete for k=5ğ‘˜5k=5italic_k = 5 [GS15], it was subsequently found that, surprisingly666This is in contrast to the fact that kğ‘˜kitalic_k-LH for commuting Hamiltonians is not known to remain QMA-hard, and in fact is in NP for certain cases [BV05, AE11, Sch11, AKV18, IJ23]., GSCON remains QCMA-complete even on Hamiltonians with pairwise commuting terms [GMV17]. In the 1D translation invariant setting, GSCON remains hard, being QCMAEXP-complete [WBG23]. We now state our first main result, which shows that GSCON is QCMA-hard to approximate. For this, we reformulate GSCON to have two thresholds mâ‰¤mâ€²ğ‘šsuperscriptğ‘šâ€²m\leq m^{\prime}italic_m â‰¤ italic_m start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. We add the promise that there always exists a unitary sequence of length polyâ¢(Nâ€²)polysuperscriptğ‘â€²\textup{poly}(N^{\prime})poly ( italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) satisfying conditions (1) and (2) above. In the YES case, this sequence has length at most mğ‘šmitalic_m, whereas in the NO case, any such sequence is length at least mâ€²superscriptğ‘šâ€²m^{\prime}italic_m start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. That such a sequence always exists even in the NO case is important to ensure the approximation ratio mâ€²/msuperscriptğ‘šâ€²ğ‘šm^{\prime}/mitalic_m start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT / italic_m is well-defined, for if no such unitary sequence satisfying (1) and (2) existed777Existing GSCON QCMA-hardness constructions indeed have no such sequence in the NO case., the ratio can trivially be set to mâ€²/mâ‰ˆâˆsuperscriptğ‘šâ€²ğ‘šm^{\prime}/m\approx\inftyitalic_m start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT / italic_m â‰ˆ âˆ by choosing arbitrarily large mâ€²superscriptğ‘šâ€²m^{\prime}italic_m start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT for the NO case. Theorem 1. For all Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 and kâ‰¥5ğ‘˜5k\geq 5italic_k â‰¥ 5, GSCON with kğ‘˜kitalic_k-local Hamiltonians is QCMA-complete for mâ€²mâˆˆÎ˜â¢(Nâ€²â£1âˆ’Ïµ)superscriptğ‘šâ€²ğ‘šÎ˜superscriptğ‘â€²1italic-Ïµ\frac{m^{\prime}}{m}\in\Theta(N^{\prime 1-\epsilon})divide start_ARG italic_m start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_ARG start_ARG italic_m end_ARG âˆˆ roman_Î˜ ( italic_N start_POSTSUPERSCRIPT â€² 1 - italic_Ïµ end_POSTSUPERSCRIPT ), for Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT the encoding size of the GSCON instance. In words, the length of the minimal unitary sequence satisfying conditions (1) and (2) is QCMA-hard to approximate, even within large relative error scaling essentially linearly in the input size, Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. Three comments: (1) The local Hamiltonians in Theorem 1 do not obey any particular geometry constraints. (2) It is important that all hardness ratios in this paper be written relative to the encoding size of the input of the problem being reduced to, and not, e.g., the number of qubits, nğ‘›nitalic_n. This correctly captures standard classical hardness of approximation results for classical Boolean kğ‘˜kitalic_k-CSPs, where the hardness ratio is relative to the number satisfied clauses. This is because the input size, Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, also scales with the number of clauses, assuming each clause has size kâˆˆOâ¢(1)ğ‘˜ğ‘‚1k\in O(1)italic_k âˆˆ italic_O ( 1 ). Our setting has this property as well, since all clauses are norm at most 1111. (3) The reason we are careful to make point (2) is because, in general, the number of clauses can be superlinear in nğ‘›nitalic_n. Thus, mapping an approximation ratio given relative to nğ‘›nitalic_n to one relative to Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT can yield an asymptotically smaller ratio. This is why simple promise gap amplification techniques, such as taking parallel copies of all clauses, typically do not suffice to achieve hardness of approximation ratios such as in Theorem 1. Result 1.5: Classical analogue of GSCON, Boolean reconfiguration. The origins of GSCON as a computational problem are rooted in the classical study of reconfiguration problems, to which we now make a detour. First studied in [GKMP09], classical reconfiguration problems have since evolved into an entire research area (see, e.g., [Nis18] for an introductory survey). In the case of kğ‘˜kitalic_k-SAT, the reconfiguration problem is specified as follows: Given an input kğ‘˜kitalic_k-SAT formula Ï•italic-Ï•\phiitalic_Ï• and satisfying assignments xğ‘¥xitalic_x and yğ‘¦yitalic_y, does there exist a sequence of bit flips from xğ‘¥xitalic_x to yğ‘¦yitalic_y, so that each intermediate string obtained is also satisfying for Ï•italic-Ï•\phiitalic_Ï•? This is the classical analogue of GSCON, with the exception that the input does not specify a bound mğ‘šmitalic_m on the number of bit flips allowed â€” in the worst case, one may require an exponential number of bit flips. As a result, its complexity is more difficult than NP, being PSPACE-complete [GKMP09]. Recently, the first PCP theorems for reconfiguration problems have been established [IDH+11, Ohs23, SM24, HO24], allowing for the first PSPACE-hardness of approximation results for many reconfiguration problems [SM24, HO24]. By leveraging our proof technique for GSCON from Theorem 1, we are able to give our own hardness of approximation result for kğ‘˜kitalic_k-SAT reconfiguration, albeit with respect to a different parameter than [SM24, HO24]. We will first state our result, followed by a discussion of how it differs from [SM24, HO24]. For this, we define the approximation problem Boolean Reconfiguration (BR, Definition 10), which is the kğ‘˜kitalic_k-SAT reconfiguration problem above, but with thresholds hâ„hitalic_h and hâ€²superscriptâ„â€²h^{\prime}italic_h start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT on the number of bit flips allowed in the YES and NO cases (analogous to GSCON), respectively. Theorem 2. BR is NP-hard to approximate for hâ€²/hâˆˆÎ˜â¢(N1âˆ’Îµ)superscriptâ„â€²â„Î˜superscriptğ‘1ğœ€h^{\prime}/h\in\Theta(N^{1-\varepsilon})italic_h start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT / italic_h âˆˆ roman_Î˜ ( italic_N start_POSTSUPERSCRIPT 1 - italic_Îµ end_POSTSUPERSCRIPT ), for any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 and Nğ‘Nitalic_N the size of the input BR instance. The main differences between Theorem 1 and [SM24, HO24] are now as follows. First, our proof does not rely on a PCP as in [SM24, HO24], but rather uses Umansâ€™ disperser-based hardness gap construction as a starting point. Second, our hardness of approximation is with respect to the length of the reconfiguration sequence. In [SM24, HO24], in contrast, there is no length parameter mğ‘šmitalic_m. Rather, hardness of approximation therein is shown in the following sense: There exists a constant Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0 such that, in the YES case, there exists a satisfying reconfiguration sequence from xğ‘¥xitalic_x to yğ‘¦yitalic_y, and in the NO case, for any reconfiguration sequence, there exists an intermediate string which satisfies at most a (1âˆ’Ïµ)1italic-Ïµ(1-\epsilon)( 1 - italic_Ïµ )-fraction of the clauses of Ï•italic-Ï•\phiitalic_Ï•, for some fixed constant Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0. In this sense, Theorem 2 is complementary to [SM24, HO24] in both its proof technique and actual result. Result 2. Ground State Entanglement (GSE). We now return to the quantum setting, and define the second natural quantum problem we study, which asks whether a given local Hamiltonian has a ground state of low entanglement. More formally, we define the Ground State Entanglement problem (GSE, Definition 8), for which the input is a local Hamiltonian Hğ»Hitalic_H, prespecified cut Ağ´Aitalic_A versus Aâ€²superscriptğ´â€²A^{\prime}italic_A start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT of the qubits Hğ»Hitalic_H acts on, and inverse polynomially separated thresholds Î·4>Î·3subscriptğœ‚4subscriptğœ‚3\eta_{4}>\eta_{3}italic_Î· start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT > italic_Î· start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT. The output is to decide whether Hğ»Hitalic_H has a ground state with entanglement entropy at most Î·3subscriptğœ‚3\eta_{3}italic_Î· start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT across the Ağ´Aitalic_A versus Aâ€²superscriptğ´â€²A^{\prime}italic_A start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT cut, or whether all ground states have entanglement entropy at least Î·4subscriptğœ‚4\eta_{4}italic_Î· start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT across this cut? Here, the entanglement entropy is a standard entanglement measure, defined for a bipartite pure state |ÏˆâŸ©Aâ¢Aâ€²subscriptketğœ“ğ´superscriptğ´â€²|\psi\rangle_{AA^{\prime}}| italic_Ïˆ âŸ© start_POSTSUBSCRIPT italic_A italic_A start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUBSCRIPT as Sâ¢(ÏA)ğ‘†subscriptğœŒğ´S(\rho_{A})italic_S ( italic_Ï start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT ), for reduced state ÏA:=TrAâ€²â¢(ÏAâ¢Aâ€²)assignsubscriptğœŒğ´subscriptTrsuperscriptğ´â€²subscriptğœŒğ´superscriptğ´â€²\rho_{A}:={\rm Tr}_{A^{\prime}}(\rho_{AA^{\prime}})italic_Ï start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT := roman_Tr start_POSTSUBSCRIPT italic_A start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( italic_Ï start_POSTSUBSCRIPT italic_A italic_A start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ) and S(Ï):=âˆ’Tr(ÏlogÏS(\rho):=-{\rm Tr}(\rho\log\rhoitalic_S ( italic_Ï ) := - roman_Tr ( italic_Ï roman_log italic_Ï) the von Neumann entropy. Our second main result is as follows. Theorem 3. For all Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 and kâ‰¥5ğ‘˜5k\geq 5italic_k â‰¥ 5, GSE is QCMA-hard for Î·4Î·3âˆˆÎ˜â¢(Nâ€²â£1âˆ’Ïµ)subscriptğœ‚4subscriptğœ‚3Î˜superscriptğ‘â€²1italic-Ïµ\frac{\eta_{4}}{\eta_{3}}\in\Theta(N^{\prime 1-\epsilon})divide start_ARG italic_Î· start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT end_ARG start_ARG italic_Î· start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_ARG âˆˆ roman_Î˜ ( italic_N start_POSTSUPERSCRIPT â€² 1 - italic_Ïµ end_POSTSUPERSCRIPT ), for Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT the encoding size of the GSE instance. In words, it is QCMA-hard to estimate the minimal entanglement entropy over all states in the ground space, even within large relative error Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. Two comments: First, unlike Theorem 1, it is not clear that GSE is also in in QCMA. This is because verifying the entropy of a given quantum state |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© is, in general, at least as hard as Quantum Statistical Zero Knowledge (QSZK) [Wat02]. In particular, when one has access to a poly-size quantum circuit preparing |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ©, the problem is QSZK-complete [BST08]. However, in GSE one does not have access to such a circuit, since |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© is an unknown ground state of Hğ»Hitalic_H! Second, there are two previous works [GH24, BFG+24] we are aware of which study questions similar to GSE, whose relationship to Theorem 3 we now clarify. The first [GH24] defines the Hamiltonian Quantum Entropy Difference (HQED) problem, which takes two local Hamiltonians as input and a pre-specified cut Ağ´Aitalic_A versus Aâ€²superscriptğ´â€²A^{\prime}italic_A start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, and asks: Among all ground states |Ïˆ1âŸ©ketsubscriptğœ“1|\psi_{1}\rangle| italic_Ïˆ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŸ© of H1subscriptğ»1H_{1}italic_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and |Ïˆ2âŸ©ketsubscriptğœ“2|\psi_{2}\rangle| italic_Ïˆ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âŸ© of H2subscriptğ»2H_{2}italic_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of minimal entanglement entropy, which of |Ïˆ1âŸ©ketsubscriptğœ“1|\psi_{1}\rangle| italic_Ïˆ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŸ© or |Ïˆ2âŸ©ketsubscriptğœ“2|\psi_{2}\rangle| italic_Ïˆ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âŸ© has larger entanglement entropy across Ağ´Aitalic_A versus Aâ€²superscriptğ´â€²A^{\prime}italic_A start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT? Here, the promise gap in entropy is an additive constant (i.e. it is not a hardness of approximation result), and the hardness obtained is for the Learning With Errors (LWE) problem [Reg09], not QCMA. In words, Reference [GH24] shows that if one could efficiently estimate the entanglement entropy difference between ground states of two given Hamiltonians within constant additive error, then one could solve LWE. Note the relationship between LWE and QCMA is not known, other than the belief that LWE is not in BQP (e.g. [Mah18]), and thus not in QCMA (since BQPâŠ†QCMABQPQCMA\textup{BQP}\subseteq\textup{QCMA}BQP âŠ† QCMA by definition). The second relevant work [BFG+24] introduces the Learning Ground State Entanglement Structure (LGSES) problem. The question is then, roughly, to determine whether the ground states of a geometrically constrained Hğ»Hitalic_H have volume law or area law entanglement across a given set of cuts. First, the differences: Like [GH24], the hardness results obtained in [BFG+24] are for LWE, not QCMA. Second, the input model to LGSES is not the standard one used in defining complexity classes, but rather has a cryptographic flavor. Namely, there are two families of computationally indistinguishable Hamiltonians, â„‹nlowsuperscriptsubscriptâ„‹ğ‘›low\mathcal{H}_{n}^{\textup{low}}caligraphic_H start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT start_POSTSUPERSCRIPT low end_POSTSUPERSCRIPT and â„‹nhighsuperscriptsubscriptâ„‹ğ‘›high\mathcal{H}_{n}^{\textup{high}}caligraphic_H start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT start_POSTSUPERSCRIPT high end_POSTSUPERSCRIPT (which we call â€œYESâ€ and â€œNOâ€ cases for reference), so that when Hğ»Hitalic_H is drawn from either â„‹nlowsuperscriptsubscriptâ„‹ğ‘›low\mathcal{H}_{n}^{\textup{low}}caligraphic_H start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT start_POSTSUPERSCRIPT low end_POSTSUPERSCRIPT or â„‹nhighsuperscriptsubscriptâ„‹ğ‘›high\mathcal{H}_{n}^{\textup{high}}caligraphic_H start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT start_POSTSUPERSCRIPT high end_POSTSUPERSCRIPT according to an appropriate random distribution, with overwhelming probability the entanglement entropy will be low or high, respectively. In constrast, our input to GSE is a single Hamiltonian Hğ»Hitalic_H along with a cut Ağ´Aitalic_A versus Aâ€²superscriptğ´â€²A^{\prime}italic_A start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT (i.e. the standard QCMA input model). Now, the similarity: The promise gap for [BFG+24] on the entanglement entropy between the â€œYESâ€ and â€œNOâ€ cases is Oâ¢(polylogâ¢(n))ğ‘‚polylogğ‘›O(\textup{polylog}(n))italic_O ( polylog ( italic_n ) ) versus Î©â¢(n)Î©ğ‘›\Omega(n)roman_Î© ( italic_n ), i.e. a ratio of (n/polylogâ¢(n))ğ‘›polylogğ‘›(n/\textup{polylog}(n))( italic_n / polylog ( italic_n ) ). However, this gap is relative to the number of qubits nğ‘›nitalic_n, not the encoding size of the input, Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, as in Theorem 3. Our understanding888Due to the multiplication of an nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n matrix Ağ´Aitalic_A with nğ‘›nitalic_n-bit string xğ‘¥xitalic_x in Definition 3.2 of the arxiv version[BFG+24]. is that Nâ€²âˆˆÎ©â¢(n2)superscriptğ‘â€²Î©superscriptğ‘›2N^{\prime}\in\Omega(n^{2})italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) in [BFG+24], yielding ratio at most Nâ€²/polylogâ¢(Nâ€²)superscriptğ‘â€²polylogsuperscriptğ‘â€²\sqrt{N^{\prime}}/\textup{polylog}(N^{\prime})square-root start_ARG italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_ARG / polylog ( italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ). Thus, relative to the input model therein, this may be viewed as an LWE-hardness of approximation result, albeit with a quadratically weaker ratio than Theorem 3. Finally, we remark there are minor overlaps between our techniques and those of [GH24, BFG+24], such as the use of circuit-to-Hamiltonian constructions. However, the key underlying approach for obtaining our QCMA-hardness results is completely different. Techniques. We begin by discussing Theorem 1 for GSCON, followed by Theorem 3 for GSE. The proof of Theorem 2 for BR is a classical analogue of the proof for GSCON, with some modifications to the clock construction; as such we omit it here. Techniques for GSCON. We show a gap-preserving reduction from the artificial QCMA-hard to approximate problem Quantum Monotone Minimum Satisfying Assignment (QMSA, Definition 5), roughly defined as follows: The input is a quantum circuit V=VTâ¢â‹¯â¢V1ğ‘‰subscriptğ‘‰ğ‘‡â‹¯subscriptğ‘‰1V=V_{T}\cdots V_{1}italic_V = italic_V start_POSTSUBSCRIPT italic_T end_POSTSUBSCRIPT â‹¯ italic_V start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT accepting a non-empty monotone set SâŠ†{0,1}nğ‘†superscript01ğ‘›S\subseteq\{0,1\}^{n}italic_S âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, and integer thresholds 0â‰¤gâ‰¤gâ€²â‰¤n0ğ‘”superscriptğ‘”â€²ğ‘›0\leq g\leq g^{\prime}\leq n0 â‰¤ italic_g â‰¤ italic_g start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT â‰¤ italic_n. The output is to decide whether there is a low Hamming weight string xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, meaning of Hamming weight at most gğ‘”gitalic_g, accepted by Vğ‘‰Vitalic_V, or if every xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT of Hamming weight at most gâ€²superscriptğ‘”â€²g^{\prime}italic_g start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT is rejected by Vğ‘‰Vitalic_V, with the promise that one of these two cases holds. Our starting point is the QCMA-hardness construction of [GS15], which we must briefly sketch (more details in Section 2). Namely, one first applies a circuit-to-Hamiltonian construction [KSV02] to Vğ‘‰Vitalic_V, obtaining a local Hamiltonian Hkitsubscriptğ»kitH_{\textup{kit}}italic_H start_POSTSUBSCRIPT kit end_POSTSUBSCRIPT encoding the action of Vğ‘‰Vitalic_V as follows: (1) Î»minâ¢(H)subscriptğœ†ğ»\lambda_{\min}(H)italic_Î» start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT ( italic_H ) is â€œsmallâ€ if and only if Vğ‘‰Vitalic_V accepts the string xğ‘¥xitalic_x it is given, and (2) the quantum state achieving this low energy is the history state of Vğ‘‰Vitalic_V, |Ïˆhistâ¢(x)âŸ©:=1T+1â¢âˆ‘t=0TViâ¢â‹¯â¢V1â¢|xâŸ©BâŠ—|0âŸ©CâŠ—|tâŸ©D,assignketsubscriptğœ“histğ‘¥1ğ‘‡1superscriptsubscriptğ‘¡0ğ‘‡tensor-productsubscriptğ‘‰ğ‘–â‹¯subscriptğ‘‰1subscriptketğ‘¥ğµsubscriptket0ğ¶subscriptketğ‘¡ğ·|\psi_{\textup{hist}}(x)\rangle:=\frac{1}{\sqrt{T+1}}\sum_{t=0}^{T}V_{i}\cdots V% _{1}|x\rangle_{B}\otimes|0\rangle_{C}\otimes|t\rangle_{D},| italic_Ïˆ start_POSTSUBSCRIPT hist end_POSTSUBSCRIPT ( italic_x ) âŸ© := divide start_ARG 1 end_ARG start_ARG square-root start_ARG italic_T + 1 end_ARG end_ARG âˆ‘ start_POSTSUBSCRIPT italic_t = 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT italic_V start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‹¯ italic_V start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | italic_x âŸ© start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT âŠ— | 0 âŸ© start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT âŠ— | italic_t âŸ© start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT , (1) where xğ‘¥xitalic_x is the string fed to Vğ‘‰Vitalic_V in register BğµBitalic_B, Cğ¶Citalic_C is the ancilla, and Dğ·Ditalic_D is the clock register tracking time, tğ‘¡titalic_t. To turn this into a GSCON instance, one then appends a 3333-qubit â€œGOâ€ register Eğ¸Eitalic_E, and sets the final Hamiltonian to H=(Hkit)Bâ¢Câ¢DâŠ—PEğ»tensor-productsubscriptsubscriptğ»kitğµğ¶ğ·subscriptğ‘ƒğ¸H=(H_{\textup{kit}})_{BCD}\otimes P_{E}italic_H = ( italic_H start_POSTSUBSCRIPT kit end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_B italic_C italic_D end_POSTSUBSCRIPT âŠ— italic_P start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT for P:=(Iâˆ’|000âŸ©â¢âŸ¨000|âˆ’|111âŸ©â¢âŸ¨111|)Eassignğ‘ƒsubscriptğ¼ket000bra000ket111bra111ğ¸P:=(I-|000\rangle\!{\langle 000|}-|111\rangle\!{\langle 111|})_{E}italic_P := ( italic_I - | 000 âŸ© âŸ¨ 000 | - | 111 âŸ© âŸ¨ 111 | ) start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT. Finally, the initial and target states are |ÏˆâŸ©=|0â¢â‹¯â¢0âŸ©Bâ¢Câ¢Dâ¢|000âŸ©Eketğœ“subscriptket0â‹¯0ğµğ¶ğ·subscriptket000ğ¸|\psi\rangle=|0\cdots 0\rangle_{BCD}|000\rangle_{E}| italic_Ïˆ âŸ© = | 0 â‹¯ 0 âŸ© start_POSTSUBSCRIPT italic_B italic_C italic_D end_POSTSUBSCRIPT | 000 âŸ© start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT and |Ï•âŸ©=|0â¢â‹¯â¢0âŸ©Bâ¢Câ¢Dâ¢|111âŸ©Eketitalic-Ï•subscriptket0â‹¯0ğµğ¶ğ·subscriptket111ğ¸|\phi\rangle=|0\cdots 0\rangle_{BCD}|111\rangle_{E}| italic_Ï• âŸ© = | 0 â‹¯ 0 âŸ© start_POSTSUBSCRIPT italic_B italic_C italic_D end_POSTSUBSCRIPT | 111 âŸ© start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT, respectively. The intuition is now as follows: In the YES case, an honest prover can first prepare the history state |Ïˆhistâ¢(x)âŸ©ketsubscriptğœ“histğ‘¥|\psi_{\textup{hist}}(x)\rangle| italic_Ïˆ start_POSTSUBSCRIPT hist end_POSTSUBSCRIPT ( italic_x ) âŸ© on registers Bâ¢Câ¢Dğµğ¶ğ·BCDitalic_B italic_C italic_D based on a Hamming weight gğ‘”gitalic_g string xğ‘¥xitalic_x, obtaining |Ïˆhistâ¢(x)âŸ©Bâ¢Câ¢Dâ¢|000âŸ©Esubscriptketsubscriptğœ“histğ‘¥ğµğ¶ğ·subscriptket000ğ¸|\psi_{\textup{hist}}(x)\rangle_{BCD}|000\rangle_{E}| italic_Ïˆ start_POSTSUBSCRIPT hist end_POSTSUBSCRIPT ( italic_x ) âŸ© start_POSTSUBSCRIPT italic_B italic_C italic_D end_POSTSUBSCRIPT | 000 âŸ© start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT, which is still in the null space of Hğ»Hitalic_H. The goal is now to flip the GO qubits, but since we are restricted to 2222-local gates, this must be done in two steps, e.g. the first two bits of Eğ¸Eitalic_E are first flipped to |11âŸ©ket11|11\rangle| 11 âŸ©. At this point, our state has high overlap with PEsubscriptğ‘ƒğ¸P_{E}italic_P start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT, â€œswitching onâ€ the Hamiltonian Hkitsubscriptğ»kitH_{\textup{kit}}italic_H start_POSTSUBSCRIPT kit end_POSTSUBSCRIPT, which checks that our history state indeed has low energy. The last bit of Eğ¸Eitalic_E can now be flipped, and the history state uncomputed in order to arrive at target state |Ï•âŸ©ketitalic-Ï•|\phi\rangle| italic_Ï• âŸ©. Soundness follows via the Traversal Lemma (Lemma 4), which shows that it is impossible999Actually, this statement is not entirely true â€” it is always possible to perform such a mapping without ever having more than inverse exponential overlap with Pğ‘ƒPitalic_P [GS15, GR23]. However, this necessarily requires an exponential number of 2222-qubit gates. to map |000âŸ©Esubscriptket000ğ¸|000\rangle_{E}| 000 âŸ© start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT to |111âŸ©Esubscriptket111ğ¸|111\rangle_{E}| 111 âŸ© start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT via 2222-local gates without preparing an intermediate state with non-trivial overlap with Pğ‘ƒPitalic_P. And when this overlap occurs, Hkitsubscriptğ»kitH_{\textup{kit}}italic_H start_POSTSUBSCRIPT kit end_POSTSUBSCRIPT will administer a large energy penalty to any history state prepared in Bâ¢Câ¢Dğµğ¶ğ·BCDitalic_B italic_C italic_D based on a string of Hamming weight at most gâ€²superscriptğ‘”â€²g^{\prime}italic_g start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. At first glance, this construction already seems to give hardness of approximation when applied to Vğ‘‰Vitalic_V from QMSA â€” in the YES case, the history state is based on a low Hamming weight gğ‘”gitalic_g string xğ‘¥xitalic_x, whereas in the NO case, any low-energy history state must encode a high Hamming weight gâ€²superscriptğ‘”â€²g^{\prime}italic_g start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT string. Since gâ€²/gâˆˆÎ˜â¢(N1âˆ’Ïµ)superscriptğ‘”â€²ğ‘”Î˜superscriptğ‘1italic-Ïµg^{\prime}/g\in\Theta(N^{1-\epsilon})italic_g start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT / italic_g âˆˆ roman_Î˜ ( italic_N start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT ), this suggests preparing the history state in the YES case requires much fewer gates than in the NO case, which translates into a short unitary sequence for GSCON in the YES case versus a long one in the NO case. The catch is that, while it takes gğ‘”gitalic_g (respectively, gâ€²superscriptğ‘”â€²g^{\prime}italic_g start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT) bits to prepare xğ‘¥xitalic_x in the YES (respectively, NO) case, the cost of preparing the superposition in |Ïˆhistâ¢(x)âŸ©ketsubscriptğœ“histğ‘¥|\psi_{\textup{hist}}(x)\rangle| italic_Ïˆ start_POSTSUBSCRIPT hist end_POSTSUBSCRIPT ( italic_x ) âŸ© given xğ‘¥xitalic_x depends on the number of gates Tğ‘‡Titalic_T in Vğ‘‰Vitalic_V, which we have no control over! Thus, the approximation ratio achieved scales roughly as (g+T)/(gâ€²+T)ğ‘”ğ‘‡superscriptğ‘”â€²ğ‘‡(g+T)/(g^{\prime}+T)( italic_g + italic_T ) / ( italic_g start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT + italic_T ), which approaches 1111 if Tğ‘‡Titalic_T grows superlinearly in the proof size, which is in general the case. A similar problem was overcome in the QCMA-hardness of approximation result for MIN-VQA by artificially â€œamplifying the costâ€ of flipping each bit while preparing string xğ‘¥xitalic_x [BGK23], so as to make the cost of preparing xğ‘¥xitalic_x scale roughly as gâ¢Tğ‘”ğ‘‡gTitalic_g italic_T rather than Tğ‘‡Titalic_T. However, one has much more control for MIN-VQA when designing a reduction, for the following reason. The input therein is a set of local Hamiltonians {G1,â€¦â¢Gl}subscriptğº1â€¦subscriptğºğ‘™{\left\{G_{1},\ldots G_{l}\right\}}{ italic_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ italic_G start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT }, and the question is whether given an initial state |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ©, one can prepare a specified target state |Ï•âŸ©ketitalic-Ï•|\phi\rangle| italic_Ï• âŸ© by applying Hamiltonian evolution according to the Gisubscriptğºğ‘–G_{i}italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, i.e. eiâ¢Gjdâ¢Î¸jdâ¢â‹¯â¢eiâ¢Gj1â¢Î¸j1â¢|ÏˆâŸ©â‰ˆ|Ï•âŸ©superscriptğ‘’ğ‘–subscriptğºsubscriptğ‘—ğ‘‘subscriptğœƒsubscriptğ‘—ğ‘‘â‹¯superscriptğ‘’ğ‘–subscriptğºsubscriptğ‘—1subscriptğœƒsubscriptğ‘—1ketğœ“ketitalic-Ï•e^{iG_{j_{d}}\theta_{j_{d}}}\cdots e^{iG_{j_{1}}\theta_{j_{1}}}|\psi\rangle% \approx|\phi\rangleitalic_e start_POSTSUPERSCRIPT italic_i italic_G start_POSTSUBSCRIPT italic_j start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT end_POSTSUBSCRIPT italic_Î¸ start_POSTSUBSCRIPT italic_j start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â‹¯ italic_e start_POSTSUPERSCRIPT italic_i italic_G start_POSTSUBSCRIPT italic_j start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT italic_Î¸ start_POSTSUBSCRIPT italic_j start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUPERSCRIPT | italic_Ïˆ âŸ© â‰ˆ | italic_Ï• âŸ© (here, the Gisubscriptğºğ‘–G_{i}italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT are allowed to be applied in any order with repetition, and with arbitrary evolution angles Î¸ğœƒ\thetaitalic_Î¸)? Thus, when designing a hardness of approximation reduction, one can construct the Gisubscriptğºğ‘–G_{i}italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT so that flipping a bit of xğ‘¥xitalic_x is artificially costly in terms of the depth dğ‘‘ditalic_d of the sequence of Hamiltonian evolutions. In contrast, for GSCON we do not have the luxury of forcing a prover to evolve according to any particular set of Hamiltonians â€” a dishonest prover can simply apply any sequence of unitaries desired, so long as each gate is 2222-local. To overcome this challenge, we begin with the basic GSCON setup outlined above, but move to a triple clock construction. Briefly, in addition to register Bâ¢Câ¢Dâ¢Eğµğ¶ğ·ğ¸BCDEitalic_B italic_C italic_D italic_E where BğµBitalic_B stores the nğ‘›nitalic_n-bit string input to Vğ‘‰Vitalic_V, we (1) add two additional clock registers Kğ¾Kitalic_K and Lğ¿Litalic_L of sizes 4â¢n4ğ‘›4n4 italic_n and 2222, respectively, (2) add two registers Fğ¹Fitalic_F and GğºGitalic_G each of size nğ‘›nitalic_n and intended to hold copies of proof xğ‘¥xitalic_x, and (3) finally an â€œamplificationâ€ register Mğ‘€Mitalic_M. The basic premise is now that an honest prover proceeds in two phases. In the first phase, it manipulates clocks Kâ¢Lğ¾ğ¿KLitalic_K italic_L to be able to first prepare its desired proof xğ‘¥xitalic_x in BğµBitalic_B. The Hamiltonian constraints we design are such that there is a unique time step tisubscriptğ‘¡ğ‘–t_{i}italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT in which bits Bisubscriptğµğ‘–B_{i}italic_B start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, Fisubscriptğ¹ğ‘–F_{i}italic_F start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, and Gisubscriptğºğ‘–G_{i}italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT can be acted on. At time tisubscriptğ‘¡ğ‘–t_{i}italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, if desired, the prover flips bits Bisubscriptğµğ‘–B_{i}italic_B start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, Fisubscriptğ¹ğ‘–F_{i}italic_F start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and Gisubscriptğºğ‘–G_{i}italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, thus creating triple redundancy. It is then forced to flip all (roughly) Tğ‘‡Titalic_T bits in the amplification register Mğ‘€Mitalic_M from all zeroes to all ones, because the next time step ti+1subscriptğ‘¡ğ‘–1t_{i}+1italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + 1 will administer an energy penalty if Bisubscriptğµğ‘–B_{i}italic_B start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT was set to 1111 but the qubits of Mğ‘€Mitalic_M still 00. It is now the triple redundancy on Bâ¢Fâ¢Gğµğ¹ğºBFGitalic_B italic_F italic_G that ensures that, once we leave timestep tisubscriptğ‘¡ğ‘–t_{i}italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, it is impossible to change bit Bisubscriptğµğ‘–B_{i}italic_B start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, because any single 2222-local gate will break the equality constraints we place between Bisubscriptğµğ‘–B_{i}italic_B start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, Fisubscriptğ¹ğ‘–F_{i}italic_F start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, and Gisubscriptğºğ‘–G_{i}italic_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT on all time steps other than tisubscriptğ‘¡ğ‘–t_{i}italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT. Next, moving to time ti+2subscriptğ‘¡ğ‘–2t_{i}+2italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + 2, the prover is allowed to uncompute Mğ‘€Mitalic_M, and subsequently goes to time ti+3subscriptğ‘¡ğ‘–3t_{i}+3italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + 3, activating another Hamiltonian check that register Mğ‘€Mitalic_M is correctly reset to all zeroes. Finally, we move to time ti+4subscriptğ‘¡ğ‘–4t_{i}+4italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + 4, and the entire process repeats for the next proof bit Bi+1subscriptğµğ‘–1B_{i+1}italic_B start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT. This first phase continues until we arrive at the final time step on clocks Kâ¢Lğ¾ğ¿KLitalic_K italic_L, which de-activates a constraint preventing the GO register Eğ¸Eitalic_E from being acted upon. In the second phase, the prover can now build a history state on registers Bâ¢Câ¢Dğµğ¶ğ·BCDitalic_B italic_C italic_D, and subsequently flip the GO qubits as in the basic setup to activate Hkitsubscriptğ»kitH_{\textup{kit}}italic_H start_POSTSUBSCRIPT kit end_POSTSUBSCRIPT, which checks the history state. For clarity, it is the flipping of all Tğ‘‡Titalic_T bits in the amplification register, Mğ‘€Mitalic_M, which allows us to achieve our desired approximation ratio. To make this logic sound, it is imperative for the clocks Kâ¢Lğ¾ğ¿KLitalic_K italic_L to be carefully designed. The clock sequence we construct for the first phase is |00000â¢â€¦â¢0âŸ©Kâ¢|00âŸ©L,subscriptket00000â€¦0ğ¾subscriptket00ğ¿\displaystyle|00000\ldots 0\rangle_{K}|00\rangle_{L},| 00000 â€¦ 0 âŸ© start_POSTSUBSCRIPT italic_K end_POSTSUBSCRIPT | 00 âŸ© start_POSTSUBSCRIPT italic_L end_POSTSUBSCRIPT , (2) |10000â¢â€¦â¢0âŸ©Kâ¢|10âŸ©L,subscriptket10000â€¦0ğ¾subscriptket10ğ¿\displaystyle|10000\ldots 0\rangle_{K}|10\rangle_{L},| 10000 â€¦ 0 âŸ© start_POSTSUBSCRIPT italic_K end_POSTSUBSCRIPT | 10 âŸ© start_POSTSUBSCRIPT italic_L end_POSTSUBSCRIPT , (3) |11000â¢â€¦â¢0âŸ©Kâ¢|11âŸ©L,subscriptket11000â€¦0ğ¾subscriptket11ğ¿\displaystyle|11000\ldots 0\rangle_{K}|11\rangle_{L},| 11000 â€¦ 0 âŸ© start_POSTSUBSCRIPT italic_K end_POSTSUBSCRIPT | 11 âŸ© start_POSTSUBSCRIPT italic_L end_POSTSUBSCRIPT , (4) |11100â¢â€¦â¢0âŸ©Kâ¢|01âŸ©L,subscriptket11100â€¦0ğ¾subscriptket01ğ¿\displaystyle|11100\ldots 0\rangle_{K}|01\rangle_{L},| 11100 â€¦ 0 âŸ© start_POSTSUBSCRIPT italic_K end_POSTSUBSCRIPT | 01 âŸ© start_POSTSUBSCRIPT italic_L end_POSTSUBSCRIPT , (5) |11110â¢â€¦â¢0âŸ©Kâ¢|00âŸ©Lâ¢, etcâ¢â€¦.subscriptket11110â€¦0ğ¾subscriptket00ğ¿, etcâ€¦\displaystyle|11110\ldots 0\rangle_{K}|00\rangle_{L}\text{, etc}\ldots.| 11110 â€¦ 0 âŸ© start_POSTSUBSCRIPT italic_K end_POSTSUBSCRIPT | 00 âŸ© start_POSTSUBSCRIPT italic_L end_POSTSUBSCRIPT , etc â€¦ . (6) which has three important properties enabling the soundness analysis to work: (1) Moving from a timestep tisubscriptğ‘¡ğ‘–t_{i}italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT to ti+1subscriptğ‘¡ğ‘–1t_{i+1}italic_t start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT requires application of a 2222-qubit unitary on a unique pair of qubits qi,1subscriptğ‘ğ‘–1q_{i,1}italic_q start_POSTSUBSCRIPT italic_i , 1 end_POSTSUBSCRIPT and qi,2subscriptğ‘ğ‘–2q_{i,2}italic_q start_POSTSUBSCRIPT italic_i , 2 end_POSTSUBSCRIPT. (2) It is impossible to jump from tisubscriptğ‘¡ğ‘–t_{i}italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT to (say) ti+2subscriptğ‘¡ğ‘–2t_{i}+2italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + 2 via a single 2222-local gate. (3) To satisfy the YES case conditions of GSCON, every intermediate state |ÏˆlâŸ©ketsubscriptğœ“ğ‘™|\psi_{l}\rangle| italic_Ïˆ start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT âŸ© computed must have essentially all its amplitude on some single timestep tilsubscriptğ‘¡subscriptğ‘–ğ‘™t_{i_{l}}italic_t start_POSTSUBSCRIPT italic_i start_POSTSUBSCRIPT italic_l end_POSTSUBSCRIPT end_POSTSUBSCRIPT â€” for if not, any 2222-qubit unitary attempting to increment the time from tisubscriptğ‘¡ğ‘–t_{i}italic_t start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT to ti+1subscriptğ‘¡ğ‘–1t_{i+1}italic_t start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT will necessarily lead to non-trivial weight being placed on an invalid clock state, which is penalized. Techniques for GSE. We now discuss Theorem 3 for estimating ground state entanglement, which again proceeds via a gap-preserving reduction from QMSA. Thus, given a circuit Vğ‘‰Vitalic_V which either accepts a low Hamming weight gğ‘”gitalic_g proof or only high Hamming weight gâ€²superscriptğ‘”â€²g^{\prime}italic_g start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT proofs, our goal is to construct a Hamiltonian with a low-energy state of low entanglement across a pre-specified cut in the YES case, or only highly entangled low-energy states in the NO case. The main idea is to add additional gates to Vğ‘‰Vitalic_V, each of which is controlled on a different proof qubit. Then, for each proof qubit set to 1111, the corresponding added gate creates a Bell pair on a new register. This ensures that when there is a low (respectively, high) Hamming proof in the proof register, Vğ‘‰Vitalic_V prepares a low- (respectively, high-) entanglement proof across a certain cut. Applying Kitaevâ€™s circuit-to-Hamiltonian construction [KSV02] now yields a local Hamiltonian whose history state is correspondingly entangled. This works as desired for the YES case, when the history state is also a low energy state of Hkitsubscriptğ»kitH_{\textup{kit}}italic_H start_POSTSUBSCRIPT kit end_POSTSUBSCRIPT. However, the main technical hurdle is that in the NO case, we must show that all low energy states are highly entangled, not just the honest prover history state. For example, if the proof register contains a superposition over multiple high Hamming weight proofs (each of whose amplitudes can differ, and whose 1111â€™s can be in different positions), it is not as straightforward to argue that the corresponding ground state generated is highly entangled. A natural first idea is to try the standard QCMA trick [WZ06] of having Vğ‘‰Vitalic_V immediately measure its proof register upon reading it to destroy such a superposition, or equivalently immediately copy its proof to a fresh ancilla and apply the principle of deferred measurement. However, this principle requires all qubit copies in the output to be traced out at the end of the computation, which is indeed the case for a general QCMA verifier interested in just measurement statistics on its designated output qubit. In our case, in contrast, we wish to quantify entanglement of the full output state across our cut. To bypass this, we instead coherently copy the proof to two new registers, and do not assume any qubits of our circuitâ€™s output are traced out. Crucially, these registers will be on different sides of the cut for the entanglement entropy. Thus, when we consider a Schmidt decomposition for computing the entropy across this cut, it will depend on amplitudes corresponding to standard basis states which contain both a classical proof and some standard basis state on the Bell pair register. This allows us to reduce the analysis to the case where the proof register just contains one classical state. A soundness analysis can now be run when the prover sends an arbitrary history state. However, when the prover sends an arbitrary low energy state, two more tricks are required. First, we weight the Hin+Hprop+Hstabsubscriptğ»insubscriptğ»propsubscriptğ»stabH_{\rm in}+H_{\rm prop}+H_{\rm stab}italic_H start_POSTSUBSCRIPT roman_in end_POSTSUBSCRIPT + italic_H start_POSTSUBSCRIPT roman_prop end_POSTSUBSCRIPT + italic_H start_POSTSUBSCRIPT roman_stab end_POSTSUBSCRIPT terms of Hkitsubscriptğ»kitH_{\textup{kit}}italic_H start_POSTSUBSCRIPT kit end_POSTSUBSCRIPT with a large penalty term and apply the (Extended) Projection Lemma [KR03, GY19] to argue that any low-energy state must be close to a history state. We then apply the Fannes inequality [Fan73], which roughly says that states close in trace distance are also close in entanglement. Open questions. We have shown that computing properties of solution spaces to quantum CSPs is QCMA-hard to approximate. As the study of hardness of approximation for quantum complexity classes remains in its infancy, there are many open questions, aside from the natural question of a quantum PCP for QMA. First, in terms of GSCON, a curious fact is that it remains QCMA-complete even on commuting Hamiltonians [GMV17]. Does QCMA-hardness of approximation also hold in this setting? For GSE, we have studied the estimation of ground state entanglement across a specified cut. Can one also show QCMA-hardness of approximation for detecting other entanglement structures, such as area law versus volume law entanglement as in the LWE-hardness results of [BFG+24]? There are two challenges here. The first is that in contrast to [boulandComplexityVerificationQuantum2019], we must account for the entanglement created by the QMSA verification circuit Vğ‘‰Vitalic_V embedded in our construction, which we have no control over. This can be partially alleviated by first modifying Vğ‘‰Vitalic_V to copy its output to an ancilla qubit, subsequently applying Vâ€ superscriptğ‘‰â€ V^{\dagger}italic_V start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT to undo the entanglement created by Vğ‘‰Vitalic_V, and then padding by identity gates. However, this is not ideal, as we cannot blow up the size of Vğ‘‰Vitalic_V by a superlinear factor (otherwise our approximation ratio suffers); thus, we can at best linearly suppress the entanglement generated by Vğ‘‰Vitalic_V. The second (bigger) problem is that even in the YES case for QMSA, the construction of [GK12b] can have linear Hamming weight accepting proofs (relative to the size of the proof register, not the instance encoding size), leading to the creation of linearly many Bell pairs in our GSE YES case. In contrast, a 1D area law requires Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 ) (or at most polylog) entanglement entropy across cuts. Finally, are there other natural QCMA-hard to approximate problems? An excellent candidate is one of the first QCMA-complete problems, approximating the length of the minimum circuit preparing a ground state of a given local Hamiltonian (MIN-CIRCUIT) [WZ06], under the additional promise that a poly-length preparation circuit exists. Can one show that this minimum circuit size is QCMA-hard to approximate? (Note that unlike the classic Minimum Circuit Size Problem (MCSP), in which one is given a Boolean truth table Tğ‘‡Titalic_T as input and asked for a minimum size circuit computing Tğ‘‡Titalic_T, this question is different in that the input is analogous to a kğ‘˜kitalic_k-CSP formula rather than a truth table.) Our techniques do not obviously extend to MIN-CIRCUIT for a seemingly crucial reason â€” for GSCON recall our main challenge was to increase the cost of preparing a history state without altering the length of the circuit Vğ‘‰Vitalic_V on which we apply Kitaevâ€™s circuit-to-Hamiltonian construction. This was critical, because we needed the cost of proof preparation to scale linearly with the size of Vğ‘‰Vitalic_V, so that we could translate a hardness gap for QMSA into one for GSCON. In contrast, MIN-CIRCUIT is a fairly â€œbare-bonesâ€ problem, e.g. there is no path through a ground space we can carve out or set of evolution Hamiltonians as in MIN-VQA through which one might attempt to exert control on a dishonest prover. Thus, it seems unclear how to amplify the cost of preparing a proof without complicating the circuit Vğ‘‰Vitalic_V fed into the circuit-to-Hamiltonian construction, which would blow up the encoding size of Hkitsubscriptğ»kitH_{\textup{kit}}italic_H start_POSTSUBSCRIPT kit end_POSTSUBSCRIPT and thus degrade the hardness ratio obtained."
https://arxiv.org/html/2411.04846v1,On the Complexity of 2-club Cluster Editing with Vertex Splitting,"Editing a graph to obtain a disjoint union of sğ‘ sitalic_s-clubs is one of the models for correlation clustering, which seeks a partition of the vertex set of a graph so that elements of each resulting set are close enough according to some given criterion. For example, in the case of editing into sğ‘ sitalic_s-clubs, the criterion is proximity since any pair of vertices (in an sğ‘ sitalic_s-club) are within a distance of sğ‘ sitalic_s from each other. In this work we consider the vertex splitting operation, which allows a vertex to belong to more than one cluster. This operation was studied as one of the parameters associated with the Cluster Editing problem. We study the complexity and parameterized complexity of the sğ‘ sitalic_s-Club Cluster Edge Deletion with Vertex Splitting and sğ‘ sitalic_s-Club Cluster Vertex Splitting problems. Both problems are shown to be \NP\NP\NP-Complete and \APX\APX\APX-hard. On the positive side, we show that both problems are Fixed-Parameter Tractable with respect to the number of allowed editing operations and that sğ‘ sitalic_s-Club Cluster Vertex Splitting is solvable in polynomial-time on the class of forests.","Correlation clustering is viewed as a graph modification problem where the objective is to perform a sequence of editing operations (or modifications) to obtain a disjoint union of clusters. Many variants of this problem have been studied in the literature, each with a different definition either of what a cluster means or of the various types of allowed modifications. In the Cluster Editing problem, for example, a cluster was defined to be a clique and the allowed editing operations were edge additions and deletions [12, 22, 18]. Later, some relaxation models such as sğ‘ sitalic_s-Clubs and sğ‘ sitalic_s-Clans emerged as they were deemed ideal models for clustering Biological Networks [7, 27]. Subsequent efforts studied overlapping clusters in a graph theoretical context [10, 15, 4]. In this work, we deal with overlapping communities by performing vertex splitting, which allows a vertex to be cloned and placed in more than one cluster. This operation was introduced in [4] in the study of the Cluster editing with Vertex Splitting problem. The notion of vertex splitting was first introduced in [19] but not in the context of correlation clustering. The Cluster Editing and Cluster Deletion problems were shown to be \NP\NP\NP-Complete in [22, 28]. Several other variants of the problem have also been proved to be \NP\NP\NP-Complete. This includes Cluster Vertex Deletion [23], 2-club Cluster Editing [25], 2-club Cluster Vertex Deletion [25], 2-club Cluster Edge Deletion [25] , Cluster Vertex Splitting [17], and Cluster Editing with Vertex Splitting [2, 5]. From a parameterized complexity standpoint, Cluster Editing, Cluster Deletion, and Cluster Vertex Deletion are known to be Fixed-Parameter Tractable (\FPT\FPT\FPT) [18, 21]. The same holds for the two club-variants: 2-club Cluster Edge Deletion and 2-club Cluster Vertex Deletion [25], while 2-club Cluster Editing was shown to be \Wâ¢[2]\Wdelimited-[]2\W[2][ 2 ]-Hard [16]. Furthermore, the Cluster Editing with Vertex Splitting problem has also been show to be \FPT\FPT\FPT [2, 5]. From a polynomial-time approximation standpoint, the Cluster Editing and Cluster Edge Deletion problems are \APX\APX\APX-Hard and have Oâ¢(logâ¡n)ğ‘‚ğ‘›O(\log n)italic_O ( roman_log italic_n ) approximation algorithms [13]. On the other hand, Cluster Vertex Deletion has a factor-two approximation algorithm [6]. To the best of our knowledge, problem variants with sğ‘ sitalic_s-clubs or vertex splitting do not have any known approximation results. The problems mentioned above are all considered different models of correlation clustering. The sğ‘ sitalic_s-Club models were shown to be effective in some networks where a clique could not capture all information needed to form better clusters [7, 27]. Vertex splitting proved to be useful, and in fact essential, when the input data has overlapping clusters, such as in protein networks [26]. So far, vertex splitting has been used along with cluster editing. In this paper we introduce the operation to the club-clustering variant by introducing two new problems: 2-club Cluster Vertex Splitting (2CCVS) and 2-club Cluster Edge Deletion with Vertex Splitting (2CCEDVS). These problems seek to modify a graph into a 2-clubs graph by performing a series of vertex splitting (2CCVS and 2CCEDVS) and edge deletion (2CCEDVS) operations. Our contribution. We prove that 2CCVS and 2CCEDVS are \NP\NP\NP-Complete. On the positive side, we prove that both problems are \FPT\FPT\FPT and that 2CCVS is solvable in polynomial-time on forests. We also show that, unless Â¶=\NPÂ¶\NP\P=\NPÂ¶ =, the two problems cannot be approximated in polynomial time with a ratio better than a certain constant >1absent1>1> 1."
https://arxiv.org/html/2411.04566v1,On the average-case hardness of BosonSampling,"BosonSampling is a popular candidate for near-term quantum advantage, which has now been experimentally implemented several times. The original proposal of Aaronson and Arkhipov from 2011 showed that classical hardness of BosonSampling is implied by a proof of the â€œGaussian Permanent Estimationâ€ conjecture. This conjecture states that eâˆ’nâ¢logâ¡nâˆ’nâˆ’Oâ¢(logâ¡n)superscriptğ‘’ğ‘›ğ‘›ğ‘›ğ‘‚ğ‘›e^{-n\log{n}-n-O(\log n)}italic_e start_POSTSUPERSCRIPT - italic_n roman_log italic_n - italic_n - italic_O ( roman_log italic_n ) end_POSTSUPERSCRIPT additive error estimates to the output probability of most random BosonSampling experiments are #P-hard. Proving this conjecture has since become the central question in the theory of quantum advantage.In this work we make progress by proving that eâˆ’nâ¢logâ¡nâˆ’nâˆ’Oâ¢(nÎ´)superscriptğ‘’ğ‘›ğ‘›ğ‘›ğ‘‚superscriptğ‘›ğ›¿e^{-n\log n-n-O(n^{\delta})}italic_e start_POSTSUPERSCRIPT - italic_n roman_log italic_n - italic_n - italic_O ( italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT additive error estimates to output probabilities of most random BosonSampling experiments are #P-hard, for any Î´>0ğ›¿0\delta>0italic_Î´ > 0. In the process, we circumvent all known barrier results for proving the hardness of BosonSampling experiments. This is nearly the robustness needed to prove hardness of BosonSamplingâ€”the remaining hurdle is now â€œmerelyâ€ to show that the nÎ´superscriptğ‘›ğ›¿n^{\delta}italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT in the exponent can be improved to Oâ¢(logâ¡n).ğ‘‚ğ‘›O(\log n).italic_O ( roman_log italic_n ) . We also obtain an analogous result for Random Circuit Sampling.Our result allows us to show, for the first time, a hardness of classical sampling result for random BosonSampling experiments, under an anticoncentration conjecture. Specifically, we prove the impossibility of multiplicative-error sampling from random BosonSampling experiments with probability 1âˆ’eâˆ’Oâ¢(n)1superscriptğ‘’ğ‘‚ğ‘›1-e^{-O(n)}1 - italic_e start_POSTSUPERSCRIPT - italic_O ( italic_n ) end_POSTSUPERSCRIPT, unless the Polynomial Hierarchy collapses.","We have seen the first claims of â€œquantum advantageâ€: the first experimental demonstration of an exponential quantum speedup [Aru19, Mor24, Wu21, Zho20, Zho21, Den23, YGE+24, Mad22]. While these experiments differ from one another dramatically, theoretically they are all solving average-case quantum sampling problems. In other words, the task is to sample from the output distribution of a quantum circuit chosen from some particular distribution. In this work we will focus on proving the classical hardness of BosonSampling experiments, in which the circuits are chosen randomly from a family of linear optical circuits [AA13]. Variants of this experiment have been implemented several times by groups at USTC, Xanadu, and NIST [Zho20, Zho21, Den23, Mad22, YGE+24]. Aaronson and Arkhipov showed that to prove the classical hardness of sampling from these experiments it suffices to prove that a problem known as GPE, or Gaussian Permanent Estimation, is #P-hard. Roughly speaking the GPE conjecture is asking if obtaining a multiplicative estimate to an output probability of a random BosonSampling experiments is #P-hard. Moreover, assuming a statistical â€œflatnessâ€ property about the output distribution known as anticoncentration (which we also assume in this work), it suffices to prove that obtaining an additive error estimate of eâˆ’nâ¢logâ¡nâˆ’nâˆ’Oâ¢(logâ¡n)superscriptğ‘’ğ‘›ğ‘›ğ‘›ğ‘‚ğ‘›e^{-n\log{n}-n-O(\log n)}italic_e start_POSTSUPERSCRIPT - italic_n roman_log italic_n - italic_n - italic_O ( roman_log italic_n ) end_POSTSUPERSCRIPT to the output probability of most random experiments is #P-hard. This latter problem is known as GPEÂ±. In the last decade, progress has been made toward proving the hardness of GPEÂ± [AA13, BFLL22, Kro23]. While Aaronson and Arkhipovâ€™s initial work showed computing additive error estimates of eâˆ’Oâ¢(n4)superscriptğ‘’ğ‘‚superscriptğ‘›4e^{-O(n^{4})}italic_e start_POSTSUPERSCRIPT - italic_O ( italic_n start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT to the output probability of most BosonSampling experiments is #P-hard [AB16], this error tolerance was subsequently improved to eâˆ’6â¢nâ¢logâ¡nâˆ’Oâ¢(n)superscriptğ‘’6ğ‘›ğ‘›ğ‘‚ğ‘›e^{-6n\log{n}-O(n)}italic_e start_POSTSUPERSCRIPT - 6 italic_n roman_log italic_n - italic_O ( italic_n ) end_POSTSUPERSCRIPT by Bouland, Fefferman, Landau, and Liu [BFLL22], and then to eâˆ’4â¢nâ¢logâ¡nâˆ’Oâ¢(n)superscriptğ‘’4ğ‘›ğ‘›ğ‘‚ğ‘›e^{-4n\log{n}-O(n)}italic_e start_POSTSUPERSCRIPT - 4 italic_n roman_log italic_n - italic_O ( italic_n ) end_POSTSUPERSCRIPT in unpublished work of Krovi [Kro23] (personal communication). Therefore the remaining gap to establish the hardness of BosonSampling is to improve the robustness of this result by a constant factor in the exponent. This seems amazingly â€œcloseâ€ to the mark in additive terms yet exponentially far away in relative terms. We note the analogous conjectures for all other quantum advantage experiments remain open as well, such as Random Circuit Sampling [BIS+18], despite much progress in the area [BFNV19, Mov23, BFLL22, KMM22, ODMZ22, Kro22]. Why has it been so difficult to improve the robustness of this result and prove classical hardness of BosonSampling or any other quantum advantage experiment? One of the major reasons is that there are well-known barrier results that show that new techniques are needed to prove hardness of sampling. The first such barrier was noted in Aaronson and Arkhipovâ€™s original paper, which we call the â€œconvexity barrierâ€ [AA13]. The basic idea is that current worst-to-average-case reductions for the permanent are based on polynomial extrapolation, following Liptonâ€™s proof [Lip91]. The set of low-degree polynomials is convex, and necessarily must be exponentially ill-conditioned (even for the subset of polynomials corresponding to valid permanent extrapolations). Thus polynomial extrapolation cannot be used to cross the finish line and prove the hardness of GPEÂ±, as it will always introduce exponential relative error. For GPEÂ±, this barrier sits at eâˆ’3â¢nâ¢logâ¡nsuperscriptğ‘’3ğ‘›ğ‘›e^{-3n\log n}italic_e start_POSTSUPERSCRIPT - 3 italic_n roman_log italic_n end_POSTSUPERSCRIPT [BFLL22]. There is also a closely related â€œnoise barrierâ€ of [BFLL22], which states that any proof of sampling hardness must not be invariant to adding constant noise rate to the experimentâ€”and by convexity, polynomial interpolation does not cross this barrier. There are also barriers specific to particular experiments. For Random Circuit Sampling (RCS) over qubits, there are two additional barriers. One is the so-called â€œdepth barrierâ€ of Napp et al. [NLPD+22]. This paper gives a classical algorithm that approximately samples from the output distribution of shallow (i.e., sufficiently small constant) depth random quantum circuit sampling experiments. On the other hand, the existing techniques for proving hardness of computing output probabilities work with respect to circuits of any depth. Therefore, if we are to prove hardness of sampling, we need to find a proof technique that is sensitive to circuit depth and only works to prove hardness for sufficiently deep circuits. Another is the â€œworst-case barrierâ€ which was identified by Krovi [Kro22]. The issue is that the desired additive robustness of computing random circuit output probabilities (2âˆ’nsuperscript2ğ‘›~{}2^{-n}2 start_POSTSUPERSCRIPT - italic_n end_POSTSUPERSCRIPT) is actually larger than the known worst-case hardness in additive terms (2âˆ’2â¢nsuperscript22ğ‘›~{}2^{-2n}2 start_POSTSUPERSCRIPT - 2 italic_n end_POSTSUPERSCRIPT), as this is derived from Fourier Sampling. Since polynomial interpolation is sensitive to noise in additive terms, it canâ€™t be used to show hardness of sampling. For BosonSampling, there is another barrier we call the â€œJerrum-Sinclair-Vigoda barrier,â€ which may be even more fundamental. It is inspired by a well-known efficient classical algorithm for multiplicatively estimating the permanent of a matrix with non-negative entries [JSV04]. This algorithm tells us that any technique used to prove the hardness of GPEÂ± must fundamentally make use of the fact that matrices with i.i.d. ğ’©â¢(0,1)ğ’©01{\mathcal{N}}(0,1)caligraphic_N ( 0 , 1 ) entries have negative as well as positive entries. All existing worst-to-average-case reductions for Gaussian permanents work equally well for non-negative permanents as well. Thus current proofs canâ€™t possibly prove the GPE conjecture. In other words, to show hardness of sampling, we will need a proof which uses a special property of matrices with negative entries (like multiplicative hardness in the worst case) which does not hold for nonnegative matrices. Indeed we have also seen algorithmic attacks on GPEÂ± which work for Gaussian matrices with positive means [EM18]â€”which make use of the fact such matrices have â€œlessâ€ cancellation than Gaussian permanents. Finally, we note there is a relativization barrier of Aaronson and Chen [AC17], which says any proof of quantum approximate sampling advantage (i.e. sampling to small â„“1subscriptâ„“1\ell_{1}roman_â„“ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT error) must use non-relativizing techniques. However our work will focus on hardness of average-case exact sampling algorithms (i.e. sampling to small multiplicative error)â€”to which a relativization barrier does not apply as noted in [AC17]â€”see Discussion Sec. 1.3. 1.1 Our results In this work we introduce a new suite of tools which allow us to obtain an exponential improvement on the state-of-the-art robustness results for BosonSampling experiments. In particular we invent new techniques that overcome all of the barriers described above. While our work does not resolve the GPE conjecture, we show it allows us to prove the first non-trivial hardness of average-case sampling result for BosonSampling. For technical reasons all of our results will be proven for orthogonal BosonSampling, i.e. where the interferometer is a random orthogonal matrix, a case for which all existing arguments for BosonSampling hold equally well. We conjecture our results could also be extended to the complex case, and discuss some of the technical difficulties involved in doing so in E. Our first result is to show we can get within an nÎ´superscriptğ‘›ğ›¿n^{\delta}italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT factor of proving hardness of sampling for BosonSampling, for any Î´>0ğ›¿0\delta>0italic_Î´ > 0. This shows for the first time we can achieve a robustness whose leading order terms match those desired for sampling hardness: Theorem 1.1. For any Î´>0ğ›¿0\delta>0italic_Î´ > 0, it is #â¢P#P\#\textsf{P}# P-hard to approximate the output probabilities of an nğ‘›nitalic_n-photon Oâ¢(n2)ğ‘‚superscriptğ‘›2O(n^{2})italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT )-mode orthogonal BosonSampling experiment to additive error eâˆ’nâ¢logâ¡nâˆ’nâˆ’Oâ¢(nÎ´)superscriptğ‘’ğ‘›ğ‘›ğ‘›ğ‘‚superscriptğ‘›ğ›¿e^{-n\log n-n-O(n^{\delta})}italic_e start_POSTSUPERSCRIPT - italic_n roman_log italic_n - italic_n - italic_O ( italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT. This is nearly at the robustness needed for hardness of samplingâ€”in particular if the nÎ´superscriptğ‘›ğ›¿n^{\delta}italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT in the exponent could â€œmerelyâ€ be improved to Oâ¢(logâ¡n)ğ‘‚ğ‘›O(\log n)italic_O ( roman_log italic_n ), this would imply hardness of sampling. This overcomes all proof barriers identified for BosonSampling, including the convexity and Jerrum-Sinclair-Vigoda barriers. In order to prove this result, we give a new worst-to-average-case reduction for BosonSampling which replaces polynomial extrapolation with polynomial coefficient extraction. This allows us to lessen the degree of the polynomial involved in the coefficient extraction argument and hence reduce the ill-conditionedness of the worst-to-average-case reduction. Crucially our proof derives the value of the worst case to relative error, and hence requires worst-case matrices with negative entries, thus surpassing the Jerrum-Sinclair-Vigoda barrier. We also show this idea can be ported to other quantum advantage experiments, like random circuit sampling: Corollary 1.2. For any Î´>0ğ›¿0\delta>0italic_Î´ > 0, it is #â¢P#P\#\textsf{P}# P-hard to approximate the output probabilities of nğ‘›nitalic_n-qubit random circuit sampling experiments of logarithmic depth to additive error 2âˆ’nâˆ’Oâ¢(nÎ´)superscript2ğ‘›ğ‘‚superscriptğ‘›ğ›¿2^{-n-O(n^{\delta})}2 start_POSTSUPERSCRIPT - italic_n - italic_O ( italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT. Just as with BosonSampling, this exponentially improves over prior work [BFNV19, Mov23, BFLL22, KMM22, Kro22], and obtains hardness which is within an nÎ´superscriptğ‘›ğ›¿n^{\delta}italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT factor of what is needed for hardness of sampling. For RCS this proof surpasses the worst-case barrier of Krovi [Kro22], as the worst-case value of the reduction is (to leading order) the same111The astute reader may notice there is a subleading reduction in the worst-case valueâ€”this is fixed in Lemma 1.3 which also applies to RCS. as the average-case value due to the dilution. It also surpasses the depth barrier of Napp et al. [NLPD+22], as the proof uses anticoncentration of RCS, which does not hold for general constant-depth RCS ensembles [DHB20a]. It thus clears all barriers for RCS as well. A closer examination of our first result, however, reveals it does not yet allow us to show any hardness of average-case sampling results. This is because the proof exhibits an exponential robustness loss in going from the average case to worst case via polynomial coefficient extraction (now reduced from eOâ¢(nâ¢logâ¡n)superscriptğ‘’ğ‘‚ğ‘›ğ‘›e^{O(n\log n)}italic_e start_POSTSUPERSCRIPT italic_O ( italic_n roman_log italic_n ) end_POSTSUPERSCRIPT to eOâ¢(nÎ´)superscriptğ‘’ğ‘‚superscriptğ‘›ğ›¿e^{O(n^{\delta})}italic_e start_POSTSUPERSCRIPT italic_O ( italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT) with no possible compensating exponential gain in the proof (for either BosonSampling or RCS). The only compensating factor in the proof is from the error in the Stockmeyer counting which is at most inverse-polynomial. Thus one cannot obtain hardness of sampling from this first argument. To address this, we develop a new worst-to-average-case reduction in which the exponential loss in robustness from coefficient extraction can be compensated by an exponential gain in robustness as well for the first time. This opens the possibility of showing an average-case sampling hardness result via Stockmeyer counting. In particular we show: Lemma 1.3. (Informal) It is #â¢ğ–¯#ğ–¯\#\mathsf{P}# sansserif_P-hard to compute output probabilities of real BosonSampling experiments to relative error Ïµrâ¢eâ¢lsubscriptitalic-Ïµğ‘Ÿğ‘’ğ‘™\epsilon_{rel}italic_Ïµ start_POSTSUBSCRIPT italic_r italic_e italic_l end_POSTSUBSCRIPT satisfying Ïµrâ¢eâ¢lâ‰¤lossÃ—vâ¢aâ¢lworsevâ¢aâ¢lavgsubscriptitalic-Ïµğ‘Ÿğ‘’ğ‘™lossğ‘£ğ‘subscriptğ‘™worseğ‘£ğ‘subscriptğ‘™avg\epsilon_{rel}\leq\text{loss}\times\frac{val_{\text{worse}}}{val_{\text{avg}}}italic_Ïµ start_POSTSUBSCRIPT italic_r italic_e italic_l end_POSTSUBSCRIPT â‰¤ loss Ã— divide start_ARG italic_v italic_a italic_l start_POSTSUBSCRIPT worse end_POSTSUBSCRIPT end_ARG start_ARG italic_v italic_a italic_l start_POSTSUBSCRIPT avg end_POSTSUBSCRIPT end_ARG where here vâ¢aâ¢lworseğ‘£ğ‘subscriptğ‘™worseval_{\text{worse}}italic_v italic_a italic_l start_POSTSUBSCRIPT worse end_POSTSUBSCRIPT is the value of the worst-case permanent we are computing, and vâ¢aâ¢lavgğ‘£ğ‘subscriptğ‘™avgval_{\text{avg}}italic_v italic_a italic_l start_POSTSUBSCRIPT avg end_POSTSUBSCRIPT is the value of the average-case permanent of the ensemble, and loss is the (exponential) loss of ill-conditionedness of polynomial coefficient extraction or extrapolation. To show hardness of average-case exact sampling, one needs Ïµrâ¢eâ¢lsubscriptitalic-Ïµğ‘Ÿğ‘’ğ‘™\epsilon_{rel}italic_Ïµ start_POSTSUBSCRIPT italic_r italic_e italic_l end_POSTSUBSCRIPT to be at most inverse polynomialâ€”then this would imply that Stockmeyerâ€™s algorithm could obtain this approximation, and hence place #â¢ğ–¯âŠ†ğ–¡ğ–¯ğ–¯ğ–­ğ–¯#ğ–¯superscriptğ–¡ğ–¯ğ–¯ğ–­ğ–¯\#\mathsf{P}\subseteq{\mathsf{BPP}}^{\mathsf{NP}}# sansserif_P âŠ† sansserif_BPP start_POSTSUPERSCRIPT sansserif_NP end_POSTSUPERSCRIPT. The key point of this equation is, for the first time, this exponential extrapolation is fighting against a compensating termâ€”the ratio of worst to average-case valuesâ€”which can be made exponential in nğ‘›nitalic_n as well. For example, for a permanent of ğ’©â¢(0,1)ğ’©01{\mathcal{N}}(0,1)caligraphic_N ( 0 , 1 ) matrices, the worst-case value (n!ğ‘›n!italic_n !) can be exponentially bigger than the average case value ( Oâ¢(n!)ğ‘‚ğ‘›O(\sqrt{n!})italic_O ( square-root start_ARG italic_n ! end_ARG )), and we will show we can restrict our worst case to having large permanents while retaining hardness. Thus the fate of average-case sampling hardness hangs in the balance of a tug of war between two competing exponential terms. If we could simply reduce the coefficient extraction loss to a weaker exponential, or strengthen the worst to average-case ratio to a bigger exponential, this could potentially solve hardness of sampling. We note an analogous theorem holds for a real variant of RCS as well. Lemma 1.3 does not quite resolve the hardness of GPEÂ±. If we engineer our worst case matrix to have a permanent of roughly n!ğ‘›n!italic_n ! (appropriately rescaled) and apply coefficient extraction, it gives us a robustness of eâˆ’1.5â¢nâ¢logâ¡nsuperscriptğ‘’1.5ğ‘›ğ‘›e^{-1.5n\log n}italic_e start_POSTSUPERSCRIPT - 1.5 italic_n roman_log italic_n end_POSTSUPERSCRIPT for standard BosonSampling, but now for a dense worst case, i.e. there is no â€œdilutionâ€ occurring in the argument. However, it does allow us to show, for the first time, a hardness of sampling result for random BosonSampling experiments: Theorem 1.4. There is no efficient classical algorithm which exactly samples from the output distribution of nğ‘›nitalic_n-photon Oâ¢(n2)ğ‘‚superscriptğ‘›2O(n^{2})italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT )-mode real BosonSampling experiments with probability more than 1âˆ’2âˆ’Oâ¢(n)1superscript2ğ‘‚ğ‘›1-2^{-O(n)}1 - 2 start_POSTSUPERSCRIPT - italic_O ( italic_n ) end_POSTSUPERSCRIPT over the choice of experiment, assuming PH does not collapse and a slight generalization of permanent anticoncentration. Here by exact sampler we mean one which makes small relative error on each output probability of the experiment. The proof of this fact requires introducing new tools in worst-to-average-case reductions which go beyond total variation distance as a means to quantify when an average-case algorithm works. We note that this sampling result is weaker than what would be implied by a proof of the GPE conjecture in two ways. First, this result proves the impossibility of classically sampling from 1âˆ’1/2Oâ¢(n)11superscript2ğ‘‚ğ‘›1-1/2^{O(n)}1 - 1 / 2 start_POSTSUPERSCRIPT italic_O ( italic_n ) end_POSTSUPERSCRIPT fraction of experiments, whereas a proof of the GPE conjecture would strengthen this to 1âˆ’1/polyâ¢(n)11polyğ‘›1-1/{\mathrm{poly}}(n)1 - 1 / roman_poly ( italic_n ) fraction of experiments. This is nontrivial, as our exponential function is larger than what we would need to say the algorithm computes the worst case directly222We emphasize that the input size for an nğ‘›nitalic_n-photon experiment is much bigger than nğ‘›nitalic_n (it is Oâ¢(n2)ğ‘‚superscriptğ‘›2O(n^{2})italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) entries, each of which must be specified to O~â¢(n)~ğ‘‚ğ‘›\tilde{O}(n)over~ start_ARG italic_O end_ARG ( italic_n ) bits of precision to define the average-case exact sampling problem). (which is 1âˆ’2âˆ’Oâ¢(n3)1superscript2ğ‘‚superscriptğ‘›31-2^{-O(n^{3})}1 - 2 start_POSTSUPERSCRIPT - italic_O ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT by Lemma 4.6). Second, our result works to rule out a classical algorithm that samples exactly (or multiplicatively close in every probability) from these experiments, rather than approximately in total variation distance. Third, we assume a slightly stronger version of anticoncentration conjecture than is standard in BosonSampling. Those caveats aside, the main point of our new result is that it shows for the first time that one can show a form of average-case sampling hardness, using polynomial coefficient extraction techniques combined with Stockmeyer counting. This had been open for all quantum supremacy proposals, as prior near-exact hardness results for computing output probabilities do not imply any average-case sampling hardness (even of exact sampling) due to the weakness of Stockmeyer counting. Interestingly this last result only holds for BosonSampling, as the state of average-case hardness for RCS is further from the target robustness than BosonSamplingâ€”see Discussion 1.3. 1.2 Proof techniques To explain our proof, it is helpful to briefly recall the average-case hardness proofs of [AA13] and its subsequent improvements [BFLL22, Kro23]. The basic idea is to use polynomial interpolation to show the squared permanent is hard to compute on average, following Lipton [Lip91]. Suppose we wish to compute the squared permanent of a worst-case matrix Wâˆˆ{0,Â±1}nÃ—nğ‘Šsuperscript0plus-or-minus1ğ‘›ğ‘›W\in\{0,\pm 1\}^{n\times n}italic_W âˆˆ { 0 , Â± 1 } start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT using only the ability to compute most Gaussian permanents Rğ‘…Ritalic_R drawn from ğ’©â¢(0,1)nÃ—nğ’©superscript01ğ‘›ğ‘›{\mathcal{N}}(0,1)^{n\times n}caligraphic_N ( 0 , 1 ) start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT. We define a univariate family of matrices interpolating between Wğ‘ŠWitalic_W and a single random choice of Gaussian matrix Rğ‘…Ritalic_R: Aâ¢(t)=(1âˆ’t)â¢R+tâ¢Wğ´ğ‘¡1ğ‘¡ğ‘…ğ‘¡ğ‘ŠA(t)=(1-t)R+tWitalic_A ( italic_t ) = ( 1 - italic_t ) italic_R + italic_t italic_W This family has three nice properties that enable the reduction: first |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT is a low-degree polynomial in tğ‘¡titalic_t, second the marginal distribution on Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) is close to Gaussian on small values of tğ‘¡titalic_t, and third, |Perâ¡(Aâ¢(1))|2=|Perâ¡(W)|2superscriptPerğ´12superscriptPerğ‘Š2|\operatorname{Per}(A(1))|^{2}=|\operatorname{Per}(W)|^{2}| roman_Per ( italic_A ( 1 ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = | roman_Per ( italic_W ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. This means one can compute |Perâ¡(W)|2superscriptPerğ‘Š2|\operatorname{Per}(W)|^{2}| roman_Per ( italic_W ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT by computing |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT at many small values of tğ‘¡titalic_t, inferring the polynomial in tğ‘¡titalic_t, and extrapolating it to 1111. The robustness of this worst-to-average-case reduction to errors on the average-case points is the ill-conditionedness of the polynomial extrapolation step. This is controlled by the degree of the polynomial involved (dğ‘‘ditalic_d), and second, the distance of extrapolation Î”Î”\Deltaroman_Î”. If a degree dğ‘‘ditalic_d polynomial is evaluated to error Â±Ïµplus-or-minusitalic-Ïµ\pm\epsilonÂ± italic_Ïµ at points t<1/Î”ğ‘¡1Î”t<1/\Deltaitalic_t < 1 / roman_Î” and extrapolated to t=1ğ‘¡1t=1italic_t = 1, the error at 1111 blows up by roughly Ïµâ¢Î”ditalic-ÏµsuperscriptÎ”ğ‘‘\epsilon\Delta^{d}italic_Ïµ roman_Î” start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT. In both the proofs of [BFLL22] and [Kro23] the main improvement was in reducing the distance of extrapolation, while keeping the same degree of polynomial (2â¢n2ğ‘›2n2 italic_n for a squared permanent). In particular in [BFLL22] the distance was reduced to Î”=Oâ¢(1/n2)Î”ğ‘‚1superscriptğ‘›2\Delta=O(1/n^{2})roman_Î” = italic_O ( 1 / italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) by introducing a robust version of Berkelamp-Welch over the complex numbers 333We note similar results for BosonSampling could be obtained by the techniques of [KMM22].. In [Kro23] the distance was improved to Î”=Oâ¢(1/n)Î”ğ‘‚1ğ‘›\Delta=O(1/n)roman_Î” = italic_O ( 1 / italic_n ) by combining this with a more sophisticated calculation of the total variation distance between Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) and Gaussian, which saves a factor of n2â¢n=e2â¢nâ¢logâ¡nsuperscriptğ‘›2ğ‘›superscriptğ‘’2ğ‘›ğ‘›n^{2n}=e^{2n\log n}italic_n start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT = italic_e start_POSTSUPERSCRIPT 2 italic_n roman_log italic_n end_POSTSUPERSCRIPT in the exponent. These yield the stated robustness values when suitably renormalized. 1.2.1 Coefficient extraction: a new way to encode the permanent A natural approach to try to improve the robustness of this argument is to reduce the degree of the polynomial involved. A simple observation is that for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, it is #â¢ğ–¯#ğ–¯\#\mathsf{P}# sansserif_P-hard to compute the permanent of an nÎµÃ—nÎµsuperscriptğ‘›ğœ€superscriptğ‘›ğœ€n^{\varepsilon}\times n^{\varepsilon}italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT Ã— italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT matrix Wğ‘ŠWitalic_W as wellâ€”this is simply polynomially shrinking the input size. Therefore a natural way to improve the robustness is to try to make Wğ‘ŠWitalic_W smaller. Unfortunately this doesnâ€™t yield much progress with polynomial extrapolation arguments. Thatâ€™s because if we set Wğ‘ŠWitalic_W to have small supportâ€”say with only Oâ¢(nÎµ)ğ‘‚superscriptğ‘›ğœ€O(n^{\varepsilon})italic_O ( italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ) nonzero entriesâ€”then Perâ¡(W)=0Perğ‘Š0\operatorname{Per}(W)=0roman_Per ( italic_W ) = 0. Trivially, a matrix must have at least nğ‘›nitalic_n non-zero entries for its permanent to be non-zero. This lower bounds how much one could gain by such arguments using extrapolation, and the best one can obtain by dilution is eâˆ’3â¢nâ¢logâ¡nâˆ’Oâ¢(n)superscriptğ‘’3ğ‘›ğ‘›ğ‘‚ğ‘›e^{-3n\log n-O(n)}italic_e start_POSTSUPERSCRIPT - 3 italic_n roman_log italic_n - italic_O ( italic_n ) end_POSTSUPERSCRIPT robustness444This is obtained by setting Wğ‘ŠWitalic_W to be a tiny nÎµsuperscriptğ‘›ğœ€n^{\varepsilon}italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT dimension worst-case matrix in the upper left corner in direct sum with an identity on the remaining nâˆ’nÎµğ‘›superscriptğ‘›ğœ€n-n^{\varepsilon}italic_n - italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT dimensionsâ€”which sits right at the convexity barrier. Our first step is to change the worst-to-average-case reduction from a problem about polynomial extrapolation to a problem about polynomial coefficient extraction. We consider a one-parameter family of matrices Aâ¢(t)=R+tâ¢Wdiluteğ´ğ‘¡ğ‘…ğ‘¡subscriptğ‘ŠdiluteA(t)=R+tW_{\text{dilute}}italic_A ( italic_t ) = italic_R + italic_t italic_W start_POSTSUBSCRIPT dilute end_POSTSUBSCRIPT and consider the case that Wdilutesubscriptğ‘ŠdiluteW_{\text{dilute}}italic_W start_POSTSUBSCRIPT dilute end_POSTSUBSCRIPT consists of a tiny nÎµsuperscriptğ‘›ğœ€n^{\varepsilon}italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT-sized worst case matrix Wâ€²superscriptğ‘Šâ€²W^{\prime}italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT in direct sum with the all 00â€™s matrix on the remaining nâˆ’nÎµğ‘›superscriptğ‘›ğœ€n-n^{\varepsilon}italic_n - italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT dimensions. The key point of this construction is, even though the value of |Perâ¡(Aâ¢(1))|2superscriptPerğ´12|\operatorname{Per}(A(1))|^{2}| roman_Per ( italic_A ( 1 ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT is not what we want (as Aâ¢(1)=R+Wdiluteğ´1ğ‘…subscriptğ‘ŠdiluteA(1)=R+W_{\text{dilute}}italic_A ( 1 ) = italic_R + italic_W start_POSTSUBSCRIPT dilute end_POSTSUBSCRIPT), the coefficients of the polynomial |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT do encode information about Perâ¡(Wâ€²)Persuperscriptğ‘Šâ€²\operatorname{Per}(W^{\prime})roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ). In particular, the degree of the polynomial |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT is now n2â¢Îµsuperscriptğ‘›2ğœ€n^{2\varepsilon}italic_n start_POSTSUPERSCRIPT 2 italic_Îµ end_POSTSUPERSCRIPT, and the top coefficient is |Perâ¡(Wâ€²)|2â¢|Perâ¡(RD)|2superscriptPersuperscriptğ‘Šâ€²2superscriptPersubscriptğ‘…ğ·2|\operatorname{Per}(W^{\prime})|^{2}|\operatorname{Per}(R_{D})|^{2}| roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT | roman_Per ( italic_R start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, where RDsubscriptğ‘…ğ·R_{D}italic_R start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT is the bottom righthand minor of Rğ‘…Ritalic_R of dimension nâˆ’nÎµğ‘›superscriptğ‘›ğœ€n-n^{\varepsilon}italic_n - italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT (see Figure 1): |Perâ¡(Aâ¢(t))|2=|Perâ¡(Wâ€²)|2â¢|Perâ¡(RD)|2â¢t2â¢nÎµ+âˆ‘â„“=0n2â¢Îµâˆ’1câ„“â¢tâ„“superscriptPerğ´ğ‘¡2superscriptPersuperscriptğ‘Šâ€²2superscriptPersubscriptğ‘…ğ·2superscriptğ‘¡2superscriptğ‘›ğœ€superscriptsubscriptâ„“0superscriptğ‘›2ğœ€1subscriptğ‘â„“superscriptğ‘¡â„“|\operatorname{Per}(A(t))|^{2}=|\operatorname{Per}(W^{\prime})|^{2}|% \operatorname{Per}(R_{D})|^{2}t^{2n^{\varepsilon}}+\displaystyle\sum_{\ell=0}^% {n^{2\varepsilon}-1}c_{\ell}t^{\ell}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = | roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT | roman_Per ( italic_R start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_t start_POSTSUPERSCRIPT 2 italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT + âˆ‘ start_POSTSUBSCRIPT roman_â„“ = 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 2 italic_Îµ end_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_c start_POSTSUBSCRIPT roman_â„“ end_POSTSUBSCRIPT italic_t start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT where the câ„“subscriptğ‘â„“c_{\ell}italic_c start_POSTSUBSCRIPT roman_â„“ end_POSTSUBSCRIPT are some other coefficients which depend (in some complicated manner) on the entries of Rğ‘…Ritalic_R and Wğ‘ŠWitalic_W. To see this, simply note that any term in the permanent which picks up all possible factors of tğ‘¡titalic_t must take all of its entries in the first nÎµsuperscriptğ‘›ğœ€n^{\varepsilon}italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT rows from the upper left submatrix. |Per(\Bigg{|}\operatorname{Per}\bigg{(}| roman_Per (Râˆ¼ğ’©â¢(0,1)nÃ—nsimilar-toğ‘…ğ’©superscript01ğ‘›ğ‘›R\sim{\mathcal{N}}(0,1)^{n\times n}italic_R âˆ¼ caligraphic_N ( 0 , 1 ) start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT+++tğ‘¡titalic_t000000RCsubscriptğ‘…ğ¶R_{C}italic_R start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPTRDsubscriptğ‘…ğ·R_{D}italic_R start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPTRAsubscriptğ‘…ğ´R_{A}italic_R start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPTRBsubscriptğ‘…ğµR_{B}italic_R start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPTWâ€²superscriptğ‘Šâ€²W^{\prime}italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPTWâ€²âˆˆ{0,Â±1}nÎµÃ—nÎµsuperscriptğ‘Šâ€²superscript0plus-or-minus1superscriptğ‘›ğœ€superscriptğ‘›ğœ€W^{\prime}\in\{0,\pm 1\}^{n^{\varepsilon}\times n^{\varepsilon}}italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ { 0 , Â± 1 } start_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT Ã— italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPTWdâ¢iâ¢lâ¢uâ¢tâ¢esubscriptğ‘Šğ‘‘ğ‘–ğ‘™ğ‘¢ğ‘¡ğ‘’W_{{dilute}}italic_W start_POSTSUBSCRIPT italic_d italic_i italic_l italic_u italic_t italic_e end_POSTSUBSCRIPT)|\bigg{)}\Bigg{|}) | Figure 1: In Theorem 1.1, we extract the coefficient of the polynomial |Perâ¡(R+tâ¢Wdâ¢iâ¢lâ¢uâ¢tâ¢e)|,Perğ‘…ğ‘¡subscriptğ‘Šğ‘‘ğ‘–ğ‘™ğ‘¢ğ‘¡ğ‘’|\operatorname{Per}(R+tW_{dilute})|,| roman_Per ( italic_R + italic_t italic_W start_POSTSUBSCRIPT italic_d italic_i italic_l italic_u italic_t italic_e end_POSTSUBSCRIPT ) | , where Rğ‘…Ritalic_R is a matrix of standard normals and Wdâ¢iâ¢lâ¢uâ¢tâ¢esubscriptğ‘Šğ‘‘ğ‘–ğ‘™ğ‘¢ğ‘¡ğ‘’W_{dilute}italic_W start_POSTSUBSCRIPT italic_d italic_i italic_l italic_u italic_t italic_e end_POSTSUBSCRIPT has a worst-case matrix in its upper left block of size nÎµÃ—nÎµsuperscriptğ‘›ğœ€superscriptğ‘›ğœ€n^{\varepsilon}\times n^{\varepsilon}italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT Ã— italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT for any constant Îµ>0,ğœ€0\varepsilon>0,italic_Îµ > 0 , with all other matrix entries being 0. The top coefficient of this polynomial is |Perâ¡Wâ€²|â¢|Perâ¡RD|,Persuperscriptğ‘Šâ€²Persubscriptğ‘…ğ·\left|\operatorname{Per}W^{\prime}||\operatorname{Per}R_{D}\right|,| roman_Per italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT | | roman_Per italic_R start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT | , where RDsubscriptğ‘…ğ·R_{D}italic_R start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT is the complementary minor to Wâ€².superscriptğ‘Šâ€²W^{\prime}.italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT . With this insight in hand, we can now give a new worst-to-average-case reduction for the permanent based on coefficient extraction: to compute |Perâ¡(Wâ€²)|2superscriptPersuperscriptğ‘Šâ€²2|\operatorname{Per}(W^{\prime})|^{2}| roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT for some worst-case matrix Wâ€²âˆˆ{0,Â±1}nÎµÃ—nÎµsuperscriptğ‘Šâ€²superscript0plus-or-minus1superscriptğ‘›ğœ€superscriptğ‘›ğœ€W^{\prime}\in\{0,\pm 1\}^{n^{\varepsilon}\times n^{\varepsilon}}italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ { 0 , Â± 1 } start_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT Ã— italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT, pick many small values of tğ‘¡titalic_t (t=Oâ¢(1/nÎµ)ğ‘¡ğ‘‚1superscriptğ‘›ğœ€t=O(1/n^{\varepsilon})italic_t = italic_O ( 1 / italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ) suffices by prior arguments) and compute |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT using our average-case algorithm. Then ask the ğ–­ğ–¯ğ–­ğ–¯{\mathsf{NP}}sansserif_NP oracle to give us a polynomial of degree 2â¢nÎµ2superscriptğ‘›ğœ€2n^{\varepsilon}2 italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT which approximately matches these values. Now look at the top coefficient of that polynomial, and divide by the value of |Perâ¡(RD)|2superscriptPersubscriptğ‘…ğ·2|\operatorname{Per}(R_{D})|^{2}| roman_Per ( italic_R start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. Crucially, we can estimate the value of |Perâ¡(RD)|2superscriptPersubscriptğ‘…ğ·2|\operatorname{Per}(R_{D})|^{2}| roman_Per ( italic_R start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT to small multiplicative error, as this is another average-case instance. As multiplicative error only adds under division, this now gives us a multiplicative estimate for |Perâ¡(Wâ€²)|2superscriptPersuperscriptğ‘Šâ€²2|\operatorname{Per}(W^{\prime})|^{2}| roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. In other words, our algorithm translates relative error in the average case to relative error in the worst case. We show that the overall robustness of this algorithm is merely Oâ¢(nÎ´)ğ‘‚superscriptğ‘›ğ›¿O(n^{\delta})italic_O ( italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT ) far in the exponent from showing quantum advantage, for any Î´>0ğ›¿0\delta>0italic_Î´ > 0 (Theorem 1.1). The key point is that our polynomial coefficient extraction step now merely depends on a polynomial of degree 2â¢nÎµ2superscriptğ‘›ğœ€2n^{\varepsilon}2 italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT rather than 2â¢n2ğ‘›2n2 italic_n, and as such its ill-conditionedness is exponentially improved. Moreover, we have crossed the Jerrum-Sinclair-Vigoda barrier for BosonSampling, as this proof requires that a multiplicative estimate to |Perâ¡(Wâ€²)|2superscriptPersuperscriptğ‘Šâ€²2|\operatorname{Per}(W^{\prime})|^{2}| roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT remains #â¢ğ–¯#ğ–¯\#\mathsf{P}# sansserif_P-hard, which only holds for matrices with both positive and negative entries. In other words, this reduction fundamentally uses the â€œquantumâ€ nature of the problemâ€”namely the GapP-completeness of computing its output probabilitiesâ€”which is at the core of the conjectured approximation resistance of average-case permanents. The corollary for RCS follows by a similar dilution argumentâ€”one simply picks a worst case random circuit which is a concatenation of an nÎµsuperscriptğ‘›ğœ€n^{\varepsilon}italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT qubit worst case instance with an nâˆ’nÎµğ‘›superscriptğ‘›ğœ€n-n^{\varepsilon}italic_n - italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT-sized random instance, and applies prior worst-to-average-case reductions [Mov23, BFLL22, KMM22]. See Appendix B for details. 1.2.2 Making exponential gains against robustness loss via squared polynomials While this first result exponentially improves on prior work, it is natural to ask how much closer we are to proving the GPE conjecture, or more generally to establishing hardness of sampling. The above results are obtained by diluting the worst case instance size so that the extrapolation/coefficient extraction blowup is lessened. However, the amount of extrapolation blowup relative to the worst case instance size has not improved. At a deeper level, despite crossing all the barriers, the proof so far still doesnâ€™t have any hope of showing hardness of sampling from Stockmeyer counting. This is because Stockmeyer counting gives ğ–¡ğ–¯ğ–¯ğ–­ğ–¯superscriptğ–¡ğ–¯ğ–¯ğ–­ğ–¯{\mathsf{BPP}}^{\mathsf{NP}}sansserif_BPP start_POSTSUPERSCRIPT sansserif_NP end_POSTSUPERSCRIPT algorithm for approximating these squared permanents to inverse poly multiplicative error, but the worst-to-average-case reduction then blows up this error exponentially. There is no compensating factor in the reduction to â€œfight againstâ€ this exponential loss. In our next set of results, we extend the coefficient extraction technique to obtain a new worst-to-average-case reduction for the permanent that contains a termâ€”in particular a worst to average-case value ratioâ€”which fights against the extrapolation loss, and which can be pumped to be an exponentially large value. Thus the status of GPE hinges on tug of war between two competing exponential factors. Interestingly, this result will only hold for orthogonal BosonSampling, and the extension to complex unitary interferometers appears to be related to open problems in complex analysis (see Sec. 1.3). To do this, it is helpful to take a step back to examine what happens with dense worst case matrices with our new coefficient extraction approach. We apply two new modifications to coefficient extraction which improve the robustness of the dense case from eâˆ’4â¢nâ¢logâ¡nâˆ’Oâ¢(n)superscriptğ‘’4ğ‘›ğ‘›ğ‘‚ğ‘›e^{-4n\log n-O(n)}italic_e start_POSTSUPERSCRIPT - 4 italic_n roman_log italic_n - italic_O ( italic_n ) end_POSTSUPERSCRIPT [Kro23] to eâˆ’1.5â¢nâ¢logâ¡nâˆ’Oâ¢(n)superscriptğ‘’1.5ğ‘›ğ‘›ğ‘‚ğ‘›e^{-1.5n\log n-O(n)}italic_e start_POSTSUPERSCRIPT - 1.5 italic_n roman_log italic_n - italic_O ( italic_n ) end_POSTSUPERSCRIPT. While these modifications appear simple at first glance, we will see they introduce a term which we can use to combat extrapolation loss. This dense result may at first look like a step backwards, but we will late show this result is strong enough to imply a nontrivial hardness of sampling result. The first idea to improve robustness in the dense case is to simply use the fact that |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT is the square of a polynomial to reduce the degree of coefficient extraction. Suppose our worst-case matrix Wğ‘ŠWitalic_W is dense and define Aâ¢(t):-R+tâ¢W:-ğ´ğ‘¡ğ‘…ğ‘¡ğ‘ŠA(t)\coloneq R+tWitalic_A ( italic_t ) :- italic_R + italic_t italic_W as before. While |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT is a degree 2â¢n2ğ‘›2n2 italic_n polynomial, trivially we have that |Perâ¡(Aâ¢(t))|2=pâ¢(t)2superscriptPerğ´ğ‘¡2ğ‘superscriptğ‘¡2|\operatorname{Per}(A(t))|^{2}=p(t)^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = italic_p ( italic_t ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT for some degree-nğ‘›nitalic_n polynomial pâ¢(t)ğ‘ğ‘¡p(t)italic_p ( italic_t ). In our reduction, after (approximately) computing pâ¢(t)2ğ‘superscriptğ‘¡2p(t)^{2}italic_p ( italic_t ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT at many values of tğ‘¡titalic_t using our average-case algorithm, we can ask the ğ–­ğ–¯ğ–­ğ–¯{\mathsf{NP}}sansserif_NP oracle to give us the underlying degree nğ‘›nitalic_n polynomial pâ¢(t)ğ‘ğ‘¡p(t)italic_p ( italic_t ) which squares to the correct value (up to the error tolerance in the average case computation). For real-value matrices, pâ¢(t)ğ‘ğ‘¡p(t)italic_p ( italic_t ) is real, so is uniquely defined up to a sign which we can resolve later in the proof. Again the highest coefficient of this polynomial (now the coefficient of tnsuperscriptğ‘¡ğ‘›t^{n}italic_t start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT) contains the value of Perâ¡(W)Perğ‘Š\operatorname{Per}(W)roman_Per ( italic_W ) that we wish to compute. One might a priori guess this simple change merely reduces the degree of extrapolation from 2â¢n2ğ‘›2n2 italic_n to nğ‘›nitalic_n. Surprisingly, it has more benefit than that! In particular, suppose our average-case algorithm computes pâ¢(t)2ğ‘superscriptğ‘¡2p(t)^{2}italic_p ( italic_t ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT to additive error Â±Î³plus-or-minusğ›¾\pm\gammaÂ± italic_Î³ at the points tğ‘¡titalic_t near 00. How much error is induced on pâ¢(t)ğ‘ğ‘¡p(t)italic_p ( italic_t ) itself? It turns out, pâ¢(t)ğ‘ğ‘¡p(t)italic_p ( italic_t ) is estimated to less error than Î³ğ›¾\gammaitalic_Î³. Suppose our ğ–­ğ–¯ğ–­ğ–¯{\mathsf{NP}}sansserif_NP oracle gives us a polynomial p~â¢(t)=pâ¢(t)+eâ¢(t)~ğ‘ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘¡\tilde{p}(t)=p(t)+e(t)over~ start_ARG italic_p end_ARG ( italic_t ) = italic_p ( italic_t ) + italic_e ( italic_t ) where eâ¢(t)ğ‘’ğ‘¡e(t)italic_e ( italic_t ) is some error polynomial. Then trivially we have pâ¢(t)2Â±Î³=(pâ¢(t)+eâ¢(t))2=pâ¢(t)2+2â¢pâ¢(t)â¢eâ¢(t)+eâ¢(t)2plus-or-minusğ‘superscriptğ‘¡2ğ›¾superscriptğ‘ğ‘¡ğ‘’ğ‘¡2ğ‘superscriptğ‘¡22ğ‘ğ‘¡ğ‘’ğ‘¡ğ‘’superscriptğ‘¡2p(t)^{2}\pm\gamma=(p(t)+e(t))^{2}=p(t)^{2}+2p(t)e(t)+e(t)^{2}italic_p ( italic_t ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT Â± italic_Î³ = ( italic_p ( italic_t ) + italic_e ( italic_t ) ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = italic_p ( italic_t ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + 2 italic_p ( italic_t ) italic_e ( italic_t ) + italic_e ( italic_t ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT As our error are vanishingly small in relative terms, the cross error term dominates, and we see that trivially |eâ¢(t)|â‰¤Î³pâ¢(t)ğ‘’ğ‘¡ğ›¾ğ‘ğ‘¡|e(t)|\leq\frac{\gamma}{p(t)}| italic_e ( italic_t ) | â‰¤ divide start_ARG italic_Î³ end_ARG start_ARG italic_p ( italic_t ) end_ARG at points tğ‘¡titalic_t near 00. In other words, we get to divide our error by the average-case value of the permanent, before we propagate the error through coefficient extraction. By assuming the Permanent Anticoncentration Conjecture 2.3, this value is n!ğ‘›\sqrt{n!}square-root start_ARG italic_n ! end_ARG so saves us an additional 0.5â¢nâ¢logâ¡n0.5ğ‘›ğ‘›0.5n\log n0.5 italic_n roman_log italic_n in the exponent beyond what we might have otherwise expected to gain in additive terms. This observation gets more interesting if we view it in relative terms. This correction factor can be seen as ensuring the relative error on pâ¢(t)ğ‘ğ‘¡p(t)italic_p ( italic_t ) is the same (up to a constant factor of 2) as the relative error on pâ¢(t)2ğ‘superscriptğ‘¡2p(t)^{2}italic_p ( italic_t ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, as relative error is preserved (up to constants) under taking powers. An observation is that this degree reduction via the square of a polynomial kept our error constant in relative terms on our underlying polynomial. On the other hand, polynomial coefficient extraction is naturally sensitive to error in additive terms. Our second observation is that we can use this mismatch to reduce the extrapolation error in relative terms, by an exponential amount. The basic idea is to now consider a worst case matrix with two components: first, a smaller and possibly negative-entry matrix Wâ€²superscriptğ‘Šâ€²W^{\prime}italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT in the upper left hand corner of size nÎµsuperscriptğ‘›ğœ€n^{\varepsilon}italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT, in direct sum with a larger matrix of all 1111â€™s of dimension nâˆ’nÎµğ‘›superscriptğ‘›ğœ€n-n^{\varepsilon}italic_n - italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT (see Figure 2). |Per(\Bigg{|}\operatorname{Per}\bigg{(}| roman_Per (Râˆ¼ğ’©â¢(0,1)nÃ—nsimilar-toğ‘…ğ’©superscript01ğ‘›ğ‘›R\sim{\mathcal{N}}(0,1)^{n\times n}italic_R âˆ¼ caligraphic_N ( 0 , 1 ) start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT+++tğ‘¡titalic_t0000 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Wâ€²âˆˆ{0,Â±1}nÎµÃ—nÎµsuperscriptğ‘Šâ€²superscript0plus-or-minus1superscriptğ‘›ğœ€superscriptğ‘›ğœ€W^{\prime}\in\{0,\pm 1\}^{n^{\varepsilon}\times n^{\varepsilon}}italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ { 0 , Â± 1 } start_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT Ã— italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPTWğ‘ŠWitalic_W)|\bigg{)}\Bigg{|}) | Figure 2: Polynomial |Perâ¡(R+tâ¢W)|,Perğ‘…ğ‘¡ğ‘Š|\operatorname{Per}(R+tW)|,| roman_Per ( italic_R + italic_t italic_W ) | , whose top coefficient is |Perâ¡Wâ€²|â¢(nâˆ’nÎµ)!.Persuperscriptğ‘Šâ€²ğ‘›superscriptğ‘›ğœ€|\operatorname{Per}W^{\prime}|(n-n^{\varepsilon})!.| roman_Per italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT | ( italic_n - italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ) ! . This is the ensemble under consideration in Thm. 4.5 where we coefficient-extract the unsquared permanent via the square method and use worst-case amplification by padding Wğ‘ŠWitalic_W with a matrix of 1111s. Interestingly, including this large-permanent sub matrix in our worst case actually improves our robustness in the worst-to-average-case reduction! This is because for this scheme, the top coefficient of the polynomial pâ¢(t)=Perâ¡(Aâ¢(t))ğ‘ğ‘¡Perğ´ğ‘¡p(t)=\operatorname{Per}(A(t))italic_p ( italic_t ) = roman_Per ( italic_A ( italic_t ) ) is equal to Perâ¡(Wâ€²)â¢(nâˆ’nÎµ)!Persuperscriptğ‘Šâ€²ğ‘›superscriptğ‘›ğœ€\operatorname{Per}(W^{\prime})(n-n^{\varepsilon})!roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) ( italic_n - italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ) !, where this large multiplicative term is coming from the value of the permanent of the bottom right hand submatrix. Therefore, to obtain an constant multiplicative error estimate to Perâ¡(Wâ€²)Persuperscriptğ‘Šâ€²\operatorname{Per}(W^{\prime})roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ), it suffices to estimate this top coefficient to additive error Oâ¢(Perâ¡(Wâ€²)â¢(nâˆ’nÎµ)!)ğ‘‚Persuperscriptğ‘Šâ€²ğ‘›superscriptğ‘›ğœ€O(\operatorname{Per}(W^{\prime})(n-n^{\varepsilon})!)italic_O ( roman_Per ( italic_W start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) ( italic_n - italic_n start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ) ! ) In other words, the fact that this permanent of the all 1111s submatrix is big allows for more error tolerance in the reduction, overall improving the robustness. We show this trick can be generalized to the more general formula: See 1.3 In particular this worst-to-average-case reduction now has an exponential termâ€”namely the value of this worst case permanent divided by the average caseâ€”fighting against the exponential loss of polynomial coefficient extraction. For BosonSampling, this ratio is roughly n!/n!=e0.5â¢nâ¢logâ¡nğ‘›ğ‘›superscriptğ‘’0.5ğ‘›ğ‘›n!/\sqrt{n!}=e^{0.5n\log n}italic_n ! / square-root start_ARG italic_n ! end_ARG = italic_e start_POSTSUPERSCRIPT 0.5 italic_n roman_log italic_n end_POSTSUPERSCRIPT which fights against a coefficient extraction loss of enâ¢logâ¡nsuperscriptğ‘’ğ‘›ğ‘›e^{n\log n}italic_e start_POSTSUPERSCRIPT italic_n roman_log italic_n end_POSTSUPERSCRIPT, resulting in a net relative error of eâˆ’0.5â¢nâ¢logâ¡nsuperscriptğ‘’0.5ğ‘›ğ‘›e^{-0.5n\log n}italic_e start_POSTSUPERSCRIPT - 0.5 italic_n roman_log italic_n end_POSTSUPERSCRIPT needed in the average case to show hardness of sampling. To show hardness of sampling in the average case, this means we â€œmerelyâ€ need to reduce the exponential loss of coefficient extraction to a weaker exponential, or increase the value of the worst-case matrix (now all 1111s) by an exponential factor. This is not an easy problemâ€”these terms are interrelated, so say simply boosting the norm of the all 1111s matrix simultaneously improves the worst to average-case ratio and worsens the coefficient extraction loss, and does not show hardness of sampling. However, we now finally have a term fighting against coefficient extraction loss. We note a similar lemma can be shown for RCS as wellâ€”in particular for a real version of RCS with random orthogonal gates (see Section 3.3)â€”but does not yield any hardness of sampling results (see Discussion 1.3). 1.2.3 Extending our results to average-case sampling In the last part of our work, we apply this new worst-to-average-case reduction to obtain the first nontrivial hardness of average-case sampling for BosonSampling. This uses techniques specific to BosonSampling, which to the best of our knowledge do not carry over to other quantum advantage schemes. To show this, we consider our new worst-to-average-case reduction, whose relative error robustness is given by Lemma 1.3. To show an average-case hardness of sampling result via Stockmeyer, we need our relative error tolerance for #â¢ğ–¯#ğ–¯\#\mathsf{P}# sansserif_P-hardness to be inverse polynomial. Our compensating ratio of the worst to average-case is e0.5â¢nâ¢logâ¡nsuperscriptğ‘’0.5ğ‘›ğ‘›e^{0.5n\log n}italic_e start_POSTSUPERSCRIPT 0.5 italic_n roman_log italic_n end_POSTSUPERSCRIPT, so we can only afford a loss of e0.5â¢nâ¢logâ¡nsuperscriptğ‘’0.5ğ‘›ğ‘›e^{0.5n\log n}italic_e start_POSTSUPERSCRIPT 0.5 italic_n roman_log italic_n end_POSTSUPERSCRIPT from coefficient extraction. Unfortunately this is not enough of a loss budget to be able to do a standard worst-to-average-case reduction. This is because in these reductions, we compute values of |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT for values of tğ‘¡titalic_t which are small enough so that Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) is distributed close in total variation distance to Gaussian, to ensure our average-case algorithm correctly computes Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) with high probability. To ensure closeness of total variation distance to constant error, tğ‘¡titalic_t must be Oâ¢(1/n)ğ‘‚1ğ‘›O(1/n)italic_O ( 1 / italic_n )â€”this calculation (due to Krovi [Kro23]) is optimal. This sets the distance of extrapolation/coefficient extraction to be at least Î”=Oâ¢(n)Î”ğ‘‚ğ‘›\Delta=O(n)roman_Î” = italic_O ( italic_n ), yielding a blowup of nnâˆ¼enâ¢logâ¡nsimilar-tosuperscriptğ‘›ğ‘›superscriptğ‘’ğ‘›ğ‘›~{}n^{n}\sim e^{n\log n}italic_n start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT âˆ¼ italic_e start_POSTSUPERSCRIPT italic_n roman_log italic_n end_POSTSUPERSCRIPT. There is no hope of closing this gap with a standard total variation distance approach. To get around this issue, our key idea is to go out of distribution. That is, what if we query points Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) which are far from Gaussian distributed? Clearly if our average-case algorithm could successfully compute the permanent of these matrices, then this would improve our robustness, as it would allow us to query points at much larger values of tğ‘¡titalic_t, and hence reduce our error blowup. For example, if we could successfully compute |Perâ¡(Aâ¢(t))|2superscriptPerğ´ğ‘¡2|\operatorname{Per}(A(t))|^{2}| roman_Per ( italic_A ( italic_t ) ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT for points t=Oâ¢(1/n)ğ‘¡ğ‘‚1ğ‘›t=O(1/\sqrt{n})italic_t = italic_O ( 1 / square-root start_ARG italic_n end_ARG ), our coefficient extraction loss would be halved in the exponent, and we could show hardness of average-case sampling! However, the issue is these matrices Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) at large values of tğ‘¡titalic_t are far in total variation distance from Gaussian, so there is no trivial guarantee our algorithm works here. In fact total variation distance arguments are useless here; the TV distance between Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) and Gaussian is of the form 1âˆ’Î´1ğ›¿1-\delta1 - italic_Î´ for a small value of Î´ğ›¿\deltaitalic_Î´. Even if we assume our average-case algorithm works perfectly, a TV distance argument would only say it must work with probability at least Î´ğ›¿\deltaitalic_Î´ on these points. This is insufficient for our polynomial coefficient extraction techniques. tğ‘¡titalic_t Figure 3: Lemma 4.3 shows that a function that computes permanents of ğ’©â¢(0,1)nÃ—nğ’©superscript01ğ‘›ğ‘›{\mathcal{N}}(0,1)^{n\times n}caligraphic_N ( 0 , 1 ) start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT matrices with 1âˆ’expâ¡(âˆ’Oâ¢(n))1ğ‘‚ğ‘›1-\exp(-O(n))1 - roman_exp ( - italic_O ( italic_n ) ) probability also computes permanents of ğ’©â¢(t,1)nÃ—nğ’©superscriptğ‘¡1ğ‘›ğ‘›{\mathcal{N}}(t,1)^{n\times n}caligraphic_N ( italic_t , 1 ) start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT matrices with 1âˆ’1/polyâ¢(n)11polyğ‘›1-1/{\mathrm{poly}}(n)1 - 1 / roman_poly ( italic_n ) probability for t=Oâ¢(1/n)ğ‘¡ğ‘‚1ğ‘›t=O(1/\sqrt{n})italic_t = italic_O ( 1 / square-root start_ARG italic_n end_ARG ). That is, an algorithm that works very often over a Gaussian distribution will also work reasonably often on a shifted Gaussian distribution. The figure depicts that events deep in the tail of one Gaussian are still tail events for a shifted Gaussian, with successful events colored blue and failure events colored orange. Instead, in our proof we go beyond total variation distance analysis to show that we can successfully query points Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) at high values of tğ‘¡titalic_t, so long as our average-case algorithm works with very high probability. The basic idea is this: suppose our average-case algorithm works near perfectly, say with probability 1âˆ’Î´1ğ›¿1-\delta1 - italic_Î´ over the choice of Gaussian matrix. We want to show it also works if we query it on these points Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) which are far from Gaussian. A basic observation is that these Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) are also Gaussian distributed, but with a shifted mean. We prove a simple lemma, Lemma 4.3, showing that rare events under one Gaussian distribution remain rare under another Gaussian, so long as their rarity is less than eâˆ’d2superscriptğ‘’superscriptğ‘‘2e^{-d^{2}}italic_e start_POSTSUPERSCRIPT - italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT where dğ‘‘ditalic_d is the distance between the means. Intuitively this is because if an event is extremely far from the mean of a Gaussian G1subscriptğº1G_{1}italic_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT (much further than the distance to the mean of G2subscriptğº2G_{2}italic_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT) it is also far from the mean of G2subscriptğº2G_{2}italic_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT as well, and hence rare under G2subscriptğº2G_{2}italic_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT (see Figure 3). We then apply this lemma to the event that the average-case algorithm fails under the standard Gaussian. If this is sufficiently rare for the average case, this is also rare for the distribution of Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ), and hence the algorithm works with high probability to compute Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) as well. There is a loss in this argument which forces Î´ğ›¿\deltaitalic_Î´ to be exponentially small. However, the key point is that if our average-case algorithm works with extremely high probability, then it can also evaluate these points Aâ¢(t)ğ´ğ‘¡A(t)italic_A ( italic_t ) at high values of tğ‘¡titalic_t, and hence lessen the coefficient extraction error in our reduction. We show this can be leveraged to show a nontrivial hardness of sampling result for an exact (i.e. relative error) average-case sampler. The proof follows the argument outlined above but requires several additional technical innovations. First, if you assume you have an average-case sampler that works with very high probability 1âˆ’Î´1ğ›¿1-\delta1 - italic_Î´ over the choice of BosonSampling experiment, this doesnâ€™t immediately imply (by Stockmeyer counting) a ğ–¡ğ–¯ğ–¯ğ–­ğ–¯superscriptğ–¡ğ–¯ğ–¯ğ–­ğ–¯{\mathsf{BPP}}^{\mathsf{NP}}sansserif_BPP start_POSTSUPERSCRIPT sansserif_NP end_POSTSUPERSCRIPT algorithm for computing Gaussian permanents with probability 1âˆ’Î´1ğ›¿1-\delta1 - italic_Î´. The issue is that submatrices of Haar random orthogonal matrices have not been shown to be exponentially close to Gaussian in TV distance, but rather have only been shown to be inverse polynomially close [JM19]. Thus setting the sampler success probability to 1âˆ’Î´1ğ›¿1-\delta1 - italic_Î´ where Î´=2âˆ’Oâ¢(n)ğ›¿superscript2ğ‘‚ğ‘›\delta=2^{-O(n)}italic_Î´ = 2 start_POSTSUPERSCRIPT - italic_O ( italic_n ) end_POSTSUPERSCRIPT for the sampler success does not automatically yield a correspondingly good algorithm for computing Gaussian permanents. To fix this we prove yet another â€œrare events lemma,â€ Proposition C.1, that allows us to transfer our high probability algorithm for Haar submatrices to Gaussian matrices, which may be of independent interest. Second, for our algorithm to work we require Perâ¡(Aâ¢(t))Perğ´ğ‘¡\operatorname{Per}(A(t))roman_Per ( italic_A ( italic_t ) ) to anticoncentrate. This is not guaranteed by the standard Permanent Anticoncentration Conjecture 2.3 as these matrices are out of distribution. We instead formulate a more general permanent anticoncentration conjecture which conjectures that general shifted mean Gaussian permanents anticoncentrate: Conjecture 1.5 (Anticoncentration of gently perturbed Gaussian permanents). There exists a polynomial fğ‘“fitalic_f such that for all nğ‘›nitalic_n and Ïµ>0,italic-Ïµ0\epsilon>0,italic_Ïµ > 0 , ğRâˆ¼ğ’©â¢(0,1)nÃ—nâ¢[|Perâ¡(R+tâ¢W)|<n!fâ¢(n,1/Ïµ)]<Ïµ,subscriptğsimilar-toğ‘…ğ’©superscript01ğ‘›ğ‘›delimited-[]Perğ‘…ğ‘¡ğ‘Šğ‘›ğ‘“ğ‘›1italic-Ïµitalic-Ïµ{\mathbf{P}}_{R\sim{\mathcal{N}}(0,1)^{n\times n}}\left[\left|\operatorname{% Per}(R+tW)\right|<\frac{\sqrt{n!}}{f(n,1/\epsilon)}\right]<\epsilon,bold_P start_POSTSUBSCRIPT italic_R âˆ¼ caligraphic_N ( 0 , 1 ) start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ | roman_Per ( italic_R + italic_t italic_W ) | < divide start_ARG square-root start_ARG italic_n ! end_ARG end_ARG start_ARG italic_f ( italic_n , 1 / italic_Ïµ ) end_ARG ] < italic_Ïµ , for arbitrary matrix Wğ‘ŠWitalic_W with entries bounded by 1111 and t=Oâ¢(1n).ğ‘¡ğ‘‚1ğ‘›t=O(\frac{1}{\sqrt{n}}).italic_t = italic_O ( divide start_ARG 1 end_ARG start_ARG square-root start_ARG italic_n end_ARG end_ARG ) . We note a special case of this conjecture has already been proven by Eldar and Mehraban [EM18] for ğ’©â¢(1/polyâ¢logâ¡n,1)ğ’©1polyğ‘›1{\mathcal{N}}(1/{\mathrm{poly}}\log n,1)caligraphic_N ( 1 / roman_poly roman_log italic_n , 1 ) matricesâ€”and Nâ¢(0,1)ğ‘01N(0,1)italic_N ( 0 , 1 ) matrices are the subject of standard anticoncentrationâ€”so our conjecture is in some sense interpolating between these proven statements and conjectures to matrices with entries like ğ’©â¢(1/n,1)ğ’©1ğ‘›1{\mathcal{N}}(1/\sqrt{n},1)caligraphic_N ( 1 / square-root start_ARG italic_n end_ARG , 1 ). See Figure 4 for a schematic. 1.3 Discussion and open problems In this work we have shown the first non-trivial average-case exact sampling result for (orthogonal) BosonSampling. It is natural to ask if our techniques can be pushed further to prove the GPE conjecture and show hardness of BosonSampling in the general case. We note that further reductions in our coefficient extraction error could possibly yield intermediate results in this direction, in particular improving our average-case success probability of the sampler to be closer to 1âˆ’1/polyâ¢(n)11polyğ‘›1-1/{\mathrm{poly}}(n)1 - 1 / roman_poly ( italic_n ). In terms of pushing our results towards approximate average-case sampling, an important question is if our techniques relativize, as we know non-relativizing techniques will be required to show hardness of approximate sampling [AC17]. Interestingly Marshall, Aaronson and Djunko [MAD24] recently introduced new techniques that do not relativize. Of course the Permanent Anticoncentration Conjecture 2.3 remains open as well, and is assumed in our work. Another natural question is if we can show any hardness of sampling for RCS. Here the principal challenge is that the state-of-the-art of average-case hardness for RCS is substantially farther from the goal than for BosonSampling [BFNV19, Mov23, BFLL22, KMM22, Kro22]. While we show one can utilize the schemes of Lemma 1.3 for a real variant of RCS to obtain a worst to average-case ratio which fights against extrapolation loss (see Sec. 3.3), this gain is at most 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT for RCS, while existing worst-to-average-case reductions have much larger robustness losses. We leave this an an open problem. We note a number of related works have studied the complexity of quantum advantage schemes under various forms of noise in the experiment, e.g. [ABOIN96, KK14, GD18, BFLL22, AGL+23, DNS+22, SYGY24, OLA+24, DHJB24, FGG+24, BBC+22, VNL+21] which can make the problems asymptotically easier in certain scenarios. In contrast our work is studying the complexity of near-noiseless variants of BosonSampling or RCS. Finally, it remains open if our proofs can be extended from real (i.e. orthogonal) BosonSampling to complex (i.e. unitary) BosonSampling. The part of our proof that breaks here is the statement that, if you have evaluations of the square of a polynomial |pâ¢(t)|2superscriptğ‘ğ‘¡2|p(t)|^{2}| italic_p ( italic_t ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, that you can infer the underlying polynomial up to phase. While this is trivial in the real case (the phase is Â±1plus-or-minus1\pm 1Â± 1, which is trivially disambiguated in the proof), in the complex case it is open if this approximately defines pâ¢(t)ğ‘ğ‘¡p(t)italic_p ( italic_t ) up to a complex phase, and this appears to be an open problem in complex analysis [Her22]. In Appendix E, we explain in more detail the nature of the difficulty of extending the result to the complex setting."
https://arxiv.org/html/2411.04353v1,\adambrainstorming titlesOn the hardness of learning ground state entanglement of geometrically local Hamiltonians1D local gapless phases are classically hard to learn,"Characterizing the entanglement structure of ground states of local Hamiltonians is a fundamental problem in quantum information. In this work we study the computational complexity of this problem, given the Hamiltonian as input. Our main result is that to show it is cryptographically hard to determine if the ground state of a geometrically local, polynomially gapped Hamiltonian on qudits (d=Oâ¢(1)ğ‘‘ğ‘‚1d=O(1)italic_d = italic_O ( 1 )) has near-area law vs near-volume law entanglement. This improves prior work of Bouland et al. (arXiv:2311.12017) showing this for non-geometrically local Hamiltonians. In particular we show this problem is roughly factoring-hard in 1D, and LWE-hard in 2D. Our proof works by constructing a novel form of public-key pseudo-entanglement which is highly space-efficient, and combining this with a modification of Gottesman and Iraniâ€™s quantum Turing machine to Hamiltonian construction. Our work suggests that the problem of learning so-called â€œgaplessâ€ quantum phases of matter might be intractable.","Characterizing the entanglement structure of ground states of local Hamiltonians is a fundamental problem in quantum information. Many works have studied when the structure of local Hamiltonians forces the ground state to have simple entanglement structures such as an area law. For example, an area law for gapped 1D local Hamiltonians has been rigorously established [13], and much progress has been made towards a 2D area law as well e.g. [1]. This is closely connected to Hamiltonian complexity, as areas laws can enable efficient algorithms for learning and describing ground states, such as through matrix product states and PEPS, e.g. [20]. It is also closely connected to questions in condensed matter physics, where different ground state entanglement structures can be hallmarks of different quantum phases of matter, such as topological phases [27]. In this work we study the complexity of learning the ground state entanglement structure of a local Hamiltonian, given the Hamiltonian as input. This is known as the â€œLearning Ground State Entanglement Structure (LGSES)â€ problem [7]. Informally the LGSES problem captures the complexity of the job of a condensed matter physicist â€“ as oftentimes one writes down a Hamiltonian and applies highly nontrivial techniques (Bethe ansatze, quantum Monte Carlo algorithms, etc.) to deduce properties of its low energy states. The difficulty of LGSES depends significantly on the assumptions made about the structure of the Hamiltonian. For example, if one assumes a constant spectral gap, then in many cases the area law forces the ground state to have a particularly simple structure, rendering the LGSES problem trivial. It has also recently been shown that with geometric locality and constant spectral gaps, one can efficiently learn properties of ground states, such as expectation values of local observables [14] if one is given labelled examples from members of a broader family444Their result also requires a certain smoothness condition on the Hamiltonians considered, see [14].. On the other hand, if the Hamiltonian has an inverse polynomial spectral gap, the problem can become much harder. For example, Bouland et al. [7] recently showed it is LWE-hard to learn if the ground state of a general local Hamiltonian has near 1D area law or near volume law entanglement. However, the Hamiltonians in their construction were not geometrically local, and hence not directly relevant to physics. With geometric locality, they were only able to obtain much weaker hardness results about detecting different variants of sub-volume law entanglement. A natural question is if it is hard to distinguish near area law vs. volume law entanglement in the geometrically local setting. Our results: In this work we show that LGSES is cryptographically hard even with geometrically local Hamiltonians, and even for determining if the ground state is near-area law vs. near volume law: We show this for 1D and 2D-local Hamiltonians on qudits where the local dimension d=Oâ¢(1)ğ‘‘ğ‘‚1d=O(1)italic_d = italic_O ( 1 ): Theorem 1.1 (Informal). It is hard for a classical computer to determine if a 1D local Hamiltonian on qudits has a ground state with 1D near area law vs. near volume law entanglement. Theorem 1.2 (Informal). It is hard for a quantum computer to determine if a 2D local Hamiltonian on qudits has a ground state with 2D near area law vs. near volume law entanglement. Here, near area law means that if ÏğœŒ\rhoitalic_Ï is the reduced density matrix on a subset of qubits, then Sâ¢(Ï)â‰¤|A|â¢polylogâ¢(n)ğ‘†ğœŒğ´polylogğ‘›S(\rho)\leq|A|\text{polylog}(n)italic_S ( italic_Ï ) â‰¤ | italic_A | polylog ( italic_n ) where Ağ´Aitalic_A is the area of the cut. The Hamiltonians have inverse polynomial spectral gaps. The first result is shown under the Decisional Composite Residuosity Assumption (DCRA), which is a standard classical hardness assumption based on discrete log/factoring. In particular we assume DCRA does not have a 2nÏµsuperscript2superscriptğ‘›italic-Ïµ2^{n^{\epsilon}}2 start_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT italic_Ïµ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT time algorithm for some value of Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0. The second result is shown assuming subexponential hardness of LWE. 1.1 Proof sketch We will describe the 1D proof, and later describe how to lift to 2D. Our proof uses on a new construction of public-key pseudo-entanglement. Here the idea is that one can construct ensembles of states for which it is difficult to estimate their entanglement, even given the description of the quantum circuit used to prepare the state. Such constructions imply hardness results for LGSES by passing the circuit ensembles through circuit to Hamiltonian constructions [11, 7]. The starting point of our work is to try to take the public-key pseudo-entanglement construction of [7] and pass them through a geometrically local circuit to Hamiltonian construction, in particular the 1D translation invariant construction of Gotteman and Irani [12]. The Gottesman-Irani construction, however, is formulated in a quantum Turing machine (QTM) model of computation, rather than the quantum circuit model. That is, give a QTM as input, it describes a Hamiltonian whose ground state on nğ‘›nitalic_n qubits encodes the computation performed by that QTM on input 1nsuperscript1ğ‘›1^{n}1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. Therefore, to apply this approach we first need to formulate a QTM variant of pseudo-entanglement, which causes several issues. First, we need to hard-code a cryptographic key into the construction. This is because the the public key enabling the preparation of the pseudo-entangled states must be provided as input to the QTM. This breaks the translation invariance of [12]. Second, it requires showing the cryptographic primitives used in [7] can be implemented in the QTM model, and not just the circuit model. Both of these changes require tedious modifications of the Gottesman-Irani construction, but are surmountable with sufficient attention to detail. However, the larger issue that we face in combining the constructions is the space complexity of our cryptographic primitives. In our setting our goal is not to show QMA-hardness of the ground state energy, but rather to show cryptographic hardness of learning the ground state entanglement. Therefore the key thing we wish to preserve in our circuit to QTM to Hamiltonian construction is the entanglement structure of the ground state. In turns out that for [12] to preserve entanglement structure, we need our pseudo-entanglement construction to run not only in polynomial time. but also in near linear space. This is because the space complexity of the QTM roughly equals the number of qudits in the chain, so a blowup say to Oâ¢(n2)ğ‘‚superscriptğ‘›2O(n^{2})italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) space effectively â€œdilutesâ€ the entanglement in the ground state, as informally these Oâ¢(n)ğ‘‚ğ‘›O(n)italic_O ( italic_n ) e-bits of entanglement are then â€œspread outâ€ amongst Oâ¢(n2)ğ‘‚superscriptğ‘›2O(n^{2})italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) qudits, meaning that states with high entanglement in the circuit are no longer highly entangled. We therefore canâ€™t afford more than a logarithmic blowup in the space complexity of the algorithm. This is immediately a problem because the key sizes used in [7] are much larger than superlinear â€“ the total key size is actually Oâ¢(n2â¢logâ¡n)ğ‘‚superscriptğ‘›2ğ‘›O(n^{2}\log n)italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_log italic_n ). This key size is coming from the fact that public-key cryptographic primitives built from LWE typically have key sizes of Oâ¢(n2)ğ‘‚superscriptğ‘›2O(n^{2})italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) or larger â€“ this is because the public key is usually a dense matrix Aâˆˆğ”½qnÃ—nğ´superscriptsubscriptğ”½ğ‘ğ‘›ğ‘›A\in\mathbb{F}_{q}^{n\times n}italic_A âˆˆ blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT. Therefore it seems extremely difficult to build public-key pseudo-entanglement with linear key size from LWE. There is also a second source of high space complexity in [7], coming from the use of nğ‘›nitalic_n different pairwise-independent hash functions, which would itself contribute a quadratic sized key even if a different crypto primitive was slotted in place of LWE. To address this we create a new construction of pseudo-entanglement which has a much smaller public key size while still hiding a big entanglement gap. First, we relax the problem to consider only classical hardness. This enables cryptographic public-key constructions with near-linear key sizes in the input size â€“ particularly a cryptographic object known as a lossy function [25] which allows one to â€œhash downâ€ entanglement across a particular cut of the qubits [7]. This alone isnâ€™t enough to fix the problem, because the prior construction had Oâ¢(n)ğ‘‚ğ‘›O(n)italic_O ( italic_n ) independent cryptographic keys plus Oâ¢(n)ğ‘‚ğ‘›O(n)italic_O ( italic_n ) hash function keys. This arises because the prior construction did a 1D â€œsweepâ€ of the line, using lossy functions to â€œtamp downâ€ entanglement across each cut of the line in the corresponding binary phase state. To fix this, we make a new construction which tamps down entanglement in a tree-like structure. First we cut down entanglement across the middle cut between the left n/2ğ‘›2n/2italic_n / 2 and right n/2ğ‘›2n/2italic_n / 2 qubits; then we cut down across the next cuts of size n/4ğ‘›4n/4italic_n / 4, etc. (see Figure 1). This still involves Oâ¢(nâ¢logâ¡n)ğ‘‚ğ‘›ğ‘›O(n\log n)italic_O ( italic_n roman_log italic_n ) applications of lossy functions, so naively would not reduce the key size. The crucial insight is that, first, the keys can be the same across each level of the tree, and second, the key size at each level can be a decreasing function of nğ‘›nitalic_n (as the security parameter coming from algorithmic tests of entanglement also shrinks with nğ‘›nitalic_n). This allows us to obtain a total key size of Oâ¢(nâ¢logâ¡n)ğ‘‚ğ‘›ğ‘›O(n\log n)italic_O ( italic_n roman_log italic_n ) across all of these lossy functions. Showing this works requires developing a new proof that tamping down entanglement across one cut doesnâ€™t â€œblow upâ€ your entanglement across another, which in [7] had followed from a simple property of 1D sweeps. It also requires further changes to the construction, as the classical lossy functions actually blow up the input size slightly, but crucially this blowup is tiny in the low-deoth tree, so does not result in much â€œdilutionâ€ of the entanglement. This allows us to remove the pairwise-independent hash functions used in prior work, which had served to avoid this blowup in input size. To lift this to 2D with LWE, to show that here the quadratic blowup in key size is acceptable â€“ we use a larger key, and then make a ground state which is a superposition of the 1D states striped horizontally vs vertically. 1.2 Discussion and open problems Our work is the first to show it can be hard to learn the ground state entanglement structure of geometrically local Hamiltonians, even promised near-maximal gaps in entanglement structure. A number of open problems remain. First, can we show hardness of LGSES for translationally invariant Hamiltonians? Such a result would parallel the development QMA-hardness in Hamiltonian complexity [16, 22, 3, 12]. However, we believe this would require developing fundamentally new techniques. This is because in 1D translation-invariant constructions, the QTMs are not allowed to have a binary input â€“ rather their input is written in unary, which allows one to show QMAEXPsubscriptQMAEXP\textsf{QMA}_{\textsf{EXP}}QMA start_POSTSUBSCRIPT EXP end_POSTSUBSCRIPT hardness. While a QTM can generate an instance of our public-key pseudo-entanglement from 1nsuperscript1ğ‘›1^{n}1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, the algorithm will generate not only the public key (i.e. the description of how to prepare the state), but also the private key which allows one to distinguish the two ensembles. In our work, the ground state can be efficiently constructed from the Hamiltonian, so this means one can efficiently extract the private key from the ground state, breaking the security. As a result, one needs to go beyond pseudo-entanglement + circuit/QTM to Hamiltonian constructions if one wishes to show hardness of translationally invariant systems. In a similar spirit, there is the also the question of if we can reduce our local dimension, which has been done in the case of QMA, e.g. [15, 5], and if we can show the 1D case is hard based on post-quantum cryptography as well. Second, there is a question about how to interpret our result through the lens of condensed matter theory. As different entanglement structures can be hallmarks of different quantum phases of matter, our results could be interpreted as a statement about hardness of learning phases of matter. Our results are shown with inverse polynomial spectral gaps, so could be saying that it is hard to learn â€œgaplessâ€ phases of matter (where gap vanishes as system size grows), which stands in contrast to gapped phases which might be easier to learn [14]. Our result also complements recent work of Schuster Haferkamp and Huang [28], a corollary of which was that it can be hard to learn topological phases of matter. However we note our result is proven in a stronger public-key input model, as our input includes the recipe for preparing the state, whereas their corollary is in a private-key input model where one is only given copies of the state itself. 1.3 Outline of the paper We introduce the notations and relevant existing results in Section 2. In Section 3, we present two lossy function constructions based on DCRA and LWE respectively, which we use in Section 4 give two public-key pseudoentangled states constructions. The quantum Turing machines for these two constructions are given in Section 5. In Section 6, we present a general framework of encoding the running history of a QTM into a local Hamiltonian. Finally in Section 7, we combine all these techniques together and prove the hardness of LGSES for both 1D Hamiltonians and 2D Hamiltonians."
https://arxiv.org/html/2411.04115v1,Condensing Against Online Adversaries,"We investigate the task of deterministically condensing randomness from Online Non-Oblivious Symbol Fixing (oNOSF) sources, a natural model of defective random sources for which it is known that extraction is impossible [AORSV, EUROCRYPTâ€™20]. A (g,â„“)ğ‘”â„“(g,\ell)( italic_g , roman_â„“ )-oNOSF source is a sequence of â„“â„“\ellroman_â„“ blocks ğ—=(ğ—1,â€¦,ğ—â„“)âˆ¼({0,1}n)â„“ğ—subscriptğ—1â€¦subscriptğ—â„“similar-tosuperscriptsuperscript01ğ‘›â„“\mathbf{X}=(\mathbf{X}_{1},\dots,\mathbf{X}_{\ell})\sim(\{0,1\}^{n})^{\ell}bold_X = ( bold_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , bold_X start_POSTSUBSCRIPT roman_â„“ end_POSTSUBSCRIPT ) âˆ¼ ( { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT, where at least gğ‘”gitalic_g of the blocks are good (are independent and have some min-entropy), and the remaining bad blocks are controlled by an online adversary where each bad block can be arbitrarily correlated with any block that appears before it.The existence of condensers was recently studied in [CGR, FOCSâ€™24]. They proved condensing impossibility results for various values of gğ‘”gitalic_g and â„“â„“\ellroman_â„“, and they showed the existence of condensers matching the impossibility results in the special case when nğ‘›nitalic_n is extremely large compared to â„“â„“\ellroman_â„“ (i.e., the setting of few blocks of large length).In this work, we make significant progress on proving the existence of condensers with strong parameters in almost all parameter regimes, even when nğ‘›nitalic_n is a large enough constant and â„“â„“\ellroman_â„“ is growing. This almost resolves the question of the existence of condensers for oNOSF sources, except when nğ‘›nitalic_n is a small constant.As our next result, we construct the first explicit condensers for oNOSF sources and achieve parameters that match the existential results of [CGR, FOCSâ€™24]. We also obtain a much improved construction for transforming low-entropy oNOSF sources (where the good blocks only have min-entropy, as opposed to being uniform) into uniform oNOSF sources.We find interesting connections and applications of our results on condensers to collective coin flipping and collective sampling, problems that are well-studied in fault-tolerant distributed computing. We use our condensers to provide very simple protocols for these problems.Finally, to understand the case of small nğ‘›nitalic_n, we focus on n=1ğ‘›1n=1italic_n = 1 which corresponds to online non-oblivious bit-fixing (oNOBF) sources. We introduce and initiate a systematic study of a new, natural notion of the influence of Boolean functions, which we call online influence, and believe is of independent interest. Using tools from Boolean Fourier analysis, we establish tight bounds on the total online influence of Boolean functions, which imply extraction lower bounds. Several problems remain open regarding this new measure of influence; progress on these will lead to improved extractors and condensers for oNOBF sources or further strengthen our lower bounds.","Randomness is extremely useful in computation with wide-ranging applications in algorithm design, cryptography, distributed computing protocols, machine learning, error-correcting codes, and much more [motwani1995randomized, vadhan_pseudorandomness_2012]. Most of these applications require access to high quality randomness. However in a lot of settings, especially arising in practice, algorithms only have access to low quality source of randomness. This motivates the notion of condensers: functions that transform weak random sources into strong random sources that are of better quality. In this line of work, the standard way of measuring the amount of randomness is using min-entropy. Formally, for a source (distribution) ğ—ğ—\mathbf{X}bold_X with support Î©Î©\Omegaroman_Î©, define its min-entropy as Hâˆâ¢(ğ—)=minxâˆˆÎ©â¡log2â¡(1/Prâ¡[ğ—=x])subscriptğ»ğ—subscriptğ‘¥Î©subscript21Prğ—ğ‘¥H_{\infty}(\mathbf{X})=\min_{x\in\Omega}\log_{2}(1/\Pr[\mathbf{X}=x])italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT ( bold_X ) = roman_min start_POSTSUBSCRIPT italic_x âˆˆ roman_Î© end_POSTSUBSCRIPT roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 / roman_Pr [ bold_X = italic_x ] ). We will also need the notion of smooth min-entropy, which measures how close a distribution is to having high entropy. Formally, for a source ğ—ğ—\mathbf{X}bold_X, its smooth min-entropy with parameter Îµğœ€\varepsilonitalic_Îµ is defined as HâˆÎµâ¢(ğ—)=maxğ˜:|ğ—âˆ’ğ˜|â‰¤Îµâ¡{Hâˆâ¢(ğ˜)}superscriptsubscriptğ»ğœ€ğ—subscript:ğ˜ğ—ğ˜ğœ€subscriptğ»ğ˜H_{\infty}^{\varepsilon}(\mathbf{X})=\max_{\mathbf{Y}:\left\lvert\mathbf{X}-% \mathbf{Y}\right\rvert\leq\varepsilon}\{H_{\infty}(\mathbf{Y})\}italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ( bold_X ) = roman_max start_POSTSUBSCRIPT bold_Y : | bold_X - bold_Y | â‰¤ italic_Îµ end_POSTSUBSCRIPT { italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT ( bold_Y ) }, where |â‹…|â‹…\left\lvert\cdot\right\rvert| â‹… | denotes the statistical distance (Definition 3.1). With this, we are ready to formally define condensers: Definition 1.1. A function ğ–¢ğ—ˆğ—‡ğ–½:{0,1}nâ†’{0,1}m:ğ–¢ğ—ˆğ—‡ğ–½â†’superscript01ğ‘›superscript01ğ‘š\mathsf{Cond}:\{0,1\}^{n}\to\{0,1\}^{m}sansserif_Cond : { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT is a (kiâ¢n,koâ¢uâ¢t,Îµ)subscriptğ‘˜ğ‘–ğ‘›subscriptğ‘˜ğ‘œğ‘¢ğ‘¡ğœ€(k_{in},k_{out},\varepsilon)( italic_k start_POSTSUBSCRIPT italic_i italic_n end_POSTSUBSCRIPT , italic_k start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT , italic_Îµ )-condenser for a family of distributions ğ’³ğ’³\mathcal{X}caligraphic_X if for all ğ—âˆˆğ’³ğ—ğ’³\mathbf{X}\in\mathcal{X}bold_X âˆˆ caligraphic_X with ğ—âˆ¼{0,1}nsimilar-toğ—superscript01ğ‘›\mathbf{X}\sim\{0,1\}^{n}bold_X âˆ¼ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT and Hâˆâ¢(ğ—)â‰¥kiâ¢nsubscriptğ»ğ—subscriptğ‘˜ğ‘–ğ‘›H_{\infty}(\mathbf{X})\geq k_{in}italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT ( bold_X ) â‰¥ italic_k start_POSTSUBSCRIPT italic_i italic_n end_POSTSUBSCRIPT, we have that HâˆÎµâ¢(ğ—)â‰¥koâ¢uâ¢tsuperscriptsubscriptğ»ğœ€ğ—subscriptğ‘˜ğ‘œğ‘¢ğ‘¡H_{\infty}^{\varepsilon}(\mathbf{X})\geq k_{out}italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ( bold_X ) â‰¥ italic_k start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT. We say kiâ¢nnsubscriptğ‘˜ğ‘–ğ‘›ğ‘›\frac{k_{in}}{n}divide start_ARG italic_k start_POSTSUBSCRIPT italic_i italic_n end_POSTSUBSCRIPT end_ARG start_ARG italic_n end_ARG is the input entropy rate, koâ¢uâ¢tmsubscriptğ‘˜ğ‘œğ‘¢ğ‘¡ğ‘š\frac{k_{out}}{m}divide start_ARG italic_k start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT end_ARG start_ARG italic_m end_ARG is the output entropy rate, and mâˆ’koâ¢uâ¢tğ‘šsubscriptğ‘˜ğ‘œğ‘¢ğ‘¡m-k_{out}italic_m - italic_k start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT is the entropy gap of ğ–¢ğ—ˆğ—‡ğ–½ğ–¢ğ—ˆğ—‡ğ–½\mathsf{Cond}sansserif_Cond. The task of the condenser is to make the output entropy rate as high as possible compared to the input entropy rate, or, in other words, to make the output distribution more â€œcondensedâ€. Related to this, it is also desirable to have as small entropy gap as possible. Notice that if the entropy gap is 00, the output distribution is Îµğœ€\varepsilonitalic_Îµ-close to the uniform distribution. Such condensers with entropy gap 00 are known as randomness extractorsâ€”a topic that has been extensively studied in theoretical computer science. When ğ’³ğ’³\mathcal{X}caligraphic_X is the family of all distributions, it is folklore that no non-trivial condensing is possible.111Assuming mâ‰¤nğ‘šğ‘›m\leq nitalic_m â‰¤ italic_n (wlog this holds since |ğ–¢ğ—ˆğ—‡ğ–½â¢({0,1}n)|â‰¤2nğ–¢ğ—ˆğ—‡ğ–½superscript01ğ‘›superscript2ğ‘›\left\lvert\mathsf{Cond}(\{0,1\}^{n})\right\rvert\leq 2^{n}| sansserif_Cond ( { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) | â‰¤ 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT), mâˆ’koâ¢uâ¢tâ‰¥(nâˆ’kiâ¢n)âˆ’logâ¡(1/(1âˆ’Îµ))ğ‘šsubscriptğ‘˜ğ‘œğ‘¢ğ‘¡ğ‘›subscriptğ‘˜ğ‘–ğ‘›11ğœ€m-k_{out}\geq(n-k_{in})-\log(1/(1-\varepsilon))italic_m - italic_k start_POSTSUBSCRIPT italic_o italic_u italic_t end_POSTSUBSCRIPT â‰¥ ( italic_n - italic_k start_POSTSUBSCRIPT italic_i italic_n end_POSTSUBSCRIPT ) - roman_log ( 1 / ( 1 - italic_Îµ ) ) and hence the output entropy rate cannot be more than the input entropy rate without incurring extremely large error (>0.999absent0.999>0.999> 0.999). So, we additionally assume that ğ’³ğ’³\mathcal{X}caligraphic_X is a structured family of sources.222A different route, that has been widely studied, is to assume access to a short independent seed. In this work, we will limit ourselves to the seedless setting. Since extractors are the highest quality condensers, a significant amount of work has focused on constructing extractors for interesting family of sources, such as: sources generated by small circuits, two independent sources, algebraically generated sources, sources generated by small space sources, and many more [tv00, chattopadhyay_explicit_2019, dgw09extractpolynomials, kamp_deterministic_2007]. However, for many natural family of sources, one can provably show that no extractor can exist. In such situations, one can still hope to show that high quality condensers exist. We note that condensers (and sources with high min-entropy rate) are very useful: the condensed distribution can be used to efficiently simulate randomized algorithms with small overhead, perform one-shot simulations for randomized protocols, cryptography and interactive proofs, and much more. [DPW14key] showed these condensers are equivalent to â€˜unpredictability extractorsâ€™ that can simulate cryptographic protocols against biased distinguishers. For details on these applications and more, see [aggarwal_how_2020, doron_almost_2023, CGR_seedless_condensers]. In this work, we focus on one natural family of sources where it is known that extraction is impossible. The family we consider are known as online non-oblivious symbol fixing sources (oNOSF sources ).333These sources are in contrast to non-oblivious symbol fixing (NOSF) sources where bad blocks can be arbitrary functions of all the good blocks. These sources were introduced in [chor_bit_1985] with applications in leakage-resilient cryptography, and have been well-studied. Formally: Definition 1.2. A (g,â„“,n,k)ğ‘”â„“ğ‘›ğ‘˜{\left(g,\ell,n,k\right)}( italic_g , roman_â„“ , italic_n , italic_k )-oNOSF source ğ—=(ğ—1,â€¦,ğ—â„“)ğ—subscriptğ—1â€¦subscriptğ—â„“\mathbf{X}=(\mathbf{X}_{1},\dots,\mathbf{X}_{\ell})bold_X = ( bold_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , bold_X start_POSTSUBSCRIPT roman_â„“ end_POSTSUBSCRIPT ) is such that each block ğ—isubscriptğ—ğ‘–\mathbf{X}_{i}bold_X start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is over {0,1}nsuperscript01ğ‘›\{0,1\}^{n}{ 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, gğ‘”gitalic_g of the blocks are are independent sources with min-entropy kğ‘˜kitalic_k (â€œgood blocksâ€), and each â€œbad blockâ€ is an arbitrary function of the blocks with an index smaller than it. When k=nğ‘˜ğ‘›k=nitalic_k = italic_n, we will call such sources uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources. These sources are inspired by real-time randomness generation settings such as in blockchains. There, each subsequent block is random or controlled by an adversary. Since these sources are generated in real time, a bad block can only be a function of the blocks that have appeared so far, and it is reasonable to assume that the good blocks contain entropy and are independent. Further, there are natural cryptographic settings, such as creating a Common Reference String, that are widely used in various cryptographic protocols where oNOSF source sources naturally arise (see [aggarwal_how_2020] for a discussion). The remainder of our introduction is structured as follows. We give an overview of previous work in Section 1.1 before presenting our main existential and explicit condenser results in Section 1.2. In Section 1.3, we show how our results have implications for collective coin flipping and sampling protocols. Next, we introduce our notion of online influence and related results in Section 1.4. We end by defining a local version of oNOSF sources and give explicit extractors for them in Section 1.5. 1.1 Previous work The study of condensers for oNOSF sources was initiated by [aggarwal_how_2020].444In [aggarwal_how_2020], these sources were called SHELA (Somewhere Honest Entropic Look Ahead) sources. Their results include the following: â€¢ It is impossible to extract from uniform oNOSF sources (even when the fraction of good blocks is an arbitrary constant). â€¢ An explicit transformation from (g,â„“,n,0.9â¢n)ğ‘”â„“ğ‘›0.9ğ‘›{\left(g,\ell,n,0.9n\right)}( italic_g , roman_â„“ , italic_n , 0.9 italic_n )-oNOSF source into a source over ({0,1}Oâ¢(n))â„“âˆ’1superscriptsuperscript01ğ‘‚ğ‘›â„“1(\{0,1\}^{O(n)})^{\ell-1}( { 0 , 1 } start_POSTSUPERSCRIPT italic_O ( italic_n ) end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT roman_â„“ - 1 end_POSTSUPERSCRIPT where gâˆ’1ğ‘”1g-1italic_g - 1 of the blocks are uniform and independent. â€¢ An explicit transformation from (g,â„“,n,0.1â¢n)ğ‘”â„“ğ‘›0.1ğ‘›{\left(g,\ell,n,0.1n\right)}( italic_g , roman_â„“ , italic_n , 0.1 italic_n )-oNOSF source into a source over ({0,1}Oâ¢(n))100â¢â„“superscriptsuperscript01ğ‘‚ğ‘›100â„“(\{0,1\}^{O(n)})^{100\ell}( { 0 , 1 } start_POSTSUPERSCRIPT italic_O ( italic_n ) end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT 100 roman_â„“ end_POSTSUPERSCRIPT where gâˆ’1ğ‘”1g-1italic_g - 1 of the blocks are uniform and independent. Even though the output entropy rate is only slightly more than the input-entropy rate in the second result and smaller in the third result, the fact that a lot of the blocks are truly uniform is very useful, and they find interesting cryptographic applications of these somewhere-extractors. oNOSF sources were further studied by [CGR_seedless_condensers], where they obtained the following results: â€¢ When nâ‰¥kâ‰¥â„“ğ‘›ğ‘˜â„“n\geq k\geq\ellitalic_n â‰¥ italic_k â‰¥ roman_â„“, there exist functions that can transform a (g,â„“,n,k)ğ‘”â„“ğ‘›ğ‘˜{\left(g,\ell,n,k\right)}( italic_g , roman_â„“ , italic_n , italic_k )-oNOSF source into a uniform (gâˆ’1,â„“âˆ’1,Oâ¢(k/â„“))ğ‘”1â„“1ğ‘‚ğ‘˜â„“{\left(g-1,\ell-1,O(k/\ell)\right)}( italic_g - 1 , roman_â„“ - 1 , italic_O ( italic_k / roman_â„“ ) )-oNOSF source (this function can be made explicit with slightly worse dependence on output length). â€¢ When nâ‰¥2Ï‰â¢(â„“)ğ‘›superscript2ğœ”â„“n\geq 2^{\omega(\ell)}italic_n â‰¥ 2 start_POSTSUPERSCRIPT italic_Ï‰ ( roman_â„“ ) end_POSTSUPERSCRIPT, there exists condenser ğ–¢ğ—ˆğ—‡ğ–½:({0,1}n)â„“â†’{0,1}m=Oâ¢(nâ‹…â„“/g):ğ–¢ğ—ˆğ—‡ğ–½â†’superscriptsuperscript01ğ‘›â„“superscript01ğ‘šğ‘‚â‹…ğ‘›â„“ğ‘”\mathsf{Cond}:(\{0,1\}^{n})^{\ell}\to\{0,1\}^{m=O(n\cdot\ell/g)}sansserif_Cond : ( { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 } start_POSTSUPERSCRIPT italic_m = italic_O ( italic_n â‹… roman_â„“ / italic_g ) end_POSTSUPERSCRIPT such that for any uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF source ğ—ğ—\mathbf{X}bold_X, HâˆÎµâ¢(ğ–¢ğ—ˆğ—‡ğ–½â¢(ğ—))â‰¥1âŒŠâ„“/gâŒ‹â‹…mâˆ’Oâ¢(logâ¡(n/Îµ))superscriptsubscriptğ»ğœ€ğ–¢ğ—ˆğ—‡ğ–½ğ—â‹…1â„“ğ‘”ğ‘šğ‘‚ğ‘›ğœ€H_{\infty}^{\varepsilon}(\mathsf{Cond}(\mathbf{X}))\geq\frac{1}{\left\lfloor% \ell/g\right\rfloor}\cdot m-O(\log(n/\varepsilon))italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ( sansserif_Cond ( bold_X ) ) â‰¥ divide start_ARG 1 end_ARG start_ARG âŒŠ roman_â„“ / italic_g âŒ‹ end_ARG â‹… italic_m - italic_O ( roman_log ( italic_n / italic_Îµ ) ). Their result is not explicit. â€¢ It is impossible to condense from uniform â¢(g,â„“,n)â¢-oNOSF sourcesuniform ğ‘”â„“ğ‘›-oNOSF sources\textrm{uniform }{\left(g,\ell,n\right)}\textrm{-oNOSF sources}uniform ( italic_g , roman_â„“ , italic_n ) -oNOSF sources with output entropy rate more than 1âŒŠâ„“/gâŒ‹1â„“ğ‘”\frac{1}{\left\lfloor\ell/g\right\rfloor}divide start_ARG 1 end_ARG start_ARG âŒŠ roman_â„“ / italic_g âŒ‹ end_ARG. We also mention a related family of sources, namely adversarial Chor-Goldreich sources. uniform oNOSF sources can be seen as a special case of adversarial Chor-Goldreich sources where the good blocks are uniform. Constructing condensers where the output entropy rate is g/â„“ğ‘”â„“g/\ellitalic_g / roman_â„“ for adversarial Chor-Goldreich sources is already a challenging task, although such condensers in various parameter regimes have been recently constructed [doron_almost_2023, GLZ_cg_condenser]. [DMOZ24condenseunpredictability] recently constructed condensers for a related more general model. 1.2 New condenser constructions Previous works only showed the existence of condensers for oNOSF sources when nâ‰¥2Ï‰â¢(â„“)ğ‘›superscript2ğœ”â„“n\geq 2^{\omega(\ell)}italic_n â‰¥ 2 start_POSTSUPERSCRIPT italic_Ï‰ ( roman_â„“ ) end_POSTSUPERSCRIPT. We vastly improve on this result in two ways. First, we show that for almost all values of n,â„“ğ‘›â„“n,\ellitalic_n , roman_â„“, even when nğ‘›nitalic_n is a small constant, excellent condensers exist. Second, we provide explicit condensers for oNOSF sources when nâ‰¥2Ï‰â¢(â„“)ğ‘›superscript2ğœ”â„“n\geq 2^{\omega(\ell)}italic_n â‰¥ 2 start_POSTSUPERSCRIPT italic_Ï‰ ( roman_â„“ ) end_POSTSUPERSCRIPT. We also obtain much better transformation from low-entropy oNOSF sources to uniform oNOSF sources that work even when kâ‰ªâ„“much-less-thanğ‘˜â„“k\ll\ellitalic_k â‰ª roman_â„“. These results show condensers always exist, except when nğ‘›nitalic_n is a very small constant (such as n=1ğ‘›1n=1italic_n = 1). To further our understanding of this case, we initiate the study of online influence of Boolean functions, a natural generalization of influence that captures the one-sided nature of our online adversary. We also discover surprising connections between condensers for oNOSF sources and protocols for natural problems in distributed computing, such as collective coin flipping and collective sampling. We now discuss our result in details below. 1.2.1 Existential condensers We show how to condense from uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources for almost all settings of â„“â„“\ellroman_â„“ and nğ‘›nitalic_n when gâ‰¥0.51â¢â„“ğ‘”0.51â„“g\geq 0.51\ellitalic_g â‰¥ 0.51 roman_â„“. In particular, we show: Theorem 1 (Informal version of Theorem 4.1). For all â„“,Îµâ„“ğœ€\ell,\varepsilonroman_â„“ , italic_Îµ where â„“â‰¥Oâ¢(logâ¡(1/Îµ))â„“ğ‘‚1ğœ€\ell\geq O(\log(1/\varepsilon))roman_â„“ â‰¥ italic_O ( roman_log ( 1 / italic_Îµ ) ), and n=104ğ‘›superscript104n=10^{4}italic_n = 10 start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT, there exists a condenser ğ–¢ğ—ˆğ—‡ğ–½:({0,1}n)â„“â†’{0,1}m:ğ–¢ğ—ˆğ—‡ğ–½â†’superscriptsuperscript01ğ‘›â„“superscript01ğ‘š\mathsf{Cond}:(\{0,1\}^{n})^{\ell}\to\{0,1\}^{m}sansserif_Cond : ( { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT such that for any uniform (0.51â¢â„“,â„“,n)0.51â„“â„“ğ‘›{\left(0.51\ell,\ell,n\right)}( 0.51 roman_â„“ , roman_â„“ , italic_n )-oNOSF source ğ—ğ—\mathbf{X}bold_X, we have HâˆÎµâ¢(ğ–¢ğ—ˆğ—‡ğ–½â¢(ğ—))â‰¥0.99â¢msuperscriptsubscriptğ»ğœ€ğ–¢ğ—ˆğ—‡ğ–½ğ—0.99ğ‘šH_{\infty}^{\varepsilon}(\mathsf{Cond}(\mathbf{X}))\geq 0.99mitalic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ( sansserif_Cond ( bold_X ) ) â‰¥ 0.99 italic_m where m=Oâ¢(â„“+logâ¡(1/Îµ))ğ‘šğ‘‚â„“1ğœ€m=O(\ell+\log(1/\varepsilon))italic_m = italic_O ( roman_â„“ + roman_log ( 1 / italic_Îµ ) ). Furthermore, when n=Ï‰â¢(1)ğ‘›ğœ”1n=\omega(1)italic_n = italic_Ï‰ ( 1 ), the output entropy rate becomes 1âˆ’oâ¢(1)1ğ‘œ11-o(1)1 - italic_o ( 1 ). This is tight since [CGR_seedless_condensers] showed it is impossible to condense uniform (0.5â¢â„“,â„“,n)0.5â„“â„“ğ‘›{\left(0.5\ell,\ell,n\right)}( 0.5 roman_â„“ , roman_â„“ , italic_n )-oNOSF sources beyond output entropy rate 0.50.50.50.5. Using our new results regarding transforming oNOSF sources to uniform oNOSF sources , we also obtain condensers for (0.51â¢â„“,â„“,n,k)0.51â„“â„“ğ‘›ğ‘˜{\left(0.51\ell,\ell,n,k\right)}( 0.51 roman_â„“ , roman_â„“ , italic_n , italic_k )-oNOSF sources when nâ‰¥polyâ¡(logâ¡(â„“))ğ‘›polyâ„“n\geq\operatorname{poly}(\log(\ell))italic_n â‰¥ roman_poly ( roman_log ( roman_â„“ ) ), Theorem 2. For all â„“,n,Îµâ„“ğ‘›ğœ€\ell,n,\varepsilonroman_â„“ , italic_n , italic_Îµ where n=polyâ¡(logâ¡(â„“/Îµ)),k=Oâ¢(logâ¡(â„“/Îµ))formulae-sequenceğ‘›polyâ„“ğœ€ğ‘˜ğ‘‚â„“ğœ€n=\operatorname{poly}(\log(\ell/\varepsilon)),k=O(\log(\ell/\varepsilon))italic_n = roman_poly ( roman_log ( roman_â„“ / italic_Îµ ) ) , italic_k = italic_O ( roman_log ( roman_â„“ / italic_Îµ ) ), there exists a condenser ğ–¢ğ—ˆğ—‡ğ–½:({0,1}n)â„“â†’{0,1}m:ğ–¢ğ—ˆğ—‡ğ–½â†’superscriptsuperscript01ğ‘›â„“superscript01ğ‘š\mathsf{Cond}:(\{0,1\}^{n})^{\ell}\to\{0,1\}^{m}sansserif_Cond : ( { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT such that for any (0.51â¢â„“,â„“,n,k)0.51â„“â„“ğ‘›ğ‘˜{\left(0.51\ell,\ell,n,k\right)}( 0.51 roman_â„“ , roman_â„“ , italic_n , italic_k )-oNOSF source ğ—ğ—\mathbf{X}bold_X, we have HâˆÎµâ¢(ğ–¢ğ—ˆğ—‡ğ–½â¢(ğ—))â‰¥mâˆ’Oâ¢(m/logâ¡(m))âˆ’Oâ¢(logâ¡(1/Îµ))superscriptsubscriptğ»ğœ€ğ–¢ğ—ˆğ—‡ğ–½ğ—ğ‘šğ‘‚ğ‘šğ‘šğ‘‚1ğœ€H_{\infty}^{\varepsilon}(\mathsf{Cond}(\mathbf{X}))\geq m-O(m/\log(m))-O(\log(% 1/\varepsilon))italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ( sansserif_Cond ( bold_X ) ) â‰¥ italic_m - italic_O ( italic_m / roman_log ( italic_m ) ) - italic_O ( roman_log ( 1 / italic_Îµ ) ) where m=Î©â¢(k)ğ‘šÎ©ğ‘˜m=\Omega(k)italic_m = roman_Î© ( italic_k ). We can also extend our result to condense from uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources for all g,â„“ğ‘”â„“g,\ellitalic_g , roman_â„“ and constant nğ‘›nitalic_n where the output entropy rate is 1/âŒŠâ„“/gâŒ‹âˆ’0.0011â„“ğ‘”0.0011/\left\lfloor\ell/g\right\rfloor-0.0011 / âŒŠ roman_â„“ / italic_g âŒ‹ - 0.001. This is tight since [CGR_seedless_condensers] showed it is impossible to condense such sources beyond output entropy rate 1/âŒŠâ„“/gâŒ‹1â„“ğ‘”1/\left\lfloor\ell/g\right\rfloor1 / âŒŠ roman_â„“ / italic_g âŒ‹. Previously, [CGR_seedless_condensers] showed how to existentially condense from uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources when gâ‰¥0.51â¢â„“ğ‘”0.51â„“g\geq 0.51\ellitalic_g â‰¥ 0.51 roman_â„“, provided nâ‰¥2Ï‰â¢(â„“)ğ‘›superscript2ğœ”â„“n\geq 2^{\omega(\ell)}italic_n â‰¥ 2 start_POSTSUPERSCRIPT italic_Ï‰ ( roman_â„“ ) end_POSTSUPERSCRIPT. As nğ‘›nitalic_n gets smaller, condensing becomes harder since a uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF source is also a uniform (gâ‹…n/1000,â„“â‹…n/1000,1000)â‹…ğ‘”ğ‘›1000â‹…â„“ğ‘›10001000{\left(g\cdot n/1000,\ell\cdot n/1000,1000\right)}( italic_g â‹… italic_n / 1000 , roman_â„“ â‹… italic_n / 1000 , 1000 )-oNOSF source. Hence, we greatly improve the parameters while using different and much simpler techniques. 1.2.2 Explicit condensers We construct the first explicit condensers for oNOSF sources . Our explicit condenser construction achieves the same parameters as the existential condenser construction of [CGR_seedless_condensers]. We show how to explicitly condense from uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources when nâ‰¥2Ï‰â¢(â„“)ğ‘›superscript2ğœ”â„“n\geq 2^{\omega(\ell)}italic_n â‰¥ 2 start_POSTSUPERSCRIPT italic_Ï‰ ( roman_â„“ ) end_POSTSUPERSCRIPT and gâ‰¥0.5â¢â„“+1ğ‘”0.5â„“1g\geq 0.5\ell+1italic_g â‰¥ 0.5 roman_â„“ + 1. We state the results for constant â„“â„“\ellroman_â„“ since that is cleaner: Theorem 3 (Informal version of Theorem 5.1). For all n,Îµğ‘›ğœ€n,\varepsilonitalic_n , italic_Îµ and constant â„“â„“\ellroman_â„“, there exists an explicit condenser ğ–¢ğ—ˆğ—‡ğ–½:({0,1}n)â„“â†’{0,1}m:ğ–¢ğ—ˆğ—‡ğ–½â†’superscriptsuperscript01ğ‘›â„“superscript01ğ‘š\mathsf{Cond}:(\{0,1\}^{n})^{\ell}\to\{0,1\}^{m}sansserif_Cond : ( { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT such that for any uniform (0.5â¢â„“+1,â„“)0.5â„“1â„“{\left(0.5\ell+1,\ell\right)}( 0.5 roman_â„“ + 1 , roman_â„“ )-oNOSF source ğ—ğ—\mathbf{X}bold_X, we have HâˆÎµâ¢(ğ–¢ğ—ˆğ—‡ğ–½â¢(ğ—))â‰¥mâˆ’Oâ¢(logâ¡(m/Îµ))superscriptsubscriptğ»ğœ€ğ–¢ğ—ˆğ—‡ğ–½ğ—ğ‘šğ‘‚ğ‘šğœ€H_{\infty}^{\varepsilon}(\mathsf{Cond}(\mathbf{X}))\geq m-O(\log(m/\varepsilon))italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ( sansserif_Cond ( bold_X ) ) â‰¥ italic_m - italic_O ( roman_log ( italic_m / italic_Îµ ) ) where m=Î©â¢(n)ğ‘šÎ©ğ‘›m=\Omega(n)italic_m = roman_Î© ( italic_n ). Just like earlier, since condensing when g=0.5â¢â„“ğ‘”0.5â„“g=0.5\ellitalic_g = 0.5 roman_â„“ is impossible, this result is also tight. Using our new results regarding transforming oNOSF sources to uniform oNOSF sources , we also obtain explicit condensers for (0.51â¢â„“,â„“,n,k)0.51â„“â„“ğ‘›ğ‘˜{\left(0.51\ell,\ell,n,k\right)}( 0.51 roman_â„“ , roman_â„“ , italic_n , italic_k )-oNOSF sources for the same parameter regime: Corollary 1.3 (Corollary 5.2, simplified). For all â„“,n,Îµâ„“ğ‘›ğœ€\ell,n,\varepsilonroman_â„“ , italic_n , italic_Îµ with constant â„“â„“\ellroman_â„“ and nâ‰¥Oâ¢(logâ¡(1/Îµ))ğ‘›ğ‘‚1ğœ€n\geq O(\log(1/\varepsilon))italic_n â‰¥ italic_O ( roman_log ( 1 / italic_Îµ ) ), there exists an explicit condenser ğ–¢ğ—ˆğ—‡ğ–½:({0,1}n)â„“â†’{0,1}m:ğ–¢ğ—ˆğ—‡ğ–½â†’superscriptsuperscript01ğ‘›â„“superscript01ğ‘š\mathsf{Cond}:(\{0,1\}^{n})^{\ell}\to\{0,1\}^{m}sansserif_Cond : ( { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT such that for any (0.5â¢â„“+2,â„“,n,polyâ¡(logâ¡n))0.5â„“2â„“ğ‘›polyğ‘›{\left(0.5\ell+2,\ell,n,\operatorname{poly}(\log n)\right)}( 0.5 roman_â„“ + 2 , roman_â„“ , italic_n , roman_poly ( roman_log italic_n ) )-oNOSF source ğ—ğ—\mathbf{X}bold_X, we have HâˆÎµâ¢(ğ–¢ğ—ˆğ—‡ğ–½â¢(ğ—))â‰¥mâˆ’Oâ¢(logâ¡(m/Îµ))superscriptsubscriptğ»ğœ€ğ–¢ğ—ˆğ—‡ğ–½ğ—ğ‘šğ‘‚ğ‘šğœ€H_{\infty}^{\varepsilon}(\mathsf{Cond}(\mathbf{X}))\geq m-O(\log(m/\varepsilon))italic_H start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Îµ end_POSTSUPERSCRIPT ( sansserif_Cond ( bold_X ) ) â‰¥ italic_m - italic_O ( roman_log ( italic_m / italic_Îµ ) ) where m=polyâ¡(logâ¡n)ğ‘špolyğ‘›m=\operatorname{poly}(\log n)italic_m = roman_poly ( roman_log italic_n ). Similar to earlier, we can also extend our result to explicitly condense from uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources in the same parameter regime so that the output entropy rate is 1/âŒŠâ„“/gâŒ‹âˆ’oâ¢(1)1â„“ğ‘”ğ‘œ11/\left\lfloor\ell/g\right\rfloor-o(1)1 / âŒŠ roman_â„“ / italic_g âŒ‹ - italic_o ( 1 ). Just like earlier, this is tight as well. Previously, [CGR_seedless_condensers] showed how to existentially condense from uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources in this parameter regime. However, they relied on the existence of a very strong pseudorandom object: â€œoutput-lightâ€ low-error two-source extractors. Such extractors, even without the output-lightness requirement, are extremely hard to construct and it is a major open problem to obtain such extractors. We are able to make this condenser explicit by building up on their ideas, making interesting observations regarding oNOSF sources , and stitching them together so that the base pseudorandom object we rely on are seeded extractors that we know how to explicitly construct with near optimal parameters. 1.2.3 Transforming low-entropy oNOSF sources to uniform oNOSF sources We show how to existentially, as well as explicitly, with a slight loss in parameters, transform (g,â„“,n,k)ğ‘”â„“ğ‘›ğ‘˜{\left(g,\ell,n,k\right)}( italic_g , roman_â„“ , italic_n , italic_k )-oNOSF sources into uniform (0.99â¢g,â„“âˆ’1,n)0.99ğ‘”â„“1ğ‘›{\left(0.99g,\ell-1,n\right)}( 0.99 italic_g , roman_â„“ - 1 , italic_n )-oNOSF sources. Formally, we show: Theorem 1.4 (Informal version of Theorem 6.1). For all â„“,n,k,Îµâ„“ğ‘›ğ‘˜ğœ€\ell,n,k,\varepsilonroman_â„“ , italic_n , italic_k , italic_Îµ where n=polyâ¡(logâ¡(â„“)),k=Oâ¢(logâ¡(â„“/Îµ))formulae-sequenceğ‘›polyâ„“ğ‘˜ğ‘‚â„“ğœ€n=\operatorname{poly}(\log(\ell)),k=O(\log(\ell/\varepsilon))italic_n = roman_poly ( roman_log ( roman_â„“ ) ) , italic_k = italic_O ( roman_log ( roman_â„“ / italic_Îµ ) ), there exists a function fğ‘“fitalic_f such that fğ‘“fitalic_f transforms (0.51â¢â„“,â„“,n,k)0.51â„“â„“ğ‘›ğ‘˜{\left(0.51\ell,\ell,n,k\right)}( 0.51 roman_â„“ , roman_â„“ , italic_n , italic_k )-oNOSF sources into uniform (0.509â¢â„“,â„“,m)0.509â„“â„“ğ‘š{\left(0.509\ell,\ell,m\right)}( 0.509 roman_â„“ , roman_â„“ , italic_m )-oNOSF sources with error Îµğœ€\varepsilonitalic_Îµ where m=Oâ¢(k)ğ‘šğ‘‚ğ‘˜m=O(k)italic_m = italic_O ( italic_k ). Our construction can also be made explicit with slightly worse dependence on mğ‘šmitalic_m and Îµğœ€\varepsilonitalic_Îµ. See Corollary 6.4 for the full tradeoff. Previously, [CGR_seedless_condensers] provided such a transformation only for nâ‰¥kâ‰¥Î©â¢(â„“)ğ‘›ğ‘˜Î©â„“n\geq k\geq\Omega(\ell)italic_n â‰¥ italic_k â‰¥ roman_Î© ( roman_â„“ ). Hence, our transformation makes a major improvement on their parameters. Such an improvement allows us to obtain better condensers for low-entropy oNOSF sources in the regime n=polyâ¡(logâ¡(â„“/Îµ))ğ‘›polyâ„“ğœ€n=\operatorname{poly}(\log(\ell/\varepsilon))italic_n = roman_poly ( roman_log ( roman_â„“ / italic_Îµ ) ) (see 2). 1.3 Application to collective coin flipping and collective sampling Condensing from oNOSF sources can be viewed as a special case of coin flipping and collective sampling protocols in the full information model that arise in fault-tolerant distributed computing. 1.3.1 Background Say there are â„“â„“\ellroman_â„“ players who have a common broadcast channel and want to jointly perform a task such as collectively flipping a coin. Some bğ‘bitalic_b players out of them are â€œbadâ€ and want to deter the task. We assume the bad players are computationally unbounded so cryptographic primitives are of no use. We further assume that each player has private access to uniform randomness. [ben-or_collective_1989] initiated the study of this model and aptly termed this task as â€œcollective coin flipping.â€ The simplest way to collectively flip a coin would be for all the players to initially agree on a function f:{0,1}â„“â†’{0,1}:ğ‘“â†’superscript01â„“01f:\{0,1\}^{\ell}\to\{0,1\}italic_f : { 0 , 1 } start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 }, then synchronously broadcast one random bit risubscriptğ‘Ÿğ‘–r_{i}italic_r start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, and to finally agree on the output being fâ¢(r1,â€¦,râ„“)ğ‘“subscriptğ‘Ÿ1â€¦subscriptğ‘Ÿâ„“f(r_{1},\dots,r_{\ell})italic_f ( italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_r start_POSTSUBSCRIPT roman_â„“ end_POSTSUBSCRIPT ). However, synchronizing broadcasts is hard, and it could be that the bad players set their output as function of the bits of the good players. [kahn_influence_1988] showed that no function fğ‘“fitalic_f can handle more than Oâ¢(â„“logâ¡â„“)ğ‘‚â„“â„“O\left(\frac{\ell}{\log\ell}\right)italic_O ( divide start_ARG roman_â„“ end_ARG start_ARG roman_log roman_â„“ end_ARG ) corruptions. One way to allow for more corruptions (almost linear) amongst players is to consider â€œprotocolsâ€ that allow more rounds of communication. In particular, a protocol can be thought of as a tree where each vertex represents a â€œroundâ€ where in every round the following happens: all good players sends their bits, then all bad players send their bits as a function of the bits of the good players, and they jointly compute a function of these bits. Depending on the outcome of the function, everyone branches on one branch in this tree. Furthermore, every leaf is labelled with final outcomes (say 00 or 1111) and, once you reach a leaf, that is the outcome that everybody agrees on. [ggl98] initiated the study of protocols where the outcomes are from a larger range and where the bad players are trying to minimize the largest probability of any outcome. They called this problem â€œcollective sampling.â€ 1.3.2 Known results [ben-or_collective_1989] showed that for protocols with outcomes {0,1}01\{0,1\}{ 0 , 1 }, bğ‘bitalic_b bad players can always ensure some outcome occurs with probability at least 12+b2â¢â„“12ğ‘2â„“\frac{1}{2}+\frac{b}{2\ell}divide start_ARG 1 end_ARG start_ARG 2 end_ARG + divide start_ARG italic_b end_ARG start_ARG 2 roman_â„“ end_ARG. [alonnoar93collective] first constructed a protocol that can handle Oâ¢(n)ğ‘‚ğ‘›O(n)italic_O ( italic_n ) corruptions. Follow-up works tried to reduce the number of rounds in this protocol where, in some settings, players were allowed to send more bits per round [russellzuckerman01, feige_noncryptographic_1999]. [ggl98] showed that for all collective sampling protocols and all outcomes, there exists a way for bğ‘bitalic_b bad players to coordinate and ensure that an outcome that happens without corruption with probability pğ‘pitalic_p, now happens with probability p1âˆ’(b/n)â‰¥pâ¢(1+bnâ¢logâ¡(1/p))superscriptğ‘1ğ‘ğ‘›ğ‘1ğ‘ğ‘›1ğ‘p^{1-(b/n)}\geq p\left(1+\frac{b}{n}\log(1/p)\right)italic_p start_POSTSUPERSCRIPT 1 - ( italic_b / italic_n ) end_POSTSUPERSCRIPT â‰¥ italic_p ( 1 + divide start_ARG italic_b end_ARG start_ARG italic_n end_ARG roman_log ( 1 / italic_p ) ). For further results and bounds, see [dodis2006fault]. 1.3.3 Connection to oNOSF sources The problem of extracting or condensing from oNOSF sources can be seen as special cases or variants of collective coin flipping and collective sampling that provide very simple protocols. For instance, suppose one has an extractor or condenser fğ‘“fitalic_f for uniform â¢(g,â„“,n)â¢-oNOSF sourcesuniform ğ‘”â„“ğ‘›-oNOSF sources\textrm{uniform }{\left(g,\ell,n\right)}\textrm{-oNOSF sources}uniform ( italic_g , roman_â„“ , italic_n ) -oNOSF sources. Then, consider a protocol where all â„“â„“\ellroman_â„“ players take turns and output nğ‘›nitalic_n random bits. The agreed final outcome is fğ‘“fitalic_f applied on these â„“â¢nâ„“ğ‘›\ell nroman_â„“ italic_n bits. This leads to protocols that are structurally much simpler since players donâ€™t have to carefully compute whose turn is it to go in various rounds and can obliviously prepare for their turn. The above protocol can also be viewed as a relaxed version of a 1111-round protocol where instead of everyone providing their output asynchronously, they take turns and provide outputs one after another in a simple sequential manner. 1.3.4 Previous results interpreted in oNOSF source context Previous impossibility results can be interpreted in the context of extracting / condensing from uniform oNOSF sources . For instance, collective coin flipping impossibility results of [ben-or_collective_1989] imply extraction impossibility results for uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources when n=1ğ‘›1n=1italic_n = 1. In particular, they imply: Corollary 1.5. There does not exist an Îµğœ€\varepsilonitalic_Îµ-extractor for uniform (g,â„“,1)ğ‘”â„“1{\left(g,\ell,1\right)}( italic_g , roman_â„“ , 1 )-oNOSF sources where Îµ=b2â¢â„“ğœ€ğ‘2â„“\varepsilon=\frac{b}{2\ell}italic_Îµ = divide start_ARG italic_b end_ARG start_ARG 2 roman_â„“ end_ARG. Similarly, we observe that the notion of collective sampling is equivalent to 00-error condensing. Hence, lower bounds of [ggl98] imply zero-error condensing lower bounds for uniform (g,â„“,n)ğ‘”â„“ğ‘›{\left(g,\ell,n\right)}( italic_g , roman_â„“ , italic_n )-oNOSF sources when n=1ğ‘›1n=1italic_n = 1. Formally: Corollary 1.6. There does not exist a condenser ğ–¢ğ—ˆğ—‡ğ–½:{0,1}â„“â†’{0,1}m:ğ–¢ğ—ˆğ—‡ğ–½â†’superscript01â„“superscript01ğ‘š\mathsf{Cond}:\{0,1\}^{\ell}\to\{0,1\}^{m}sansserif_Cond : { 0 , 1 } start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT for uniform (g,â„“,1)ğ‘”â„“1{\left(g,\ell,1\right)}( italic_g , roman_â„“ , 1 )-oNOSF sources that can guarantee output smooth min-entropy (with parameter Îµ=0ğœ€0\varepsilon=0italic_Îµ = 0) more than k=gâ„“â‹…mğ‘˜â‹…ğ‘”â„“ğ‘šk=\frac{g}{\ell}\cdot mitalic_k = divide start_ARG italic_g end_ARG start_ARG roman_â„“ end_ARG â‹… italic_m. 1.3.5 Îµğœ€\varepsilonitalic_Îµ-collective sampling Since collective sampling lower bounds show that for any protocol, 00-error condensing beyond rate g/â„“ğ‘”â„“g/\ellitalic_g / roman_â„“ is impossible, one can naturally ask whether condensing with small error Îµğœ€\varepsilonitalic_Îµ is possible: We call this problem Îµğœ€\varepsilonitalic_Îµ-collective sampling where the goal is to output a distribution which is Îµğœ€\varepsilonitalic_Îµ-close to a distribution where every output has small probability. Interpreted this way, this is exactly what protocols arising out of our condensers for uniform oNOSF sources provide: Using 1, when each player has access to 104superscript10410^{4}10 start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT random bits, there exists a simple protocol that can handle 0.49â¢â„“0.49â„“0.49\ell0.49 roman_â„“ corrupt players such that the players can collectively sample a distribution over m=Oâ¢(â„“)ğ‘šğ‘‚â„“m=O(\ell)italic_m = italic_O ( roman_â„“ ) bits which is 2âˆ’Î©â¢(â„“)superscript2Î©â„“2^{-\Omega(\ell)}2 start_POSTSUPERSCRIPT - roman_Î© ( roman_â„“ ) end_POSTSUPERSCRIPT-close to having entropy 0.99â¢m0.99ğ‘š0.99m0.99 italic_m. As far as we are aware, such a protocol cannot be implied using any other previous protocol (a lot of previous protocols are obtained through leader election protocols which do not seem useful here since the leader has access to only constant number of bits). We similarly obtain explicit protocols using 3 for the case when each player has access to nâ‰¥2Ï‰â¢(â„“)ğ‘›superscript2ğœ”â„“n\geq 2^{\omega(\ell)}italic_n â‰¥ 2 start_POSTSUPERSCRIPT italic_Ï‰ ( roman_â„“ ) end_POSTSUPERSCRIPT bits. 1.3.6 Collective coin flipping and sampling with weak random sources A natural extension to collective coin flipping and sampling in the full information model is when all players only have access to weak source of randomness (that are independent from each other) instead of true uniform randomness. This question was first studied by [gsv05]. [klrz08network] used network extractor protocol to transform weak random sources of each player into independent private random sources. This way, after using the network extraction protocol, players can follow the usual collective coin flipping / sampling protocol. [gsz21network] improved the network extraction protocol using two-source non-malleable extractors. Using our (g,â„“,n,k)ğ‘”â„“ğ‘›ğ‘˜{\left(g,\ell,n,k\right)}( italic_g , roman_â„“ , italic_n , italic_k )-oNOSF source condensers, we obtain alternative, simple Îµğœ€\varepsilonitalic_Îµ-collective sampling protocols in the setting where players have access to weak sources of randomness. We obtain such an existential protocol using 2, and explicit protocol using Corollary 1.3. 1.4 Online influence When nğ‘›nitalic_n is a large enough constant, we showed that great condensers do exist for oNOSF sources . We now study the case of small nğ‘›nitalic_n. In particular, we focus on the case of n=1ğ‘›1n=1italic_n = 1. We call such uniform (g,â„“,1)ğ‘”â„“1{\left(g,\ell,1\right)}( italic_g , roman_â„“ , 1 )-oNOSF sources as (g,â„“)ğ‘”â„“{\left(g,\ell\right)}( italic_g , roman_â„“ )-oNOBF sources; oNOBF stands for online non-oblivious bit-fixing sources. We ask what is the exact tradeoff between gğ‘”gitalic_g, â„“â„“\ellroman_â„“, and Îµğœ€\varepsilonitalic_Îµ for extracting / condensing from oNOBF sources . Towards this, we introduce a new notion of influence for Boolean functions which we call online influence. Definition 1.7 (Online influence). For a function f:{0,1}â„“â†’{0,1}:ğ‘“â†’superscript01â„“01f:\{0,1\}^{\ell}\to\{0,1\}italic_f : { 0 , 1 } start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 }, the online influence of the iğ‘–iitalic_i-th bit is ğ¨ğˆiâ¡[f]=ğ”¼xâˆ¼ğ”iâˆ’1[|ğ”¼yâˆ¼ğ”â„“âˆ’i[fâ¢(x,1,y)]âˆ’ğ”¼yâˆ¼ğ”â„“âˆ’i[fâ¢(x,0,y)]|]subscriptğ¨ğˆğ‘–ğ‘“subscriptğ”¼similar-toğ‘¥subscriptğ”ğ‘–1subscriptğ”¼similar-toğ‘¦subscriptğ”â„“ğ‘–ğ‘“ğ‘¥1ğ‘¦subscriptğ”¼similar-toğ‘¦subscriptğ”â„“ğ‘–ğ‘“ğ‘¥0ğ‘¦\displaystyle\operatorname{\mathbf{oI}}_{i}[f]=\operatorname*{\mathbb{E}}_{x% \sim\mathbf{U}_{i-1}}\left[\left\lvert\operatorname*{\mathbb{E}}_{y\sim\mathbf% {U}_{\ell-i}}[f(x,1,y)]-\operatorname*{\mathbb{E}}_{y\sim\mathbf{U}_{\ell-i}}[% f(x,0,y)]\right\rvert\right]bold_oI start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT [ italic_f ] = blackboard_E start_POSTSUBSCRIPT italic_x âˆ¼ bold_U start_POSTSUBSCRIPT italic_i - 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT [ | blackboard_E start_POSTSUBSCRIPT italic_y âˆ¼ bold_U start_POSTSUBSCRIPT roman_â„“ - italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT [ italic_f ( italic_x , 1 , italic_y ) ] - blackboard_E start_POSTSUBSCRIPT italic_y âˆ¼ bold_U start_POSTSUBSCRIPT roman_â„“ - italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT [ italic_f ( italic_x , 0 , italic_y ) ] | ] and the total online influence is ğ¨ğˆâ¡[f]ğ¨ğˆğ‘“\displaystyle\operatorname{\mathbf{oI}}[f]bold_oI [ italic_f ] =âˆ‘i=1â„“ğ¨ğˆiâ¡[f].absentsuperscriptsubscriptğ‘–1â„“subscriptğ¨ğˆğ‘–ğ‘“\displaystyle=\sum_{i=1}^{\ell}\operatorname{\mathbf{oI}}_{i}[f].= âˆ‘ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT bold_oI start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT [ italic_f ] . We first observe that for monotone functions, online influence equals the usual notion of influence (see Lemma 7.4 for a proof). Next, we show a PoincarÃ© style inequality for total online influence: Theorem 4 (Theorem 7.5, restated). For any f:{0,1}â„“â†’{0,1}:ğ‘“â†’superscript01â„“01f:\{0,1\}^{\ell}\to\{0,1\}italic_f : { 0 , 1 } start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 }, we have Var(f)â‰¤ğ¨ğˆâ¡[f]â‰¤â„“â¢Var(f)Varğ‘“ğ¨ğˆğ‘“â„“Varğ‘“\operatorname*{Var}(f)\leq\operatorname{\mathbf{oI}}[f]\leq\sqrt{\ell% \operatorname*{Var}(f)}roman_Var ( italic_f ) â‰¤ bold_oI [ italic_f ] â‰¤ square-root start_ARG roman_â„“ roman_Var ( italic_f ) end_ARG. These inequalities are tight, with tightness exhibited by PARITY and MAJORITY respectively (see Example 7.6 for more details). We then ask the natural question that for a function fğ‘“fitalic_f, what is the maximum online influence out of all nğ‘›nitalic_n bits? For the usual notion of influence, this question was resolved by the famous theorem of [kahn_influence_1988] who showed there always exists a bit with influence at least Var(f)â‹…Î©â¢(logâ¡â„“â„“)â‹…Varğ‘“Î©â„“â„“\operatorname*{Var}(f)\cdot\Omega\left(\frac{\log\ell}{\ell}\right)roman_Var ( italic_f ) â‹… roman_Î© ( divide start_ARG roman_log roman_â„“ end_ARG start_ARG roman_â„“ end_ARG ). We show that surprisingly, there exists a balanced function, namely the address function, where every bit has online influence at most Oâ¢(1â„“)ğ‘‚1â„“O\left(\frac{1}{\ell}\right)italic_O ( divide start_ARG 1 end_ARG start_ARG roman_â„“ end_ARG ) (see Lemma 7.12 for a proof). This provides a separation between the usual notion of influence and online influence. Additionally, in Lemma 7.13, we show that the address function is an extractor for uniform (â„“âˆ’1,â„“)â„“1â„“{\left(\ell-1,\ell\right)}( roman_â„“ - 1 , roman_â„“ )-oNOSF sources with error 1/â„“1â„“1/\ell1 / roman_â„“ . Lastly, we show that using this notion of online influence, we can obtain the following extraction lower bound: Theorem 1.8 (Informal version of Theorem 7.17). For Îµ<0.01ğœ€0.01\varepsilon<0.01italic_Îµ < 0.01, there do not exist extractors for (0.98â¢â„“,â„“)0.98â„“â„“{\left(0.98\ell,\ell\right)}( 0.98 roman_â„“ , roman_â„“ )-oNOBF sources with error at most Îµğœ€\varepsilonitalic_Îµ. A similar extraction lower bound was shown in [aggarwal_how_2020] using different techniques. 1.5 Extracting from local oNOSF sources A natural variation on our definition of oNOSF sources is to consider the case where the adversary cannot remember the value of every good block in the past; rather, it can only remember the value of the most recent sğ‘ sitalic_s blocks. Arguably, this is a realistic assumption in the setting of many short blocks, where it could be difficult to introduce long range correlation."
https://arxiv.org/html/2411.03444v1,Algebraic metacomplexity and representation theory,"We prove that in the algebraic metacomplexity framework, the decomposition of metapolynomials into their isotypic components can be implemented efficiently, namely with only a quasipolynomial blowup in the circuit size. This means that many existing algebraic complexity lower bound proofs can be efficiently converted into isotypic lower bound proofs via highest weight metapolynomials, a notion studied in geometric complexity theory. In the context of algebraic natural proofs, our result means that without loss of generality algebraic natural proofs can be assumed to be isotypic. Our proof is built on the PoincarÃ©â€“Birkhoffâ€“Witt theorem for Lie algebras and on Gelfandâ€“Tsetlin theory, for which we give the necessary comprehensive background.","Strong computational complexity lower bounds are often difficult to prove, for many different complexity measures. In most cases, the inability to prove lower bounds can be explained by barrier results such as the Relativization barrier due to Baker, Gill and Solovay [BGS75], the Algebrization barrier due to Aaronson and Wigderson [AW09] and the Natural Proofs barrier due to Razborov and Rudich [RR94]. Metacomplexity studies the complexity of computing various complexity measures, such as the minimum circuit complexity of a function. One eventual goal of the metacomplexity program is to understand mathematically why lower bounds are hard to prove. In this paper, we study metacomplexity in the algebraic circuit complexity setup from a representation-theoretic viewpoint. Algebraic complexity focuses on proving complexity lower bounds for various problems related to the computation of multivariate polynomials and rational functions. Prominent examples include the discrete Fourier transform, matrix multiplication, and solving systems of linear equations; see [BCS13]. In algebraic complexity, the main model of computation is the algebraic circuit, which is a labeled directed graph encoding an algorithm to evaluate a polynomial. Most polynomials require large algebraic circuits; however exhibiting explicit ones with such property is difficult. Valiantâ€™s flagship conjecture [Val79], known as ğ–µğ–¯â‰ ğ–µğ–­ğ–¯ğ–µğ–¯ğ–µğ–­ğ–¯\mathsf{VP}\neq\mathsf{VNP}sansserif_VP â‰  sansserif_VNP, states that the algebraic circuit complexity of the permanent polynomial ğ—‰ğ–¾ğ—‹dâ¢(x1,1,â€¦,xd,d)=âˆ‘Ï€âˆˆğ”–dâˆi=1dxi,Ï€â¢(i)subscriptğ—‰ğ–¾ğ—‹ğ‘‘subscriptğ‘¥11â€¦subscriptğ‘¥ğ‘‘ğ‘‘subscriptğœ‹subscriptğ”–ğ‘‘superscriptsubscriptproductğ‘–1ğ‘‘subscriptğ‘¥ğ‘–ğœ‹ğ‘–\mathsf{per}_{d}(x_{1,1},\dots,x_{d,d})=\sum_{\pi\in\mathfrak{S}_{d}}\prod_{i=% 1}^{d}x_{i,\pi(i)}sansserif_per start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_x start_POSTSUBSCRIPT 1 , 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_d , italic_d end_POSTSUBSCRIPT ) = âˆ‘ start_POSTSUBSCRIPT italic_Ï€ âˆˆ fraktur_S start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT end_POSTSUBSCRIPT âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i , italic_Ï€ ( italic_i ) end_POSTSUBSCRIPT is not polynomially bounded as a function of dğ‘‘ditalic_d; this conjecture is an algebraic analog of the ğ–¯â‰ ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}\neq\mathsf{NP}sansserif_P â‰  sansserif_NP conjecture: indeed, the permanent of the adjacency matrix of a bipartite graph counts the number of perfect matchings, which is a #â¢ğ–¯#ğ–¯\#\mathsf{P}# sansserif_P-hard problem. Since the superlinear algebraic lower bounds for general circuits demonstrated by Strassen [Str73] and Baur & Strassen [BS83], there have been no significant improvements in these lower bounds for more than four decades. This stagnation has prompted research into understanding the limitations of current proof techniques for establishing strong lower bounds for algebraic circuits, in order to guide us away from lower bound techniques that are inherently limited. Many current proof techniques in algebraic complexity theory are implicitly based on metapolynomials. Examples of such techniques are rank methods [LO15, LST21], methods based on geometric features [LMR13, GGIL22], and the geometric complexity program [MS01, Mul12]. We refer to Section 2.2 for a more extensive discussion. Informally, metapolynomials are polynomials whose variables are coefficients of polynomials. The concept dates back to resultants and invariants of forms [Cay45, Syl52], while the term â€œmetapolynomialâ€ was coined in [Reg02], and made popular in [GKSS17]. A classical example is the metapolynomial b2âˆ’4â¢aâ¢csuperscriptğ‘24ğ‘ğ‘b^{2}-4acitalic_b start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - 4 italic_a italic_c in the coefficients of a univariate degree 2222 polynomial aâ¢x2+bâ¢x+cğ‘superscriptğ‘¥2ğ‘ğ‘¥ğ‘ax^{2}+bx+citalic_a italic_x start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + italic_b italic_x + italic_c, which vanishes exactly when the two roots of the polynomial coincide. In this paper, we study the algebraic circuit complexity of metapolynomials, and their representation theoretic structure. We prove that the search space for lower bounds proofs via metapolynomials can be drastically reduced to isotypic metapolynomials, or to highest weight vectors, with only a quasipolynomial circuit size blowup. This reduction is common in the geometric setting, see e.g., [AC07, BI11, BI13, AIR16, CIM17, BHIM22]; however the general circuit size blowup was unknown. Our method can be used to extract isotypic metapolynomials for example from rank-based lower bounds proofs, and the obtained metapolynomials give the same lower bounds. Generally, metapolynomials are not affected by barriers for rank methods [EGOW18, GaÅ‚17]. In fact, metapolynomials characterize border complexity classes in the sense of Section 2.4. Metapolynomials We work over the field â„‚â„‚\mathbb{C}blackboard_C of complex numbers, and the set {x1,x2,â€¦}subscriptğ‘¥1subscriptğ‘¥2â€¦\{x_{1},x_{2},\ldots\}{ italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , â€¦ } of variables. For every sequence ğ’Šğ’Š\bm{i}bold_italic_i of nonnegative integers with âˆ‘jij<âˆsubscriptğ‘—subscriptğ‘–ğ‘—\sum_{j}i_{j}<\inftyâˆ‘ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_i start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT < âˆ, a monomial xğ’Šsuperscriptğ‘¥ğ’Šx^{\bm{i}}italic_x start_POSTSUPERSCRIPT bold_italic_i end_POSTSUPERSCRIPT is the finite product of variables x1i1â¢x2i2â¢â‹¯superscriptsubscriptğ‘¥1subscriptğ‘–1superscriptsubscriptğ‘¥2subscriptğ‘–2â‹¯x_{1}^{i_{1}}x_{2}^{i_{2}}\cdotsitalic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_i start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_i start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â‹¯, and a polynomial fğ‘“fitalic_f is a finite linear combination of monomials. For every monomial xğ’Š=x1i1â¢x2i2â¢â‹¯superscriptğ‘¥ğ’Šsuperscriptsubscriptğ‘¥1subscriptğ‘–1superscriptsubscriptğ‘¥2subscriptğ‘–2â‹¯x^{\bm{i}}=x_{1}^{i_{1}}x_{2}^{i_{2}}\cdotsitalic_x start_POSTSUPERSCRIPT bold_italic_i end_POSTSUPERSCRIPT = italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_i start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_i start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â‹¯, define a metavariable cğ’Šsubscriptğ‘ğ’Šc_{\bm{i}}italic_c start_POSTSUBSCRIPT bold_italic_i end_POSTSUBSCRIPT. A metavariable cğ’Šsubscriptğ‘ğ’Šc_{{\bm{i}}}italic_c start_POSTSUBSCRIPT bold_italic_i end_POSTSUBSCRIPT has degree 1, and it has weight ğ’Šğ’Š\bm{i}bold_italic_i. Finite products of metavariables are called metamonomials, and finite linear combinations of metamonomials are called metapolynomials. The weight of a metamonomial is the sum of the weights of its metavariables. If every metamonomial in a metapolynomial Î”Î”\Deltaroman_Î” has the same weight, then Î”Î”\Deltaroman_Î” is called a weight metapolynomial (and the zero metapolynomial has every weight). For a fixed weight wğ‘¤witalic_w the metapolynomials of that weight form a vector space, the weight wğ‘¤witalic_w space. Every metapolynomial can be written as a unique sum of weight metapolynomials of different weights. A metapolynomial is called affine linear if all its metamonomials have degree at most 1, i.e., are just a metavariable or a constant. Every metapolynomial Î”Î”\Deltaroman_Î” can be evaluated at any polynomial fğ‘“fitalic_f by assigning to each metavariable the coefficient of the corresponding monomial in fğ‘“fitalic_f. For example, the discriminant of a degree two homogeneous polynomial in two variables c20â¢x02+c11â¢x0â¢x1+c02â¢x12subscriptğ‘20superscriptsubscriptğ‘¥02subscriptğ‘11subscriptğ‘¥0subscriptğ‘¥1subscriptğ‘02superscriptsubscriptğ‘¥12c_{20}x_{0}^{2}+c_{11}x_{0}x_{1}+c_{02}x_{1}^{2}italic_c start_POSTSUBSCRIPT 20 end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + italic_c start_POSTSUBSCRIPT 11 end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + italic_c start_POSTSUBSCRIPT 02 end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT is the metapolynomial Î”=c112âˆ’4â¢c20â¢c02Î”superscriptsubscriptğ‘1124subscriptğ‘20subscriptğ‘02\Delta=c_{11}^{2}-4c_{20}c_{02}roman_Î” = italic_c start_POSTSUBSCRIPT 11 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - 4 italic_c start_POSTSUBSCRIPT 20 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 02 end_POSTSUBSCRIPT. It is a classical fact that Î”â¢(f)=0Î”ğ‘“0\Delta(f)=0roman_Î” ( italic_f ) = 0 if and only if f=â„“2ğ‘“superscriptâ„“2f=\ell^{2}italic_f = roman_â„“ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT for some homogeneous linear polynomial â„“=Î±0â¢x0+Î±1â¢x1â„“subscriptğ›¼0subscriptğ‘¥0subscriptğ›¼1subscriptğ‘¥1\ell=\alpha_{0}x_{0}+\alpha_{1}x_{1}roman_â„“ = italic_Î± start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT + italic_Î± start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. In principle, metapolynomials can involve metavariables that correspond to monomials of different degrees, but for our purposes it is sufficient to consider the case where all metavariables correspond to monomials of the same degree dğ‘‘ditalic_d, see 1.2. Every such metapolynomial can be decomposed uniquely as a sum of its homogeneous degree Î´ğ›¿\deltaitalic_Î´ components, and we call a homogeneous degree Î´ğ›¿\deltaitalic_Î´ metapolynomial a metapolynomial of format (Î´,d,k)ğ›¿ğ‘‘ğ‘˜(\delta,d,k)( italic_Î´ , italic_d , italic_k ) if all its metavariables only involve the variables x1,â€¦,xksubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜x_{1},\ldots,x_{k}italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT. Algebraic circuits In this paper, we are mostly interested in the algebraic circuit size of metapolynomials. Algebraic circuits for metapolynomials are defined in the same way as for usual polynomials, as follows. An algebraic circuit is a directed acyclic graph in which each vertex has indegree 00 or 2222. Every indegree 0 vertex is called input gate and it is labelled by an affine linear metapolynomial; every indegree 2 vertex is called a computation gate and it is labeled by either â€œ+++â€ or â€œÃ—\timesÃ—â€; every edge is labeled by a complex number, which is assumed to be 1 if this scalar is omitted; there is exactly one vertex of outdegree 0. An algebraic circuit computes a metapolynomial at every vertex by induction over the directed acyclic graph structure (the labels on the edges rescale the computed values), i.e., if the values computed at the children of a gate vğ‘£vitalic_v are Î”1subscriptÎ”1\Delta_{1}roman_Î” start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Î”2subscriptÎ”2\Delta_{2}roman_Î” start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and the incoming edges to vğ‘£vitalic_v are labelled with Î±1subscriptğ›¼1\alpha_{1}italic_Î± start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Î±2subscriptğ›¼2\alpha_{2}italic_Î± start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, respectively, then the value computed at vğ‘£vitalic_v is Î±1â¢Î”1+Î±2â¢Î”2subscriptğ›¼1subscriptÎ”1subscriptğ›¼2subscriptÎ”2\alpha_{1}\Delta_{1}+\alpha_{2}\Delta_{2}italic_Î± start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT roman_Î” start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + italic_Î± start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT roman_Î” start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT or Î±1â¢Î±2â¢Î”1â¢Î”2subscriptğ›¼1subscriptğ›¼2subscriptÎ”1subscriptÎ”2\alpha_{1}\alpha_{2}\Delta_{1}\Delta_{2}italic_Î± start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT italic_Î± start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT roman_Î” start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT roman_Î” start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, depending on whether vğ‘£vitalic_v is labelled with a â€œ+++â€ or a â€œÃ—\timesÃ—â€. An algebraic circuit computes the metapolynomial computed at its outdegree 0 vertex. The size of a circuit is the total number of its vertices. The algebraic circuit complexity of a metapolynomial is the minimum size of an algebraic circuit computing it. For example, Figure 1 shows that the algebraic circuit complexity of the discriminant is at most 6. Algebraic circuits for polynomials are defined analogously. c11subscriptğ‘11c_{11}italic_c start_POSTSUBSCRIPT 11 end_POSTSUBSCRIPTc20subscriptğ‘20c_{20}italic_c start_POSTSUBSCRIPT 20 end_POSTSUBSCRIPTc02subscriptğ‘02c_{02}italic_c start_POSTSUBSCRIPT 02 end_POSTSUBSCRIPTÃ—\timesÃ—Ã—\timesÃ—+++âˆ’44-4- 4 Figure 1: An algebraic circuit computing the discriminant Î”=c112âˆ’4â¢c20â¢c02Î”superscriptsubscriptğ‘1124subscriptğ‘20subscriptğ‘02\Delta=c_{11}^{2}-4c_{20}c_{02}roman_Î” = italic_c start_POSTSUBSCRIPT 11 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - 4 italic_c start_POSTSUBSCRIPT 20 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 02 end_POSTSUBSCRIPT. Representation Theory A partition Î»=(Î»1,Î»2,â€¦)ğœ†subscriptğœ†1subscriptğœ†2â€¦\lambda=(\lambda_{1},\lambda_{2},\ldots)italic_Î» = ( italic_Î» start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Î» start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , â€¦ ) is a finite sequence of non-increasing positive natural numbers. Let â„“â¢(Î»)=maxâ¡{jâˆ£Î»jâ‰ 0}â„“ğœ†conditionalğ‘—subscriptğœ†ğ‘—0\ell(\lambda)=\max\{j\mid\lambda_{j}\neq 0\}roman_â„“ ( italic_Î» ) = roman_max { italic_j âˆ£ italic_Î» start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT â‰  0 }. We define Î»j=0subscriptğœ†ğ‘—0\lambda_{j}=0italic_Î» start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT = 0 for all j>â„“â¢(Î»)ğ‘—â„“ğœ†j>\ell(\lambda)italic_j > roman_â„“ ( italic_Î» ). Write |Î»|:=âˆ‘jÎ»jassignğœ†subscriptğ‘—subscriptğœ†ğ‘—|\lambda|:=\sum_{j}\lambda_{j}| italic_Î» | := âˆ‘ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT italic_Î» start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT, and say that Î»ğœ†\lambdaitalic_Î» is a partition of |Î»|ğœ†|\lambda|| italic_Î» | of length â„“â¢(Î»)â„“ğœ†\ell(\lambda)roman_â„“ ( italic_Î» ). In this case we write Î»âŠ¢|Î»|provesğœ†ğœ†\lambda\mathchoice{\scalebox{1.2}[0.7]{ $\vdash$}\,}{\scalebox{1.2}[0.7]{ $% \vdash$}\,}{\scalebox{0.7}{\scalebox{1.2}[0.7]{$\vdash$}}\,}{\scalebox{0.5}{% \scalebox{1.2}[0.7]{$\vdash$}}\,}|\lambda|italic_Î» âŠ¢ | italic_Î» | or Î»âŠ¢â„“â¢(Î»)|Î»|\lambda\mathchoice{\scalebox{1.2}[0.7]{ $\vdash$}_{\ell(\lambda)}\,}{\scalebox% {1.2}[0.7]{ $\vdash$}_{\ell(\lambda)}\,}{\scalebox{0.7}{\scalebox{1.2}[0.7]{$% \vdash$}}_{\ell(\lambda)}\,}{\scalebox{0.5}{\scalebox{1.2}[0.7]{$\vdash$}}_{% \ell(\lambda)}\,}|\lambda|italic_Î» âŠ¢ start_POSTSUBSCRIPT roman_â„“ ( italic_Î» ) end_POSTSUBSCRIPT | italic_Î» | depending on whether the length is relevant. For example, Î»=(4,2,2)ğœ†422\lambda=(4,2,2)italic_Î» = ( 4 , 2 , 2 ) is a partition of 8888 of length 3333, i.e., Î»âŠ¢3 8\lambda\mathchoice{\scalebox{1.2}[0.7]{ $\vdash$}_{3}\,}{\scalebox{1.2}[0.7]{ % $\vdash$}_{3}\,}{\scalebox{0.7}{\scalebox{1.2}[0.7]{$\vdash$}}_{3}\,}{% \scalebox{0.5}{\scalebox{1.2}[0.7]{$\vdash$}}_{3}\,}8italic_Î» âŠ¢ start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT 8. The Young diagram of a partition Î»ğœ†\lambdaitalic_Î» is a top-left justified array of boxes with Î»jsubscriptğœ†ğ‘—\lambda_{j}italic_Î» start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT many boxes in row jğ‘—jitalic_j. For example, the Young diagram for (4,2,2)422(4,2,2)( 4 , 2 , 2 ) is \yngâ¢(4,2,2)\yng422\yng(4,2,2)( 4 , 2 , 2 ). A Young tableau Tğ‘‡Titalic_T is a filling of the boxes of a Young diagram with numbers. The partition Î»ğœ†\lambdaitalic_Î» is called the shape of Tğ‘‡Titalic_T. For example, \youngâ¢(1421,31,24)\young14213124\young(1421,31,24)( 1421 , 31 , 24 ) is a Young tableau of shape (4,2,2)422(4,2,2)( 4 , 2 , 2 ). A Young tableau is semistandard if the numbers within each row from left to right are non-decreasing, and the numbers within each column from top to bottom are strictly increasing, for example \youngâ¢(1122,23,44)\young11222344\young(1122,23,44)( 1122 , 23 , 44 ). For each partition Î»ğœ†\lambdaitalic_Î» there exists a unique superstandard tableau, that is the tableau with only the number jğ‘—jitalic_j in row jğ‘—jitalic_j, e.g., \youngâ¢(1111,22,33)\young11112233\young(1111,22,33)( 1111 , 22 , 33 ). The group GLksubscriptGLğ‘˜\textnormal{GL}_{k}GL start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT acts on the space â„‚â¢[x1,â€¦,xk]dâ„‚subscriptsubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜ğ‘‘\mathbb{C}[x_{1},\ldots,x_{k}]_{d}blackboard_C [ italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ] start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT of homogeneous polynomials of degree dğ‘‘ditalic_d on â„‚ksuperscriptâ„‚ğ‘˜\mathbb{C}^{k}blackboard_C start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT by linear change of coordinates. This action induces, again by linear change of coordinates, an action on the space of metapolynomials with format (Î´,d,k)ğ›¿ğ‘‘ğ‘˜(\delta,d,k)( italic_Î´ , italic_d , italic_k ) for every Î´ğ›¿\deltaitalic_Î´. For instance, the change of basis swapping the two coordinates on â„‚2superscriptâ„‚2\mathbb{C}^{2}blackboard_C start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, defines the change of basis on â„‚â¢[x0,x1]2â„‚subscriptsubscriptğ‘¥0subscriptğ‘¥12\mathbb{C}[x_{0},x_{1}]_{2}blackboard_C [ italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ] start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT obtained by exchanging x0subscriptğ‘¥0x_{0}italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT and x1subscriptğ‘¥1x_{1}italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. This induces a linear change of coordinates on â„‚â¢[c20,c11,c02]â„‚subscriptğ‘20subscriptğ‘11subscriptğ‘02\mathbb{C}[c_{20},c_{11},c_{02}]blackboard_C [ italic_c start_POSTSUBSCRIPT 20 end_POSTSUBSCRIPT , italic_c start_POSTSUBSCRIPT 11 end_POSTSUBSCRIPT , italic_c start_POSTSUBSCRIPT 02 end_POSTSUBSCRIPT ] which exchanges c20subscriptğ‘20c_{20}italic_c start_POSTSUBSCRIPT 20 end_POSTSUBSCRIPT and c02subscriptğ‘02c_{02}italic_c start_POSTSUBSCRIPT 02 end_POSTSUBSCRIPT and leaves c11subscriptğ‘11c_{11}italic_c start_POSTSUBSCRIPT 11 end_POSTSUBSCRIPT fixed. The discriminant c112âˆ’4â¢c02â¢c20superscriptsubscriptğ‘1124subscriptğ‘02subscriptğ‘20c_{11}^{2}-4c_{02}c_{20}italic_c start_POSTSUBSCRIPT 11 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - 4 italic_c start_POSTSUBSCRIPT 02 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 20 end_POSTSUBSCRIPT is sent to itself by this change of coordinates. More precisely the group actions are defined as follows. For every homogeneous degree dğ‘‘ditalic_d polynomial fğ‘“fitalic_f in kğ‘˜kitalic_k variables and every gâˆˆGLkğ‘”subscriptGLğ‘˜g\in\textnormal{GL}_{k}italic_g âˆˆ GL start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT, the polynomial gâ‹…fâ‹…ğ‘”ğ‘“g\cdot fitalic_g â‹… italic_f is defined by (gâ‹…f)â¢(x)=fâ¢(gâˆ’1â¢x)â‹…ğ‘”ğ‘“ğ‘¥ğ‘“superscriptğ‘”1ğ‘¥(g\cdot f)(x)=f(g^{-1}x)( italic_g â‹… italic_f ) ( italic_x ) = italic_f ( italic_g start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_x ) for every xâˆˆâ„‚kğ‘¥superscriptâ„‚ğ‘˜x\in\mathbb{C}^{k}italic_x âˆˆ blackboard_C start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT. Similarly, for every format (Î´,d,k)ğ›¿ğ‘‘ğ‘˜(\delta,d,k)( italic_Î´ , italic_d , italic_k ) metapolynomial Î”Î”\Deltaroman_Î”, the metapolynomial gâ‹…Î”â‹…ğ‘”Î”g\cdot\Deltaitalic_g â‹… roman_Î” is defined by (gâ‹…Î”)â¢(f)=Î”â¢(gâˆ’1â‹…f)â‹…ğ‘”Î”ğ‘“Î”â‹…superscriptğ‘”1ğ‘“(g\cdot\Delta)(f)=\Delta(g^{-1}\cdot f)( italic_g â‹… roman_Î” ) ( italic_f ) = roman_Î” ( italic_g start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT â‹… italic_f ) for every homogeneous degree dğ‘‘ditalic_d polynomial fğ‘“fitalic_f. The details about this action are provided in Section 4. The vector space of metapolynomials of format (Î´,d,k)ğ›¿ğ‘‘ğ‘˜(\delta,d,k)( italic_Î´ , italic_d , italic_k ) is closed under this action of GLksubscriptGLğ‘˜\textnormal{GL}_{k}GL start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT, and it decomposes into a direct sum of subspaces which are also closed under the action of GLksubscriptGLğ‘˜\textnormal{GL}_{k}GL start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT: these subspaces are called isotypic components and they are in one to one correspondence with partitions Î»âŠ¢kÎ´d\lambda\mathchoice{\scalebox{1.2}[0.7]{ $\vdash$}_{k}\,}{\scalebox{1.2}[0.7]{ % $\vdash$}_{k}\,}{\scalebox{0.7}{\scalebox{1.2}[0.7]{$\vdash$}}_{k}\,}{% \scalebox{0.5}{\scalebox{1.2}[0.7]{$\vdash$}}_{k}\,}{\delta d}italic_Î» âŠ¢ start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT italic_Î´ italic_d. The summand corresponding to the partition Î»ğœ†\lambdaitalic_Î» is called the Î»ğœ†\lambdaitalic_Î»-isotypic component. This is called the isotypic decomposition. Each Î»ğœ†\lambdaitalic_Î»-isotypic component decomposes even further into a direct sum of subspaces with one summand for each semistandard tableau Tğ‘‡Titalic_T of shape Î»ğœ†\lambdaitalic_Î». We call the component for Tğ‘‡Titalic_T the Tğ‘‡Titalic_T-isotypic component. If Tğ‘‡Titalic_T is a superstandard tableau of shape Î»ğœ†\lambdaitalic_Î», then the corresponding Tğ‘‡Titalic_T-isotypic component is called the highest weight metapolynomial vector space of weight Î»ğœ†\lambdaitalic_Î». Equivalently, a highest weight vector of weight Î»ğœ†\lambdaitalic_Î» is a metapolynomial Î”Î”\Deltaroman_Î” with gâ‹…Î”=t1Î»1â¢â‹¯â¢tkÎ»kâ¢Î”â‹…ğ‘”Î”superscriptsubscriptğ‘¡1subscriptğœ†1â‹¯superscriptsubscriptğ‘¡ğ‘˜subscriptğœ†ğ‘˜Î”g\cdot\Delta=t_{1}^{\lambda_{1}}\cdots t_{k}^{\lambda_{k}}\Deltaitalic_g â‹… roman_Î” = italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Î» start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â‹¯ italic_t start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_Î» start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT end_POSTSUPERSCRIPT roman_Î”, for every gâˆˆGLkğ‘”subscriptGLğ‘˜g\in\textnormal{GL}_{k}italic_g âˆˆ GL start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT upper triangular with t1,â€¦,tksubscriptğ‘¡1â€¦subscriptğ‘¡ğ‘˜t_{1},\ldots,t_{k}italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_t start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT on the main diagonal. The Î»ğœ†\lambdaitalic_Î»-isotypic component is known to be the linear span of the union of the orbits of all its highest weight vectors. For example (not easily verifiable by hand, see Example 5.4), the space of metapolynomials of format (Î´,d,k)=(3,2,3)ğ›¿ğ‘‘ğ‘˜323(\delta,d,k)=(3,2,3)( italic_Î´ , italic_d , italic_k ) = ( 3 , 2 , 3 ) decomposes into three nonzero isotypic components, corresponding to partitions (6,0,0)600(6,0,0)( 6 , 0 , 0 ), (4,2,0)420(4,2,0)( 4 , 2 , 0 ) and (2,2,2)222(2,2,2)( 2 , 2 , 2 ) of Î´â‹…d=6â‹…ğ›¿ğ‘‘6\delta\cdot d=6italic_Î´ â‹… italic_d = 6. The isotypic component (4,2,0)420(4,2,0)( 4 , 2 , 0 ) further decomposes into three Tğ‘‡Titalic_T-isotypic components for the three semistandard tableaux of shape (4,2,0)420(4,2,0)( 4 , 2 , 0 ): \youngâ¢(1122,33)\young112233\young(1122,33)( 1122 , 33 ), \youngâ¢(1123,23)\young112323\young(1123,23)( 1123 , 23 ), \youngâ¢(1133,22)\young113322\young(1133,22)( 1133 , 22 ). The metapolynomial Î”=c2,0,0â¢c0,2,0â¢c0,0,2Î”subscriptğ‘200subscriptğ‘020subscriptğ‘002\Delta=c_{2,0,0}c_{0,2,0}c_{0,0,2}roman_Î” = italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT can be written according to this decomposition as 60â¢Î”60Î”\displaystyle 60\,\Delta60 roman_Î” =\displaystyle== 2â¢(c1,0,12â¢c0,2,0+2â¢c1,1,0â¢c1,0,1â¢c0,1,1+c2,0,0â¢c0,1,12+c1,1,02â¢c0,0,2+2â¢c2,0,0â¢c0,2,0â¢c0,0,2)2superscriptsubscriptğ‘1012subscriptğ‘0202subscriptğ‘110subscriptğ‘101subscriptğ‘011subscriptğ‘200superscriptsubscriptğ‘0112superscriptsubscriptğ‘1102subscriptğ‘0022subscriptğ‘200subscriptğ‘020subscriptğ‘002\displaystyle 2\big{(}c_{1,0,1}^{2}c_{0,2,0}+2c_{1,1,0}c_{1,0,1}c_{0,1,1}+c_{2% ,0,0}c_{0,1,1}^{2}+c_{1,1,0}^{2}c_{0,0,2}+2c_{2,0,0}c_{0,2,0}c_{0,0,2}\big{)}2 ( italic_c start_POSTSUBSCRIPT 1 , 0 , 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT + 2 italic_c start_POSTSUBSCRIPT 1 , 1 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 0 , 1 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 1 , 1 end_POSTSUBSCRIPT + italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 1 , 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + italic_c start_POSTSUBSCRIPT 1 , 1 , 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT + 2 italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT ) +\displaystyle++ [ 2(âˆ’c0,2,0c1,0,12âˆ’2c0,1,1c1,0,1c1,1,0+4c0,0,2c1,1,02âˆ’c0,1,12c2,0,0+8c0,0,2c0,2,0c2,0,0)\displaystyle\Big{[}\ 2\big{(}-c_{0,2,0}c_{1,0,1}^{2}-2c_{0,1,1}c_{1,0,1}c_{1,% 1,0}+4c_{0,0,2}c_{1,1,0}^{2}-c_{0,1,1}^{2}c_{2,0,0}+8c_{0,0,2}c_{0,2,0}c_{2,0,% 0}\big{)}[ 2 ( - italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 0 , 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - 2 italic_c start_POSTSUBSCRIPT 0 , 1 , 1 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 0 , 1 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 1 , 0 end_POSTSUBSCRIPT + 4 italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 1 , 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_c start_POSTSUBSCRIPT 0 , 1 , 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT + 8 italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT ) +\displaystyle++ 00\displaystyle\phantom{\Big{[}\ }0 +\displaystyle++ 5(c0,2,0c1,0,12âˆ’c0,1,1c1,0,1c1,1,0âˆ’c0,0,2c1,1,02+c0,1,12c2,0,0+4c0,0,2c0,2,0c2,0,0)]\displaystyle\phantom{\Big{[}\ }5\big{(}c_{0,2,0}c_{1,0,1}^{2}-c_{0,1,1}c_{1,0% ,1}c_{1,1,0}-c_{0,0,2}c_{1,1,0}^{2}+c_{0,1,1}^{2}c_{2,0,0}+4c_{0,0,2}c_{0,2,0}% c_{2,0,0}\big{)}\ \Big{]}5 ( italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 0 , 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_c start_POSTSUBSCRIPT 0 , 1 , 1 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 0 , 1 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 1 , 0 end_POSTSUBSCRIPT - italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 1 , 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + italic_c start_POSTSUBSCRIPT 0 , 1 , 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT + 4 italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT ) ] +\displaystyle++ 5â¢(âˆ’c1,0,12â¢c0,2,0+c1,1,0â¢c1,0,1â¢c0,1,1âˆ’c2,0,0â¢c0,1,12âˆ’c1,1,02â¢c0,0,2+4â¢c2,0,0â¢c0,2,0â¢c0,0,2),5superscriptsubscriptğ‘1012subscriptğ‘020subscriptğ‘110subscriptğ‘101subscriptğ‘011subscriptğ‘200superscriptsubscriptğ‘0112superscriptsubscriptğ‘1102subscriptğ‘0024subscriptğ‘200subscriptğ‘020subscriptğ‘002\displaystyle 5\big{(}-c_{1,0,1}^{2}c_{0,2,0}+c_{1,1,0}c_{1,0,1}c_{0,1,1}-c_{2% ,0,0}c_{0,1,1}^{2}-c_{1,1,0}^{2}c_{0,0,2}+4c_{2,0,0}c_{0,2,0}c_{0,0,2}\big{)},5 ( - italic_c start_POSTSUBSCRIPT 1 , 0 , 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT + italic_c start_POSTSUBSCRIPT 1 , 1 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 1 , 0 , 1 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 1 , 1 end_POSTSUBSCRIPT - italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 1 , 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_c start_POSTSUBSCRIPT 1 , 1 , 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT + 4 italic_c start_POSTSUBSCRIPT 2 , 0 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 2 , 0 end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT 0 , 0 , 2 end_POSTSUBSCRIPT ) , where the five summands from top to bottom are \youngâ¢(112233)\young112233\young(112233)( 112233 )-isotypic, \youngâ¢(1122,33)\young112233\young(1122,33)( 1122 , 33 )-isotypic, \youngâ¢(1123,23)\young112323\young(1123,23)( 1123 , 23 )-isotypic, \youngâ¢(1133,22)\young113322\young(1133,22)( 1133 , 22 )-isotypic, and \youngâ¢(11,22,33)\young112233\young(11,22,33)( 11 , 22 , 33 )-isotypic, respectively. The fifth summand is a highest weight vector, because \youngâ¢(11,22,33)\young112233\young(11,22,33)( 11 , 22 , 33 ) is superstandard. All summands have weight (2,2,2), because Î”Î”\Deltaroman_Î” has weight (2,2,2). Let â„‚â¢[x1,â€¦,xk]dâ„‚subscriptsubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜ğ‘‘\mathbb{C}[x_{1},\ldots,x_{k}]_{d}blackboard_C [ italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ] start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT denote the space of homogeneous degree dğ‘‘ditalic_d polynomials in the variables x1,â€¦,xksubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜x_{1},\ldots,x_{k}italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT. Let â„•â„•\mathbb{N}blackboard_N denote the set of natural numbers including zero. Theorem 1.1 (Main theorem). Let Î”:â„‚â¢[x1,â€¦,xk]dâ†’â„‚:Î”â†’â„‚subscriptsubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜ğ‘‘â„‚\Delta\colon\mathbb{C}[x_{1},\dots,x_{k}]_{d}\to\mathbb{C}roman_Î” : blackboard_C [ italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ] start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT â†’ blackboard_C be a metapolynomial of format (Î´,d,k)ğ›¿ğ‘‘ğ‘˜(\delta,d,k)( italic_Î´ , italic_d , italic_k ) computed by an algebraic circuit of size sğ‘ sitalic_s. Then 1. For every weight Î¼âˆˆâ„•kğœ‡superscriptâ„•ğ‘˜\mu\in\mathbb{N}^{k}italic_Î¼ âˆˆ blackboard_N start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT, |Î¼|=dâ¢Î´ğœ‡ğ‘‘ğ›¿|\mu|=d\delta| italic_Î¼ | = italic_d italic_Î´, the projection of Î”Î”\Deltaroman_Î” onto the weight space of weight Î¼ğœ‡\muitalic_Î¼ can be computed by a circuit of size Oâ¢(sâ¢(Î´â¢d)2â¢k3)ğ‘‚ğ‘ superscriptğ›¿ğ‘‘2superscriptğ‘˜3O(s(\delta d)^{2k^{3}})italic_O ( italic_s ( italic_Î´ italic_d ) start_POSTSUPERSCRIPT 2 italic_k start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). 2. For every partition Î»âŠ¢dâ¢Î´provesğœ†ğ‘‘ğ›¿\lambda\mathchoice{\scalebox{1.2}[0.7]{ $\vdash$}\,}{\scalebox{1.2}[0.7]{ $% \vdash$}\,}{\scalebox{0.7}{\scalebox{1.2}[0.7]{$\vdash$}}\,}{\scalebox{0.5}{% \scalebox{1.2}[0.7]{$\vdash$}}\,}d\deltaitalic_Î» âŠ¢ italic_d italic_Î´ the projection of Î”Î”\Deltaroman_Î” onto the Î»ğœ†\lambdaitalic_Î»-isotypic component can be computed by a circuit of size Oâ¢(sâ¢k2â¢k2â¢(Î´â¢d)2â¢k3)ğ‘‚ğ‘ superscriptğ‘˜2superscriptğ‘˜2superscriptğ›¿ğ‘‘2superscriptğ‘˜3O(sk^{2k^{2}}(\delta d)^{2k^{3}})italic_O ( italic_s italic_k start_POSTSUPERSCRIPT 2 italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ( italic_Î´ italic_d ) start_POSTSUPERSCRIPT 2 italic_k start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). 3. For every partition Î»âŠ¢dâ¢Î´provesğœ†ğ‘‘ğ›¿\lambda\mathchoice{\scalebox{1.2}[0.7]{ $\vdash$}\,}{\scalebox{1.2}[0.7]{ $% \vdash$}\,}{\scalebox{0.7}{\scalebox{1.2}[0.7]{$\vdash$}}\,}{\scalebox{0.5}{% \scalebox{1.2}[0.7]{$\vdash$}}\,}d\deltaitalic_Î» âŠ¢ italic_d italic_Î´ the projection of Î”Î”\Deltaroman_Î” onto the highest weight space of weight Î»ğœ†\lambdaitalic_Î» can be computed by a circuit of size Oâ¢(sâ¢(k+1)2â¢k2â¢(Î´â¢d)2â¢k3)ğ‘‚ğ‘ superscriptğ‘˜12superscriptğ‘˜2superscriptğ›¿ğ‘‘2superscriptğ‘˜3O(s(k+1)^{2k^{2}}(\delta d)^{2k^{3}})italic_O ( italic_s ( italic_k + 1 ) start_POSTSUPERSCRIPT 2 italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ( italic_Î´ italic_d ) start_POSTSUPERSCRIPT 2 italic_k start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). 4. For every semistandard tableau Tğ‘‡Titalic_T of shape Î»âŠ¢dâ¢Î´provesğœ†ğ‘‘ğ›¿\lambda\mathchoice{\scalebox{1.2}[0.7]{ $\vdash$}\,}{\scalebox{1.2}[0.7]{ $% \vdash$}\,}{\scalebox{0.7}{\scalebox{1.2}[0.7]{$\vdash$}}\,}{\scalebox{0.5}{% \scalebox{1.2}[0.7]{$\vdash$}}\,}d\deltaitalic_Î» âŠ¢ italic_d italic_Î´ the projection of Î”Î”\Deltaroman_Î” onto the Tğ‘‡Titalic_T-isotypic space can be computed by a circuit of size Oâ¢(sâ¢k2â¢k2â¢(Î´â¢d)2â¢k4)ğ‘‚ğ‘ superscriptğ‘˜2superscriptğ‘˜2superscriptğ›¿ğ‘‘2superscriptğ‘˜4O(sk^{2k^{2}}(\delta d)^{2k^{4}})italic_O ( italic_s italic_k start_POSTSUPERSCRIPT 2 italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ( italic_Î´ italic_d ) start_POSTSUPERSCRIPT 2 italic_k start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). Remark 1.2. In general, algebraic complexity classes are defined for possibly non-homogeneous polynomials. In this paper, we assume that polynomials and metapolynomials are homogeneous. However, one can lift the results to the nonhomogeneous setting as follows. A polynomial fâ¢(x1,â€¦,xk)ğ‘“subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜f(x_{1},\ldots,x_{k})italic_f ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ) is called homogeneous if all its monomials have the same degree. For dâ‰¥degâ¡(f)ğ‘‘degreeğ‘“d\geq\deg(f)italic_d â‰¥ roman_deg ( italic_f ), define the degree dğ‘‘ditalic_d homogenization fâ™¯â¢dâ¢(x0,x1,â€¦,xk):=x0dâ¢fâ¢(x1/x0,â€¦,xk/x0).assignsuperscriptğ‘“â™¯ğ‘‘subscriptğ‘¥0subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜superscriptsubscriptğ‘¥0ğ‘‘ğ‘“subscriptğ‘¥1subscriptğ‘¥0â€¦subscriptğ‘¥ğ‘˜subscriptğ‘¥0f^{\sharp d}(x_{0},x_{1},\ldots,x_{k}):=x_{0}^{d}f(x_{1}/x_{0},\ldots,x_{k}/x_% {0}).italic_f start_POSTSUPERSCRIPT â™¯ italic_d end_POSTSUPERSCRIPT ( italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ) := italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT italic_f ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT / italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT / italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ) . If fğ‘“fitalic_f has an algebraic circuit of size sğ‘ sitalic_s, then fâ™¯â¢dsuperscriptğ‘“â™¯ğ‘‘f^{\sharp d}italic_f start_POSTSUPERSCRIPT â™¯ italic_d end_POSTSUPERSCRIPT has an algebraic circuit of size at most Oâ¢(sâ¢d)ğ‘‚ğ‘ ğ‘‘O(sd)italic_O ( italic_s italic_d ): sâ¢(d+1)ğ‘ ğ‘‘1s(d+1)italic_s ( italic_d + 1 ) for extracting the homogeneous parts of fğ‘“fitalic_f via interpolation, dğ‘‘ditalic_d operations to compute all values x0,x02,â€¦,x0dsubscriptğ‘¥0superscriptsubscriptğ‘¥02â€¦superscriptsubscriptğ‘¥0ğ‘‘x_{0},x_{0}^{2},\ldots,x_{0}^{d}italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT, and another d+1ğ‘‘1d+1italic_d + 1 for multiplying the homogeneous components with the correct powers of x0subscriptğ‘¥0x_{0}italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT, and a final dğ‘‘ditalic_d for adding up the results. Given a metapolynomial Î”Î”\Deltaroman_Î” that does not involve x0subscriptğ‘¥0x_{0}italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT, define Î”â™¯â¢dsuperscriptÎ”â™¯ğ‘‘\Delta^{\sharp d}roman_Î” start_POSTSUPERSCRIPT â™¯ italic_d end_POSTSUPERSCRIPT by replacing every metavariable cğ’Šsubscriptğ‘ğ’Šc_{\bm{i}}italic_c start_POSTSUBSCRIPT bold_italic_i end_POSTSUBSCRIPT with cğ’Š+(dâˆ’|ğ’Š|,0,0,â€¦)subscriptğ‘ğ’Šğ‘‘ğ’Š00â€¦c_{\bm{i}+(d-|\bm{i}|,0,0,\ldots)}italic_c start_POSTSUBSCRIPT bold_italic_i + ( italic_d - | bold_italic_i | , 0 , 0 , â€¦ ) end_POSTSUBSCRIPT, and setting every metavariable cğ’Šsubscriptğ‘ğ’Šc_{\bm{i}}italic_c start_POSTSUBSCRIPT bold_italic_i end_POSTSUBSCRIPT with |ğ’Š|>dğ’Šğ‘‘|\bm{i}|>d| bold_italic_i | > italic_d to zero. Clearly we have Î”â™¯â¢dâ¢(fâ™¯â¢d)=Î”â¢(f)superscriptÎ”â™¯ğ‘‘superscriptğ‘“â™¯ğ‘‘Î”ğ‘“\Delta^{\sharp d}(f^{\sharp d})=\Delta(f)roman_Î” start_POSTSUPERSCRIPT â™¯ italic_d end_POSTSUPERSCRIPT ( italic_f start_POSTSUPERSCRIPT â™¯ italic_d end_POSTSUPERSCRIPT ) = roman_Î” ( italic_f ), provided that dâ‰¥degâ¡(f)ğ‘‘degreeğ‘“d\geq\deg(f)italic_d â‰¥ roman_deg ( italic_f ). Hence, in this paper we can always assume that fğ‘“fitalic_f is homogeneous. âˆ Organization of the paper In the first part of Section 2 we illustrate the motivations for studying the circuit complexity of the isotypic components and the highest weight vectors in the space of metapolynomials, in the context of algebraic complexity lower bounds and border complexity classes. In Section 2.5, based on Theorem 1.1 we prove that algebraic natural proofs can without loss of generality be assumed to be isotypic, see Theorem 2.4. Section 3 sketches the main ideas behind Theorem 1.1. In Section 4, we provide an introduction to Lie algebras, universal enveloping algebras, and their representation theory, on which the core of the proof is built. In Section 5.1, we explain the construction of the projection maps used in the proof of the main theorem; we describe the efficient circuit implementation in Section 5.2. In Appendix A, we prove the results of Section 2.5. In Appendix B, we show one part of the proof of the PoincarÃ©â€“Birkhoffâ€“Witt Theorem (Theorem 4.9); this proof is explicit and can be used to construct the projectors in Theorem 1.1."
https://arxiv.org/html/2411.04073v1,Rescheduling after vehicle failures in the multi-depot rural postman problem with rechargeable and reusable vehicles,"We present a centralized auction algorithm to solve the Multi-Depot Rural Postman Problem with Rechargeable and Reusable Vehicles (MD-RPP-RRV), focusing on rescheduling arc routing after vehicle failures. The problem involves finding a heuristically obtained best feasible routes for multiple rechargeable and reusable vehicles with capacity constraints capable of performing multiple trips from multiple depots, with the possibility of vehicle failures. Our algorithm auctions the failed trips to active (non-failed) vehicles through local auctioning, modifying initial routes to handle dynamic vehicle failures efficiently. When a failure occurs, the algorithm searches for the best active vehicle to perform the failed trip and inserts the trip into that vehicleâ€™s route, which avoids a complete rescheduling and reduces the computational effort. We compare the algorithmâ€™s solutions against offline optimal solutions obtained from solving a Mixed Integer Linear Programming (MILP) formulation using the Gurobi solver; this formulation assumes that perfect information about the vehicle failures and failure times are given. We derived a set of 257 failure scenarios from arc routing instances in the literature and used them to perform a competitive analysis. For each scenario we used a simulated annealing algorithm to generate an initial set of routes and then used the centralized auction algorithm to reschedule after each vehicle failure. The results demonstrate that the centralized auction algorithm produces solutions that are, in some cases, near-optimal; moreover the execution time for the proposed approach is much more consistent and is, for some instances, orders of magnitude less than the execution time of the Gurobi solver. The theoretical analysis provides an upper bound for the competitive ratio and computational complexity of our algorithm, offering a formal performance guarantee in dynamic failure scenarios.","Unmanned battery-operated rechargeable vehicles are becoming more prevalent in real-world applications due to their cost-effectiveness and efficiency [1, 2]. However, these systems still face significant challenges. The failure rate for drones is approximately 1 in 1,000 flight hours, two orders of magnitude higher than commercial aviationâ€™s 1 in 100,000 flight hours, and sophisticated Unmanned Aerial Vehicle (UAV) systems face an overall failure rate of 25% [3]. These failures can lead to significant delays and disruptions, underscoring the need for improved reliability in unmanned vehicle operations. Although many preventive maintenance approaches have been proposed to increase the reliability of unmanned vehicles [3, 4], any failure during a mission requires changing the mission plan to react to the loss of the vehicle. This paper, therefore, proposes an approach for effectively managing and mitigating the impact of vehicle failures on routing after they occur, specifically addressing the challenges of rerouting and task reallocation to ensure mission completion despite unexpected vehicle breakdowns. In the MD-RPP-RRV, the vehicles have limited capacity (operation time) but can be recharged and reused for multiple trips from multiple depots to traverse a subset of edges (required edges) in a weighted undirected connected graph, minimizing mission time. The maximum time taken by vehicles to traverse all required edges is referred to as mission time or maximum trip time. One of the key assumptions considered in our previous study [5] to solve the MD-RPP-RRV was that vehicles do not fail during their trips. In this study of the MD-RPP-RRV with vehicle failures, we relax that assumption and consider that multiple (but not all) vehicles might fail randomly during their trips. This study developed and evaluated a rescheduling approach that reacts to vehicle failures; it requires no information about the vehicle failures before the vehicles begin following their routes. Studying the MD-RPP-RRV with vehicle failures is crucial for addressing real-world challenges in applications like parcel delivery, infrastructure inspection, and surveillance, where unmanned vehicles may encounter failures during operation, necessitating the development of quick rerouting approaches for remaining active vehicles to ensure mission completion. The MD-RPP-RRV is NP-hard to solve [5] as it generalizes the RPP, which is proven to be NP-hard [6]. In its simplest case, with a single depot and single trip, the MD-RPP-RRV reduces to the RPP. Hence, solving the MD-RPP-RRV with vehicle failures poses significant computational challenges due to the additional complexities introduced by random vehicle failures. This paper proposes a centralized auction algorithm to address the MD-RPP-RRV with vehicle failures. We chose a centralized approach over decentralized methods due to its ability to maintain a global perspective, enabling quicker decision-making and more efficient task reallocation essential for handling multiple random vehicle failures dynamically. Our approach efficiently reassigns trips that a failed vehicle was supposed to complete (considered as tasks) to the remaining active vehicles (considered as agents) with the objective of minimizing the increase in mission time. To evaluate the performance of our proposed algorithm, we compared its solutions against offline optimal solutions obtained from solving the Mixed Integer Linear Programming (MILP) formulation using the Gurobi optimizer with vehicle failures known beforehand. We also empirically and theoretically analyzed the competitive ratio to assess the proposed algorithmâ€™s solution quality relative to the offline optimal solution. The main contributions of this paper are the following: 1. A centralized auction algorithm that reformulates the MD-RPP-RRV as a variant of the Generalized Assignment Problem (GAP) [25]. This approach efficiently handles dynamic vehicle failures by reassigning tasks without complete rerouting, reducing computational complexity. Our method addresses a gap in existing auction approaches [34] by applying them to dynamic failures in arc routing problems, specifically the MD-RPP-RRV, which has not been previously explored in this context. This algorithm extends centralized auction methods [36, 37] to handle more complex task allocation scenarios in the MD-RPP-RRV context in the following ways: (a) Assigning multiple failed trips (tasks) to a single vehicle (agent). (b) Dynamically reallocating trips from failed vehicles to active ones during the mission, thereby adapting to changes in the available vehicle fleet size due to failures. This approach addresses limitations in existing methods that typically assign only one task per agent or assume a fixed number of agents throughout the mission. 2. Experimental results that describe the quality of the solutions that the approach generates and the execution time required. 3. A theoretical upper bound for the competitive ratio of our proposed centralized auction algorithm to solve the MD-RPP-RRV with vehicle failures. This analysis provides a formal performance guarantee for our algorithm in dynamic failure scenarios. The remainder of this paper is organized as follows: Section 2 presents a literature review of related works. Section 3 provides the assumptions and presents a MILP formulation for the MD-RPP-RRV with known vehicle failures and failure times. Section 4 describes the proposed centralized auction algorithm. Section 5 presents our experimental results. It details the testing of our proposed algorithm on failure scenarios created from benchmark instances. It also compares the quality of the solutions with offline optimal solutions that were obtained by solving the MILP formulation using the Gurobi solver. Section 6 concludes the paper."
https://arxiv.org/html/2411.03813v1,On the satisfiability of random3333-SAT formulaswithkğ‘˜kitalic_k-wise independent clauses,"The problem of identifying the satisfiability threshold of random 3333-SAT formulas has received a lot of attention during the last decades and has inspired the study of other threshold phenomena in random combinatorial structures. The classical assumption in this line of research is that, for a given set of nğ‘›nitalic_n Boolean variables, each clause is drawn uniformly at random among all sets of three literals from these variables, independently from other clauses. Here, we keep the uniform distribution of each clause, but deviate significantly from the independence assumption and consider richer families of probability distributions. For integer parameters nğ‘›nitalic_n, mğ‘šmitalic_m, and kğ‘˜kitalic_k, we denote by â„±kâ¢(n,m)subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) the family of probability distributions that produce formulas with mğ‘šmitalic_m clauses, each selected uniformly at random from all sets of three literals from the nğ‘›nitalic_n variables, so that the clauses are kğ‘˜kitalic_k-wise independent. Our aim is to make general statements about the satisfiability or unsatisfiability of formulas produced by distributions in â„±kâ¢(n,m)subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) for different values of the parameters nğ‘›nitalic_n, mğ‘šmitalic_m, and kğ‘˜kitalic_k.Our technical results are as follows: First, all probability distributions in â„±2â¢(n,m)subscriptâ„±2ğ‘›ğ‘š\mathcal{F}_{2}(n,m)caligraphic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_n , italic_m ) with mâˆˆÎ©â¢(n3)ğ‘šÎ©superscriptğ‘›3m\in\Omega(n^{3})italic_m âˆˆ roman_Î© ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) return unsatisfiable formulas with high probability. This result is tight. We show that there exists a probability distribution ğ’Ÿâˆˆâ„±3â¢(n,m)ğ’Ÿsubscriptâ„±3ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{3}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n , italic_m ) with mâˆˆOâ¢(n3)ğ‘šğ‘‚superscriptğ‘›3m\in O(n^{3})italic_m âˆˆ italic_O ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) so that a random formula drawn from ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is almost always satisfiable. In contrast, for m=Î©â¢(n2)ğ‘šÎ©superscriptğ‘›2m=\Omega(n^{2})italic_m = roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ), any probability distribution ğ’Ÿâˆˆâ„±4â¢(n,m)ğ’Ÿsubscriptâ„±4ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{4}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n , italic_m ) returns an unsatisfiable formula with high probability. This is our most surprising and technically involved result. Finally, for any integer kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2, any probability distribution ğ’Ÿâˆˆâ„±kâ¢(n,m)ğ’Ÿsubscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) with m=Oâ¢(n1âˆ’1/k)ğ‘šğ‘‚superscriptğ‘›11ğ‘˜m=O(n^{1-1/k})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) returns a satisfiable formula with high probability.","Satisfiability of propositional formulas (SAT) is one of the most renowned problems in theoretical computer science. It appeared in the first lists of NP-complete problems independently proposed by Cook and Levin, and is pivotal for many developments in modern complexity theory. Today, many lower bounds on the running time of algorithms rely on the Exponential Time Hypothesis for solving SAT [11, 18, 36, 37]. On the practical side, SAT solvers are frequently deployed in hardware circuit design, model checking, program verification, automated planning and scheduling, as well as in solving real-life instantiations of combinatorial optimization problems such as FCC spectrum auctions. Modern SAT solvers often find solutions to large industrial instances with thousands or even millions of variables despite the NP-hardness of the problem. However, there is still a large discrepancy between the performance of SAT solvers on those instances and theoretical average-case predictions, which have been studied in great depth under the line of research on random SAT. Random SAT. A jğ‘—jitalic_j-CNF formula Ï•italic-Ï•\phiitalic_Ï• over nğ‘›nitalic_n variables is composed of mğ‘šmitalic_m OR-clauses, each containing exactly jğ‘—jitalic_j literals of jğ‘—jitalic_j different variables. In the most commonly studied random SAT model, a formula Ï•italic-Ï•\phiitalic_Ï• is generated uniformly at random from all possible jğ‘—jitalic_j-CNF formulas over nğ‘›nitalic_n variables and mğ‘šmitalic_m clauses. The most prominent theoretical question related to random SAT is to identify the satisfiability threshold rjsubscriptğ‘Ÿğ‘—r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT such that limnâ†’âˆğğ«â¡[Ï•â¢ is satisfiable]subscriptâ†’ğ‘›ğğ«italic-Ï• is satisfiable\lim_{n\to\infty}\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is % satisfiable}\right]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}% ]}{[\phi\text{ is satisfiable}]}roman_lim start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT bold_Pr [ italic_Ï• is satisfiable ] is equal to 00 when m/n>rjğ‘šğ‘›subscriptğ‘Ÿğ‘—m/n>r_{j}italic_m / italic_n > italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT, and equal to 1111 when m/n<rjğ‘šğ‘›subscriptğ‘Ÿğ‘—m/n<r_{j}italic_m / italic_n < italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT. It has been established [15] that 2222-SAT has r2=1subscriptğ‘Ÿ21r_{2}=1italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = 1, and its phase transition window [10] is mâˆˆ[nâˆ’Î˜â¢(n1/3),n+Î˜â¢(n1/3)]ğ‘šğ‘›Î˜superscriptğ‘›13ğ‘›Î˜superscriptğ‘›13m\in[n-\Theta(n^{1/3}),n+\Theta(n^{1/3})]italic_m âˆˆ [ italic_n - roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 1 / 3 end_POSTSUPERSCRIPT ) , italic_n + roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 1 / 3 end_POSTSUPERSCRIPT ) ]. For jâ‰¥3ğ‘—3j\geq 3italic_j â‰¥ 3, the asymptotic jğ‘—jitalic_j-SAT threshold was shown to be 2jâ¢logâ¡2âˆ’12â¢(1+logâ¡2)Â±ojâ¢(1)plus-or-minussuperscript2ğ‘—21212subscriptğ‘œğ‘—12^{j}\log 2-\frac{1}{2}(1+\log 2)\pm o_{j}(1)2 start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT roman_log 2 - divide start_ARG 1 end_ARG start_ARG 2 end_ARG ( 1 + roman_log 2 ) Â± italic_o start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( 1 ) as jâ†’âˆâ†’ğ‘—j\to\inftyitalic_j â†’ âˆ [17] (improving previous results from [3]), while for large enough jğ‘—jitalic_j the exact value of rjsubscriptğ‘Ÿğ‘—r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT was determined in [20]. However, the question of identifying rjsubscriptğ‘Ÿğ‘—r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT for small values of jğ‘—jitalic_j remains open. In particular, random 3333-SAT has attracted a lot of attention. For the lower bound part, it has been shown in a series of papers [15, 12, 32, 1, 35, 39] that r3â‰¥3.52subscriptğ‘Ÿ33.52r_{3}\geq 3.52italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT â‰¥ 3.52 (the currently best known bound is due to [35, 39]). The upper bound part is studied by [27, 38, 21, 19]; the currently best known bound is r3<4.49subscriptğ‘Ÿ34.49r_{3}<4.49italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT < 4.49 due to [19]. The estimate r3â‰ˆ4.26subscriptğ‘Ÿ34.26r_{3}\approx 4.26italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT â‰ˆ 4.26 was derived from numerical experiments [40] (see also [14, 41]). A more recent line of work [29, 30, 31, 42] extends the standard model of random jğ‘—jitalic_j-SAT to non-uniform distributions. Their motivation comes from the empirical observation that, in practice, CNF formulas often have rather different frequencies/probabilities for the nğ‘›nitalic_n variables to appear in each clause (following a power-law distribution instead of a uniform one). Namely, Friedrich and Rothenberger [31] proposed a non-uniform random model, where the literals {xi,xiÂ¯}iâˆˆ[n]subscriptsubscriptğ‘¥ğ‘–Â¯subscriptğ‘¥ğ‘–ğ‘–delimited-[]ğ‘›\{x_{i},\overline{x_{i}}\}_{i\in[n]}{ italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , overÂ¯ start_ARG italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG } start_POSTSUBSCRIPT italic_i âˆˆ [ italic_n ] end_POSTSUBSCRIPT are selected independently at random in each clause cğ‘citalic_c of the random jğ‘—jitalic_j-CNF with ğğ«â¡[xiâˆˆc]=ğğ«â¡[xiÂ¯âˆˆc]=piğğ«subscriptğ‘¥ğ‘–ğ‘ğğ«Â¯subscriptğ‘¥ğ‘–ğ‘subscriptğ‘ğ‘–\operatorname{\mathbf{Pr}}\mathchoice{\left[x_{i}\in c\right]}{[x_{i}\in c]}{[% x_{i}\in c]}{[x_{i}\in c]}=\operatorname{\mathbf{Pr}}\mathchoice{\left[% \overline{x_{i}}\in c\right]}{[\overline{x_{i}}\in c]}{[\overline{x_{i}}\in c]% }{[\overline{x_{i}}\in c]}=p_{i}bold_Pr [ italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âˆˆ italic_c ] = bold_Pr [ overÂ¯ start_ARG italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG âˆˆ italic_c ] = italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and where probabilities ğ©=(pi)iâˆˆ[n]ğ©subscriptsubscriptğ‘ğ‘–ğ‘–delimited-[]ğ‘›\mathbf{p}=(p_{i})_{i\in[n]}bold_p = ( italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_i âˆˆ [ italic_n ] end_POSTSUBSCRIPT may vary across different variables. They find satisfiability threshold r2â¢(ğ©)subscriptğ‘Ÿ2ğ©r_{2}(\mathbf{p})italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( bold_p ) of non-uniform random 2222-SAT for certain regimes depending on ğ©ğ©\mathbf{p}bold_p. However, the non-uniform model of [31] does not capture the community biases/correlations (i.e., the fact that certain variables are more likely to appear together in a clause), which are often observed in practice [6]. This leads us to the question of whether it is possible to relax the strong independence assumption in the existing random SAT literature. Relaxation of independence. We first observe that it does not make much sense to study distributions of SAT formulas with arbitrary correlations over the clauses. Indeed, by allowing correlation between several clauses, one may enforce that the random formula Ï•italic-Ï•\phiitalic_Ï• contains large fixed sub-formulas corresponding to NP-hard SAT variants. This would be at odds with our goal of studying average-case complexity. Therefore, we must keep a certain degree of independence in the distribution of instances. We propose to consider the relaxation of mutual independence over mğ‘šmitalic_m clauses in a random formula Ï•italic-Ï•\phiitalic_Ï• to kğ‘˜kitalic_k-wise independence for a small constant kğ‘˜kitalic_k. To keep the new model tractable, we focus on 3333-SAT and uniform distribution of literals within each clause. I.e., we assume that (i) every 3333-OR-clause cğ‘citalic_c of a random 3333-CNF formula Ï•italic-Ï•\phiitalic_Ï• has three literals of three distinct variables drawn uniformly at random among all such triplets of literals and that (ii) given this marginal distribution of each clause câˆ¼Funi.similar-toğ‘subscriptğ¹uni.c\sim F_{\text{uni.}}italic_c âˆ¼ italic_F start_POSTSUBSCRIPT uni. end_POSTSUBSCRIPT, the distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D over the clause set Cğ¶Citalic_C in Ï•italic-Ï•\phiitalic_Ï• is only kğ‘˜kitalic_k-wise independent instead of the mutually independent distribution ğ’ŸInd.=(Funi.)âŠ—msubscriptğ’ŸInd.superscriptsubscriptğ¹uni.tensor-productabsentğ‘š\mathcal{D}_{\text{Ind.}}=\left(F_{\text{uni.}}\right)^{\otimes m}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT = ( italic_F start_POSTSUBSCRIPT uni. end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT âŠ— italic_m end_POSTSUPERSCRIPT in the standard model. This is a natural generalization that has been considered in a number of different settings but, to the best of our knowledge, not in the context of random SAT. Note that the smaller kğ‘˜kitalic_k is, the bigger the set of possible distributions ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D. Furthermore, for small values of kğ‘˜kitalic_k, a kğ‘˜kitalic_k-wise independent distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D can still capture a large class of dependencies among clauses but at the same time does not allow correlation between any kğ‘˜kitalic_k-tuples of clauses. In mathematical terms, the family of discrete kğ‘˜kitalic_k-wise independent distributions naturally appears when we map the set of distributions to the set of their low-degree moments. Specifically, if a distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is supported on the nğ‘›nitalic_n-dimensional binary cube111Similar moment functions can be defined for any distribution with discrete marginals. suppâ¢(D)={âˆ’1,1}nsuppğ·superscript11ğ‘›\texttt{supp}(D)=\{-1,1\}^{n}supp ( italic_D ) = { - 1 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, then all its moments of degree up to kğ‘˜kitalic_k can be described as Î¼â¢(D)=(ğ„â¡[âˆiâˆˆSxi])|S|â‰¤kğœ‡ğ·subscriptğ„subscriptproductğ‘–ğ‘†subscriptğ‘¥ğ‘–ğ‘†ğ‘˜\mu(D)=(\operatorname{\mathbf{E}}\mathchoice{\left[\prod_{i\in S}x_{i}\right]}% {[\prod_{i\in S}x_{i}]}{[\prod_{i\in S}x_{i}]}{[\prod_{i\in S}x_{i}]})_{|S|% \leq k}italic_Î¼ ( italic_D ) = ( bold_E [ âˆ start_POSTSUBSCRIPT italic_i âˆˆ italic_S end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ] ) start_POSTSUBSCRIPT | italic_S | â‰¤ italic_k end_POSTSUBSCRIPT. As low-degree moments (basically, the image of Î¼ğœ‡\muitalic_Î¼) are extremely important in statistical analysis, it is equally important to study the kernel of the aforementioned mapping, which exactly corresponds to the family of kğ‘˜kitalic_k-wise independent distributions. Let us provide additional justifications of our framework by discussing some of the theoretical work on random 3333SAT and on other settings with similar kğ‘˜kitalic_k-wise independence relaxation. Pseudo-randomness. Historically, the kğ‘˜kitalic_k-wise relaxation of independence has been actively used in the literature on derandomization and pseudo-randomness, as it allows to significantly reduce the amount of random bits needed to generate random objects. For example, Alon and Nussboim [5] consider random ErdÅ‘s-RÃ©nyi graphs and examine the minimal degree kğ‘˜kitalic_k of independence needed to achieve a variety of graph properties and statistics (such as connectivity, existence of perfect matchings, existence of Hamiltonian cycles, clique and chromatic numbers, etc.) that match those in the mutually independent case. Benjamini et al. [9] consider similar questions for monotone boolean functions. The motivation in [5] comes from the fact that there are efficient constructions of kğ‘˜kitalic_k-wise independent distributions with â€œlow degree of independenceâ€ (say k=Oâ¢(logâ¡n)ğ‘˜ğ‘‚ğ‘›k=O(\log n)italic_k = italic_O ( roman_log italic_n )) that utilize only polylogâ¢(n)polylogğ‘›\text{polylog}(n)polylog ( italic_n ) random bits, i.e., much fewer than the polynomial number of random bits required to generate mutually independent distributions. While some of this motivation can be applied to our setting of random 3333-SAT, it is a conceptually different story. Indeed, the perspective of pseudo-random generation is through the lenses of â€œprobability theoryâ€, where one controls the distributions and can simply choose one that satisfies necessary conditions such as, e.g., (logâ¡n)ğ‘›(\log n)( roman_log italic_n )-wise independence. On the other hand, our motivation stems from â€œstatisticsâ€, as our ideal model should have a reasonable fit to empirical observations. So, we would like to use as minimal assumptions as possible and study small (constant) degrees of independence. Refutability of 3333-SAT. While the research on lower bounds for random 3333-SAT often comes up with certain simple heuristics that efficiently find a satisfying assignment (see, e.g., the surveys by Achlioptas [2] and Flaxman [26]), it is extremely hard to find an efficient refutation of a unsatisfiable 3333-SAT formula. Indeed, the common approach to refute a given SAT formula is proof in resolution. Chvatal and Szemeredi [16] first showed that a random 3333-CNF formula with m=Î˜â¢(n)ğ‘šÎ˜ğ‘›m=\Theta(n)italic_m = roman_Î˜ ( italic_n ) clauses (which is almost surely unsatisfiable) almost surely admits only exponential size proof in resolution. Later, Ben-Sasson and Wigderson [8] derived similar result for much larger m=Oâ¢(n3/2âˆ’Îµ)ğ‘šğ‘‚superscriptğ‘›32ğœ€m=O(n^{3/2-\varepsilon})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 - italic_Îµ end_POSTSUPERSCRIPT ). On the positive side, [28] gave the first polynomial time algorithm via spectral techniques that almost surely222Refutation in this case is an algorithm with one-sided error: it always refutes the formula correctly by producing certain certificates, or says that the formula might be correct. refutes a random 3333-SAT formula with m=n3/2+Îµğ‘šsuperscriptğ‘›32ğœ€m=n^{3/2+\varepsilon}italic_m = italic_n start_POSTSUPERSCRIPT 3 / 2 + italic_Îµ end_POSTSUPERSCRIPT clauses. The best known bound on mğ‘šmitalic_m is due to Feige and Ofek [25] who proved that, for a sufficiently large constant cğ‘citalic_c, random 3333-SAT formulas with m=câ‹…n3/2ğ‘šâ‹…ğ‘superscriptğ‘›32m=c\cdot n^{3/2}italic_m = italic_c â‹… italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT clauses can be almost surely refuted in polynomial time using another spectral graph algorithm. We note that a similar situation (extremely high probability of unsatisfiability for a random formula and inability to efficiently confirm it) is unlikely to happen in our kğ‘˜kitalic_k-clause independent model for constant kğ‘˜kitalic_k. Indeed, the main proof approach for dealing with arbitrary kğ‘˜kitalic_k-wise independent distribution is to define a kğ‘˜kitalic_k-wise statistic, which differentiates any satisfiable formula from a typical unsatisfiable one. Testing kğ‘˜kitalic_k-wise independence. The property of kğ‘˜kitalic_k-wise independence of a distribution with nğ‘›nitalic_n components can be tested using nOâ¢(k)=pâ¢oâ¢lâ¢yâ¢(n)superscriptğ‘›ğ‘‚ğ‘˜ğ‘ğ‘œğ‘™ğ‘¦ğ‘›n^{O(k)}=poly(n)italic_n start_POSTSUPERSCRIPT italic_O ( italic_k ) end_POSTSUPERSCRIPT = italic_p italic_o italic_l italic_y ( italic_n ) many samples in polynomial time, when kğ‘˜kitalic_k is a constant [4, 43]. This is a useful property to have, as it allows one to verify with only polynomially many instances of random 3333-SAT, whether these instances conform to kğ‘˜kitalic_k-wise independence or not. Robust mechanism design. A recent line of work in robust mechanism design also considers families of kğ‘˜kitalic_k-wise independent Bayesian priors in single and multi-unit auctions [13, 22, 33, 34]. Their motivation is similar to ours, as they also rely on the statistical point of view to justify the extension of the results for mutual independent priors typically assumed in Bayesian mechanism design to kğ‘˜kitalic_k-wise independent ones. 1.1 Problem formulation We consider random 3333-CNF formulas with nğ‘›nitalic_n variables generated from a distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D over mğ‘šmitalic_m clauses, where the mutual independence assumption over clauses is relaxed to kğ‘˜kitalic_k-wise independence. We use the term kğ‘˜kitalic_k-clause independence to refer to such distributions. We denote such families of distributions by â„±kâ¢(n,m)subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ), where each ğ’Ÿâˆˆâ„±kâ¢(n,m)ğ’Ÿsubscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) has identical marginals uniformly distributed over all possible OR-clauses and those marginals are only assumed to be kğ‘˜kitalic_k-wise independent in ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D. We would like to understand the following question for small values of kğ‘˜kitalic_k: How does the satisfiability threshold r3subscriptğ‘Ÿ3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT of random 3333-SAT formulas behave under any kğ‘˜kitalic_k-clause independent distribution ğ’Ÿâˆˆâ„±kâ¢(n,m)ğ’Ÿsubscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m )? As the distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is not unique, there might be a large gap between lower and upper estimates of r3subscriptğ‘Ÿ3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT. To this end, we formally define the lower satisfiability threshold LSTkâ¢(n)subscriptLSTğ‘˜ğ‘›\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) as an upper bound on mğ‘šmitalic_m, such that a random formula Ï•italic-Ï•\phiitalic_Ï• drawn from a distribution in â„±kâ¢(n,m)subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) with mâ‰¤LSTkâ¢(n)ğ‘šsubscriptLSTğ‘˜ğ‘›m\leq\texttt{LST}_{k}(n)italic_m â‰¤ LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) clauses has ğğ«â¡[Ï•â¢ is satisfiable]â‰¥23ğğ«italic-Ï• is satisfiable23\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\geq\frac{2}{3}bold_Pr [ italic_Ï• is satisfiable ] â‰¥ divide start_ARG 2 end_ARG start_ARG 3 end_ARG. Similarly, the upper satisfiability threshold USTkâ¢(n)subscriptUSTğ‘˜ğ‘›\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) is a lower bound on mğ‘šmitalic_m, such that the random formula Ï•italic-Ï•\phiitalic_Ï• with mâ‰¥USTkâ¢(n)ğ‘šsubscriptUSTğ‘˜ğ‘›m\geq\texttt{UST}_{k}(n)italic_m â‰¥ UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) clauses has ğğ«â¡[Ï•â¢ is satisfiable]â‰¤13ğğ«italic-Ï• is satisfiable13\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\leq\frac{1}{3}bold_Pr [ italic_Ï• is satisfiable ] â‰¤ divide start_ARG 1 end_ARG start_ARG 3 end_ARG. What kind of bounds on upper USTkâ¢(n)subscriptUSTğ‘˜ğ‘›\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) and lower LSTkâ¢(n)subscriptLSTğ‘˜ğ‘›\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) thresholds should we expect? Reasonable expectations. The condition ğ’Ÿâˆˆâ„±kâ¢(n,m)ğ’Ÿsubscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) only says something about configurations of at most kğ‘˜kitalic_k clauses and does not put any other restrictions on the random formula Ï•âˆ¼ğ’Ÿsimilar-toitalic-Ï•ğ’Ÿ\phi\sim\mathcal{D}italic_Ï• âˆ¼ caligraphic_D. As the degree of independence kğ‘˜kitalic_k is a small constant, any argument that gives bounds on LSTksubscriptLSTğ‘˜\texttt{LST}_{k}LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT or USTksubscriptUSTğ‘˜\texttt{UST}_{k}UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT can only rely on statistics of at most a constant number of clauses. Hence, it is rather likely that bounds on LSTksubscriptLSTğ‘˜\texttt{LST}_{k}LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT and USTksubscriptUSTğ‘˜\texttt{UST}_{k}UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT come together with efficient procedures of, respectively, finding a satisfying assignment for a random formula Ï•italic-Ï•\phiitalic_Ï•, or certifying that Ï•italic-Ï•\phiitalic_Ï• is not satisfiable. Hence, given the prior work on random 3333-SAT for ğ’ŸInd.âˆˆâ„±kâ¢(n,m)subscriptğ’ŸInd.subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}_{\text{Ind.}}\in\mathcal{F}_{k}(n,m)caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ), we get the following picture: Upper satisfiability threshold. The best known result for refuting 3333-CNF formulas efficiently is due to Feige and Ofek [25], who show how to do it only for a fairly large number of clauses m=câ‹…n3/2ğ‘šâ‹…ğ‘superscriptğ‘›32m=c\cdot n^{3/2}italic_m = italic_c â‹… italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT. Furthermore, for any smaller number of clauses m=Oâ¢(n3/2âˆ’Îµ)ğ‘šğ‘‚superscriptğ‘›32ğœ€m=O(n^{3/2-\varepsilon})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 - italic_Îµ end_POSTSUPERSCRIPT ), a random 3333-CNF formula is likely to have only exponential in nğ‘›nitalic_n proof size for any unsatisfiability proof in resolution [8]. Hence, it is out of reach to aim for a better bound on USTkâ¢(n)subscriptUSTğ‘˜ğ‘›\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) than Oâ¢(n3/2)ğ‘‚superscriptğ‘›32O(n^{3/2})italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT ) while relying only on kğ‘˜kitalic_k-wise independence for some constant kğ‘˜kitalic_k. In fact, the best known positive result on efficiently computable proofs of unsatisfiability in resolution is due to Beame et al. [7], who show that an ordered DLL algorithm executed on a random 3333-SAT instance with m=Î©â¢(n2/logâ¡n)ğ‘šÎ©superscriptğ‘›2ğ‘›m=\Omega(n^{2}/\log n)italic_m = roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / roman_log italic_n ) clauses terminates in polynomial time. Lower satisfiability threshold. As the proofs for the lower bounds on r3subscriptğ‘Ÿ3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT often establish simple procedures that find satisfying assignments with high probability, it is still possible that LSTkâ¢(n)subscriptLSTğ‘˜ğ‘›\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) is of similar order Î˜â¢(n)Î˜ğ‘›\Theta(n)roman_Î˜ ( italic_n ) as the lower bounds on r3subscriptğ‘Ÿ3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT for ğ’ŸInd.subscriptğ’ŸInd.\mathcal{D}_{\text{Ind.}}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT. Thus, the most ambitious result would be to show that LSTkâ¢(n)â‰¤ckâ‹…nsubscriptLSTğ‘˜ğ‘›â‹…subscriptğ‘ğ‘˜ğ‘›\texttt{LST}_{k}(n)\leq c_{k}\cdot nLST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) â‰¤ italic_c start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT â‹… italic_n for constant cksubscriptğ‘ğ‘˜c_{k}italic_c start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT that increases with kğ‘˜kitalic_k. A more modest goal is to aim for LSTkâ¢(n)=oâ¢(n)subscriptLSTğ‘˜ğ‘›ğ‘œğ‘›\texttt{LST}_{k}(n)=o(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_o ( italic_n ) for a constant kğ‘˜kitalic_k, where LSTkâ¢(n)â†’Î˜â¢(n)â†’subscriptLSTğ‘˜ğ‘›Î˜ğ‘›\texttt{LST}_{k}(n)\to\Theta(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) â†’ roman_Î˜ ( italic_n ) as kâ†’+âˆâ†’ğ‘˜k\to+\inftyitalic_k â†’ + âˆ. 1.2 Our results We obtain the following bounds on the lower and upper satisfiability thresholds LSTkâ¢(n)subscriptLSTğ‘˜ğ‘›\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) and USTkâ¢(n)subscriptUSTğ‘˜ğ‘›\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) for various values of kğ‘˜kitalic_k. Lower satisfiability thresholds. We show (in Theorem 6.1) that LSTkâ¢(n)â‰¥Î©â¢(n1âˆ’1/k)subscriptLSTğ‘˜ğ‘›Î©superscriptğ‘›11ğ‘˜\texttt{LST}_{k}(n)\geq\Omega(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) â‰¥ roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) for any kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2. I.e., any kğ‘˜kitalic_k-clause independent random formula is satisfiable with high probability if it contains at most Oâ¢(n1âˆ’1/k)ğ‘‚superscriptğ‘›11ğ‘˜O(n^{1-1/k})italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) clauses. The argument is simple: for any kğ‘˜kitalic_k-clause independent distribution, we look at the 3333-uniform hypergraph that corresponds to the variables of a random formula Ï•italic-Ï•\phiitalic_Ï• produced according to this distribution, and argue that this graph does not have Berge-cycles, with high probability. We also provide an informal justification that this bound is asymptotically tight, i.e., that LSTkâ¢(n)=Oâ¢(n1âˆ’1/k)subscriptLSTğ‘˜ğ‘›ğ‘‚superscriptğ‘›11ğ‘˜\texttt{LST}_{k}(n)=O(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ). Specifically, we outline a plausible approach for constructing a kğ‘˜kitalic_k-clause independent distribution with m=Oâ¢(n1âˆ’1/k)ğ‘šğ‘‚superscriptğ‘›11ğ‘˜m=O(n^{1-1/k})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) clauses such that most of its formulas are unsatisfiable. Our approach is built upon existing constructions of dense hyper-graphs with large girth. It is interesting to note that, in both the proof of the LSTkâ¢(n)=Î©â¢(n1âˆ’1/k)subscriptLSTğ‘˜ğ‘›Î©superscriptğ‘›11ğ‘˜\texttt{LST}_{k}(n)=\Omega(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) result and the approach for showing that LSTkâ¢(n)=Oâ¢(n1âˆ’1/k)subscriptLSTğ‘˜ğ‘›ğ‘‚superscriptğ‘›11ğ‘˜\texttt{LST}_{k}(n)=O(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ), we only need to consider variables and can completely ignore the distribution over the literals. Upper satisfiability thresholds. We first consider small degrees of independence, i.e., kâˆˆ{2,3}ğ‘˜23k\in\{2,3\}italic_k âˆˆ { 2 , 3 }. In both cases, we show that USTkâ¢(n)=Î˜â¢(n3)subscriptUSTğ‘˜ğ‘›Î˜superscriptğ‘›3\texttt{UST}_{k}(n)=\Theta(n^{3})UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ), meaning that one needs almost all possible clauses in a 3333-clause (as well as 2222-clause) independent formula to ensure that it is unsatisfiable (see Theorem 3.1 and Theorem 4.1). The most nontrivial part is to construct the distribution ğ’Ÿâˆˆâ„±3â¢(n,m)ğ’Ÿsubscriptâ„±3ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{3}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n , italic_m ) with m=Î˜â¢(n3)ğ‘šÎ˜superscriptğ‘›3m=\Theta(n^{3})italic_m = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) and ğğ«â¡[Ï•â¢ is satisfiable]â‰¥23ğğ«italic-Ï• is satisfiable23\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\geq\frac{2}{3}bold_Pr [ italic_Ï• is satisfiable ] â‰¥ divide start_ARG 2 end_ARG start_ARG 3 end_ARG. Our construction is based on â€œ3333-XOR formulasâ€ (i.e., OR-clauses that have either one or three literals that are satisfied by a randomly planted truth assignment), which aligns well with the intuition developed in previous work [24, 25]. The main technical difficulty is to ensure kğ‘˜kitalic_k-clause independence by adding a small fraction of unsatisfiable instances and checking all 3333-wise statistics. Our most exciting and technically involved result (see Theorem 5.1) is our proof that UST4â¢(n)=Oâ¢(n2)subscriptUST4ğ‘›ğ‘‚superscriptğ‘›2\texttt{UST}_{4}(n)=O(n^{2})UST start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ), i.e., a random formula Ï•âˆ¼ğ’Ÿsimilar-toitalic-Ï•ğ’Ÿ\phi\sim\mathcal{D}italic_Ï• âˆ¼ caligraphic_D with m=Oâ¢(n2)ğ‘šğ‘‚superscriptğ‘›2m=O(n^{2})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) clauses is unsatisfiable with large probability for any 4444-clause independent distribution ğ’Ÿâˆˆâ„±4â¢(n,m)ğ’Ÿsubscriptâ„±4ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{4}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n , italic_m ). It is worth noting that such a bound is much harder to get under the 4444-wise independence assumption than in the case of a mutually independent distribution ğ’ŸInd.subscriptğ’ŸInd.\mathcal{D}_{\text{Ind.}}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT. Indeed, Feige and Ofek [25] describe a very simple refutation algorithm for m=Î˜â¢(n2)ğ‘šÎ˜superscriptğ‘›2m=\Theta(n^{2})italic_m = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) that fixes a variable xğ‘¥xitalic_x and considers all clauses containing xğ‘¥xitalic_x or xÂ¯Â¯ğ‘¥\overline{x}overÂ¯ start_ARG italic_x end_ARG (there will be Î˜â¢(n)Î˜ğ‘›\Theta(n)roman_Î˜ ( italic_n ) such clauses in expectation). Then, after deleting xğ‘¥xitalic_x (or xÂ¯Â¯ğ‘¥\overline{x}overÂ¯ start_ARG italic_x end_ARG), one can reduce the problem to the refutation of the respective random 2222-CNF sub-instance, which can be easily verified in polynomial time and has a low satisfiability threshold of r2=1subscriptğ‘Ÿ21r_{2}=1italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = 1. This simple approach obviously fails for 4444-clause independent distributions. We instead construct a bipartite multigraph Gâ¢(Ï•)ğºitalic-Ï•G(\phi)italic_G ( italic_Ï• ) between pairs of distinct literals on one side and all singleton literals on the other, in which every OR-clause in Ï•italic-Ï•\phiitalic_Ï• corresponds to three different edges. We then carefully examine the statistic Îºâ¢(Ï•)ğœ…italic-Ï•\kappa(\phi)italic_Îº ( italic_Ï• ) that counts K2,2subscriptğ¾22K_{2,2}italic_K start_POSTSUBSCRIPT 2 , 2 end_POSTSUBSCRIPT subgraphs in Gâ¢(Ï•)ğºitalic-Ï•G(\phi)italic_G ( italic_Ï• ) for a random Ï•âˆ¼ğ’Ÿsimilar-toitalic-Ï•ğ’Ÿ\phi\sim\mathcal{D}italic_Ï• âˆ¼ caligraphic_D. We find that the expected value of Îºâ¢(Ï•)ğœ…italic-Ï•\kappa(\phi)italic_Îº ( italic_Ï• ) for random Ï•italic-Ï•\phiitalic_Ï• is only slightly larger than its absolute minimal value, while at the same time Îºâ¢(Ï•)ğœ…italic-Ï•\kappa(\phi)italic_Îº ( italic_Ï• ) is significantly larger than its expectation when Ï•italic-Ï•\phiitalic_Ï• is satisfiable. Our argument bears certain similarities with the argument in [25], which also looked at intersections of two literals between pairs of clauses but used the 3333-XOR principle and a differently constructed non-bipartite graph. 1.3 Roadmap The rest of the paper is structured as follows. We begin with preliminary definitions and notation in Section 2. Then, we warm up with our tight bounds on the upper satisfiability threshold UST2â¢(n)subscriptUST2ğ‘›\texttt{UST}_{2}(n)UST start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_n ) in Section 3. Our lower bound on UST3â¢(n)subscriptUST3ğ‘›\texttt{UST}_{3}(n)UST start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n ) is proved in Section 4 while our upper bound on UST4â¢(n)subscriptUST4ğ‘›\texttt{UST}_{4}(n)UST start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n ) follows in Section 5. Section 6 is devoted to the study of the lower satisfiability threshold."
https://arxiv.org/html/2411.02936v1,Deriving Nonuniform Lower Bounds from Uniform Nondeterministic Lower Bounds,"Proving complexity lower bounds remains a challenging task: currently, we only know how to prove conditional uniform (algorithm) lower bounds and nonuniform (circuit) lower bounds in restricted circuit models. About a decade ago, Williams (STOC 2010) showed how to derive nonuniform lower bounds from uniform upper bounds: roughly, by designing a fast algorithm for checking satisfiability of circuits, one gets a lower bound for this circuit class. Since then, a number of results of this kind have been proved. For example, Jahanjou et al. (ICALP 2015) and Carmosino et al. (ITCS 2016) proved that if \NSETH fails, then \E\NPsuperscript\E\NP\E^{\NP}start_POSTSUPERSCRIPT end_POSTSUPERSCRIPT has circuit size Ï‰â¢(n)ğœ”ğ‘›\omega(n)italic_Ï‰ ( italic_n ). Just recently, it was shown how uniform lower bounds can be used to derive nonuniform lower bounds: Belova et al. (SODA 2024) showed that if for every Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, \MAX-3-\SAT cannot be solved in co-nondeterministic time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ), then, for any Î´>0ğ›¿0\delta>0italic_Î´ > 0, there exists an explicit polynomial family of arithmetic circuit size Î©â¢(nÎ´)Î©superscriptğ‘›ğ›¿\Omega(n^{\delta})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT ); Williams (FOCS 2024) showed that if \NSETH is true, then Boolean Inner Product on nğ‘›nitalic_n-bit vectors cannot be computed by \ETHRâˆ˜\ETHR\ETHR\ETHR\ETHR{}\circ\ETHR{}âˆ˜ circuits of size 2Îµâ¢nsuperscript2ğœ€ğ‘›2^{\varepsilon n}2 start_POSTSUPERSCRIPT italic_Îµ italic_n end_POSTSUPERSCRIPT, for some Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0. In this paper, we continue developing this line of research and show that nondeterministic uniform lower bounds imply nonuniform lower bounds for various types of objects that are notoriously hard to analyze: circuits, matrix rigidity, and tensor rank. Specifically, we prove the following three results.If \NSETH is true, then there exists a monotone Boolean function family in \co\NP of monotone circuit size 2Î©â¢(n/logâ¡n)superscript2Î©ğ‘›ğ‘›2^{\Omega(n/\log n)}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n / roman_log italic_n ) end_POSTSUPERSCRIPT. Combining this with the result above, we get win-win circuit lower bounds: either \E\NPsuperscript\E\NP\E^{\NP{}}start_POSTSUPERSCRIPT end_POSTSUPERSCRIPT requires circuits of size wâ¢(n)ğ‘¤ğ‘›w(n)italic_w ( italic_n ) or \coNP\coNP\coNP requires monotone circuits of size 2Î©â¢(n/logâ¡n)superscript2Î©ğ‘›ğ‘›2^{\Omega(n/\log n)}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n / roman_log italic_n ) end_POSTSUPERSCRIPT.If \MAX-3-\SAT cannot be solved in co-nondeterministic time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ), for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, then for all Î´>0ğ›¿0\delta>0italic_Î´ > 0 and infinitely many kğ‘˜kitalic_k, there is an explicit 2logOâ¢(1)â¡ksuperscript2superscriptğ‘‚1ğ‘˜2^{\log^{O(1)}k}2 start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT family of kÃ—kğ‘˜ğ‘˜k\times kitalic_k Ã— italic_k matrices, containing at least one matrix of k1/2âˆ’Î´superscriptğ‘˜12ğ›¿k^{1/2-\delta}italic_k start_POSTSUPERSCRIPT 1 / 2 - italic_Î´ end_POSTSUPERSCRIPT rigidity k2âˆ’Î´superscriptğ‘˜2ğ›¿k^{2-\delta}italic_k start_POSTSUPERSCRIPT 2 - italic_Î´ end_POSTSUPERSCRIPT.If \MAX-3-\SAT cannot be solved in co-nondeterministic time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ), for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, then, for all Î´>0ğ›¿0\delta>0italic_Î´ > 0, some Î”>0Î”0\Delta>0roman_Î” > 0, and infinitely many kğ‘˜kitalic_k, there are two explicit 2logOâ¢(1)â¡ksuperscript2superscriptğ‘‚1ğ‘˜2^{\log^{O(1)}k}2 start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT families of kÃ—kğ‘˜ğ‘˜k\times kitalic_k Ã— italic_k matrices and kÃ—kÃ—kğ‘˜ğ‘˜ğ‘˜k\times k\times kitalic_k Ã— italic_k Ã— italic_k tensors such that either some matrix has k1âˆ’Î´superscriptğ‘˜1ğ›¿k^{1-\delta}italic_k start_POSTSUPERSCRIPT 1 - italic_Î´ end_POSTSUPERSCRIPT rigidity k2âˆ’Î´superscriptğ‘˜2ğ›¿k^{2-\delta}italic_k start_POSTSUPERSCRIPT 2 - italic_Î´ end_POSTSUPERSCRIPT or some tensor has rank k1+Î”superscriptğ‘˜1Î”k^{1+\Delta}italic_k start_POSTSUPERSCRIPT 1 + roman_Î” end_POSTSUPERSCRIPT.","1 Complexity Lower Bounds Finding the minimum time required to solve a given computational problem is a central question in computational complexity. Answering such a question for a particular problem involves proving a complexity lower bound, that is, showing that no fast algorithm can solve this problem. While the Time Hierarchy Theorem [HS65, HS66] guarantees that there are problems in Â¶ that cannot be solved in time Oâ¢(nk)ğ‘‚superscriptğ‘›ğ‘˜O(n^{k})italic_O ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ), for any k>1ğ‘˜1k>1italic_k > 1, we have no superlinear lower bounds for specific problems. For example, for \SAT, one of the most important \NP-complete problems, we have no algorithms working significantly faster than a brute force approach and at the same time have no methods of excluding a possibility that it can be solved in linear time. 1.1 Conditional Lower Bounds As unconditional complexity lower bounds remain elusive, the classical complexity theory allows one to prove conditional lower bounds of the following form: if a problem Ağ´Aitalic_A cannot be solved in polynomial time, then BğµBitalic_B cannot be solved in polynomial time too. Such results are proved via reductions that are essentially algorithms: one shows how to transform an instance of Ağ´Aitalic_A into an instance of BğµBitalic_B. Nowadays, hundreds of such reductions between various \NP-hard problems are known. For instance, if \SAT cannot be solved in polynomial time, then the Hamiltonian Cycle problem also cannot be solved in polynomial time. In a recently emerged area of fine-grained complexity, one aims to construct tighter reductions between problems showing that even a tiny improvement of an algorithm for one of them automatically leads to improved algorithms for the other one. For example, as proved by Williams [Wil05], if \SAT cannot be solved in time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ), for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, then the Orthogonal Vectors problem cannot be solved in time Oâ¢(n2âˆ’Îµ)ğ‘‚superscriptğ‘›2ğœ€O(n^{2-\varepsilon})italic_O ( italic_n start_POSTSUPERSCRIPT 2 - italic_Îµ end_POSTSUPERSCRIPT ), for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0. Again, many reductions of this form have been developed in recent years. We refer the reader to a recent survey by Vassilevska Williams [Vas18]. 1.2 Circuit Lower Bounds One of the reasons why proving complexity lower bounds is challenging is that an algorithm (viewed as a Turing machine or a RAM machine) is a relatively complex object: it has a memory, may contain loops, function calls (that may in turn be recursive). A related computational model of Boolean circuits has a much simpler structure (a straight-line program) and the same time is powerful enough to model algorithms: if a problem can be solved by algorithms in time Tâ¢(n)ğ‘‡ğ‘›T(n)italic_T ( italic_n ), then it can also be solved by circuits in time Oâ¢(Tâ¢(n)â¢logâ¡Tâ¢(n))ğ‘‚ğ‘‡ğ‘›ğ‘‡ğ‘›O(T(n)\log T(n))italic_O ( italic_T ( italic_n ) roman_log italic_T ( italic_n ) ) [PF79]. It turns out that proving circuit lower bounds is also challenging: while it is not difficult to show that almost all Boolean functions can be computed by circuits of exponential size only (this was proved by Shannon [Sha49] back in 1949), for no function from \NP, we can currently exclude a possibility that it can be computed by circuits of linear size [LY22, FGHK16]. Strong lower bounds are only known for restricted models such as monotone circuits, constant-depth circuits, and formulas. Various such unconditional lower bounds can be found in the book by Jukna [Juk12]. An important difference between algorithms and circuits is that algorithms is a uniform model of computation (an algorithm is a program that needs to process instances of all possible lengths), whereas circuits are nonuniform: when saying that a problem can be solved by circuits, one usually means that there is an infinite collection of circuits, one circuit for every possible input length, and different circuits in this collection can, in principle, implement different programs. This makes the circuit model strictly more powerful than algorithms: on the one hand, every problem solved by algorithms can be solved by circuits of roughly the same size; on the other hand, it is not difficult to come up with a problem of small circuit size that cannot be solved by algorithms. 1.3 Connections Between Lower and Upper Bounds Intuitively, it seems that proving complexity upper bounds should be easier than proving lower bounds. This intuition is well supported by a much higher number of results on algorithms compared to the number of results on lower bounds. Indeed, to prove an upper bound on the complexity of a problem, one designs an algorithm for the problem and analyzes it. Whereas to prove a complexity lower bound, one needs to reason about a wide range of fast algorithms (or small circuits) and to argue that none of them is able to solve the problem at hand. Perhaps surprisingly, the tasks of proving lower and upper complexity bounds are connected to each other. A classical example is Karpâ€“Lipton theorem [KL80] stating that if Â¶ = \NP, then \EXP requires circuits of size Î©â¢(2n/n)Î©superscript2ğ‘›ğ‘›\Omega(2^{n}/n)roman_Î© ( 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT / italic_n ). More recently, Williams [Wil13] established a deep connection between upper bound for Circuit Sat and circuit lower bounds. Extending his results, Jahanjou, Miles and Viola [JMV18] proved that if \NSETH is false (meaning that \UNSAT can be solved fast with nondeterminism), then \E\NP\E{}^{\NP{}}start_FLOATSUPERSCRIPT end_FLOATSUPERSCRIPT requires series-parallel Boolean circuits of size Ï‰â¢(n)ğœ”ğ‘›\omega(n)italic_Ï‰ ( italic_n ). Such results show how to derive nonuniform lower bounds (that is, circuit lower bounds) from uniform upper bounds (algorithm upper bounds). Even though one can simulate an algorithm using circuits with slight overhead, the converse is not true as there are undecidable languages of low circuit complexity. Until recently, it was unknown how one can get nonuniform lower bounds from uniform lower bounds. In 2024, [BKM+24] proved that if \MAX-kğ‘˜kitalic_k-\SAT cannot be solved in co-nondeterministic time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ) for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, then for any Î´>0ğ›¿0\delta>0italic_Î´ > 0, there exists an explicit polynomial family that cannot be computed by arithmetic circuits of size Oâ¢(nÎ´)ğ‘‚superscriptğ‘›ğ›¿O(n^{\delta})italic_O ( italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT ). Also, Williams [Wil24] proved that if \NSETH holds, then Boolean Inner Product on nğ‘›nitalic_n-bit vectors cannot be computed by \ETHRâˆ˜\ETHR\ETHR\ETHR\ETHR{}\circ\ETHR{}âˆ˜ circuits of size 2Îµâ¢nsuperscript2ğœ€ğ‘›2^{\varepsilon n}2 start_POSTSUPERSCRIPT italic_Îµ italic_n end_POSTSUPERSCRIPT, for some Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0. Combined with the result above, it immediately leads to win-win circuit lower bounds: if \NSETH fails, we have a lower bound for series-parallel circuits, otherwise we have a lower bound for \ETHRâˆ˜\ETHR\ETHR\ETHR\ETHR{}\circ\ETHR{}âˆ˜ circuits. 1.4 Our Contribution In this paper, we derive a number of nonuniform lower bounds from uniform nondeterministic lower bounds. Our lower bounds apply for various objects that are notoriously hard to analyze: circuits, matrix rigidity, and tensor rank. For circuits, we get a win-win situation similar to the one by Williams. Below, we give formal statements of the lower bounds for the three types of objects followed by a discussion of known bounds for these objects. Our first result says that if \UNSAT cannot be solved fast nondeterministically, then one can prove much stronger (than known) monotone circuit lower bounds. Theorem 1. If \NSETH is true, then there exists a monotone Boolean function family in \coNP\coNP\coNP of monotone circuit size 2Î©â¢(n/logâ¡n)superscript2Î©ğ‘›ğ‘›2^{\Omega(n/\log n)}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n / roman_log italic_n ) end_POSTSUPERSCRIPT. Combining this with circuit lower bounds from the negation of \NSETH due to [JMV18, CGI+16], leads to win-win circuit lower bounds. It should be noted that proving any of these two circuit lower bounds is a challenging long-standing open problem. Corollary 1. At least one of the following two circuit lower bounds holds: 1. \E\NPsuperscript\E\NP\E^{\NP}start_POSTSUPERSCRIPT end_POSTSUPERSCRIPT requires series-parallel circuits of size Ï‰â¢(n)ğœ”ğ‘›\omega(n)italic_Ï‰ ( italic_n ); 2. There is an explicit function fâˆˆ\coNPğ‘“\coNPf\in\coNPitalic_f âˆˆ that requires monotone circuits of size 2Î©â¢(n/logâ¡n)superscript2Î©ğ‘›ğ‘›2^{\Omega(n/\log n)}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n / roman_log italic_n ) end_POSTSUPERSCRIPT. Our second result says that if \MAX-3-\SAT cannot be solved fast co-nondeterministically, then there exists small explicit families of rigid matrices. Theorem 2. If \MAX-3-\SAT cannot be solved in co-nondeterministic time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ), for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, then, for all Î´>0ğ›¿0\delta>0italic_Î´ > 0, there is a generator g:{0,1}logOâ¢(1)â¡kâ†’ğ”½kÃ—k:ğ‘”â†’superscript01superscriptğ‘‚1ğ‘˜superscriptğ”½ğ‘˜ğ‘˜g\colon\{0,1\}^{\log^{O(1)}k}\to\mathbb{F}^{k\times k}italic_g : { 0 , 1 } start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT â†’ blackboard_F start_POSTSUPERSCRIPT italic_k Ã— italic_k end_POSTSUPERSCRIPT computable in time polynomial in kğ‘˜kitalic_k such that, for infinitely many kğ‘˜kitalic_k, there exist a seed sğ‘ sitalic_s for which gâ¢(s)ğ‘”ğ‘ g(s)italic_g ( italic_s ) has k12âˆ’Î´superscriptğ‘˜12ğ›¿k^{\frac{1}{2}-\delta}italic_k start_POSTSUPERSCRIPT divide start_ARG 1 end_ARG start_ARG 2 end_ARG - italic_Î´ end_POSTSUPERSCRIPT-rigidity k2âˆ’Î´superscriptğ‘˜2ğ›¿k^{2-\delta}italic_k start_POSTSUPERSCRIPT 2 - italic_Î´ end_POSTSUPERSCRIPT. Our third result extends the second result by including high-rank tensors. Theorem 3. If \MAX-3-\SAT cannot be solved in co-nondeterministic time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ) for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, then for all Î´>0ğ›¿0\delta>0italic_Î´ > 0 and some Î”>0Î”0\Delta>0roman_Î” > 0 there are two generators g1:{0,1}logOâ¢(1)â¡kâ†’ğ”½kÃ—k:subscriptğ‘”1â†’superscript01superscriptğ‘‚1ğ‘˜superscriptğ”½ğ‘˜ğ‘˜g_{1}\colon\{0,1\}^{\log^{O(1)}k}\to\mathbb{F}^{k\times k}italic_g start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT : { 0 , 1 } start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT â†’ blackboard_F start_POSTSUPERSCRIPT italic_k Ã— italic_k end_POSTSUPERSCRIPT and g2:{0,1}logOâ¢(1)â¡kâ†’ğ”½kÃ—kÃ—k:subscriptğ‘”2â†’superscript01superscriptğ‘‚1ğ‘˜superscriptğ”½ğ‘˜ğ‘˜ğ‘˜g_{2}\colon\{0,1\}^{\log^{O(1)}k}\to\mathbb{F}^{k\times k\times k}italic_g start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT : { 0 , 1 } start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT â†’ blackboard_F start_POSTSUPERSCRIPT italic_k Ã— italic_k Ã— italic_k end_POSTSUPERSCRIPT computable in time polynomial in kğ‘˜kitalic_k such that, for infinitely many kğ‘˜kitalic_k, at least one of the following is satisfied: â€¢ g1â¢(s)subscriptğ‘”1ğ‘ g_{1}(s)italic_g start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_s ) has k1âˆ’Î´superscriptğ‘˜1ğ›¿k^{1-\delta}italic_k start_POSTSUPERSCRIPT 1 - italic_Î´ end_POSTSUPERSCRIPT-rigidity k2âˆ’Î´superscriptğ‘˜2ğ›¿k^{2-\delta}italic_k start_POSTSUPERSCRIPT 2 - italic_Î´ end_POSTSUPERSCRIPT, for some sğ‘ sitalic_s; â€¢ rankâ¡(g2â¢(s))ranksubscriptğ‘”2ğ‘ \operatorname{rank}(g_{2}(s))roman_rank ( italic_g start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_s ) ) is at least k1+Î”superscriptğ‘˜1Î”k^{1+\Delta}italic_k start_POSTSUPERSCRIPT 1 + roman_Î” end_POSTSUPERSCRIPT, for some sğ‘ sitalic_s. It is worth noting that [BKM+24] showed circuit lower bounds under the same assumption: if \MAX-kğ‘˜kitalic_k-\SAT cannot be solved in co-nondeterministic time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ) for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, then for any Î´>0ğ›¿0\delta>0italic_Î´ > 0, there exists an explicit polynomial family that cannot be computed by arithmetic circuits of size Oâ¢(nÎ´)ğ‘‚superscriptğ‘›ğ›¿O(n^{\delta})italic_O ( italic_n start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT ). The best known lower bounds for the size of depth-three circuits computing an explicit Boolean function is 2Î©â¢(n)superscript2Î©ğ‘›2^{\Omega(\sqrt{n})}2 start_POSTSUPERSCRIPT roman_Î© ( square-root start_ARG italic_n end_ARG ) end_POSTSUPERSCRIPT [HÃ¥s89, PPSZ05]. Proving a 2Ï‰â¢(n)superscript2ğœ”ğ‘›2^{\omega(\sqrt{n})}2 start_POSTSUPERSCRIPT italic_Ï‰ ( square-root start_ARG italic_n end_ARG ) end_POSTSUPERSCRIPT lower bound for this restricted circuit model remains a challenging open problem and it is known that a lower bound as strong as 2Ï‰â¢(n/logâ¡logâ¡n)superscript2ğœ”ğ‘›ğ‘›2^{\omega(n/\log\log n)}2 start_POSTSUPERSCRIPT italic_Ï‰ ( italic_n / roman_log roman_log italic_n ) end_POSTSUPERSCRIPT would give an wâ¢(n)ğ‘¤ğ‘›w(n)italic_w ( italic_n ) lower bound for unrestricted circuits via Valiantâ€™s reduction [Val77]. One way of proving better depth-three circuit lower bounds is via canonical circuits introduced by Goldreich and Wigderson [GW20]. They are closely related to rigid matrices: if Tğ‘‡Titalic_T is an nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n matrix of rğ‘Ÿritalic_r-rigidity r3superscriptğ‘Ÿ3r^{3}italic_r start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT, then the corresponding bilinear function requires canonical circuits of size 2Î©â¢(r)superscript2Î©ğ‘Ÿ2^{\Omega(r)}2 start_POSTSUPERSCRIPT roman_Î© ( italic_r ) end_POSTSUPERSCRIPT [GW20]. Goldreich and Tal [GT18] showed that a random Toeplitz matrix has rğ‘Ÿritalic_r-rigidity n3r2â¢logâ¡nsuperscriptğ‘›3superscriptğ‘Ÿ2ğ‘›\frac{n^{3}}{r^{2}\log n}divide start_ARG italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT end_ARG start_ARG italic_r start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_log italic_n end_ARG, which implies a 2Î©â¢(n3/5)superscript2Î©superscriptğ‘›352^{\Omega(n^{3/5})}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n start_POSTSUPERSCRIPT 3 / 5 end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT lower bound on canonical depth-three circuits for an explicit function. Thus, by substituting n2/3âˆ’Î´superscriptğ‘›23ğ›¿n^{2/3-\delta}italic_n start_POSTSUPERSCRIPT 2 / 3 - italic_Î´ end_POSTSUPERSCRIPT-rigidity for some Î´>0ğ›¿0\delta>0italic_Î´ > 0 in our trade off Theorem 3, we derive the following result: Corollary 2. If \MAX-3-\SAT cannot be solved in co-nondeterministic time Oâ¢(2(1âˆ’Îµ)â¢n)ğ‘‚superscript21ğœ€ğ‘›O(2^{(1-\varepsilon)n})italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT ), for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, then, for any Î´>0ğ›¿0\delta>0italic_Î´ > 0 and for infinitely many nğ‘›nitalic_n, one can construct an explicit family of 2logOâ¢(1)â¡nsuperscript2superscriptğ‘‚1ğ‘›2^{\log^{O(1)}n}2 start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT functions such that at least one of them is either bilinear and requires canonical circuits of size 2Î©â¢(n2/3âˆ’Î´)superscript2Î©superscriptğ‘›23ğ›¿2^{\Omega(n^{2/3-\delta})}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 / 3 - italic_Î´ end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT or trilinear and requires arithmetic circuits of size Î©â¢(n1.25)Î©superscriptğ‘›1.25\Omega(n^{1.25})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.25 end_POSTSUPERSCRIPT ). This conditionally improves the recent result of Goldreich [Gol22], who presented an Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 )-linear function that requires canonical depth-two circuits of size 2Î©â¢(n1âˆ’Îµ)superscript2Î©superscriptğ‘›1ğœ€2^{\Omega(n^{1-\varepsilon})}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 - italic_Îµ end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT, for every Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0. Moreover, every bilinear function can be computed by canonical circuits of size 2Oâ¢(n2/3)superscript2ğ‘‚superscriptğ‘›232^{O(n^{2/3})}2 start_POSTSUPERSCRIPT italic_O ( italic_n start_POSTSUPERSCRIPT 2 / 3 end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT, so the lower bound is almost optimal and conditionally addresses Open Problem 6.5 from [GT18]. 1.4.1 Monotone Functions For monotone \NP-problems (like Clique, Matching, Hamiltonian Cycle), it is natural to ask what is their monotone circuit size. A celebrated result by Razborov [Raz85] is a lower bound nÎ©â¢(logâ¡n)superscriptğ‘›Î©ğ‘›n^{\Omega(\log n)}italic_n start_POSTSUPERSCRIPT roman_Î© ( roman_log italic_n ) end_POSTSUPERSCRIPT on monotone circuit size. Subsequently, Andreev [And85] proved a 2n1/8âˆ’oâ¢(1)superscript2superscriptğ‘›18ğ‘œ12^{n^{1/8-o(1)}}2 start_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 1 / 8 - italic_o ( 1 ) end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT lower bound for another explicit monotone function. Following the work of [AB87, And87, Juk99, HR00], in 2020, Cavalar, Kumar and Rossman [CKR22] achieved the best known lower bound of 2n1/2âˆ’oâ¢(1)superscript2superscriptğ‘›12ğ‘œ12^{n^{1/2-o(1)}}2 start_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT 1 / 2 - italic_o ( 1 ) end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT. Proving a 2Ï‰â¢(n1/2)superscript2ğœ”superscriptğ‘›122^{\omega(n^{1/2})}2 start_POSTSUPERSCRIPT italic_Ï‰ ( italic_n start_POSTSUPERSCRIPT 1 / 2 end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT lower bound remains a challenging open problem (whereas a lower bound 2Î©â¢(n)superscript2Î©ğ‘›2^{\Omega(n)}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n ) end_POSTSUPERSCRIPT was recently proved by Pitassi and Robere [PR17] for monotone formulas). Our Theorem 1 establishes a stronger lower bound under an assumption that \NSETH holds. 1.4.2 Matrix Rigidity A matrix Mğ‘€Mitalic_M over a field ğ”½ğ”½\mathbb{F}blackboard_F has r-rigidity s if for any matrices R,Sğ‘…ğ‘†R,Sitalic_R , italic_S over a field ğ”½ğ”½\mathbb{F}blackboard_F such that M=R+Sğ‘€ğ‘…ğ‘†M=R+Sitalic_M = italic_R + italic_S and rankâ¡(R)â‰¤rrankğ‘…ğ‘Ÿ\operatorname{rank}(R)\leq rroman_rank ( italic_R ) â‰¤ italic_r we have that Sğ‘†Sitalic_S has at least sğ‘ sitalic_s nonzero entries. That is, one needs to change at least sğ‘ sitalic_s elements in Mğ‘€Mitalic_M to change its rank down to at most rğ‘Ÿritalic_r. The concept of rigidity was introduced by Valiant [Val77] and Grigoriev [Gri80]. It has striking connections to areas such as computational complexity [Lok09, AW17, AC19, GKW21], communication complexity [Wun12], data structure lower bounds [DGW19, RR20], and error-correcting codes [Dvi11]. Valiant [Val77] proved that if a matrix Mğ‘€Mitalic_M has Îµâ¢nğœ€ğ‘›\varepsilon nitalic_Îµ italic_n-rigidity n1+Î´superscriptğ‘›1ğ›¿n^{1+\delta}italic_n start_POSTSUPERSCRIPT 1 + italic_Î´ end_POSTSUPERSCRIPT for some Îµ,Î´>0ğœ€ğ›¿0\varepsilon,\delta>0italic_Îµ , italic_Î´ > 0, then the bilinear form of Mğ‘€Mitalic_M cannot be computed by arithmetic circuits of size Oâ¢(n)ğ‘‚ğ‘›O(n)italic_O ( italic_n ) and depth Oâ¢(logâ¡n)ğ‘‚ğ‘›O(\log n)italic_O ( roman_log italic_n ). Following Razborov [Raz89], Wunderlich [Wun12] proved that the existence of strongly-explicit matrices with 2(logâ¡logâ¡n)Ï‰â¢(1)superscript2superscriptğ‘›ğœ”12^{(\log\log n)^{\omega(1)}}2 start_POSTSUPERSCRIPT ( roman_log roman_log italic_n ) start_POSTSUPERSCRIPT italic_Ï‰ ( 1 ) end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT-rigidity Î´â¢n2ğ›¿superscriptğ‘›2\delta n^{2}italic_Î´ italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, for some Î´>0ğ›¿0\delta>0italic_Î´ > 0, implies the existence of a language that does not belong to the communication complexity analog of \PH\PH\PH. Although it is known [Val77] that for any rğ‘Ÿritalic_r almost every nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n matrix has rğ‘Ÿritalic_r-rigidity Î©â¢((nâˆ’r)2logâ¡n)Î©superscriptğ‘›ğ‘Ÿ2ğ‘›\Omega(\frac{(n-r)^{2}}{\log n})roman_Î© ( divide start_ARG ( italic_n - italic_r ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG roman_log italic_n end_ARG ) over algebraically closed fields, obtaining an explicit constructions of rigid matrices remains a long-standing open question. Many works have aimed at finding explicit or semi-explicit rigid matrices [Fri93, PV91, SSS97, AW17, DE19, AC19, DL20, VK22, BGKM23, BHPT24]. We are interested in constructing small explicit111Matrix or family of matrices is called explicit if it is polynomial time constructible. families of rigid matrices, since they can be used to prove arithmetic circuits lower bounds [Val77]. The best known polynomial-time constructible matrices have rğ‘Ÿritalic_r-rigidity n2râ¢logâ¡(n/r)superscriptğ‘›2ğ‘Ÿğ‘›ğ‘Ÿ\frac{n^{2}}{r}\log(n/r)divide start_ARG italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG italic_r end_ARG roman_log ( italic_n / italic_r ) for any rğ‘Ÿritalic_r, which was proved by Shokrollahi, Spielman and Stemann [SSS97]. Goldreich and Tal [GT18] proved that a random nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n Toeplitz matrix over ğ”½2subscriptğ”½2\mathbb{F}_{2}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT (i.e., a matrix of the form Ai,j=aiâˆ’jsubscriptğ´ğ‘–ğ‘—subscriptğ‘ğ‘–ğ‘—A_{i,j}=a_{i-j}italic_A start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT = italic_a start_POSTSUBSCRIPT italic_i - italic_j end_POSTSUBSCRIPT for some random bits aâˆ’(nâˆ’1),â€¦,anâˆ’1subscriptğ‘ğ‘›1â€¦subscriptğ‘ğ‘›1a_{-(n-1)},\ldots,a_{n-1}italic_a start_POSTSUBSCRIPT - ( italic_n - 1 ) end_POSTSUBSCRIPT , â€¦ , italic_a start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT) has rğ‘Ÿritalic_r-rigidity n3r2â¢logâ¡nsuperscriptğ‘›3superscriptğ‘Ÿ2ğ‘›\frac{n^{3}}{r^{2}\log n}divide start_ARG italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT end_ARG start_ARG italic_r start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_log italic_n end_ARG for râ‰¥nğ‘Ÿğ‘›r\geq\sqrt{n}italic_r â‰¥ square-root start_ARG italic_n end_ARG. However, the size of that family is exponential in nğ‘›nitalic_n. Our Theorem 2 demonstrates that, under the assumption that \MAX-3333-\SAT is hard, for any Î´>0ğ›¿0\delta>0italic_Î´ > 0, for infinitely many nğ‘›nitalic_n one can construct a 2logOâ¢(1)â¡nsuperscript2superscriptğ‘‚1ğ‘›2^{\log^{O(1)}n}2 start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT-sized family of nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n matrices with at least one having n1/2âˆ’Î´superscriptğ‘›12ğ›¿n^{1/2-\delta}italic_n start_POSTSUPERSCRIPT 1 / 2 - italic_Î´ end_POSTSUPERSCRIPT-rigidity n2âˆ’Î´superscriptğ‘›2ğ›¿n^{2-\delta}italic_n start_POSTSUPERSCRIPT 2 - italic_Î´ end_POSTSUPERSCRIPT. This result is still far from the regime where circuit lower bounds can be derived via Valiantâ€™s result, but it strictly improves the polynomial-time construction [SSS97] for any r<nğ‘Ÿğ‘›r<\sqrt{n}italic_r < square-root start_ARG italic_n end_ARG and improves the result of Goldreich and Tal [GT18] by substantially reducing the family size while maintaining the same rigidity for râ‰ˆnğ‘Ÿğ‘›r\approx\sqrt{n}italic_r â‰ˆ square-root start_ARG italic_n end_ARG. An open question remains as to whether explicit constructions of rigid matrices exist in the class Â¶\NPsuperscriptÂ¶\NP\P^{\NP{}}Â¶ start_POSTSUPERSCRIPT end_POSTSUPERSCRIPT [Ram20]. The construction provided by Goldreich and Tal [GT18] lies in \E\NPsuperscript\E\NP\E^{\NP{}}start_POSTSUPERSCRIPT end_POSTSUPERSCRIPT. Alman and Chen [AC19] demonstrated that there exists a constant Î´>0ğ›¿0\delta>0italic_Î´ > 0 such that, for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, one can construct nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n matrices with 2(logâ¡n)1/4âˆ’Îµsuperscript2superscriptğ‘›14ğœ€2^{(\log n)^{1/4-\varepsilon}}2 start_POSTSUPERSCRIPT ( roman_log italic_n ) start_POSTSUPERSCRIPT 1 / 4 - italic_Îµ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT-rigidity Î´â¢n2ğ›¿superscriptğ‘›2\delta n^{2}italic_Î´ italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT in Â¶\NPsuperscriptÂ¶\NP\P^{\NP}Â¶ start_POSTSUPERSCRIPT end_POSTSUPERSCRIPT. Our construction, in the class \DTIMEâ¢[2logOâ¢(1)â¡n]\NP\DTIMEsuperscriptdelimited-[]superscript2superscriptğ‘‚1ğ‘›\NP\DTIME[2^{\log^{O(1)}n}]^{\NP}[ 2 start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ] start_POSTSUPERSCRIPT end_POSTSUPERSCRIPT, produces matrices with n12âˆ’Î´superscriptğ‘›12ğ›¿n^{\frac{1}{2}-\delta}italic_n start_POSTSUPERSCRIPT divide start_ARG 1 end_ARG start_ARG 2 end_ARG - italic_Î´ end_POSTSUPERSCRIPT-rigidity n2âˆ’Î´superscriptğ‘›2ğ›¿n^{2-\delta}italic_n start_POSTSUPERSCRIPT 2 - italic_Î´ end_POSTSUPERSCRIPT for any Î´>0ğ›¿0\delta>0italic_Î´ > 0, under the condition that \MAX-3-\SAT is hard. 1.4.3 Tensor Rank and Arithmetic Circuits Proving arithmetic circuit lower bounds is another important challenge of complexity theory. An arithmetic circuit over a field ğ”½ğ”½\mathbb{F}blackboard_F uses as inputs formal variables and field elements and computes in every gate either a sum or a product. As proved by Strassen [Str73, Str75] and Baur and Strassen [BS83], it is known that computing âˆ‘i=1nxinsuperscriptsubscriptğ‘–1ğ‘›superscriptsubscriptğ‘¥ğ‘–ğ‘›\sum_{i=1}^{n}x_{i}^{n}âˆ‘ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT requires arithmetic circuits of size Î©â¢(nâ¢logâ¡n)Î©ğ‘›ğ‘›\Omega(n\log n)roman_Î© ( italic_n roman_log italic_n ), provided nğ‘›nitalic_n does not divide the characteristic of ğ”½ğ”½\mathbb{F}blackboard_F. Raz [Raz03] further established that arithmetic circuits with bounded coefficients require Î©â¢(n2â¢logâ¡n)Î©superscriptğ‘›2ğ‘›\Omega(n^{2}\log n)roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_log italic_n ) gates to perform matrix multiplication over â„â„\mathbb{R}blackboard_R or â„‚â„‚\mathbb{C}blackboard_C, following the work in [RS03]. However, no superlinear lower bounds are known for polynomials of constant degree. For constant-depth arithmetic circuits over fields of characteristic 2222, exponential lower bounds are known [Raz87, Smo87]. For other finite characteristics, exponential lower bounds are known only for depth 3333 [GK98, GR98]. For characteristic 00, the best lower bound for depth 3333 is Î©â¢(n2âˆ’Îµ)Î©superscriptğ‘›2ğœ€\Omega(n^{2-\varepsilon})roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 - italic_Îµ end_POSTSUPERSCRIPT ) [SW99]. Matrix multiplication is one of the fundamental problems whose arithmetic circuit size is of great interest. While many highly nontrivial algorithms for it are known (starting from Strassen [Str69]), we still do not have superlinear lower bounds on its arithmetic circuit complexity. Proving such lower bounds is closely related to the problem of determining the rank of tensors. A dğ‘‘ditalic_d-dimensional tensor is said to have rank qğ‘qitalic_q if it can be expressed as a sum of qğ‘qitalic_q rank-one tensors. Here, a rank-one dğ‘‘ditalic_d-dimensional tensor is a tensor of the form u1âŠ—â‹¯âŠ—udtensor-productsubscriptğ‘¢1â‹¯subscriptğ‘¢ğ‘‘u_{1}\otimes\dots\otimes u_{d}italic_u start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŠ— â‹¯ âŠ— italic_u start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT, where âŠ—tensor-product\otimesâŠ— stands for a tensor product. By a multiplication tensor, we mean a tensor of size n2Ã—n2Ã—n2superscriptğ‘›2superscriptğ‘›2superscriptğ‘›2n^{2}\times n^{2}\times n^{2}italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT Ã— italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT Ã— italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT (formally defined in Section 2.4). Establishing an upper bound for the rank of the multiplication tensor provides a means of proving upper bounds for matrix multiplication via the laser method [Str86]. Moreover, proving a lower bound for the tensor rank would yield superlinear lower bounds for arithmetic circuits computing the polynomial defined by that tensor. Therefore, proving lower bounds on the tensor rank provides a path to proving lower bounds on arithmetic circuits. For the rank of the matrix multiplication tensor, Bshouty [Bsh89] and BlÃ¤ser [BlÃ¤99] proved a lower bound 2.5â¢n2âˆ’Î˜â¢(n)2.5superscriptğ‘›2Î˜ğ‘›2.5n^{2}-\Theta(n)2.5 italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - roman_Î˜ ( italic_n ). Subsequently, Shpilka [Shp03] improved the bound to 3â¢n2âˆ’oâ¢(n2)3superscriptğ‘›2ğ‘œsuperscriptğ‘›23n^{2}-o(n^{2})3 italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_o ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) over ğ”½2subscriptğ”½2\mathbb{F}_{2}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. The bound 3â¢n2âˆ’oâ¢(n)3superscriptğ‘›2ğ‘œğ‘›3n^{2}-o(n)3 italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_o ( italic_n ) was later achieved by Landsberg [Lan14] over arbitrary fields and further slightly improved by Massarenti and Raviolo [MR13, MR14]. Alexeev, Forbes and Tsimerman [AFT11] constructed explicit dğ‘‘ditalic_d-dimensional tensors with rank 2â¢nâŒŠd2âŒ‹+nâˆ’Î˜â¢(dâ¢logâ¡n)2superscriptğ‘›ğ‘‘2ğ‘›Î˜ğ‘‘ğ‘›2n^{\left\lfloor\frac{d}{2}\right\rfloor}+n-\Theta(d\log n)2 italic_n start_POSTSUPERSCRIPT âŒŠ divide start_ARG italic_d end_ARG start_ARG 2 end_ARG âŒ‹ end_POSTSUPERSCRIPT + italic_n - roman_Î˜ ( italic_d roman_log italic_n ), thus improving the lower bounds on high-dimensional tensors. Nevertheless, superlinear size lower bounds for constant-degree polynomials remain unknown. Additionally, HÃ¥stad [HÃ¥s90] established that determining the rank of a dğ‘‘ditalic_d-dimensional tensor is \NP-hard for any dâ‰¥3ğ‘‘3d\geq 3italic_d â‰¥ 3. Consequently, a major open problem is to construct an explicit family of dğ‘‘ditalic_d-dimensional tensors with rank at least nâŒŠd2âŒ‹+Îµsuperscriptğ‘›ğ‘‘2ğœ€n^{\left\lfloor\frac{d}{2}\right\rfloor+\varepsilon}italic_n start_POSTSUPERSCRIPT âŒŠ divide start_ARG italic_d end_ARG start_ARG 2 end_ARG âŒ‹ + italic_Îµ end_POSTSUPERSCRIPT for some Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 and dâ‰¥3ğ‘‘3d\geq 3italic_d â‰¥ 3. Our Theorem 3 shows that, under an assumption that \MAX-3-\SAT cannot be solved fast co-nondeterministically, one gets an explicit 2logOâ¢(1)â¡nsuperscript2superscriptğ‘‚1ğ‘›2^{\log^{O(1)}n}2 start_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT italic_O ( 1 ) end_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT-size family of nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n-matrices and nÃ—nÃ—nğ‘›ğ‘›ğ‘›n\times n\times nitalic_n Ã— italic_n Ã— italic_n-tensors, such that for any Î´>0ğ›¿0\delta>0italic_Î´ > 0 and some Î”>0Î”0\Delta>0roman_Î” > 0 at least one of the matrices has n1âˆ’Î´superscriptğ‘›1ğ›¿n^{1-\delta}italic_n start_POSTSUPERSCRIPT 1 - italic_Î´ end_POSTSUPERSCRIPT-rigidity n2âˆ’Î´superscriptğ‘›2ğ›¿n^{2-\delta}italic_n start_POSTSUPERSCRIPT 2 - italic_Î´ end_POSTSUPERSCRIPT or one of the tensors has rank n1+Î”superscriptğ‘›1Î”n^{1+\Delta}italic_n start_POSTSUPERSCRIPT 1 + roman_Î” end_POSTSUPERSCRIPT. Furthermore, we establish a trade-off between matrix rigidity and tensor rank, see Theorem 9. Other results for proving lower bounds on tensor rank under certain assumptions are known. Nederlof [Ned20] proved that, if for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, the bipartite TSP problem cannot be solved in time 2(1âˆ’Îµ)â¢nsuperscript21ğœ€ğ‘›2^{(1-\varepsilon)n}2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT, then the matrix multiplication tensor has superlinear rank. Additionally, BjÃ¶rklund and Kaski [BK24] recently proved that if, for any Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, there exists a kğ‘˜kitalic_k such that the kğ‘˜kitalic_k-Set Cover problem cannot be solved in time Oâ¢(2(1âˆ’Îµ)â¢nâ¢|â„±|)ğ‘‚superscript21ğœ€ğ‘›â„±O(2^{(1-\varepsilon)n}|\mathcal{F}|)italic_O ( 2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT | caligraphic_F | ), then there is an explicit tensor with superlinear rank, where â„±â„±\mathcal{F}caligraphic_F is a family of subsets of [n]delimited-[]ğ‘›[n][ italic_n ], each of size at most kğ‘˜kitalic_k. Pratt [Pra24] improved this result, showing that under the same conjecture there exists an explicit tensor of shape nÃ—nÃ—nğ‘›ğ‘›ğ‘›n\times n\times nitalic_n Ã— italic_n Ã— italic_n and rank at least n1.08superscriptğ‘›1.08n^{1.08}italic_n start_POSTSUPERSCRIPT 1.08 end_POSTSUPERSCRIPT. [BCH+24] showed that if for every Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 Chromatic Number problem cannot be solved in time 2(1âˆ’Îµ)â¢nsuperscript21ğœ€ğ‘›2^{(1-\varepsilon)n}2 start_POSTSUPERSCRIPT ( 1 - italic_Îµ ) italic_n end_POSTSUPERSCRIPT, then there exists an explicit tensor of superlinear rank. 1.5 Structure of the Paper The paper is organized as follows. In Section 2, we introduce the notation used throughout the paper and provide the necessary background information. In Section 3, we introduce the main ideas of each result. In Section 4, we establish the win-win circuit lower bound. In Section 5, we construct rigid matrices conditioned that \MAX-3-\SAT cannot be solved fast co-nondeterministically. In Section 6, we construct either three-dimensional tensors with high rank or matrices with high rigidity under the same assumption. In Section 7 we discuss future directions and open problems."
https://arxiv.org/html/2411.03230v1,Fermionic Independent Set and Laplacian of an independence complex are QMA-hard,"The Independent Set is a well known NP-hard optimization problem. In this work, we define a fermionic generalization of the Independent Set problem and prove that the optimization problem is QMA-hard in a kğ‘˜kitalic_k-particle subspace using perturbative gadgets. We discuss how the Fermionic Independent Set is related to the problem of computing the minimum eigenvalue of the kthsuperscriptğ‘˜thk^{\text{th}}italic_k start_POSTSUPERSCRIPT th end_POSTSUPERSCRIPT-Laplacian of an independence complex of a vertex weighted graph. Consequently, we use the same perturbative gadget to prove QMA-hardness of the later problem resolving an open conjecture from [1] and give the first example of a natural topological data analysis problem that is QMA-hard.","Quantum Merlin Arthur (QMA) is the complexity class of decision problems for which a â€˜yesâ€™ solution can be efficiently verified using a quantum computer. The kğ‘˜kitalic_k-Local Hamiltonian problem [2, 3, 4] was the first non-trivial problem shown to be QMA-complete. Since then numerous other problems have been proven QMA-complete, mostly arising in quantum computing and information science [5]. While the kğ‘˜kitalic_k-Local Hamiltonian problem serves as a fundamental QMA-complete problem, analogous to kğ‘˜kitalic_k-SATâ€™s role in NP-completeness, the majority of NP-complete problems are constrained combinatorial optimization problems such as Minimum Vertex Cover, Maximum Independent Set, and Longest Path [6]. Such constrained optimization problems had a great impact on the development of classical algorithms, and hardness results. By studying quantum generalizations of such constrained optimization problems, we can explore new quantum algorithms and hardness results for quantum problems that are currently lacking. This kind of motivation inspired a previous work [7] which studies quantum generalizations of classical constrained problems with Vertex Cover as a driving example. Following this motivation, we define a fermionic generalization of the Independent Set and study its computational complexity. We prove that the Fermionic Independent Set is QMA-hard when restricted to a kğ‘˜kitalic_k-particle subspace. When problems without an obvious quantum connection are shown to be related QMA, it can offer new insights into the structure of QMA and as well as the problem at hand. One such problem in Homology is to determine the existence of a kğ‘˜kitalic_k-dimensional hole in a topological space. When the space is represented by the clique complex of a graph, this problem is of practical interest in Topological Data Analysis (TDA) which uses topological features such as holes to characterize and study data. TDA has found a broad range of applications from computational neuroscience [8] to cosmology [9]. Recently, there has been a significant progress towards understanding the computational complexity of determining the existence of a hole by relating it to quantum complexity classes. This connection was possible because of a correspondence between the combinatorial Laplacian of a clique complex whose null space captures the holes and a supersymmetric Hamiltonian [10]. The question of whether the clique complex has a kğ‘˜kitalic_k-dimensional hole or not is equivalent to whether the supersymmetric Hamiltonian has a zero energy ground state or not in the kğ‘˜kitalic_k-particle subspace. In this work, we prove that computing the minimum eigenvalue of the kthsuperscriptğ‘˜thk^{\text{th}}italic_k start_POSTSUPERSCRIPT th end_POSTSUPERSCRIPT-Laplacian of a clique complex is QMA-hard resolving an open conjecture from [1] in the affirmative. Our result is proved for the Laplacian operator of the independence complex and holds true for the clique complex as well since the clique complex of a graph is same as the independence complex of the complement graph. A novelty of our work lies in the simplicity of our proof techniques based on perturbative gadgets compared to highly specialized homological proof techniques of previous works [11, 1]. Although the Fermionic Independent Set and the minimum eigenvalue problem of the Laplacian of an independence complex might seem unrelated at first, when expressed as constrained optimization problems they differ only slightly in their objective functions. The similarity between the problems is also reflected in the fact that we use the same perturbative gadget to prove QMA-hardness of both the problems. We consequently establish the first QMA-hardness result of a natural TDA problem. 1.1 Related Work Crichigno and Kohler [11] proved that the problem of deciding whether the minimum eigenvalue of the kthsuperscriptğ‘˜thk^{\text{th}}italic_k start_POSTSUPERSCRIPT th end_POSTSUPERSCRIPT-Lapalacian is equal to 00 or >0absent0>0> 0 is QMA1-hard where QMA1 is the complexity class QMA with perfect completeness. But the corresponding QMA1-hard supersymmetric Hamiltonians that they construct can have exponentially small gap above the zero energy ground space. This was later improved by King and Kohler [1] where they constructed QMA1-hard supersymmetric Hamiltonians corresponding to clique complexes of vertex weighted graphs with inverse polynomial gap above the zero energy ground space, thereby placing them in QMA. The authors conjectured in [1] that there are supersymmetric Hamiltonians corresponding to clique complexes which are QMA-hard, meaning estimating the minimum eigenvalue of the Laplacian operator even when it is nonzero is QMA-hard, rather than just QMA1-hard. 1.2 Notation and organization The notation [n]delimited-[]ğ‘›[n][ italic_n ] denotes the set of integers {1,2,â€¦,n}12â€¦ğ‘›\{1,2,...,n\}{ 1 , 2 , â€¦ , italic_n }. A graph is denoted by GğºGitalic_G, Gâ¢([n],E)ğºdelimited-[]ğ‘›ğ¸G([n],E)italic_G ( [ italic_n ] , italic_E ) where vertices are labeled by elements from [n]delimited-[]ğ‘›[n][ italic_n ] and set Eğ¸Eitalic_E denotes the edges between the vertices. An edge between vertices iğ‘–iitalic_i and jğ‘—jitalic_j is represent by iâ¢jğ‘–ğ‘—ijitalic_i italic_j. Hamiltonians are denoted by Hğ»Hitalic_H and Vğ‘‰Vitalic_V with various subscripts, and projectors are denoted by Pğ‘ƒPitalic_P and Î Î \Piroman_Î  with various subscripts. Hilbert spaces are denoted by â„‹â„‹\mathcal{H}caligraphic_H with various subscripts. The notation ÏğœŒ\rhoitalic_Ï denotes a density operator and the notation Trâ¢[A]Trdelimited-[]ğ´\mathrm{Tr}[A]roman_Tr [ italic_A ] denotes the matrix trace of an operator Ağ´Aitalic_A. Positive semi-definiteness of an operator Ağ´Aitalic_A is denoted by Aâª°0succeeds-or-equalsğ´0A\succeq 0italic_A âª° 0. Fermionic creation and annihilation operators are denoted by aâ€ superscriptğ‘â€ a^{\dagger}italic_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT, ağ‘aitalic_a. Pauli matrices Xğ‘‹Xitalic_X, Yğ‘ŒYitalic_Y, and Zğ‘Zitalic_Z are defined as follows X=[0110],Y=[0âˆ’ii0],andZ=[100âˆ’1].formulae-sequenceğ‘‹matrix0110formulae-sequenceğ‘Œmatrix0ğ‘–ğ‘–0andğ‘matrix1001\displaystyle X=\begin{bmatrix}0&1\\ 1&0\end{bmatrix},\,\,\,\,\,\,Y=\begin{bmatrix}0&-i\\ i&0\end{bmatrix},\,\text{and}\,\,\,\,\,\,Z=\begin{bmatrix}1&0\\ 0&-1\end{bmatrix}.italic_X = [ start_ARG start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW end_ARG ] , italic_Y = [ start_ARG start_ROW start_CELL 0 end_CELL start_CELL - italic_i end_CELL end_ROW start_ROW start_CELL italic_i end_CELL start_CELL 0 end_CELL end_ROW end_ARG ] , and italic_Z = [ start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL - 1 end_CELL end_ROW end_ARG ] . In section 2, we define the Fermionic Independent Set problem and the minimum eigenvalue problem of the Laplacian of an independence complex of a vertex weighted graph. We briefly the similarities and the differences between the two problems. In appendix A, we recall some theorems behind perturbative gadgets necessary for our work. In section 3, we give a proof of QMA-hardness of Fermionic Independent Set problem when restricted to a kğ‘˜kitalic_k-particle subspace. In section 4, we extend the QMA-hardness proof to minimum eigenvalue problem of the kthsuperscriptğ‘˜thk^{\text{th}}italic_k start_POSTSUPERSCRIPT th end_POSTSUPERSCRIPT-Laplacian of an independence complex."
https://arxiv.org/html/2411.03103v1,Benign landscape for Burer-Monteiro factorizations of MaxCut-type semidefinite programs,"We consider MaxCut-type semidefinite programs (SDP) which admit a low rank solution. To numerically leverage the low rank hypothesis, a standard algorithmic approach is the Burer-Monteiro factorization, which allows to significantly reduce the dimensionality of the problem at the cost of its convexity. We give a sharp condition on the conditioning of the Laplacian matrix associated with the SDP under which any second-order critical point of the non-convex problem is a global minimizer. By applying our theorem, we improve on recent results about the correctness of the Burer-Monteiro approach on â„¤2subscriptâ„¤2\mathbb{Z}_{2}blackboard_Z start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-synchronization problems.","1.1 Presentation of the problem Semidefinite programs (SDP) are optimization tools that allow the solving and modeling of a variety of problems across applied sciences. A number of problems admits a SDP formulation in combinatorial optimization [Goemans and Williamson, 1995], machine learning and data sciences [Lanckriet et al., 2004], statistics and signal processing [CandÃ¨s, Strohmer, and Voroninski, 2013]. In this paper, we are interested in so-called MaxCut-type SDPs: minXâˆˆğ•ŠnÃ—nğ‘‹superscriptğ•Šğ‘›ğ‘›min\displaystyle\underset{X\in\mathbb{S}^{n\times n}}{\mbox{min}}start_UNDERACCENT italic_X âˆˆ blackboard_S start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT end_UNDERACCENT start_ARG min end_ARG âˆ’âŸ¨C,XâŸ©ğ¶ğ‘‹\displaystyle-\left\langle C,X\right\rangle- âŸ¨ italic_C , italic_X âŸ© (SDP) s.t. Xâª°0succeeds-or-equalsğ‘‹0\displaystyle X\succeq 0italic_X âª° 0 diagâ¢(X)=ğŸn,diagğ‘‹subscript1ğ‘›\displaystyle\mathrm{diag}(X)=\operatorname{\mathbf{1}}_{n},roman_diag ( italic_X ) = bold_1 start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , where the operator diag:â„nÃ—nâ†’â„n:diagâ†’superscriptâ„ğ‘›ğ‘›superscriptâ„ğ‘›\operatorname{diag}:\mathbb{R}^{n\times n}\to\mathbb{R}^{n}roman_diag : blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT â†’ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT extracts the diagonal of a square matrix, ğŸn=(1â¢â€¦â¢1)Tâˆˆâ„nsubscript1ğ‘›superscript1â€¦1ğ‘‡superscriptâ„ğ‘›\operatorname{\mathbf{1}}_{n}=(1\dots 1)^{T}\in\mathbb{R}^{n}bold_1 start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT = ( 1 â€¦ 1 ) start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT and the symmetric matrix Câˆˆâ„nÃ—nğ¶superscriptâ„ğ‘›ğ‘›C\in\mathbb{R}^{n\times n}italic_C âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT is called the cost matrix. SDP of this form are especially known to provide precise convex relaxations of MaxCut problems from graph optimization [Goemans and Williamson, 1995]. They can also model problems such as group synchronization, phase retrieval and the Kuramoto model, for particular choices of the cost matrix Cğ¶Citalic_C. Several general methods exist to numerically solve problem (SDP), but they scale poorly with nğ‘›nitalic_n. For instance, interior-point solvers require Oâ¢(n3)ğ‘‚superscriptğ‘›3O(n^{3})italic_O ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) computations per iteration and Oâ¢(n2)ğ‘‚superscriptğ‘›2O(n^{2})italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) to store the variable [Benson, Ye, and Zhang, 2000]. To reduce the computational complexity of solvers, one must exploit the specific properties of the problem at hand, if any. For instance, it may be known in advance that the solution to (SDP) is low-rank: [Pataki, 1998] guarantees that there exists a solution with rank bounded by 2â¢n+Oâ¢(1)2ğ‘›ğ‘‚1\sqrt{2n}+O(1)square-root start_ARG 2 italic_n end_ARG + italic_O ( 1 ) and, when (SDP) is the relaxation of a combinatorial problem, the optimal rank is often much less (see for instance [CandÃ¨s, Strohmer, and Voroninski, 2013] for a theoretical justification in a particular case, [JournÃ©e, Bach, Absil, and Sepulchre, 2010] for a numerical investigation). In this case, it is possible to tackle the problem using its so-called Burer-Monteiro factorization. The principle is to factor the variable as X=Vâ¢VTğ‘‹ğ‘‰superscriptğ‘‰ğ‘‡X=VV^{T}italic_X = italic_V italic_V start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT, for Vâˆˆâ„nÃ—pğ‘‰superscriptâ„ğ‘›ğ‘V\in\mathbb{R}^{n\times p}italic_V âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_p end_POSTSUPERSCRIPT, where pâˆˆâ„•ğ‘â„•p\in\mathbb{N}italic_p âˆˆ blackboard_N is larger or equal to the rank of the sought solution, and much smaller than nğ‘›nitalic_n. Then, one optimizes over Vğ‘‰Vitalic_V, instead of directly over Xğ‘‹Xitalic_X. minVâˆˆâ„nÃ—pğ‘‰superscriptâ„ğ‘›ğ‘min\displaystyle\underset{V\in\mathbb{R}^{n\times p}}{\mbox{min}}start_UNDERACCENT italic_V âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_p end_POSTSUPERSCRIPT end_UNDERACCENT start_ARG min end_ARG âˆ’âŸ¨C,Vâ¢VTâŸ©ğ¶ğ‘‰superscriptğ‘‰ğ‘‡\displaystyle-\left\langle C,VV^{T}\right\rangle- âŸ¨ italic_C , italic_V italic_V start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT âŸ© (Burer-Monteiro) s.t. diagâ¡(Vâ¢VT)=ğŸn.diagğ‘‰superscriptğ‘‰ğ‘‡subscript1ğ‘›\displaystyle\operatorname{diag}(VV^{T})=\operatorname{\mathbf{1}}_{n}.roman_diag ( italic_V italic_V start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT ) = bold_1 start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT . The factorized problem reduces the number of variables to nâ¢pğ‘›ğ‘npitalic_n italic_p instead of the Oâ¢(n2)ğ‘‚superscriptğ‘›2O(n^{2})italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) variables of the initial problem which is computationally advantageous when pâ‰ªnmuch-less-thanğ‘ğ‘›p\ll nitalic_p â‰ª italic_n. However, the convexity is lost, so standard solvers are not guaranteed to reach the solution. Still, in practice, solvers oftentimes converge to a global solution Vâˆˆâ„nÃ—pğ‘‰superscriptâ„ğ‘›ğ‘V\in\mathbb{R}^{n\times p}italic_V âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_p end_POSTSUPERSCRIPT of the factorized problem, for which X=Vâ¢VTğ‘‹ğ‘‰superscriptğ‘‰ğ‘‡X=VV^{T}italic_X = italic_V italic_V start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT solves the initial problem. 1.2 Prior work and our contribution The main explanation proposed in the literature for the success of standard algorithms at solving (Burer-Monteiro) has been the benign non-convexity of the optimization landscape: it may be that all second-order critical points of (Burer-Monteiro) are global minimizers. Since standard algorithms typically find a second-order critical point [Lee, Panageas, Piliouras, Simchowitz, Jordan, and Recht, 2019], they consequently find a global minimizer. Literature suggests that, the greater pğ‘pitalic_p is, the more likely it is that the landscape is benign. More precisely, when pâ‰¥2â¢n+Oâ¢(1)ğ‘2ğ‘›ğ‘‚1p\geq\sqrt{2n}+O(1)italic_p â‰¥ square-root start_ARG 2 italic_n end_ARG + italic_O ( 1 ), the landscape of the factorized problem is benign for almost all cost matrices Cğ¶Citalic_C [Boumal, Voroninski, and Bandeira, 2020]. This property is even true for all cost matrices if p>n2ğ‘ğ‘›2p>\frac{n}{2}italic_p > divide start_ARG italic_n end_ARG start_ARG 2 end_ARG [Boumal, Voroninski, and Bandeira, 2020, Cor. 5.11], while it can fail for a zero Lebesgue measure subset of cost matrices if 2â¢n+Oâ¢(1)â‰¤pâ‰¤n22ğ‘›ğ‘‚1ğ‘ğ‘›2\sqrt{2n}+O(1)\leq p\leq\frac{n}{2}square-root start_ARG 2 italic_n end_ARG + italic_O ( 1 ) â‰¤ italic_p â‰¤ divide start_ARG italic_n end_ARG start_ARG 2 end_ARG [Oâ€™Carroll, Srinivas, and Vijayaraghavan, 2022]. However, when pâ‰¤2â¢n+Oâ¢(1)ğ‘2ğ‘›ğ‘‚1p\leq\sqrt{2n}+O(1)italic_p â‰¤ square-root start_ARG 2 italic_n end_ARG + italic_O ( 1 ), there is a subset of cost matrices Cğ¶Citalic_C of positive Lebesgue measure for which (Burer-Monteiro) admits non-optimal critical points [Waldspurger and Waters, 2020] (with a gap to the optimal value scaling in Oâ¢(1/p)ğ‘‚1ğ‘O(1/p)italic_O ( 1 / italic_p ) [Mei, Misiakiewicz, Montanari, and Oliveira, 2017], but strictly positive). Nonetheless, in practice, standard algorithms seem to find a solution of (Burer-Monteiro) below the threshold 2â¢n2ğ‘›\sqrt{2n}square-root start_ARG 2 italic_n end_ARG, suggesting that, maybe, the set of cost matrices with a non-optimal critical point is small, and â€œtypicalâ€ cost matrices do not belong to it. Therefore, researchers have tried to find properties on Cğ¶Citalic_C guaranteeing that Cğ¶Citalic_C is not in this bad set, focusing for the moment on the setting where the minimizer of (SDP) has rank 1111. The articles [McRae and Boumal, 2024] and [McRae, Abdalla, Bandeira, and Boumal, 2024] discuss matrices Cğ¶Citalic_C with a specific structure, motivated by synchronization problems. They prove that the landscape of (Burer-Monteiro) is benign under conditions which involve eigenvalues of the subcomponents of Cğ¶Citalic_C. [Ling, 2023] considers general matrices Cğ¶Citalic_C and shows that the landscape is benign if the condition number of the associated Laplacian matrix is smaller than pâˆ’12ğ‘12\frac{p-1}{2}divide start_ARG italic_p - 1 end_ARG start_ARG 2 end_ARG. For important instances of (SDP) (mainly â„¤2subscriptâ„¤2\mathbb{Z}_{2}blackboard_Z start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-synchronization with additive Gaussian noise and multiplicative Bernoulli noise), these recent results show that standard algorithms, applied to (Burer-Monteiro), retrieve the rank 1111 solution under close to optimal conditions. Main result Our main result is a sufficient condition on the condition number of a certain matrix related to (SDP) which ensures that the landscape of (Burer-Monteiro) is benign. This tightens the result of [Ling, 2023]: we show that if the condition number of the Laplacian matrix associated with Cğ¶Citalic_C is less than pğ‘pitalic_p (instead of pâˆ’12ğ‘12\frac{p-1}{2}divide start_ARG italic_p - 1 end_ARG start_ARG 2 end_ARG in [Ling, 2023]), then the landscape of (Burer-Monteiro) is benign. Furthermore, we show that this bound is essentially optimal. Finally, by applying our theorem to â„¤2subscriptâ„¤2\mathbb{Z}_{2}blackboard_Z start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-synchronization, we also improve on the applications of [McRae, Abdalla, Bandeira, and Boumal, 2024] and [Ling, 2023]. 1.3 Structure of the paper In section 2, we present our main result and, in section 3, its application to â„¤2subscriptâ„¤2\mathbb{Z}_{2}blackboard_Z start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-synchronization with additive Gaussian noise and Bernoulli noise. In section 4 we provide the proof of the main theorem, without the technical details that we leave for the appendix. 1.4 Notation Throughout this paper, ğ•ŠnÃ—nsuperscriptğ•Šğ‘›ğ‘›\mathbb{S}^{n\times n}blackboard_S start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT is the set of symmetric nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n matrices. We write Xâª°0succeeds-or-equalsğ‘‹0X\succeq 0italic_X âª° 0 if Xğ‘‹Xitalic_X is a positive semidefinite matrix. For a matrix Xâˆˆâ„nÃ—nğ‘‹superscriptâ„ğ‘›ğ‘›X\in\mathbb{R}^{n\times n}italic_X âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT, when it makes sense, Î»1â¢(X)â‰¤Î»2â¢(X)â‰¤â‹¯â‰¤Î»nâ¢(X)subscriptğœ†1ğ‘‹subscriptğœ†2ğ‘‹â‹¯subscriptğœ†ğ‘›ğ‘‹\lambda_{1}(X)\leq\lambda_{2}(X)\leq\dots\leq\lambda_{n}(X)italic_Î» start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X ) â‰¤ italic_Î» start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X ) â‰¤ â‹¯ â‰¤ italic_Î» start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_X ) are the eigenvalues of Xğ‘‹Xitalic_X in ascending order. For matrices X,Yâˆˆâ„nÃ—mğ‘‹ğ‘Œsuperscriptâ„ğ‘›ğ‘šX,Y\in\mathbb{R}^{n\times m}italic_X , italic_Y âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_m end_POSTSUPERSCRIPT, âŸ¨X,YâŸ©=Trâ¡(XTâ¢Y)ğ‘‹ğ‘ŒTrsuperscriptğ‘‹ğ‘‡ğ‘Œ\left\langle X,Y\right\rangle=\operatorname{Tr}(X^{T}Y)âŸ¨ italic_X , italic_Y âŸ© = roman_Tr ( italic_X start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT italic_Y ) is the standard inner product on â„nÃ—msuperscriptâ„ğ‘›ğ‘š\mathbb{R}^{n\times m}blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_m end_POSTSUPERSCRIPT, XâŠ™Ydirect-productğ‘‹ğ‘ŒX\odot Yitalic_X âŠ™ italic_Y is the entry-wise or Hadamard product, âˆ¥Xâˆ¥F=âŸ¨X,XâŸ©subscriptdelimited-âˆ¥âˆ¥ğ‘‹ğ¹ğ‘‹ğ‘‹\left\lVert X\right\rVert_{F}=\sqrt{\left\langle X,X\right\rangle}âˆ¥ italic_X âˆ¥ start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT = square-root start_ARG âŸ¨ italic_X , italic_X âŸ© end_ARG is the Frobenius norm on â„nÃ—msuperscriptâ„ğ‘›ğ‘š\mathbb{R}^{n\times m}blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_m end_POSTSUPERSCRIPT, Xi:âˆˆâ„msubscriptğ‘‹:ğ‘–absentsuperscriptâ„ğ‘šX_{i:}\in\mathbb{R}^{m}italic_X start_POSTSUBSCRIPT italic_i : end_POSTSUBSCRIPT âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT is the iğ‘–iitalic_i-th row of Xğ‘‹Xitalic_X and X:jâˆˆâ„nsubscriptğ‘‹:absentğ‘—superscriptâ„ğ‘›X_{:j}\in\mathbb{R}^{n}italic_X start_POSTSUBSCRIPT : italic_j end_POSTSUBSCRIPT âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is the jğ‘—jitalic_j-th column of Xğ‘‹Xitalic_X. For Xâˆˆâ„nÃ—mğ‘‹superscriptâ„ğ‘›ğ‘šX\in\mathbb{R}^{n\times m}italic_X âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_m end_POSTSUPERSCRIPT, âˆ¥Xâˆ¥delimited-âˆ¥âˆ¥ğ‘‹\left\lVert X\right\rVertâˆ¥ italic_X âˆ¥ is the spectral or â„“2subscriptâ„“2\ell_{2}roman_â„“ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT operator norm of Xğ‘‹Xitalic_X and âˆ¥Xâˆ¥âˆsubscriptdelimited-âˆ¥âˆ¥ğ‘‹\left\lVert X\right\rVert_{\infty}âˆ¥ italic_X âˆ¥ start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT is the â„“âˆsubscriptâ„“\ell_{\infty}roman_â„“ start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT-norm of Xğ‘‹Xitalic_X i.e. the maximum entry in absolute value. The operator ddiag:â„nÃ—nâ†’ğ•ŠnÃ—n:ddiagâ†’superscriptâ„ğ‘›ğ‘›superscriptğ•Šğ‘›ğ‘›\operatorname{ddiag}:\mathbb{R}^{n\times n}\to\mathbb{S}^{n\times n}roman_ddiag : blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT â†’ blackboard_S start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT zeroes out all the non diagonal entries of a matrix and for any vector xâˆˆâ„nğ‘¥superscriptâ„ğ‘›x\in\mathbb{R}^{n}italic_x âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, diagâ¡(x)âˆˆğ•ŠnÃ—ndiagğ‘¥superscriptğ•Šğ‘›ğ‘›\operatorname{diag}(x)\in\mathbb{S}^{n\times n}roman_diag ( italic_x ) âˆˆ blackboard_S start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT is the diagonal matrix with the coordinates of xğ‘¥xitalic_x on the diagonal. For any x,yâˆˆâ„ğ‘¥ğ‘¦â„x,y\in\mathbb{R}italic_x , italic_y âˆˆ blackboard_R the notation xâ‰²yless-than-or-similar-toğ‘¥ğ‘¦x\lesssim yitalic_x â‰² italic_y means that there exists a constant C>0ğ¶0C>0italic_C > 0 that does not depend on any parameter, such that xâ‰¤Câ¢yğ‘¥ğ¶ğ‘¦x\leq Cyitalic_x â‰¤ italic_C italic_y. For any vector xâˆˆâ„nğ‘¥superscriptâ„ğ‘›x\in\mathbb{R}^{n}italic_x âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, âˆ¥xâˆ¥delimited-âˆ¥âˆ¥ğ‘¥\left\lVert x\right\rVertâˆ¥ italic_x âˆ¥ is the Euclidean norm of xğ‘¥xitalic_x, ğŸn=(1â¢â€¦â¢1)Tâˆˆâ„nsubscript1ğ‘›superscript1â€¦1ğ‘‡superscriptâ„ğ‘›\operatorname{\mathbf{1}}_{n}=(1\dots 1)^{T}\in\mathbb{R}^{n}bold_1 start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT = ( 1 â€¦ 1 ) start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT."
https://arxiv.org/html/2411.03096v1,On the Complexity of Pure-State Consistency of Local Density Matrices,"In this work we investigate the computational complexity of the pure consistency of local density matrices (ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM) and pure Nğ‘Nitalic_N-representability (ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability) problems. In these problems the input is a set of reduced density matrices and the task is to determine whether there exists a global pure state consistent with these reduced density matrices. While mixed ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM, i.e. where the global state can be mixed, was proven to be ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-complete by Broadbent and Grilo [JoC 2022], almost nothing was known about the complexity of the pure version. Before our work the best upper and lower bounds were ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ) and ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA. Our contribution to the understanding of these problems is twofold.Firstly, we define a pure state analogue of the complexity class ğ–°ğ–¬ğ– +limit-fromğ–°ğ–¬ğ– \mathsf{QMA}{+}sansserif_QMA + of Aharanov and Regev [FOCS 2003], which we call ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA. We prove that both ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability and ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM are complete for this new class. Along the way we supplement Broadbent and Grilo by proving hardness for 2-qubit reduced density matrices and showing that mixed Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’N\mathchar 45\relax\mathsf{Representability}italic_N - sansserif_Representability is ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA complete.Secondly, we improve the upper bound on ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM. Using methods from algebraic geometry, we prove that ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– âŠ†ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PureSuperQMA}\subseteq\mathsf{PSPACE}sansserif_PureSuperQMA âŠ† sansserif_PSPACE. Our methods, and the ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE upper bound, are also valid for ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM with exponential or even perfect precision, hence ğ—‰ğ—‹ğ–¾ğ–¼ğ—‚ğ—Œğ–¾âˆ’ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ—‰ğ—‹ğ–¾ğ–¼ğ—‚ğ—Œğ–¾ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{precise\mathchar 45\relax PureCLDM}sansserif_precise - sansserif_PureCLDM is not ğ—‰ğ—‹ğ–¾ğ–¼ğ—‚ğ—Œğ–¾âˆ’ğ–°ğ–¬ğ– â¢(ğŸ¤)=ğ–­ğ–¤ğ–·ğ–¯ğ—‰ğ—‹ğ–¾ğ–¼ğ—‚ğ—Œğ–¾ğ–°ğ–¬ğ– 2ğ–­ğ–¤ğ–·ğ–¯\mathsf{precise\mathchar 45\relax QMA(2)}=\mathsf{NEXP}sansserif_precise - sansserif_QMA ( sansserif_2 ) = sansserif_NEXP-complete, unless ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤=ğ–­ğ–¤ğ–·ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–­ğ–¤ğ–·ğ–¯\mathsf{PSPACE}=\mathsf{NEXP}sansserif_PSPACE = sansserif_NEXP. We view this as evidence for a negative answer to the longstanding open question whether ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM is ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )-complete.","â€œAre these local density matrices consistent with some global state?â€ This problem, known as the consistency of local density matrices problem (ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM) or quantum marginal problem, and as the Nğ‘Nitalic_N-representability problem (Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’N\mathchar 45\relax\mathsf{Representability}italic_N - sansserif_Representability) when dealing with indistinguishable particles, is of fundamental importance to quantum physics. In fact, it was already recognized as an important question in the sixties [Col63]. At that time, the hope was that the ground state energy of quantum systems could be found using reduced density matrices. This hope was supported by the fact that Hamiltonians showing up in nature are all local. One requirement would be that it is possible to check that alleged reduced density matrices are indeed consistent with a valid global quantum state, hence the interest in the ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM problem. Over the years it became apparent that this hope would not materialize, especially when Kitaev proved that computing ground state energies of local Hamiltonians is ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-hard [KSV02]. Also the ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM problem itself was proven to be hard. First by Liu, who proved that the (mixed state) ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM problem is contained in ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA and ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-complete under Turing reductions [Liu06] and later, together with Christandl and Verstraete, proved that the Nğ‘Nitalic_N-representability problem is also ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-complete under Turing reductions [LCV07]. This was improved by Broadbent and Grilo who showed that the mixed ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM is also ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-hard under Karp reductions, establishing it as ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA complete [BG22]. While the complexity of the mixed ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM and mixed Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’N\mathchar 45\relax\mathsf{Representability}italic_N - sansserif_Representability is quite well understood, our understanding of the pure versions, ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM and ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability, is limited. In these pure versions, one imposes the additional restriction that the consistent state should be pure. This restriction is quite natural as an (isolated) quantum system whose state is known exactly will be in a pure state [NC10]. Whereas mixed ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM is contained in ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA, it is unknown whether a similar containment holds for ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM. Instead, Liu, Christandl and Verstraete prove a ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ) upper bound to the fermionic ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability. They leave completeness as an open problem, one that remains open to this day. A similar upper bound for the bosonic ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability was proven in [WMN10]. However, as the best known upper bound to ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ) is ğ–­ğ–¤ğ–·ğ–¯ğ–­ğ–¤ğ–·ğ–¯\mathsf{NEXP}sansserif_NEXP, these results do not narrow down the complexity of ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability much. Our results In this work we investigate the complexity of ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM and ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability and give evidence towards a negative answer to the longstanding open question whether they are ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )-complete. Definition 1.1 (kâˆ’ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ‘˜ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬k\mathchar 45\relax\mathsf{PureCLDM}italic_k - sansserif_PureCLDM, informal). We are given pairs (Ïm,Cm),â€¦,(Ïm,Cm)subscriptğœŒğ‘šsubscriptğ¶ğ‘šâ€¦subscriptğœŒğ‘šsubscriptğ¶ğ‘š(\rho_{m},C_{m}),\dots,(\rho_{m},C_{m})( italic_Ï start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT , italic_C start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT ) , â€¦ , ( italic_Ï start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT , italic_C start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT ), where the ÏisubscriptğœŒğ‘–\rho_{i}italic_Ï start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT are reduced density matrices and CiâŠ†[n]subscriptğ¶ğ‘–delimited-[]ğ‘›C_{i}\subseteq[n]italic_C start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âŠ† [ italic_n ] with |Ci|â‰¤ksubscriptğ¶ğ‘–ğ‘˜\lvert C_{i}\rvert\leq k| italic_C start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT | â‰¤ italic_k for all iğ‘–iitalic_i. Additionally, we are given parameters Î±ğ›¼\alphaitalic_Î± and Î²ğ›½\betaitalic_Î² with Î²âˆ’Î±â‰¥1/polyâ¡(n)ğ›½ğ›¼1polyğ‘›\beta-\alpha\geq 1/\operatorname{poly}(n)italic_Î² - italic_Î± â‰¥ 1 / roman_poly ( italic_n ). Decide whether: â€¢ YES: there exists a consistent pure state, that is, a state |ÏˆâŸ©delimited-|âŸ©ğœ“\lvert\psi\rangle| italic_Ïˆ âŸ© such that âˆ¥TrCiÂ¯(|ÏˆâŸ©âŸ¨Ïˆ|)âˆ’Ïiâˆ¥â‰¤Î±\lVert\operatorname{Tr}_{\overline{C_{i}}}(\lvert\psi\rangle\langle\psi\rvert)% -\rho_{i}\rVert\leq\alphaâˆ¥ roman_Tr start_POSTSUBSCRIPT overÂ¯ start_ARG italic_C start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG end_POSTSUBSCRIPT ( | italic_Ïˆ âŸ© âŸ¨ italic_Ïˆ | ) - italic_Ï start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âˆ¥ â‰¤ italic_Î± for all iâˆˆ[m]ğ‘–delimited-[]ğ‘ši\in[m]italic_i âˆˆ [ italic_m ]. â€¢ NO: all pure states are â€œfar fromâ€ consistent, that is, for all |ÏˆâŸ©delimited-|âŸ©ğœ“\lvert\psi\rangle| italic_Ïˆ âŸ©, there is an iâˆˆ[m]ğ‘–delimited-[]ğ‘ši\in[m]italic_i âˆˆ [ italic_m ] with âˆ¥TrCiÂ¯(|ÏˆâŸ©âŸ¨Ïˆ|)âˆ’Ïiâˆ¥â‰¥Î²\lVert\operatorname{Tr}_{\overline{C_{i}}}(\lvert\psi\rangle\langle\psi\rvert)% -\rho_{i}\rVert\geq\betaâˆ¥ roman_Tr start_POSTSUBSCRIPT overÂ¯ start_ARG italic_C start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG end_POSTSUBSCRIPT ( | italic_Ïˆ âŸ© âŸ¨ italic_Ïˆ | ) - italic_Ï start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âˆ¥ â‰¥ italic_Î² We begin our study of the complexity of ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM by defining a new complexity class, which we call ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA, inspired by the class ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{SuperQMA}sansserif_SuperQMA222ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{SuperQMA}sansserif_SuperQMA was called ğ–°ğ–¬ğ– +limit-fromğ–°ğ–¬ğ– \mathsf{QMA}{+}sansserif_QMA + in [AR03], but recently ğ–°ğ–¬ğ– +superscriptğ–°ğ–¬ğ– \mathsf{QMA}^{+}sansserif_QMA start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT has been used to refer to ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA with proofs with nonnegative amplitudes [JW23, BFM24]. As ğ–°ğ–¬ğ– +limit-fromğ–°ğ–¬ğ– \mathsf{QMA}{+}sansserif_QMA + is sometimes referred to as ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA with a super-verifier, we use ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{SuperQMA}sansserif_SuperQMA. from [AR03]. Definition 1.2 (ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA, informal). A promise problem Ağ´Aitalic_A is in ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– â¢(m,Îµ,Î´)ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ‘šğœ€ğ›¿\mathsf{PureSuperQMA}(m,\varepsilon,\delta)sansserif_PureSuperQMA ( italic_m , italic_Îµ , italic_Î´ ) if there exist mğ‘šmitalic_m constraints ğ’±={(Vx,i,rx,i,sx,i)}iâˆˆ[m]ğ’±subscriptsubscriptğ‘‰ğ‘¥ğ‘–subscriptğ‘Ÿğ‘¥ğ‘–subscriptğ‘ ğ‘¥ğ‘–ğ‘–delimited-[]ğ‘š\mathcal{V}=\{(V_{x,i},r_{x,i},s_{x,i})\}_{i\in[m]}caligraphic_V = { ( italic_V start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT , italic_r start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT ) } start_POSTSUBSCRIPT italic_i âˆˆ [ italic_m ] end_POSTSUBSCRIPT such that: â€¢ âˆ€xâˆˆAyesâˆƒ|ÏˆâŸ©:Pri(|p(Vx,i,Ïˆ)âˆ’rx,i|â‰¤sx,i)=1\forall x\in A_{\textup{yes}}\;\exists\lvert\psi\rangle\colon\Pr_{i}(\lvert p(% V_{x,i},\psi)-r_{x,i}\rvert\leq s_{x,i})=1âˆ€ italic_x âˆˆ italic_A start_POSTSUBSCRIPT yes end_POSTSUBSCRIPT âˆƒ | italic_Ïˆ âŸ© : roman_Pr start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( | italic_p ( italic_V start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT , italic_Ïˆ ) - italic_r start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT | â‰¤ italic_s start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT ) = 1, that is, the Vx,isubscriptğ‘‰ğ‘¥ğ‘–V_{x,i}italic_V start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT accept |ÏˆâŸ©delimited-|âŸ©ğœ“\lvert\psi\rangle| italic_Ïˆ âŸ© with acceptance probability at most sx,isubscriptğ‘ ğ‘¥ğ‘–s_{x,i}italic_s start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT away from rx,isubscriptğ‘Ÿğ‘¥ğ‘–r_{x,i}italic_r start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT. â€¢ âˆ€xâˆˆAnoâˆ€|ÏˆâŸ©:Pri(|p(Vx,i,Ïˆ)âˆ’rx,i|â‰¤sx,i+Îµ)â‰¤1âˆ’Î´\forall x\in A_{\textup{no}}\;\forall\lvert\psi\rangle\colon\Pr_{i}(\lvert p(V% _{x,i},\psi)-r_{x,i}\rvert\leq s_{x,i}+\varepsilon)\leq 1-\deltaâˆ€ italic_x âˆˆ italic_A start_POSTSUBSCRIPT no end_POSTSUBSCRIPT âˆ€ | italic_Ïˆ âŸ© : roman_Pr start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( | italic_p ( italic_V start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT , italic_Ïˆ ) - italic_r start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT | â‰¤ italic_s start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT + italic_Îµ ) â‰¤ 1 - italic_Î´, that is, at least a Î´ğ›¿\deltaitalic_Î´ fraction of the Vx,isubscriptğ‘‰ğ‘¥ğ‘–V_{x,i}italic_V start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT accept |ÏˆâŸ©delimited-|âŸ©ğœ“\lvert\psi\rangle| italic_Ïˆ âŸ© with probability more than sx,i+Îµsubscriptğ‘ ğ‘¥ğ‘–ğœ€s_{x,i}+\varepsilonitalic_s start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT + italic_Îµ away from rx,isubscriptğ‘Ÿğ‘¥ğ‘–r_{x,i}italic_r start_POSTSUBSCRIPT italic_x , italic_i end_POSTSUBSCRIPT. We denote the union of ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– â¢(m,Îµ,Î´)ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ‘šğœ€ğ›¿\mathsf{PureSuperQMA}(m,\varepsilon,\delta)sansserif_PureSuperQMA ( italic_m , italic_Îµ , italic_Î´ ) where mğ‘šmitalic_m is polynomial and Îµğœ€\varepsilonitalic_Îµ and Î´ğ›¿\deltaitalic_Î´ are inverse polynomial as ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– â¢(poly,1/poly,1/poly)-:ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– -:ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– poly1poly1polyğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}(\operatorname{poly},1/\operatorname{poly},1/% \operatorname{poly})\eqcolon\mathsf{PureSuperQMA}sansserif_PureSuperQMA ( roman_poly , 1 / roman_poly , 1 / roman_poly ) -: sansserif_PureSuperQMA. We prove that by varying the parameters of ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA one gets a range of complexity classes going all the way up to ğ–­ğ–¤ğ–·ğ–¯ğ–­ğ–¤ğ–·ğ–¯\mathsf{NEXP}sansserif_NEXP: Proposition 1.3. ğ–°ğ–¬ğ– âŠ†ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– âŠ†ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– â¢(exp,1/poly,1/poly)âŠ†ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– 1poly1polyğ–°ğ–¬ğ– 2\mathsf{QMA}\subseteq\mathsf{PureSuperQMA}\subseteq\mathsf{PureSuperQMA}(\exp,% 1/\operatorname{poly},1/\operatorname{poly})\subseteq\mathsf{QMA}(2)sansserif_QMA âŠ† sansserif_PureSuperQMA âŠ† sansserif_PureSuperQMA ( roman_exp , 1 / roman_poly , 1 / roman_poly ) âŠ† sansserif_QMA ( 2 ). Proposition 1.4. ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– â¢(exp,1/exp,1/exp)=ğ–­ğ–¤ğ–·ğ–¯ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– 11ğ–­ğ–¤ğ–·ğ–¯\mathsf{PureSuperQMA}(\exp,1/\exp,1/\exp)=\mathsf{NEXP}sansserif_PureSuperQMA ( roman_exp , 1 / roman_exp , 1 / roman_exp ) = sansserif_NEXP Next, we give a â€œnormal formâ€ for ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA. We show that the complexity does not change if we restrict ourselves to constraints (Vi,ri,si)subscriptğ‘‰ğ‘–subscriptğ‘Ÿğ‘–subscriptğ‘ ğ‘–(V_{i},r_{i},s_{i})( italic_V start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_r start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) with ri=12subscriptğ‘Ÿğ‘–12r_{i}=\frac{1}{2}italic_r start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = divide start_ARG 1 end_ARG start_ARG 2 end_ARG and si=0subscriptğ‘ ğ‘–0s_{i}=0italic_s start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = 0. We use this to prove our first main result, which is that ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA captures the complexity of ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM. In fact, we are able to show hardness even for kâˆ’ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬1ğ‘˜subscriptğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬1k\mathchar 45\relax\mathsf{PureCLDM}_{1}italic_k - sansserif_PureCLDM start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, which is kâˆ’ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ‘˜ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬k\mathchar 45\relax\mathsf{PureCLDM}italic_k - sansserif_PureCLDM with â€œexact consistencyâ€ (Î±=0ğ›¼0\alpha=0italic_Î± = 0). Theorem 1.5. kâˆ’ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬1ğ‘˜subscriptğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬1k\mathchar 45\relax\mathsf{PureCLDM}_{1}italic_k - sansserif_PureCLDM start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT is ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA-complete for all kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2. We also show completeness for both fermionic and bosonic ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability. Theorem 1.6. Fermionic ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’1ğ–¯ğ—ğ—‹ğ–¾ğ‘subscriptğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’1\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}_{1}sansserif_Pure - italic_N - sansserif_Representability start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT is ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA-complete. Theorem 1.7. Bosonic ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’1ğ–¯ğ—ğ—‹ğ–¾ğ‘subscriptğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’1\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}_{1}sansserif_Pure - italic_N - sansserif_Representability start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT is ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA-complete. Combining Propositions 1.3 and 1.5 we conclude that ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA can only be ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )-complete if a polynomial number of constraints give the same power as exponentially many constraints. Corollary 1.8. If ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– â¢(poly,1/poly,1/poly)âŠŠğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– â¢(exp,1/poly,1/poly)ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– poly1poly1polyğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– 1poly1poly\mathsf{PureSuperQMA}(\operatorname{poly},1/\operatorname{poly},1/% \operatorname{poly})\subsetneq\mathsf{PureSuperQMA}(\exp,1/\operatorname{poly}% ,1/\operatorname{poly})sansserif_PureSuperQMA ( roman_poly , 1 / roman_poly , 1 / roman_poly ) âŠŠ sansserif_PureSuperQMA ( roman_exp , 1 / roman_poly , 1 / roman_poly ), then ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM is not ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )-hard. Along the way to Theorem 1.5, we show that the kâˆ’ğ–¢ğ–«ğ–£ğ–¬ğ‘˜ğ–¢ğ–«ğ–£ğ–¬k\mathchar 45\relax\mathsf{CLDM}italic_k - sansserif_CLDM problem is already ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-hard for kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2. This improves upon the results by Broadbent and Grilo [BG22] who show hardness for kâ‰¥5ğ‘˜5k\geq 5italic_k â‰¥ 5. We also resolve one of their open questions by showing that the (mixed) fermionic and bosonic Nğ‘Nitalic_N-representability problems are ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-hard, already for 2222-particle reduced density matrices. Having proven Theorem 1.5, we address the relation between ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA and other complexity classes. Our second main result sharpens the upper bound on the complexity of ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM from ğ–°ğ–¬ğ– â¢(2)âŠ†ğ–­ğ–¤ğ–·ğ–¯ğ–°ğ–¬ğ– 2ğ–­ğ–¤ğ–·ğ–¯\mathsf{QMA}(2)\subseteq\mathsf{NEXP}sansserif_QMA ( 2 ) âŠ† sansserif_NEXP to ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE. Theorem 1.9. ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– âŠ†ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PureSuperQMA}\subseteq\mathsf{PSPACE}sansserif_PureSuperQMA âŠ† sansserif_PSPACE. What does this mean for ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )? Of course showing that ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM is ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )-hard would imply ğ–°ğ–¬ğ– â¢(2)âŠ†ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–°ğ–¬ğ– 2ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{QMA}(2)\subseteq\mathsf{PSPACE}sansserif_QMA ( 2 ) âŠ† sansserif_PSPACE but there is a catch. To prove Theorem 1.9 we use methods from algebraic geometry that also work for ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA with exponential precision and even with perfect precision. This allows us to obtain the following corollary which can be interpreted as evidence that ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM is not ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )-hard. Corollary 1.10. If ğ—‰ğ—‹ğ–¾ğ–¼ğ—‚ğ—Œğ–¾âˆ’ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ—‰ğ—‹ğ–¾ğ–¼ğ—‚ğ—Œğ–¾ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{precise\mathchar 45\relax PureCLDM}sansserif_precise - sansserif_PureCLDM is ğ–°ğ–¬ğ– â¢(2)ğ–¾ğ—‘ğ—‰ğ–°ğ–¬ğ– subscript2ğ–¾ğ—‘ğ—‰\mathsf{QMA}(2)_{\mathsf{exp}}sansserif_QMA ( 2 ) start_POSTSUBSCRIPT sansserif_exp end_POSTSUBSCRIPT-hard, then ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤=ğ–­ğ–¤ğ–·ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–­ğ–¤ğ–·ğ–¯\mathsf{PSPACE}=\mathsf{NEXP}sansserif_PSPACE = sansserif_NEXP. This means that, assuming ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤â‰ ğ–­ğ–¤ğ–·ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–­ğ–¤ğ–·ğ–¯\mathsf{PSPACE}\neq\mathsf{NEXP}sansserif_PSPACE â‰  sansserif_NEXP, any ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )-hardness proof for ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM must fail for their precise versions. To prove Theorem 1.9 we rely results by Grigoriev and Pasechnik [GP05] that can solve certain large polynomials in exponential time. We modify their algorithm to work in ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE and get the following result which is worth stating in its own right. Theorem 1.11 (informal). Let p:â„nâ†’â„:ğ‘â†’superscriptâ„ğ‘›â„p\colon\mathbb{R}^{n}\to\mathbb{R}italic_p : blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ blackboard_R and Q:â„Nâ†’â„n:ğ‘„â†’superscriptâ„ğ‘superscriptâ„ğ‘›Q\colon\mathbb{R}^{N}\to\mathbb{R}^{n}italic_Q : blackboard_R start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT â†’ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT be polynomials where the degree of Qğ‘„Qitalic_Q is at most 2 and N=2nğ‘superscript2ğ‘›N=2^{n}italic_N = 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. Assume that the zeros of pâ¢(Qâ¢(X))ğ‘ğ‘„ğ‘‹p(Q(X))italic_p ( italic_Q ( italic_X ) ) are bounded. Then there exists a ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE algorithm for determining whether pâ¢(Qâ¢(X))=0ğ‘ğ‘„ğ‘‹0p(Q(X))=0italic_p ( italic_Q ( italic_X ) ) = 0 has a solution. We also show that approximate solutions to pâ¢(Qâ¢(X))ğ‘ğ‘„ğ‘‹p(Q(X))italic_p ( italic_Q ( italic_X ) ) can be computed in (function) ğ–­ğ–¢â¢(poly)ğ–­ğ–¢poly\mathsf{NC}(\operatorname{poly})sansserif_NC ( roman_poly ). Hence an approximately consistent state for a given ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM instance can be computed in ğ–­ğ–¢â¢(poly)ğ–­ğ–¢poly\mathsf{NC}(\operatorname{poly})sansserif_NC ( roman_poly ), if this exists. Finally, we showcase the applicability Theorem 1.11 by giving some applications. In the first of these applications we improve upon a result by Shi and Wu. In [SW15] they give a ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE algorithm for optimizing the energy of â€œdecomposableâ€ Hamiltonians over separable states. Using our framework we are able to reprove this fact, and even get a better runtime dependence on the error. As a second application, we show that deciding if there exists a unique333We say a state |Ï•âŸ©delimited-|âŸ©italic-Ï•\lvert\phi\rangle| italic_Ï• âŸ© is the unique state consistent with some local density matrices if any state that is orthogonal to |Ï•âŸ©delimited-|âŸ©italic-Ï•\lvert\phi\rangle| italic_Ï• âŸ© is far from consistent. pure state that is consistent with given local density matrices is also in ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE. In other words, we can decide in ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE whether the local density matrices fully describe the physics of the system. As a final application, we show how to decide a variant of ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM, where the input only specifies the spectrum of the local density matrices. This version is sometimes referred to as the quantum marginal problem, although others use that name for our ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM. Proof techniques We now sketch the proofs of our main theorems, organized by topic. ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA-hardness. The proof of the ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA-completeness of ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM closely follows Broadbent and Griloâ€™s proof of the ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-hardness of the mixed ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM problem but with several key changes. Before we elaborate on those, let us sketch the original proof. Starting with an arbitrary ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-verifier Vğ‘‰Vitalic_V, one can use Kitaevâ€™s circuit-to-Hamiltonian construction to obtain a Hamiltonian whose low energy states include the history state of the computation. One would like to construct local density matrices that are consistent with a global state (the history state) if and only if the original computation was accepting. However, one obstacle is the dependence of the history state on the witness (or proof) state. To circumvent this problem, Broadbent and Grilo use sğ‘ sitalic_s-simulatable codes from [GSY19]. These are codes whose codewords are sğ‘ sitalic_s-simulatable, that is, their reduced density matrices on at most sğ‘ sitalic_s qubits can be efficiently computed by a classical algorithm, just like their evolution under local unitaries. They now consider a different verification circuit Vâ€²superscriptğ‘‰â€²V^{\prime}italic_V start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT that implements the original circuit Vğ‘‰Vitalic_V on data encoded with such an sğ‘ sitalic_s-simulatable code, starting from a similarly encoded proof state. From the properties of the code, it follows that the reduced density matrices of the history state corresponding to Vâ€²superscriptğ‘‰â€²V^{\prime}italic_V start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT can be efficiently constructed. As the final step of the proof, it is shown that these reduced density matrices indeed are consistent if and only if the original computation was accepting. To adapt this approach to our needs we make several important changes. 1. To make sure that the proof is indeed encoded correctly, Broadbent and Grilo add a step to their protocol enforcing this, which essentially boils down to decoding and immediately encoding again. To make sure that the reduced density matrices can also be computed during this process, they ask for the proof as encrypted by a one-time pad, together with the keys. This one-time pad is then undone only after checking the encoding. It is this one-time padding that makes the consistent state a mixed state, which we want to avoid. To do so we reduce the number of possible one-time pad keys and do a separate check for each key. We do this by using the same key for the one-time pad encryption of every qubit. This means that individual proof qubits are still in a maximally mixed state, but there are only 4444 different keys. We abstract this change away into a modified super-verifier that has an accepting proof with maximally mixed 1111-local density matrices (see Section 3.1.2). 2. We use the 2222-local circuit-to-Hamiltonian construction of [KKR06] instead of Kitaevâ€™s original 5555-local construction [KSV02]. This is so we can easily extend to the Nğ‘Nitalic_N-representability problem, which is ordinarily defined with 2222-particle density matrices. Using this different construction causes some technical issues. To resolve these we introduce an â€œExtraction Lemmaâ€, which allows extracting 1111-local density matrices at certain time steps from the 2222-local density matrices of the history state (see Section 3.1.2). 3. We need to check the proof against multiple constraints. For each constraint, we apply its circuit, decode the output qubit, encode the output qubit, and finally undo the circuit (see Section 3.1.3). The output probability can be extract from the time step between decoding and encoding. ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE upper bound. The main obstacle to prove the ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE upper bound is that the purity constraint is not a convex constraint. This prevents convex optimization approaches from being used, which are the standard for proving containment in ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE. We take a wholly different approach: we convert a ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA instance into a system of polynomials and use methods from algebraic geometry to solve these. We begin by writing Pr(Vi accepts |ÏˆâŸ©)âˆ’12\Pr(V_{i}\text{ accepts }\lvert\psi\rangle)-\frac{1}{2}roman_Pr ( italic_V start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT accepts | italic_Ïˆ âŸ© ) - divide start_ARG 1 end_ARG start_ARG 2 end_ARG as a real multivariate polynomial. The real and complex parts of every coefficient of the proof state will be represented by separate variables. This yields for every constraint Visubscriptğ‘‰ğ‘–V_{i}italic_V start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, a polynomial Qi:â„2â¢Nâ†’â„:subscriptğ‘„ğ‘–â†’superscriptâ„2ğ‘â„Q_{i}\colon\mathbb{R}^{2N}\to\mathbb{R}italic_Q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT : blackboard_R start_POSTSUPERSCRIPT 2 italic_N end_POSTSUPERSCRIPT â†’ blackboard_R, where N=2nğ‘superscript2ğ‘›N=2^{n}italic_N = 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is the dimension of the proof state. These Qisubscriptğ‘„ğ‘–Q_{i}italic_Q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT are polynomials in exponentially many variables, which might seem bad as it is ğ–­ğ–¤ğ–·ğ–¯ğ–­ğ–¤ğ–·ğ–¯\mathsf{NEXP}sansserif_NEXP-hard to determine if a general polynomial in exponentially many variables of degree â‰¥4absent4\geq 4â‰¥ 4 has a zero.444The statement for degree dâ‰¥4ğ‘‘4d\geq 4italic_d â‰¥ 4 follows because linear programming over 0âˆ’1010\mathchar 45\relax 10 - 1 with exponentially many variables is ğ–­ğ–¤ğ–·ğ–¯ğ–­ğ–¤ğ–·ğ–¯\mathsf{NEXP}sansserif_NEXP-hard. Restriction to 0âˆ’1010\mathchar 45\relax 10 - 1 can be enforced by the quartic polynomial equality âˆ‘i(xi2âˆ’1)2=0subscriptğ‘–superscriptsuperscriptsubscriptğ‘¥ğ‘–2120\sum_{i}(x_{i}^{2}-1)^{2}=0âˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - 1 ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = 0. It is also ğ–­ğ–¤ğ–·ğ–¯ğ–­ğ–¤ğ–·ğ–¯\mathsf{NEXP}sansserif_NEXP hard to determine if a system of degree 3333 polynomials has a zero. To see this we use ğ–°ğ–¬ğ– â¢(2)ğ–¾ğ—‘ğ—‰=ğ–­ğ–¤ğ–·ğ–¯ğ–°ğ–¬ğ– subscript2ğ–¾ğ—‘ğ—‰ğ–­ğ–¤ğ–·ğ–¯\mathsf{QMA}(2)_{\mathsf{exp}}=\mathsf{NEXP}sansserif_QMA ( 2 ) start_POSTSUBSCRIPT sansserif_exp end_POSTSUBSCRIPT = sansserif_NEXP. The acceptance probability âŸ¨Ïˆ|Î aâ¢câ¢c|ÏˆâŸ©\langle\psi\rvert\Pi_{acc}\lvert\psi\rangleâŸ¨ italic_Ïˆ | roman_Î  start_POSTSUBSCRIPT italic_a italic_c italic_c end_POSTSUBSCRIPT | italic_Ïˆ âŸ© is a quadratic polynomial and the restriction to separable proofs can be enforced using the degree 3333 polynomial âŸ¨Ïˆ|(|Ï•1âŸ©âŠ—|Ï•2âŸ©)âˆ’1=0\langle\psi\rvert(\lvert\phi_{1}\rangle\otimes\lvert\phi_{2}\rangle)-1=0âŸ¨ italic_Ïˆ | ( | italic_Ï• start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŸ© âŠ— | italic_Ï• start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âŸ© ) - 1 = 0. However, and this turns out to be crucial, the Qisubscriptğ‘„ğ‘–Q_{i}italic_Q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT have a degree of a most 2222. We combine the Qisubscriptğ‘„ğ‘–Q_{i}italic_Q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT by taking another specially constructed polynomial pğ‘pitalic_p, this one with polynomially many variables and degree d=polyâ¡(n)ğ‘‘polyğ‘›d=\operatorname{poly}(n)italic_d = roman_poly ( italic_n ), and considering pâ¢(Qâ¢(X))=0ğ‘ğ‘„ğ‘‹0p(Q(X))=0italic_p ( italic_Q ( italic_X ) ) = 0. We ensure that this latter equation will have a solution iff the ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA verifier accepts. To solve this system, we use results by Grigoriev and Pasechnik [GP05]. To our knowledge, this is the first time these techniques are used in a quantum context. Because the techniques are quite general and powerful we hope they will find more use there. Grigoriev and Pasechnik exhibit an algorithm for solving such systems pâ¢(Qâ¢(X))=0ğ‘ğ‘„ğ‘‹0p(Q(X))=0italic_p ( italic_Q ( italic_X ) ) = 0 with quadratic Qğ‘„Qitalic_Q in exponential time. We will refer to such polynomials as GP systems. We modify their algorithm to get an efficient parallel algorithm, that is, an ğ–­ğ–¢â¢(poly)=ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–­ğ–¢polyğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{NC}(\operatorname{poly})=\mathsf{PSPACE}sansserif_NC ( roman_poly ) = sansserif_PSPACE algorithm for deciding if there is a zero. Broadly, their original algorithm consists of two steps. First, they show how such a system pâ¢(Qâ¢(X))=0ğ‘ğ‘„ğ‘‹0p(Q(X))=0italic_p ( italic_Q ( italic_X ) ) = 0 can be reduced to a set of (exponentially many) different polynomial systems, each consisting of polynomially many equations in only polynomially many variables. These smaller systems are called â€œpiecesâ€. They prove that solutions to the original system, at least one in every connected component, can be recovered from the solutions of the pieces. The pieces could be solved using standard methods in exponential time or ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE, but there is a catch: for the reduction of the number of variables, Grigoriev and Pasechnik rely on three key assumptions. These are almost always555They are generically true. Informally, this means that there is some polynomial that is 0 iff they do not hold. satisfied, but can fail for certain degenerate cases. To circumvent this issue, they consider small perturbations of the original system and show that for sufficiently small values of these perturbations all assumptions are satisfied. Next, they show that the solutions to the original system are exactly equal to the limits of solutions of the perturbed system as the perturbations go to 00. The second part of their work is concerned with the computation of these limits. To get an efficient parallel algorithm, we mostly leave the first step as it is, but compute the limits differently. Whereas Grigoriev and Pasechnik consider the solutions of the perturbed systems as Puiseux series in the (infinitesimal) perturbations, we consider the perturbations as variables and the zeros as a set-valued function of these variables. We show that in this perspective the zeros of the original system are still equal to the limits of the solutions of the perturbed system. Our new perspective allows us to write the limit of the set of solutions as the set of points satisfying some formula in the first-order theory of the reals. A ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE algorithm for deciding the first-order theory of the reals (we use [Ren92-2]) can now be used to determine, for each piece, whether the corresponding solution set is empty. Doing these checks for all of the exponentially many pieces in parallel results in a ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE algorithm for deciding if pâ¢(Qâ¢(X))ğ‘ğ‘„ğ‘‹p(Q(X))italic_p ( italic_Q ( italic_X ) ) has any solutions. The approximation algorithm follows by using an algorithm to find approximate solutions to first-order theory of the reals formulas [Ren92-4]. We cannot directly use this to extract the entire solution though, as the number of entries is too big. Instead, we isolate a solution using a univariate encoding and extract all entries in parallel. With this setup, the three applications that we exhibit follow straightforwardly. We describe how to write them as GP systems, which can then be solved in ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE. Related work The computational complexity of (mixed) ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM and Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’N\mathchar 45\relax\mathsf{Representability}italic_N - sansserif_Representability has previously been studied by Liu, Broadbent and Grilo, as mentioned before. Liu [Liu06] proves that (mixed) ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM is contained in ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA and hard under Turing reductions. Similar results for Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’N\mathchar 45\relax\mathsf{Representability}italic_N - sansserif_Representability are proven in [LCV07]. This was improved by Broadbent and Grilo who proved (among other results regarding zero-knowledge proof systems) that (mixed) ğ–¢ğ–«ğ–£ğ–¬ğ–¢ğ–«ğ–£ğ–¬\mathsf{CLDM}sansserif_CLDM is also ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-hard under Karp reductions, thereby fully resolving its complexity [BG22]. Both Liu, and Broadbent and Grilo do not intensively study ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM, although [LCV07] does show containment of fermionic ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability in ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ), leaving hardness as an open question. A similar containment for bosonic ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability was shown in [WMN10]. That does not mean that ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM and ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability have not been studied before. There is a large body of work focussing on finding necessary and/or sufficient conditions for reduced density matrices to be consistent with a global state. Among these works is [Kly04], which focuses on the case where the reduced density matrices are non-overlapping. The paper establishes conditions that are necessary and sufficient for the existence of a consistent pure state in this case. Mazziotti [Maz16] derives necessary conditions for a two-fermion density matrix to have a consist global Nğ‘Nitalic_N-fermion pure state. [YSWNG21] rewrite ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM as an optimization problem over separable state. They then apply the method of symmetric extensions to this notoriously hard problem to describe ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM as a hierarchy of SDPâ€™s. That is, they describe SDPâ€™s depending on a parameter Nğ‘Nitalic_N such that any â€œNoâ€ instance will be discovered by the SDP for sufficiently large Nğ‘Nitalic_N. They do not, however, prove any upper bounds on the size of Nğ‘Nitalic_N required. In [BFLMW24], the authors consider ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA with an internally separable proof. They prove that when this proof is mixed, the class is contained in ğ–¤ğ–·ğ–¯ğ–¤ğ–·ğ–¯\mathsf{EXP}sansserif_EXP, whereas it is equal to ğ–­ğ–¤ğ–·ğ–¯ğ–­ğ–¤ğ–·ğ–¯\mathsf{NEXP}sansserif_NEXP if the proof is pure. This provides the, to our knowledge first, instance where pure proofs are provably stronger than mixed proofs, modulo standard complexity theoretic assumptions. An algorithm for solving polynomial systems more general than those considered in Theorem 1.11 is given in [Gri13]. It shows that a system of kğ‘˜kitalic_k polynomials of degree dğ‘‘ditalic_d in nğ‘›nitalic_n variables can be solved in time polyâ¡(nd3â¢k)polysuperscriptğ‘›superscriptğ‘‘3ğ‘˜\operatorname{poly}\left(n^{d^{3k}}\right)roman_poly ( italic_n start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT 3 italic_k end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). One downside to this algorithm is that it finds solution over the complex numbers instead of the reals. This makes it hard to constrain the norm of variables, as the complex conjugate is not a polynomial. Discussion and open questions Our work sheds some more light on the complexity of ğ–¯ğ—ğ—‹ğ–¾âˆ’Nâˆ’ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’ğ–¯ğ—ğ—‹ğ–¾ğ‘ğ–±ğ–¾ğ—‰ğ—‹ğ–¾ğ—Œğ–¾ğ—‡ğ—ğ–ºğ–»ğ—‚ğ—…ğ—‚ğ—ğ—’\mathsf{Pure}\mathchar 45\relax N\mathchar 45\relax\mathsf{Representability}sansserif_Pure - italic_N - sansserif_Representability and ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM. However, the story is far from complete as the relation between ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA and ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA or ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE remains poorly understood. We conjecture Conjecture 1.12. ğ–°ğ–¬ğ– âŠŠğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– âŠŠğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– 2\mathsf{QMA}\subsetneq\mathsf{PureSuperQMA}\subsetneq\mathsf{QMA}(2)sansserif_QMA âŠŠ sansserif_PureSuperQMA âŠŠ sansserif_QMA ( 2 ). We give some evidence that ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA differs from ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ). Indeed, we prove that their precise versions are equal only if ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤=ğ–­ğ–¤ğ–·ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–­ğ–¤ğ–·ğ–¯\mathsf{PSPACE}=\mathsf{NEXP}sansserif_PSPACE = sansserif_NEXP. However, this does not necessarily carry over from the precise setting to the â€œstandardâ€ setting. It would therefore be nice to see more evidence that ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– âŠŠğ–°ğ–¬ğ– â¢(2)ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– 2\mathsf{PureSuperQMA}\subsetneq\mathsf{QMA}(2)sansserif_PureSuperQMA âŠŠ sansserif_QMA ( 2 ), such as an oracle separation. Of course, separating ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA from ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ) relative to an oracle is at least as hard as separating ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA from ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ) in this way, something that has been eluding researchers to this date. Perhaps, however, the new perspective offered by ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA can lead to new insights. Recently, it has been suggested that purity testing is at the heart of ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )â€™s power[BFLMW24]. While we provide evidence that ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM is not ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )-hard, that does not mean the end for this suggestion. One way to formalize the idea that ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 )â€™s power derives from purity would be to prove that ğ–°ğ–¬ğ– â¢(2)=ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– â¢(exp,1/poly,1/poly)ğ–°ğ–¬ğ– 2ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– 1poly1poly\mathsf{QMA}(2)=\mathsf{PureSuperQMA}(\exp,1/\operatorname{poly},1/% \operatorname{poly})sansserif_QMA ( 2 ) = sansserif_PureSuperQMA ( roman_exp , 1 / roman_poly , 1 / roman_poly ). Note that our results do not provide evidence against this equality, as the ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE upper bound crucially relies on there being only polynomially many constraints. Lastly, it would be nice to see if the GP system framework used for our ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE upper bound can find other uses. An approach one could take here is to try to use it for a ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE or ğ–¤ğ–·ğ–¯ğ–¤ğ–·ğ–¯\mathsf{EXP}sansserif_EXP upper bound on ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ). There are two main obstacles here. Firstly, any such approach needs to make essential use of the promise gap in order to work for ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ) but not for ğ–°ğ–¬ğ– â¢(2)ğ–¾ğ—‘ğ—‰ğ–°ğ–¬ğ– subscript2ğ–¾ğ—‘ğ—‰\mathsf{QMA}(2)_{\mathsf{exp}}sansserif_QMA ( 2 ) start_POSTSUBSCRIPT sansserif_exp end_POSTSUBSCRIPT (assuming ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤â‰ ğ–­ğ–¤ğ–·ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–­ğ–¤ğ–·ğ–¯\mathsf{PSPACE}\neq\mathsf{NEXP}sansserif_PSPACE â‰  sansserif_NEXP). Secondly, naively converting a ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ) instance into polynomials yields degree 3, for which the techniques from [GP05] no longer work. One potential way around this is to use the fact that [GP05] can find a point in every connected component of the solutions. Perhaps it is possible to write a ğ–°ğ–¬ğ– â¢(2)ğ–°ğ–¬ğ– 2\mathsf{QMA}(2)sansserif_QMA ( 2 ) instance as degree-2 polynomials in such a way that, although invalid solutions666I.e. solutions that do not have the required tensor product structure. may exist, these will not be in the same connected component as the valid solutions. In this case, a valid solution would always be found if one exists. Organization The paper consists of three main parts. In the first part, we formally define ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA and prove some of its properties. The second part is devoted to proving the ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– ğ–¯ğ—ğ—‹ğ–¾ğ–²ğ—ğ—‰ğ–¾ğ—‹ğ–°ğ–¬ğ– \mathsf{PureSuperQMA}sansserif_PureSuperQMA-completeness of ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬ğ–¯ğ—ğ—‹ğ–¾ğ–¢ğ–«ğ–£ğ–¬\mathsf{PureCLDM}sansserif_PureCLDM. The completeness of the bosonic and fermionic Nğ‘Nitalic_N-representability problems are at the end of this section. The last section deals with the ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE upper bound. We will spend particular effort covering the methods from [GP05] here, hoping that this paves the way to their further use. We conclude the section by giving some applications."
https://arxiv.org/html/2411.03006v1,Neural Networks and (Virtual) Extended Formulations,"Neural networks with piecewise linear activation functions, such as rectified linear units (ReLU) or maxout, are among the most fundamental models in modern machine learning. We make a step towards proving lower bounds on the size of such neural networks by linking their representative capabilities to the notion of the extension complexity xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) of a polytope Pğ‘ƒPitalic_P, a well-studied quantity in combinatorial optimization and polyhedral geometry. To this end, we propose the notion of virtual extension complexity vxcâ¡(P)=minâ¡{xcâ¡(Q)+xcâ¡(R)âˆ£P+Q=R}vxcğ‘ƒxcğ‘„conditionalxcğ‘…ğ‘ƒğ‘„ğ‘…\operatorname{vxc}(P)=\min\{\operatorname{xc}(Q)+\operatorname{xc}(R)\mid P+Q=R\}roman_vxc ( italic_P ) = roman_min { roman_xc ( italic_Q ) + roman_xc ( italic_R ) âˆ£ italic_P + italic_Q = italic_R }. This generalizes xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) and describes the number of inequalities needed to represent the linear optimization problem over Pğ‘ƒPitalic_P as a difference of two linear programs. We prove that vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ) is a lower bound on the size of a neural network that optimizes over Pğ‘ƒPitalic_P. While it remains open to derive strong lower bounds on virtual extension complexity, we show that powerful results on the ordinary extension complexity can be converted into lower bounds for monotone neural networks, that is, neural networks with only nonnegative weights. Furthermore, we show that one can efficiently optimize over a polytope Pğ‘ƒPitalic_P using a small virtual extended formulation. We therefore believe that virtual extension complexity deserves to be studied independently from neural networks, just like the ordinary extension complexity. As a first step in this direction, we derive an example showing that extension complexity can go down under Minkowski sum.","While machine learning is nowadays driven by rapid empirical progress, our work focuses on the theoretical understanding of the underlying models and methods. A crucial building block are feedforward neural networks. These are directed, acyclic graphs in which each vertex (neuron) defines a simple computation, usually a linear transformation composed with a scalar-valued, continuous and piecewise linear (CPWL) activation function. While a standard choice for the activation function is the rectified linear unit (ReLU) xâ†¦maxâ¡{0,x}maps-toğ‘¥0ğ‘¥x\mapsto\max\{0,x\}italic_x â†¦ roman_max { 0 , italic_x }, in this paper we focus on the more general maxout networks. These allow to compute the maximum of constantly many linear functions at each neuron. As a result, the entire network computes a (potentially complex) CPWL function. One of the big challenges in the theoretical analysis of neural networks is to understand how many neurons one requires to exactly or approximately represent a given (CPWL) function. To the best of our knowledge, it is an open question whether there exists a family of CPWL functions, which we can evaluate in polynomial time, but which cannot be represented by polynomial-size neural networks. The piecewise linear nature of the studied networks suggests to tackle such questions by means of polyhedral geometry, see, e.g., the recent survey [25]. In fact, a similar problem to the question above used to be open for a long time in the context of linear programming, until RothvoÃŸ [37] resolved it affirmatively: does there exist a polytope Pğ‘ƒPitalic_P over which we can optimize in polynomial time, but any linear programming formulation must have exponential size? This question can be formalized with the notion of extension complexity xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ), which describes the minimal number of facets of any polytope Qğ‘„Qitalic_Q that projects onto Pğ‘ƒPitalic_P. In this case, we call Qğ‘„Qitalic_Q an extended formulation of Pğ‘ƒPitalic_P. RothvoÃŸ [37] proved that the matching polytope has exponential extension complexity even though Edmondsâ€™ algorithm [11] can be used to find the maximum weight matching or minimum weight perfect matching in polynomial time. Additionally, it was also proven that a couple of polytopes associated with NP-hard optimization problems like the travelling salesperson problem have exponential extension complexity [14]. There is a direct translation between polytopes (as feasible sets of linear programs) and CPWL functions (represented by neural networks) through the notion of the support function fPâ¢(c)=maxxâˆˆPâ¡câŠ¤â¢xsubscriptğ‘“ğ‘ƒğ‘subscriptğ‘¥ğ‘ƒsuperscriptğ‘topğ‘¥f_{P}(c)=\max_{x\in P}c^{\top}xitalic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT ( italic_c ) = roman_max start_POSTSUBSCRIPT italic_x âˆˆ italic_P end_POSTSUBSCRIPT italic_c start_POSTSUPERSCRIPT âŠ¤ end_POSTSUPERSCRIPT italic_x of a polytope Pğ‘ƒPitalic_P. This (convex) CPWL function, which has one linear region for each vertex of Pğ‘ƒPitalic_P, uniquely determines Pğ‘ƒPitalic_P via convex duality. Computing fPâ¢(c)subscriptğ‘“ğ‘ƒğ‘f_{P}(c)italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT ( italic_c ) means determining the objective value when optimizing over Pğ‘ƒPitalic_P in cğ‘citalic_c-direction. Each CPWL function fPsubscriptğ‘“ğ‘ƒf_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT can be represented by a neural network [1], though the required number of neurons can be large. To quantify this, we define the neural network complexity nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ) as the minimum number of neurons to represent fPsubscriptğ‘“ğ‘ƒf_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT by a maxout neural network. 1.1 Our Contributions The aim of this paper is to connect the world of extended formulations with the study of neural networks. A â€œdream resultâ€ in this direction would be to bound xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) polynomially in nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ). Then the breakthrough results on extension complexity would directly imply strong lower bounds on the size of neural networks. It turns out, however, that there is one feature of neural networks that seems to make the â€œdream resultâ€ difficult to obtain: namely the ability to use subtraction. To remedy this, we propose the notion of virtual extension complexity vxcâ¡(P)=minâ¡{xcâ¡(Q)+xcâ¡(R)âˆ£Q and R are polytopes with â¢P+Q=R},vxcğ‘ƒxcğ‘„conditionalxcğ‘…Q and R are polytopes with ğ‘ƒğ‘„ğ‘…\operatorname{vxc}(P)=\min\{\operatorname{xc}(Q)+\operatorname{xc}(R)\mid\text% {$Q$ and $R$ are polytopes with }P+Q=R\}\ ,roman_vxc ( italic_P ) = roman_min { roman_xc ( italic_Q ) + roman_xc ( italic_R ) âˆ£ italic_Q and italic_R are polytopes with italic_P + italic_Q = italic_R } , where P+Q={p+qâˆ£pâˆˆP,qâˆˆQ}ğ‘ƒğ‘„conditional-setğ‘ğ‘formulae-sequenceğ‘ğ‘ƒğ‘ğ‘„P+Q=\{p+q\mid p\in P,q\in Q\}italic_P + italic_Q = { italic_p + italic_q âˆ£ italic_p âˆˆ italic_P , italic_q âˆˆ italic_Q } is the Minkowski sum. In this definition, Pğ‘ƒPitalic_P is a (formal) Minkowski difference of two polytopes Qğ‘„Qitalic_Q and Rğ‘…Ritalic_R. Note that this is not the same as R+(âˆ’1)â‹…Qğ‘…â‹…1ğ‘„R+(-1)\cdot Qitalic_R + ( - 1 ) â‹… italic_Q but rather the inverse operation of Minkowski addition. The name virtual extension complexity is derived from virtual polytopes [33], a framework for the algebraic study of formal Minkowski differences of polytopes. Observe that vxcâ¡(P)â‰¤xcâ¡(P)vxcğ‘ƒxcğ‘ƒ\operatorname{vxc}(P)\leq\operatorname{xc}(P)roman_vxc ( italic_P ) â‰¤ roman_xc ( italic_P ) because we can always choose Q={0}ğ‘„0Q=\{0\}italic_Q = { 0 } with xcâ¡({0})=0xc00\operatorname{xc}(\{0\})=0roman_xc ( { 0 } ) = 0. In that sense, virtual extension complexity is really a strengthening of the ordinary extension complexity. In Section 3, we deduce that vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ) is indeed a lower bound for nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ), up to a constant factor. This leaves the open question to find ways to lower-bound vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ) in order to achieve the original goal to lower-bound nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ). A consequence of the discussion above is that, if one removes the ability to subtract within neural networks, we do indeed obtain our â€œdream resultâ€, namely lower bounds through xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ). The resulting model is the one of monotone neural networks, which are neural networks with only nonnegative weights. In analogy to nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ), we define the monotone neural network complexity mnncâ¡(P)mnncğ‘ƒ\operatorname{mnnc}(P)roman_mnnc ( italic_P ) as the minimum number of neurons to represent fPsubscriptğ‘“ğ‘ƒf_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT by a monotone maxout neural network. In Section 4, we show how lower bounds on xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) imply lower bounds on exact and approximate representations of monotone neural networks. Studying monotone neural networks is justified both from a theoretical and a practical perspective. From the theoretical perspective, it is a natural approach in complexity theory to prove lower bounds first for monotone models of computation, to first circumvent some additional challenges of the general case; see, e.g., [42]. From the practical perspective, it is always a good idea to incorporate prior knowledge about a problem into a machine learning algorithm to solve that problem. If one knows that the target function should be a monotone function, then it might be a good idea to constrain each unit of the neural network to compute a monotone functionâ€”this exactly corresponds to nonnegative weights. See [29] and the references therein for recent studies of monotone neural networks in the machine learning community. Summarizing, in this paper, we discuss four ways to represent a polytope or its support function through (virtual) extended formulations and (monotone) neural networks. Figure 1 shows what we know about how the associated complexity measures xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ), vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ), nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ), and mnncâ¡(P)mnncğ‘ƒ\operatorname{mnnc}(P)roman_mnnc ( italic_P ) relate to each other. xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P )mnncâ¡(P)mnncğ‘ƒ\operatorname{mnnc}(P)roman_mnnc ( italic_P )vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P )nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P )?? Figure 1: Relations between complexity measures for a polytope Pğ‘ƒPitalic_P. A directed arc means that the tail can be polynomially bounded by the head. It remains an open question whether xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) and nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ) can be related this way. We conclude with some insights for vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ) and its relation to xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ). Observe that P+Q=Rğ‘ƒğ‘„ğ‘…P+Q=Ritalic_P + italic_Q = italic_R is equivalent to fP=fRâˆ’fQsubscriptğ‘“ğ‘ƒsubscriptğ‘“ğ‘…subscriptğ‘“ğ‘„f_{P}=f_{R}-f_{Q}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT = italic_f start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT - italic_f start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT pointwise. Therefore, intuitively, in order to optimize over Pğ‘ƒPitalic_P, one only needs to optimize over Rğ‘…Ritalic_R and Qğ‘„Qitalic_Q and subtract the results. We make this intuition formal in Section 5.1, implying that small extended formulations for Qğ‘„Qitalic_Q and Rğ‘…Ritalic_R are sufficient to optimize efficiently over Pğ‘ƒPitalic_P. Furthermore, in Section 5.2, we provide a class of examples with P+Q=Rğ‘ƒğ‘„ğ‘…P+Q=Ritalic_P + italic_Q = italic_R demonstrating that xcâ¡(R)xcğ‘…\operatorname{xc}(R)roman_xc ( italic_R ) can be much smaller than xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ). This gives important insights on how extension complexity behaves under Minkowski sum and implies that we really need to look at both xcâ¡(Q)xcğ‘„\operatorname{xc}(Q)roman_xc ( italic_Q ) and xcâ¡(R)xcğ‘…\operatorname{xc}(R)roman_xc ( italic_R ) in order to lower-bound vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ). 1.2 Further Related Work In this paper we aim to prove lower bounds on neural networks representing combinatorial optimization problems. Complementing upper bounds can be found in [22] for minimum spanning trees and maximum flows. Furthermore, in [23], similar upper bounds for the knapsack problem are given, even though they are different in flavor because some integrality assumptions are made. Concerning the general expressivity of (piecewise linear) neural networks, the celebrated universal approximation theorems state that a single layer of neurons is sufficient to approximate any continuous function on a bounded domain; see [10] for the original version for sigmoid activation functions and [27] for a version that encompasses ReLU. However, such shallow neural networks usually require a large number of neurons. A sequence of results demonstrates that deeper networks sometimes require exponentially fewer neurons to represent the same functions; see, e.g., [1, 12]. In terms of exact representation, it is known that a function can be represented if and only if it is CPWL [1], and it is still an open question whether constant depth is sufficient to do so [21, 20]. Interestingly, also for this question, monotone networks seem to be more amenable for proving lower bounds than their non-monotone counterparts [41]. Furthermore, the related question of how to efficiently write a non-convex CPWL function as a difference of two convex ones received quite some attention recently [5, 40]. We would like to emphasize that we view neural networks as a model of real-valued computation, as opposed to binary models of computation like Boolean circuits and Turing machines. In fact, if one restricts the inputs of a neural network to be binary, it is not too difficult to simulate AND-, OR-, and NOT-gates [32]. Thus, in such a binary model, every problem in P can be solved with polynomial-size neural networks. However, such networks would usually be very sensitive to single bits in the input and therefore cannot naturally be transformed into exact or approximate neural networks in the real-valued model. See also the discussion in [22] for more details. The more useful connection to circuit complexity is through arithmetic [38], and in particular tropical circuits [26], which are also real-valued models of computation. Again we refer to [22] for a more detailed discussion of how these models relate to neural networks. In fact, the extension complexity has been related before to Boolean and arithmetic circuits, see [13, 24]. This is also related to Goemansâ€™ proof that the permutahedron has extension complexity ğ’ªâ¢(nâ¢logâ¡n)ğ’ªğ‘›ğ‘›\mathcal{O}(n\log n)caligraphic_O ( italic_n roman_log italic_n ) [16], as this goes via sorting networks, which can be seen as a very specific version of a piecewise-linear arithmetic circuit."
https://arxiv.org/html/2411.02819v1,Coboundary expansion of coset complexes,"Coboundary expansion is a high dimensional generalization of the Cheeger constant to simplicial complexes. Originally, this notion was motivated by the fact that it implies topological expansion, but nowadays a significant part of the motivation stems from its deep connection to problems in theoretical computer science such as agreement expansion in the low soundness regime. In this paper, we prove coboundary expansion with non-Abelian coefficients for the coset complex construction of Kaufman and Oppenheim. Our proof uses a novel global argument, as opposed to the local-to-global arguments that are used to prove cosystolic expansion.","In this paper we show that the coset complexes that were introduced by [KO18] (or in fact a variant of those) are coboundary expanders over the symmetric group. In addition to the importance of the coboundary expansion result per se, our work suggests that the recent result of [BMV24] that construct PCPs over some variants of the Ramanujan complexes, could potentially be implemented also over the coset complexes to yield efficient PCPs over the coset complexes, i.e., efficient PCPs over elementary high dimensional expanders. 1.1 Our contribution In this paper, we will show that for every finite group Î›Î›\Lambdaroman_Î›, a slight variation of the Kaufman-Oppenheim complexes give examples of bounded degree 1111-coboundary expanders over Î›Î›\Lambdaroman_Î›. More explicitly, for nâ‰¥3ğ‘›3n\geq 3italic_n â‰¥ 3 and pğ‘pitalic_p prime, we construct an infinite family of nğ‘›nitalic_n-dimensional coset complexes {Xn,p(s)}s>3â¢nsubscriptsuperscriptsubscriptğ‘‹ğ‘›ğ‘ğ‘ ğ‘ 3ğ‘›\{X_{n,p}^{(s)}\}_{s>3n}{ italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT ( italic_s ) end_POSTSUPERSCRIPT } start_POSTSUBSCRIPT italic_s > 3 italic_n end_POSTSUBSCRIPT modelled over the family of groups {SLn+1â¡(ğ”½pâ¢[t]/âŸ¨tsâŸ©)}s>3â¢nsubscriptsubscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡delimited-âŸ¨âŸ©superscriptğ‘¡ğ‘ ğ‘ 3ğ‘›\{\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t]/\langle t^{s}\rangle)\}_{s>3n}{ roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] / âŸ¨ italic_t start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT âŸ© ) } start_POSTSUBSCRIPT italic_s > 3 italic_n end_POSTSUBSCRIPT using a slight variation of the construction in [KO18]. For this construction, our main result in this paper is the following: Theorem 1.1 (Main Theorem - informal, see formal Theorem 6.2). Let nâ‰¥3ğ‘›3n\geq 3italic_n â‰¥ 3 and Î›Î›\Lambdaroman_Î› a finite group. For every prime pğ‘pitalic_p that is large enough with respect to nğ‘›nitalic_n and |Î›|Î›|\Lambda|| roman_Î› |, the family {Xn,p(s)}s>3â¢nsubscriptsuperscriptsubscriptğ‘‹ğ‘›ğ‘ğ‘ ğ‘ 3ğ‘›\{X_{n,p}^{(s)}\}_{s>3n}{ italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT ( italic_s ) end_POSTSUPERSCRIPT } start_POSTSUBSCRIPT italic_s > 3 italic_n end_POSTSUBSCRIPT has uniformly bounded degree and (uniformly) 1111-coboundary expansion over Î›Î›\Lambdaroman_Î›. The main difficulty in the proof of our main Theorem is showing vanishing of cohomology with respect to a non-Abelian group Î›Î›\Lambdaroman_Î› - this is due to the fact that cosystolic expansion for such groups is known via a combination of previous work. Thus, once we prove vanishing of cohomology the previous known cosystolic result for coset complexes could be upgraded to a coboundary expansion result. We note that vanishing of cohomology with finite coefficients is inherently a global property and cannot be attained via local to global considerations. This is the main challenge we are facing, as most developed techniques within high dimensional expansion are of local to global nature, but a local to global argument can not imply vanishing of cohomology when working with finite coefficients. We note that our proof of this result is fairly elementary and self-contained - we only use some external results regarding the presentation of SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) and some of its subgroups in terms of generators and relations. Notably, unlike similar results obtained in [BLM24, DDL24] (for a completely different family of complexes), we do not use any sophisticated tools from the theory of algebraic groups nor do we need the strong results of the congruence subgroup property and the strong approximation theorem. 1.2 Significance of coboundary expansion over the symmetric group within CS In the following, we discuss the notions of coboundary expansion, cosystolic expansion and agreement expansion and their relation to PCP construction. Coboundary expansion. Coboundary expansion is a topological notion of high dimensional expansion that was introduced by Gromov [Gro10] and independently by Linial and Meshulam [LM06]. Gromov has studied this notion since he has shown that coboundary expansion over ğ”½2subscriptğ”½2\mathbb{F}_{2}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of a simplicial complex implies the topological overlapping property of the complex. Gromov knew how to prove this topological expansion property for complexes with small diameter, but his main interest was to obtain it for complexes with unbounded diameter, such as the Ramanujan complexes defined in [LSV05a, LSV05b] 111When we refer to Ramanujan complexes below, any quotient of an affine A~nsubscript~ğ´ğ‘›\widetilde{A}_{n}over~ start_ARG italic_A end_ARG start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT building with sufficiently large injectivity radius can be used. since he wanted to show the existence of bounded degree complexes with the topological overlapping property. This question of Gromov was resolved by [KKL14, EK24] using a relaxed notion to coboundary expansion called cosystolic expansion. Cosystolic expansion. Cosystolic expansion is the requirement that an approximate cocycle (i.e., a cochain whose coboundary is small) is close to a genuine cocycle. Coboundary expansion is equivalent to cosystolic expansion plus additional requirement of vanishing of the relevant cohomologies. Importantly, cosystolic expansion is a global testability question that could be deduced by local to global means (see [KKL14, EK24] that have shown cosystolic expansion with ğ”½2subscriptğ”½2\mathbb{F}_{2}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT coefficients). However, in contrast to cosystolic expansion, coboundary expansion is a global property that can not be deduced by local to global means. The techniques to get cosystolic expansion with ğ”½2subscriptğ”½2\mathbb{F}_{2}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT coefficients by local to global means were also pivotal in obtaining good LTCS and good qLDPCs [EKZ20, DEL+22, PK22]. Coset complexes. The Ramanujan complexes were shown to be bounded degree cosystolic expanders, but their construction was rather involved. This raised the question of the existence of bounded degree cosystolic expanders with an elementary construction. The first construction of bounded degree spectral high dimensional expanders was given in [KO18] using the idea of coset complexes. This idea was generalized in [KO23, OP22, dPVB24] to other similar constructions of bounded degree spectral high dimensional expanders. It was later shown in [KO21], that the complexes constructed in [KO18] are also give rise bounded degree cosystolic expanders over ğ”½2subscriptğ”½2\mathbb{F}_{2}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT in dimension 2 (it is conjectured that this result can be generalized to higher dimensions). These construction remain one of the main sources of examples for HDXâ€™s (e.g., see [DLYZ23]). Agreement expansion in the high and low soundness regimes. In another line of work within CS [DK17] have studied the notion of agreement expansion and have shown that high dimensional spectral expanders are agreement expanders in the high soundness regime; Agreement expansion in the high soundness regime asks roughly for the following: Given a binary assignment to the vertices of each k face in a complex of dimension n>kğ‘›ğ‘˜n>kitalic_n > italic_k such that almost all k-assignments are agreeing on their intersections, is it the case that there exists a global binary function on all the vertices of the complex whose restriction to the different k-faces agrees with most assignments to the k-faces. This question is related to PCPs and is called agreement expansion in the high soundness regime. However for PCPs constructions one needs a stronger requirement called agreement expansion in the low soundless regime. Agreement expansion in the low soundless regime roughly requires that if 1 percent of the intersection of the k-faces are agreeing then there exists a global function that is consistent with a constant fraction of the k-sets. In [DK17] it was shown that spectral high dimensional expansion is sufficient for agreement expansion in the high soundness regime and they have conjectured that it should imply also the low soundness case. So the state of things until recently has been that agreement expansion in the high soundness case is implied by spectral high dimensional expansion and robustness of codes and topological overlapping property are implied by cosystolic expansion (i.e. by topological expansion) or similar variants (see also [FK24]). List agreement expansion and the bridge between spectral and topological high dimensional expansion. The work of [GK23] has recently defined a stronger version of the agreement expansion that also needs topological expansion in additional to spectral high dimensional expansion. They have defined the notion of list agreement expansion ; in which the agreement expansion question in the high soundness regime is changed so that the input on each k-face is a list of lğ‘™litalic_l different assignments to the k-face (and not only one) and the question is the following : if a typical pair of k-faces that intersect are agreeing on their whole list then there exist lğ‘™litalic_l-global functions that are consistent with most assignments of lğ‘™litalic_l-lists on kğ‘˜kitalic_k-faces. In [GK23] it was also shown that if the complex is both a spectral high dimensional expander and a coboundary expander over the symmetric group then it has the list-agreement expansion property in the high soundness regime. Then the following question arises: what is the relation between agreement expansion in the low soundness regime, that is useful towards PCP construction and the list-agreement expansion in the high soundness regime? Reduction from agreement with low soundness to list agreement with high soundness. In two independent works [BM24] and [DD24b] have shown that there is a reduction from agreement expansion in the low soundness regime to list agreement expansion in the high soundness. Namely one can solve low soundness agreement by translating it to high soundness agreement on lists (with additional requirement that the coboundary expansion constant in links is independent of the complex dimension). As was explained, high soundness agreement on lists can be solved by coboundary expansion of the complex and by spectral expansion of it. The Path towards PCP construction. After those works that have shown a reduction from agreement expansion in the low soundness to list agreement expansion in the high soundness regime, the main challenge towards obtaining bounded degree complexes that supports agreement expansion in the low soundness regime has been in coming up with a bounded degree complexes that are coboundary expanders over the symmetric group. [BLM24, DDL24] have shown the existence of such complexes based on an earlier work of [CL24]. Thus, these works have shown the existence of bounded degree complexes that support agreement expansion in the low soundness regime. All these efforts have culminated in the [BMV24] that showed that a complex which supports agreement expansion in the low soundness regime gives rise to an efficient PCP by routing through it existing local PCP. On the implications of our work. Based on the previous discussion, the main global challenge to get a PCP from a complex with expanding links is in proving the global property that this complex is a coboundary expander over the symmetric group. The main difficulty is that coboundary expansion of the complex is a property that can not be implied by local to global means that are abundant in the high dimensional expansion literature. We see the significance of our results in three key aspects: First, proving coboundary expansion of the coset complex over the symmetric group. Second, solving the main global challenge towards constructing PCPs based on the coset complex (although the local problem of providing coboundary expansion constants of the links that are independent of the degree is still open). Third, we provide a novel global technique for proving vanishing of the first cohomology over the symmetric group (in contrast to other techniques for establishing spectral expansion or cosystolic expansion that are of local nature). We believe that our work can be generalized to the other constructions of spectral expanders using coset complexes in [OP22]. 1.3 Comparison to similar results It is intriguing to compare our proof of the vanishing of cohomology with recent results in [BLM24, DDL24]. Given a finite group Î›Î›\Lambdaroman_Î› both our work and [BLM24, DDL24] construct a family of high-dimensional expanders with trivial 1-cohomology relative to Î›Î›\Lambdaroman_Î›-coefficients, following a similar outline. The approach begins with an â€algebraicâ€ simplicial complex that has trivial 1-cohomology with respect to Î›Î›\Lambdaroman_Î›, and then passes to a family of high-dimensional expanders by taking quotients via congruence subgroups, which also have trivial 1-cohomology with Î›Î›\Lambdaroman_Î›-coefficients. Despite this shared framework, the methods and challenges in the proofs differ significantly. In [BLM24, DDL24], the initial complex is a contractible symplectic C~nsubscript~ğ¶ğ‘›\widetilde{C}_{n}over~ start_ARG italic_C end_ARG start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT-building, which has trivial cohomology for any group. The difficulty lies in proving that the congruence subgroups exhibit trivial 1-cohomology with respect to Î›Î›\Lambdaroman_Î›, requiring deep results from group theory, such as the congruence subgroup property and the strong approximation theorem. In contrast, our work begins with a coset complex over SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ). For nâ‰¥3ğ‘›3n\geq 3italic_n â‰¥ 3, the explicit description of the congruence subgroups, which follows from the fact that SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) has the same presentation as a Steinberg group, makes the vanishing of 1-cohomology for congruence subgroups with Î›Î›\Lambdaroman_Î›-coefficients almost trivial when p>|Î›|ğ‘Î›p>|\Lambda|italic_p > | roman_Î› |. This is a straightforward argument requiring no deep theoretical results. Most of our effort focuses on proving that the coset complex over SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) has trivial 1-cohomology with respect to Î›Î›\Lambdaroman_Î› (unlike the work in [BLM24, DDL24], the coset complex in our case is not simply connected). 1.4 Proof overview In order to show that a family of complexes {X(s)}superscriptğ‘‹ğ‘ \{X^{(s)}\}{ italic_X start_POSTSUPERSCRIPT ( italic_s ) end_POSTSUPERSCRIPT } has 1111-coboundary expansion over a group Î›Î›\Lambdaroman_Î›, one needs to show two things: First, that the family has 1111-cosystolic expansion over Î›Î›\Lambdaroman_Î›. Second, that for every sğ‘ sitalic_s, H1â¢(X(s),Î›)=0superscriptğ»1superscriptğ‘‹ğ‘ Î›0H^{1}(X^{(s)},\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_X start_POSTSUPERSCRIPT ( italic_s ) end_POSTSUPERSCRIPT , roman_Î› ) = 0. In [KO21] it was shown that the Kaufman-Oppenheim complexes (with large enough prime pğ‘pitalic_p) have 1111-cosystolic expansion over ğ”½2subscriptğ”½2\mathbb{F}_{2}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. The new results of Dikstein and Dinur in [DD24a, DD24b] show that the same proof given in [KO21] actually show that the Kaufman-Oppenheim complexes have 1111-cosystolic expansion over any group Î›Î›\Lambdaroman_Î› (see a more detailed explanation of this point in Section 2.5 below). Thus we are left to show a vanishing of cohomology result for the coset complexes in our construction. This is done via the following steps: Vanishing of cohomology for a quotient. Let Xğ‘‹Xitalic_X be a simplicial complex and Nğ‘Nitalic_N a group acting simplicially on Xğ‘‹Xitalic_X. The quotient complex, denoted N\X\ğ‘ğ‘‹N\backslash Xitalic_N \ italic_X, is defined via identifying all the vertices of Xğ‘‹Xitalic_X that are in the same orbit of Nğ‘Nitalic_N. Under some mild conditions on Xğ‘‹Xitalic_X and on the action of Nğ‘Nitalic_N, the following result holds for every group Î›Î›\Lambdaroman_Î›: If both H1â¢(X,Î›)=0superscriptğ»1ğ‘‹Î›0H^{1}(X,\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_X , roman_Î› ) = 0 and H1â¢(N,Î›)=0superscriptğ»1ğ‘Î›0H^{1}(N,\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_N , roman_Î› ) = 0, then H1â¢(N\X,Î›)=0superscriptğ»1\ğ‘ğ‘‹Î›0H^{1}(N\backslash X,\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_N \ italic_X , roman_Î› ) = 0 (see exact formulation in Theorem 3.1 below). Passing to the coset complex of SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ). It was already observed in [KO23] that the Kaufman-Oppenheim coset complexes over the family of groups {SLn+1â¡(ğ”½pâ¢[t]/âŸ¨tsâŸ©)}s>3â¢nsubscriptsubscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡delimited-âŸ¨âŸ©superscriptğ‘¡ğ‘ ğ‘ 3ğ‘›\{\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t]/\langle t^{s}\rangle)\}_{s>3n}{ roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] / âŸ¨ italic_t start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT âŸ© ) } start_POSTSUBSCRIPT italic_s > 3 italic_n end_POSTSUBSCRIPT are actually all quotients of a coset complex modelled over SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ). Namely, for any n,pğ‘›ğ‘n,pitalic_n , italic_p, there are coset complexes Xn,psubscriptğ‘‹ğ‘›ğ‘X_{n,p}italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT modelled over SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) and normal subgroups Î“n,psâ—SLn+1â¡(ğ”½pâ¢[t])â—superscriptsubscriptÎ“ğ‘›ğ‘ğ‘ subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\Gamma_{n,p}^{s}\triangleleft\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_Î“ start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT â— roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) such that for any s>3â¢nğ‘ 3ğ‘›s>3nitalic_s > 3 italic_n, Xn,p(s)=Î“n,ps\Xn,psuperscriptsubscriptğ‘‹ğ‘›ğ‘ğ‘ \superscriptsubscriptÎ“ğ‘›ğ‘ğ‘ subscriptğ‘‹ğ‘›ğ‘X_{n,p}^{(s)}=\Gamma_{n,p}^{s}\backslash X_{n,p}italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT ( italic_s ) end_POSTSUPERSCRIPT = roman_Î“ start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT \ italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT. We will see that if Î›Î›\Lambdaroman_Î› is a group that has no non-trivial element of order pğ‘pitalic_p, then H1â¢(Î“n,ps,Î›)=0superscriptğ»1superscriptsubscriptÎ“ğ‘›ğ‘ğ‘ Î›0H^{1}(\Gamma_{n,p}^{s},\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( roman_Î“ start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT , roman_Î› ) = 0 for every sğ‘ sitalic_s. In particular, if Î›Î›\Lambdaroman_Î› is finite and p>|Î›|ğ‘Î›p>|\Lambda|italic_p > | roman_Î› |, then H1â¢(Î“n,ps,Î›)=0superscriptğ»1superscriptsubscriptÎ“ğ‘›ğ‘ğ‘ Î›0H^{1}(\Gamma_{n,p}^{s},\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( roman_Î“ start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT , roman_Î› ) = 0 for every sğ‘ sitalic_s. By the discussion above, if we can show that for such p>|Î›|ğ‘Î›p>|\Lambda|italic_p > | roman_Î› |, it also holds that H1â¢(Xn,p,Î›)=0superscriptğ»1subscriptğ‘‹ğ‘›ğ‘Î›0H^{1}(X_{n,p},\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT , roman_Î› ) = 0, then it will follow that H1â¢(Xn,p(s),Î›)=0superscriptğ»1superscriptsubscriptğ‘‹ğ‘›ğ‘ğ‘ Î›0H^{1}(X_{n,p}^{(s)},\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT start_POSTSUPERSCRIPT ( italic_s ) end_POSTSUPERSCRIPT , roman_Î› ) = 0 for every s>3â¢nğ‘ 3ğ‘›s>3nitalic_s > 3 italic_n. Vanishing of cohomology for Xn,psubscriptğ‘‹ğ‘›ğ‘X_{n,p}italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT. Fix nâ‰¥3ğ‘›3n\geq 3italic_n â‰¥ 3 and pğ‘pitalic_p an odd prime. To avoid cumbersome notation, we will denote X=Xn,pğ‘‹subscriptğ‘‹ğ‘›ğ‘X=X_{n,p}italic_X = italic_X start_POSTSUBSCRIPT italic_n , italic_p end_POSTSUBSCRIPT. By the previous paragraph, we need to show that for any finite group Î›Î›\Lambdaroman_Î›, if p>|Î›|ğ‘Î›p>|\Lambda|italic_p > | roman_Î› |, then H1â¢(X,Î›)=0superscriptğ»1ğ‘‹Î›0H^{1}(X,\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_X , roman_Î› ) = 0. Had we known that Xğ‘‹Xitalic_X is simply connected, then we would be done, since for every simply connected complexes, the 1111-cohomology vanishes with respect to any group Î›Î›\Lambdaroman_Î›. However, Xğ‘‹Xitalic_X is a coset complex and there is a characterization of simple connectedness for coset complexes (see [AH93] and further discussion below) that Xğ‘‹Xitalic_X does not meet. Fortunately, the universal cover of Xğ‘‹Xitalic_X, denoted X~~ğ‘‹\widetilde{X}over~ start_ARG italic_X end_ARG, has an explicit description as a coset complex. Namely, there is an explicit abstract group Î“~~Î“\widetilde{\Gamma}over~ start_ARG roman_Î“ end_ARG and a simply connected coset complex X~~ğ‘‹\widetilde{X}over~ start_ARG italic_X end_ARG modelled over Î“~~Î“\widetilde{\Gamma}over~ start_ARG roman_Î“ end_ARG such that Î“~â†’SLn+1â¡(ğ”½pâ¢[t])â†’~Î“subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\widetilde{\Gamma}\rightarrow\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])over~ start_ARG roman_Î“ end_ARG â†’ roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) is a surjective homomorphism that induces a covering map X~â†’Xâ†’~ğ‘‹ğ‘‹\widetilde{X}\rightarrow Xover~ start_ARG italic_X end_ARG â†’ italic_X. The group Î“~~Î“\widetilde{\Gamma}over~ start_ARG roman_Î“ end_ARG is given in terms of generators and relations such that the generators can be identified with a generating set of SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) and the set of relations of Î“~~Î“\widetilde{\Gamma}over~ start_ARG roman_Î“ end_ARG is a partial set of the relations in a finite presentation of SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ). We will refer to the relations in the presentation of SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) that do not appear in the presentation of Î“~~Î“\widetilde{\Gamma}over~ start_ARG roman_Î“ end_ARG as the â€œmissing relationsâ€. Adding relations to Î“~~Î“\widetilde{\Gamma}over~ start_ARG roman_Î“ end_ARG and considering the coset complex with the added relations is equivalent to passing to a quotient of X~~ğ‘‹\widetilde{X}over~ start_ARG italic_X end_ARG by the normal subgroup generated by the added relations. The crux of our proof is that we can add the missing relations to Î“~~Î“\widetilde{\Gamma}over~ start_ARG roman_Î“ end_ARG in an iterative process, such that the normal group that we divide by has no Î›Î›\Lambdaroman_Î› 1111-cohomology. Thus, we start with H1â¢(X~,Î›)=0superscriptğ»1~ğ‘‹Î›0H^{1}(\widetilde{X},\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( over~ start_ARG italic_X end_ARG , roman_Î› ) = 0 (since X~~ğ‘‹\widetilde{X}over~ start_ARG italic_X end_ARG is simply connected) and pass in a sequence of quotients X0=X~,X1=N0\X0,â€¦,Xm=Nmâˆ’1\Xmâˆ’1formulae-sequencesubscriptğ‘‹0~ğ‘‹formulae-sequencesubscriptğ‘‹1\subscriptğ‘0subscriptğ‘‹0â€¦subscriptğ‘‹ğ‘š\subscriptğ‘ğ‘š1subscriptğ‘‹ğ‘š1X_{0}=\widetilde{X},X_{1}=N_{0}\backslash X_{0},...,X_{m}=N_{m-1}\backslash X_% {m-1}italic_X start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT = over~ start_ARG italic_X end_ARG , italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_N start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT \ italic_X start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , â€¦ , italic_X start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT = italic_N start_POSTSUBSCRIPT italic_m - 1 end_POSTSUBSCRIPT \ italic_X start_POSTSUBSCRIPT italic_m - 1 end_POSTSUBSCRIPT such that Xm=Xsubscriptğ‘‹ğ‘šğ‘‹X_{m}=Xitalic_X start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT = italic_X and in each step H1â¢(Ni,Î›)=0superscriptğ»1subscriptğ‘ğ‘–Î›0H^{1}(N_{i},\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_N start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , roman_Î› ) = 0 and thus H1â¢(Xi+1,Î›)=0superscriptğ»1subscriptğ‘‹ğ‘–1Î›0H^{1}(X_{i+1},\Lambda)=0italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT ( italic_X start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT , roman_Î› ) = 0 by the discussion above. This result builds on identifying the relations in SLn+1â¡(ğ”½pâ¢[t])subscriptSLğ‘›1subscriptğ”½ğ‘delimited-[]ğ‘¡\operatorname{SL}_{n+1}(\mathbb{F}_{p}[t])roman_SL start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [ italic_t ] ) as pairs of roots in the root system Ansubscriptğ´ğ‘›A_{n}italic_A start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT and establishing a combinatorial propagation result in the chambers of Ansubscriptğ´ğ‘›A_{n}italic_A start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT (passing from the relations in Î“~~Î“\widetilde{\Gamma}over~ start_ARG roman_Î“ end_ARG to the missing relations)."
https://arxiv.org/html/2411.02702v1,Corners in Quasirandom Groups via Sparse Mixing,"We improve the best known upper bounds on the density of corner-free sets over quasirandom groups from inverse poly-logarithmic to quasi-polynomial. We make similarly substantial improvements to the best known lower bounds on the communication complexity of a large class of permutation functions in the 3-player Number-on-Forehead model. Underpinning both results is a general combinatorial theorem that extends the recent work of Kelley, Lovett, and Meka (STOCâ€™24), itself a development of ideas from the breakthrough result of Kelley and Meka on three-term arithmetic progressions (FOCSâ€™23).","In the early 1980s, Chandra, Furst, and Lipton introduced the Number-on-Forehead (NOF) model of communication complexity [14] to better capture interaction with shared information. The kğ‘˜kitalic_k-NOF model is defined by kğ‘˜kitalic_k players communicating over a shared channel in order to compute a function f:({0,1}n)kâ†’{0,1}:ğ‘“â†’superscriptsuperscript01ğ‘›ğ‘˜01f:(\{0,1\}^{n})^{k}\to\{0,1\}italic_f : ( { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT â†’ { 0 , 1 }. Each player can see the kâˆ’1ğ‘˜1k-1italic_k - 1 inputs of every other player, but they cannot see their own. Albeit perhaps unintuitive at first glance, the model has a number of strikingly powerful and surprising connections to other areas of theoretical computer science and combinatorics. For example, lower bounds for k=Ï‰â¢(logâ¡n)ğ‘˜ğœ”ğ‘›k=\omega(\log n)italic_k = italic_Ï‰ ( roman_log italic_n ) players would imply breakthrough circuit lower bounds [13, 42, 44, 9], and the communication complexity of several natural functions is known to be equivalent to central problems in Ramsey theory [14, 51, 39]. Unfortunately, our understanding of this model is severely lacking. Only in the past year have researchers discovered explicit functions witnessing strong separations between randomized and deterministic 3-NOF communication complexity [31], despite the fact that optimal separations were long known to exist non-explicitly [5]. More precisely, Kelley, Lovett, and Meka exhibited an explicit 3-player function which has a constant cost randomized protocol, but requires Î©â¢(n1/3)Î©superscriptğ‘›13\Omega(n^{1/3})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / 3 end_POSTSUPERSCRIPT ) bits of communication to compute deterministically. Their primary technical tool is a combinatorial adaptation of ideas from the recent breakthrough of Kelley and Meka on three-term arithmetic progressions (3APs) [32]. One of the most well-studied functions in the NOF setting is Exactly-N, where each player receives a number in [N]â‰”{1,2,â€¦,N}â‰”delimited-[]ğ‘12â€¦ğ‘[N]\coloneqq\{1,2,\dots,N\}[ italic_N ] â‰” { 1 , 2 , â€¦ , italic_N }, and they wish to determine if their numbers sum to Nğ‘Nitalic_N. Introduced by [14], they showed that the 3-NOF complexity of Exactly-N is at most Oâ¢(logâ¡N)ğ‘‚ğ‘O(\sqrt{\log N})italic_O ( square-root start_ARG roman_log italic_N end_ARG ) using the Behrend construction of 3-AP free sets [6]. In fact, they observed a near equivalence between Exactly-N (for three players) and the size of sets SâŠ‚[N]2ğ‘†superscriptdelimited-[]ğ‘2S\subset[N]^{2}italic_S âŠ‚ [ italic_N ] start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT without corners: three points (x,y),(x+z,y),(x,y+z)âˆˆ[N]2ğ‘¥ğ‘¦ğ‘¥ğ‘§ğ‘¦ğ‘¥ğ‘¦ğ‘§superscriptdelimited-[]ğ‘2(x,y),(x+z,y),(x,y+z)\in[N]^{2}( italic_x , italic_y ) , ( italic_x + italic_z , italic_y ) , ( italic_x , italic_y + italic_z ) âˆˆ [ italic_N ] start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT with zâ‰ 0ğ‘§0z\neq 0italic_z â‰  0. The first nontrivial bounds on the size of such sets were proven earlier by Ajtai and SzemerÃ©di [2], but the quantitative behavior was poor, since the proof relied on SzemerÃ©diâ€™s regularity lemma [52]. The strongest bound to date is due to Shkredov [50], who showed any corner-free set of size Î´â¢N2ğ›¿superscriptğ‘2\delta N^{2}italic_Î´ italic_N start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT must satisfy Î´â‰¤Oâ¢(1(logâ¡logâ¡N)c)ğ›¿ğ‘‚1superscriptğ‘ğ‘\delta\leq O\left(\frac{1}{(\log\log N)^{c}}\right)italic_Î´ â‰¤ italic_O ( divide start_ARG 1 end_ARG start_ARG ( roman_log roman_log italic_N ) start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT end_ARG ) for some absolute constant c>0ğ‘0c>0italic_c > 0 (see also [49] and the exposition by Green over finite fields [23, 24]). Using the connection shown by [14], this implies that the complexity of Exactly-N is at least Î©â¢(logâ¡logâ¡logâ¡N)Î©ğ‘\Omega(\log\log\log N)roman_Î© ( roman_log roman_log roman_log italic_N ). Unfortunately, the techniques developed in [31] do not suffice to improve this lower bound, since they only apply to much denser functions. Concretely, the number of solutions of Exactly-N (that is, triples x,y,zâˆˆ[N]ğ‘¥ğ‘¦ğ‘§delimited-[]ğ‘x,y,z\in[N]italic_x , italic_y , italic_z âˆˆ [ italic_N ] that satisfy x+y+z=Nğ‘¥ğ‘¦ğ‘§ğ‘x+y+z=Nitalic_x + italic_y + italic_z = italic_N) is at most N2superscriptğ‘2N^{2}italic_N start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, whereas the function exhibited by [31] to have strong lower bounds for deterministic NOF communication has N3âˆ’csuperscriptğ‘3ğ‘N^{3-c}italic_N start_POSTSUPERSCRIPT 3 - italic_c end_POSTSUPERSCRIPT solutions for some small constant c>0ğ‘0c>0italic_c > 0; their technique is restricted to such functions. Observe that corners may be viewed as a multidimensional generalization of arithmetic progressions. In fact, upper bounds on corner-free sets easily imply upper bounds on 3AP-free sets (see e.g. [55, Section 2.4]). Given their tight relationship, many researchers have suspected that the recent techniques of Kelley and Meka [32] used to improve bounds for 3AP-free sets will be amenable to usage in the case of corners (see e.g. [40] and [43, Section 1.2]). While there is some preliminary evidence that this direction is viable [30, 41], such strong bounds remain currently beyond reach. 1.1 Our results A common strategy in additive combinatorics when working over the integers is to prove a similar result in some model setting, such as finite fields, then port the result back to the integers using standard machinery. One interesting setting is quasirandom groups. For now, one can think of a quasirandom group as a finite group GğºGitalic_G enjoying the property that any two large sets A,BâŠ‚Gğ´ğµğºA,B\subset Gitalic_A , italic_B âŠ‚ italic_G â€œmixâ€ under convolutions. In other words, if we take random samples aâˆˆAğ‘ğ´a\in Aitalic_a âˆˆ italic_A and bâˆˆBğ‘ğµb\in Bitalic_b âˆˆ italic_B, then the distribution of aâ¢bğ‘ğ‘abitalic_a italic_b is close to the uniform distribution over GğºGitalic_G. A classic example of a quasirandom group is G=SL2â¢(ğ”½p)ğºsubscriptSL2subscriptğ”½ğ‘G=\mathrm{SL}_{2}(\mathbb{F}_{p})italic_G = roman_SL start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ), the set of 2Ã—2222\times 22 Ã— 2 matrices over the finite field ğ”½psubscriptğ”½ğ‘\mathbb{F}_{p}blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT for pğ‘pitalic_p prime with determinant 1. The Exactly-N problem naturally generalizes to any finite group GğºGitalic_G [8], where the players receive inputs x,y,zâˆˆGğ‘¥ğ‘¦ğ‘§ğºx,y,z\in Gitalic_x , italic_y , italic_z âˆˆ italic_G and accept if and only if their inputs satisfy xâ¢yâ¢z=1Gğ‘¥ğ‘¦ğ‘§subscript1ğºxyz=1_{G}italic_x italic_y italic_z = 1 start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT. Note that over any group, Exactly-N has a constant cost randomized protocol by reducing to equality. We obtain the following lower bound for computing Exactly-N over G=SL2â¢(ğ”½p)ğºsubscriptSL2subscriptğ”½ğ‘G=\mathrm{SL}_{2}(\mathbb{F}_{p})italic_G = roman_SL start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ) by either deterministic or even non-deterministic protocols. Theorem 1.1 (Special case of Theorem 4.3). Any non-deterministic 3-NOF protocol computing Exactly-N over G=SL2â¢(ğ”½p)ğºsubscriptSL2subscriptğ”½ğ‘G=\mathrm{SL}_{2}(\mathbb{F}_{p})italic_G = roman_SL start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ) for prime pğ‘pitalic_p requires Î©â¢(log1/4â¡|G|)Î©superscript14ğº\Omega(\log^{1/4}|G|)roman_Î© ( roman_log start_POSTSUPERSCRIPT 1 / 4 end_POSTSUPERSCRIPT | italic_G | ) bits of communication. Similar to the abelian case, there exists an intimate connection between Exactly-N over a group GğºGitalic_G and corner-free sets in GÃ—GğºğºG\times Gitalic_G Ã— italic_G. However, there is a slight subtlety here, as corners generalize to the non-abelian setting in two non-equivalent ways. One option is triples of the form {(x,y),(zâ¢x,y),(x,zâ¢y)}ğ‘¥ğ‘¦ğ‘§ğ‘¥ğ‘¦ğ‘¥ğ‘§ğ‘¦\{(x,y),(zx,y),(x,zy)\}{ ( italic_x , italic_y ) , ( italic_z italic_x , italic_y ) , ( italic_x , italic_z italic_y ) } for zâ‰ 1Gğ‘§subscript1ğºz\neq 1_{G}italic_z â‰  1 start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT, often referred to as naÃ¯ve corners. In this setting, Austin [4] proved that for G=SL2â¢(ğ”½p)ğºsubscriptSL2subscriptğ”½ğ‘G=\mathrm{SL}_{2}(\mathbb{F}_{p})italic_G = roman_SL start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ), any subset of GÃ—GğºğºG\times Gitalic_G Ã— italic_G without naÃ¯ve corners has size |G|2âˆ’Îµsuperscriptğº2ğœ€|G|^{2-\varepsilon}| italic_G | start_POSTSUPERSCRIPT 2 - italic_Îµ end_POSTSUPERSCRIPT for some small constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0. Alternatively, one can consider triples of the form {(x,y),(xâ¢z,y),(x,zâ¢y)}ğ‘¥ğ‘¦ğ‘¥ğ‘§ğ‘¦ğ‘¥ğ‘§ğ‘¦\{(x,y),(xz,y),(x,zy)\}{ ( italic_x , italic_y ) , ( italic_x italic_z , italic_y ) , ( italic_x , italic_z italic_y ) } for zâ‰ 1Gğ‘§subscript1ğºz\neq 1_{G}italic_z â‰  1 start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT, sometimes called BMZ corners after the first researchers to study them [11]. This formulation is less understood, and it corresponds to the three-player Exactly-N function over general groups (see e.g. [54, Lemma 21]). We will focus our attention on this latter generalization, and henceforth refer to them simply as corners. Austin also showed that corner-free sets over SL2â¢(ğ”½p)subscriptSL2subscriptğ”½ğ‘\mathrm{SL}_{2}(\mathbb{F}_{p})roman_SL start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ) have density at most Î´â‰¤Oâ¢(1/logcâ¡|G|)ğ›¿ğ‘‚1superscriptğ‘ğº\delta\leq O(1/\log^{c}|G|)italic_Î´ â‰¤ italic_O ( 1 / roman_log start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT | italic_G | ) for some absolute constant c>0ğ‘0c>0italic_c > 0 (see [54, Section 5] for a nice exposition). We are able to substantially improve this bound. Theorem 1.2 (Special case of Corollary 4.10). Let G=SL2â¢(ğ”½p)ğºsubscriptSL2subscriptğ”½ğ‘G=\mathrm{SL}_{2}(\mathbb{F}_{p})italic_G = roman_SL start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ) for prime pğ‘pitalic_p. Then, any corner-free subset of GÃ—GğºğºG\times Gitalic_G Ã— italic_G has size at most Î´â¢|G|2ğ›¿superscriptğº2\delta|G|^{2}italic_Î´ | italic_G | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT for Î´â‰¤expâ¡(âˆ’Î©â¢(log1/4â¡|G|)).ğ›¿Î©superscript14ğº\delta\leq\exp{\left(-\Omega\left(\log^{1/4}|G|\right)\right)}.italic_Î´ â‰¤ roman_exp ( - roman_Î© ( roman_log start_POSTSUPERSCRIPT 1 / 4 end_POSTSUPERSCRIPT | italic_G | ) ) . We emphasize that Theorems 1.1 and 1.2 are only special cases of more general theorems, and we direct readers to Sections 4.1 and 4.2, respectively, for details. Both of our results are consequences of a general combinatorial theorem which may be of independent interest. Before stating it, we require some definitions. A set SâŠ‚[N]3ğ‘†superscriptdelimited-[]ğ‘3S\subset[N]^{3}italic_S âŠ‚ [ italic_N ] start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT is called a permutation function111Such sets are called 2-dimensional permutations in [34, 37], and extend graph functions studied in [5, 51]. if for any fixing of two coordinates of some aâˆˆ[N]3ğ‘superscriptdelimited-[]ğ‘3a\in[N]^{3}italic_a âˆˆ [ italic_N ] start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT, there is precisely one choice of the other coordinate such that aâˆˆSğ‘ğ‘†a\in Sitalic_a âˆˆ italic_S. For example, S={(x,y,z):xâ¢yâ¢z=1G}âŠ‚G3ğ‘†conditional-setğ‘¥ğ‘¦ğ‘§ğ‘¥ğ‘¦ğ‘§subscript1ğºsuperscriptğº3S=\{(x,y,z):xyz=1_{G}\}\subset G^{3}italic_S = { ( italic_x , italic_y , italic_z ) : italic_x italic_y italic_z = 1 start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT } âŠ‚ italic_G start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT is an example of a permutation function (identifying [N]delimited-[]ğ‘[N][ italic_N ] with GğºGitalic_G). Given a permutation function SâŠ‚[N]3ğ‘†superscriptdelimited-[]ğ‘3S\subset[N]^{3}italic_S âŠ‚ [ italic_N ] start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT and a subset AâŠ‚Sğ´ğ‘†A\subset Sitalic_A âŠ‚ italic_S, we denote by AXâ¢Y,AXâ¢Z,AYâ¢ZâŠ‚[N]2subscriptğ´ğ‘‹ğ‘Œsubscriptğ´ğ‘‹ğ‘subscriptğ´ğ‘Œğ‘superscriptdelimited-[]ğ‘2A_{XY},A_{XZ},A_{YZ}\subset[N]^{2}italic_A start_POSTSUBSCRIPT italic_X italic_Y end_POSTSUBSCRIPT , italic_A start_POSTSUBSCRIPT italic_X italic_Z end_POSTSUBSCRIPT , italic_A start_POSTSUBSCRIPT italic_Y italic_Z end_POSTSUBSCRIPT âŠ‚ [ italic_N ] start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT the projections of Ağ´Aitalic_A to the Xâ¢Y,Xâ¢Z,Yâ¢Zğ‘‹ğ‘Œğ‘‹ğ‘ğ‘Œğ‘XY,XZ,YZitalic_X italic_Y , italic_X italic_Z , italic_Y italic_Z-faces of [N]3superscriptdelimited-[]ğ‘3[N]^{3}[ italic_N ] start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT, respectively. Theorem 1.3 (Informal special case of Theorem 2.4). Let dâ‰¥1ğ‘‘1d\geq 1italic_d â‰¥ 1. Suppose SâŠ‚[N]3ğ‘†superscriptdelimited-[]ğ‘3S\subset[N]^{3}italic_S âŠ‚ [ italic_N ] start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT is a permutation function and AâŠ‚Sğ´ğ‘†A\subset Sitalic_A âŠ‚ italic_S is a set of size |A|â‰¥2âˆ’dâ¢|S|ğ´superscript2ğ‘‘ğ‘†|A|\geq 2^{-d}|S|| italic_A | â‰¥ 2 start_POSTSUPERSCRIPT - italic_d end_POSTSUPERSCRIPT | italic_S |. If Sğ‘†Sitalic_S is sufficiently pseudorandom (in the sense of Definition 2.1), then |{(x,y,z)âˆˆ[N]3:(x,y)âˆˆAXâ¢Y,(x,z)âˆˆAXâ¢Z,(y,z)âˆˆAYâ¢Z}|â‰¥2âˆ’Oâ¢(d3)â¢N3.conditional-setğ‘¥ğ‘¦ğ‘§superscriptdelimited-[]ğ‘3formulae-sequenceğ‘¥ğ‘¦subscriptğ´ğ‘‹ğ‘Œformulae-sequenceğ‘¥ğ‘§subscriptğ´ğ‘‹ğ‘ğ‘¦ğ‘§subscriptğ´ğ‘Œğ‘superscript2ğ‘‚superscriptğ‘‘3superscriptğ‘3\left|\left\{(x,y,z)\in[N]^{3}:(x,y)\in A_{XY},(x,z)\in A_{XZ},(y,z)\in A_{YZ}% \right\}\right|\geq 2^{-O(d^{3})}N^{3}.| { ( italic_x , italic_y , italic_z ) âˆˆ [ italic_N ] start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT : ( italic_x , italic_y ) âˆˆ italic_A start_POSTSUBSCRIPT italic_X italic_Y end_POSTSUBSCRIPT , ( italic_x , italic_z ) âˆˆ italic_A start_POSTSUBSCRIPT italic_X italic_Z end_POSTSUBSCRIPT , ( italic_y , italic_z ) âˆˆ italic_A start_POSTSUBSCRIPT italic_Y italic_Z end_POSTSUBSCRIPT } | â‰¥ 2 start_POSTSUPERSCRIPT - italic_O ( italic_d start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT italic_N start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT . For now, the reader can think of the pseudorandomness condition as saying that the density of Sğ‘†Sitalic_S stays roughly the same whenever you restrict to some large cube. Theorem 1.3 should be compared with [31, Lemma 2.10], where they refer to the quantity on the left-hand side of the above inequality as the â€œcylinder intersection closure of Ağ´Aitalic_A.â€ The two results can be viewed as similar statements in two extreme regimes for the set Sğ‘†Sitalic_S. Our theorem holds when Sğ‘†Sitalic_S is permutation function, so it must necessarily be sparse (of size |S|=N2ğ‘†superscriptğ‘2|S|=N^{2}| italic_S | = italic_N start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT), whereas their result holds in the dense case where Sğ‘†Sitalic_S has size roughly N3âˆ’csuperscriptğ‘3ğ‘N^{3-c}italic_N start_POSTSUPERSCRIPT 3 - italic_c end_POSTSUPERSCRIPT for some small enough constant c>0ğ‘0c>0italic_c > 0. We briefly note that our pseudorandomness notion differs from theirs to better reflect an alternative regime of interest. 1.2 Future work We conclude by noting a few directions for future work. The results of [31] hold for sufficiently dense functions, while our results apply only to permutation functions which are sparse. It would be interesting to see if these results can be unified in a theorem which works in all density regimes. Another natural open question is to extend Theorem 1.2 to give quasi-polynomial bounds for corner-free sets over the integers or ğ”½2nsuperscriptsubscriptğ”½2ğ‘›\mathbb{F}_{2}^{n}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. Over the integers, there are constructions of corner-free sets of size 2âˆ’Î©â¢(logâ¡N)â¢N2superscript2Î©ğ‘superscriptğ‘22^{-\Omega(\sqrt{\log N})}N^{2}2 start_POSTSUPERSCRIPT - roman_Î© ( square-root start_ARG roman_log italic_N end_ARG ) end_POSTSUPERSCRIPT italic_N start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT [6] (see also the recent improvements [38, 25, 29]). Thus, such an extension would be optimal in the â€œshapeâ€ of the bound. While we are optimistic that the techniques present here may be useful in these settings, we are not able to directly apply Theorem 1.3, since the corresponding ambient set (see Section 4.2 for more details) Sâ‰”{(x,y,x+y)âˆˆ(â„¤/Nâ¢â„¤)3:x,yâˆˆâ„¤/Nâ¢â„¤}â‰”ğ‘†conditional-setğ‘¥ğ‘¦ğ‘¥ğ‘¦superscriptâ„¤ğ‘â„¤3ğ‘¥ğ‘¦â„¤ğ‘â„¤S\coloneqq\{(x,y,x+y)\in(\mathbb{Z}/N\mathbb{Z})^{3}:x,y\in\mathbb{Z}/N\mathbb% {Z}\}italic_S â‰” { ( italic_x , italic_y , italic_x + italic_y ) âˆˆ ( blackboard_Z / italic_N blackboard_Z ) start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT : italic_x , italic_y âˆˆ blackboard_Z / italic_N blackboard_Z } is not sufficiently pseudorandom (in the sense of Definition 2.1). For instance, if X,Y={1,â€¦,N/4}ğ‘‹ğ‘Œ1â€¦ğ‘4X,Y=\{1,\dots,N/4\}italic_X , italic_Y = { 1 , â€¦ , italic_N / 4 } and Z={3â¢N/4,â€¦,Nâˆ’1}ğ‘3ğ‘4â€¦ğ‘1Z=\{3N/4,\dots,N-1\}italic_Z = { 3 italic_N / 4 , â€¦ , italic_N - 1 }, then the cube XÃ—YÃ—Zğ‘‹ğ‘Œğ‘X\times Y\times Zitalic_X Ã— italic_Y Ã— italic_Z is dense in (â„¤/Nâ¢â„¤)3superscriptâ„¤ğ‘â„¤3(\mathbb{Z}/N\mathbb{Z})^{3}( blackboard_Z / italic_N blackboard_Z ) start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT but contains no points in Sğ‘†Sitalic_S. Similar obstructions also exist if we replace â„¤/Nâ¢â„¤â„¤ğ‘â„¤\mathbb{Z}/N\mathbb{Z}blackboard_Z / italic_N blackboard_Z with other abelian groups. Along similar lines, we note the bound in Theorem 1.2 appears to essentially be the quantitative limit of our techniques. However, it remains plausible that the strong structure imbued by quasirandomness guarantees that the largest corner-free sets over G=SL2â¢(ğ”½p)ğºsubscriptSL2subscriptğ”½ğ‘G=\textrm{SL}_{2}(\mathbb{F}_{p})italic_G = SL start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ) have size |G|2âˆ’Îµsuperscriptğº2ğœ€|G|^{2-\varepsilon}| italic_G | start_POSTSUPERSCRIPT 2 - italic_Îµ end_POSTSUPERSCRIPT for some small constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0. Such bounds would imply optimal separations between randomized and deterministic 3-NOF protocols. It would also be interesting to extend our NOF lower bounds to more than 3 players. Paper organization. We provide a detailed proof overview of our main theorem in Section 2 with proofs of the main technical lemmas deferred to Sections 5, 6, and 7. Section 3 contains a review of preliminary definitions and facts. Section 4 contains applications to lower bounds in the NOF model of communication, corners in quasirandom groups, and insights about the triangle removal lemma, respectively. Acknowledgments. We thank Russell Impagliazzo and David Zuckerman for helpful conversations, and Ilya Shkredov for answering a question about the current state-of-the-art. MJ would like to thank Sarah Peluse for her encouragement and collaboration on this question, as well as Amey Bhangale and Surya Teja Gavva for their collaboration on this question at the Simons Institue for the Theory of Computing."
https://arxiv.org/html/2411.02554v1,Quantum-Computable One-Way Functionswithout One-Way Functions,"We construct a classical oracle relative to which ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP but quantum-computable quantum-secure trapdoor one-way functions exist. This is a substantial strengthening of the result of Kretschmer, Qian, Sinha, and Tal (STOC 2023), which only achieved single-copy pseudorandom quantum states relative to an oracle that collapses ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP to ğ–¯ğ–¯\mathsf{P}sansserif_P. For example, our result implies multi-copy pseudorandom states and pseudorandom unitaries, but also classical-communication public-key encryption, signatures, and oblivious transfer schemes relative to an oracle on which ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP. Hence, in our new relativized world, classical computers live in â€œAlgorithmicaâ€ whereas quantum computers live in â€œCryptomania,â€ using the language of Impagliazzoâ€™s worlds.Our proof relies on a new distributional block-insensitivity lemma for ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuits, wherein a single block is resampled from an arbitrary distribution.","What cryptography would survive in the event of someone or some organization discovering a practical algorithm to solve ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP-complete problems? Unfortunately, almost all computationally-secure classical cryptography relies on the existence of one-way functions [IL89, Gol90]. Thus, their security certainly requires at least ğ–¯â‰ ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}\neq\mathsf{NP}sansserif_P â‰  sansserif_NP. Recent works have hinted that quantum analogues of many important cryptographic tasks may not be subject to this barrier. A series of black-box separations established that pseudorandom quantum statesâ€”a quantum counterpart to classical pseudorandom generatorsâ€”can exist relative to oracles that make ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP [KQST23], ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA [Kre21], and more powerful complexity classes [LMW24] computationally easy. Combined with parallel efforts to build cryptosystems from pseudorandom states [AQY22, MY22, AGQY22, ALY24, BBO+24, CGG24], we now know that useful computationally-secure quantum cryptography could conceivably exist in a world where ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP. Upon closer inspection, the cryptographic protocols realized in these oracle separations all require quantum communication, or even long-term quantum memory, in addition to fault-tolerant quantum computation. So, these oracle separations are hardly a satisfactory replacement for the classical cryptography that we currently use. For example, it is possible that we find efficient algorithms for problems like breaking SHA-3 and learning with errors before we have quantum internet or reliable quantum storage. Even outside of this nightmare scenario, quantum communication is not always desirable. Besides the obvious challenges of engineering a robust quantum channel, there are other theoretical and practical limitations to protocols that use quantum communication. Certain scenarios require broadcasting, which is impossible quantumly due to the no-broadcasting theorem [BCF+96]. For a concrete example, public-key encryptions and digital signatures with public key infrastructure (PKI) have been essential for securing digital communications. While quantum versions of public-key encryptions from one-way functions [BGHD+23, Col23, KMNY24, MW24] and digital signatures without one-way functions [GC01, MY22] have been explored, these schemes all make use of an uncloneable quantum public key, besides only satisfying weak security requirements such as one-time security. This unclonability is undesirable from the PKI perspective because it prevents the PKI from distributing the public key: once the copies that the PKI holds are exhausted, new users would be unable to obtain public keys and take part in the protocols. Altogether, these limitations of quantum communication in cryptography give rise to the following natural question: What quantum cryptography with classical communication is still possible if ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP? 1.1 Main Result Consider a quantum-computable one-way function (OWF), which is like an ordinary one-way function except that instead of mandating an efficient classical evaluation algorithm, we permit (pseudo-deterministic) quantum algorithms as well. Security must hold against both classical and quantum adversaries. It is clear that this is a weakening of traditional (quantum-secure) one-way functions. Since the only difference is in permitting evaluation by a quantum computer, one might be optimistic that this object is not so different from one-way functions, perhaps by employing some clever dequantizations. After all, a ğ–¡ğ–¯ğ–¯ğ–¡ğ–¯ğ–¯\mathsf{BPP}sansserif_BPP-computable pseudo-deterministic one-way function can be derandomized through standard black-box techniques.111In particular, a ğ–¡ğ–¯ğ–¯ğ–¡ğ–¯ğ–¯\mathsf{BPP}sansserif_BPP-computable OWF fâ¢(x;r)ğ‘“ğ‘¥ğ‘Ÿf(x;r)italic_f ( italic_x ; italic_r ) gives a distributional OWF fâ€²â¢(x,r):=fâ¢(x;r)assignsuperscriptğ‘“â€²ğ‘¥ğ‘Ÿğ‘“ğ‘¥ğ‘Ÿf^{\prime}(x,r):=f(x;r)italic_f start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ( italic_x , italic_r ) := italic_f ( italic_x ; italic_r ), which can then be used to construct a standard OWF [IL89]. In this work, we show, surprisingly, that quantum-computable OWFs can exist in an oracle world where ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP, and therefore dequantizing a quantum-computable OWF is impossible in a black-box fashion. In fact, our main theorem is a significant strengthening of this, where we construct quantum-computable trapdoor one-way functions that are consistent with ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP. Theorem 1 (Theorem 32, informal). There exists a classical oracle relative to which ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP and a quantum-computable trapdoor one-way function exists. Furthermore, the trapdoor one-way function has pseudorandom public keys. By invoking known post-quantum fully black-box reductions, we obtain that relative to the same classical oracle as Theorem 1, the following classical-communication cryptographic schemes also exist: â€¢ Public-key encryptions with semantic security. (Corollary 39) â€¢ Public-key signatures with existential unforgeable security. ([Son14, Section 5.1]) â€¢ Oblivious transfer protocols with simulation security. (Corollary 39) Therefore, it appears that in this oracular world, classical computers live in â€œAlgorithmicaâ€ while quantum computers live in â€œCryptomaniaâ€ [Imp95], even without the need of any long-term quantum memory or quantum communication! As a corollary, all of these cryptographic schemes are separated from ğ–¯â‰ ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}\neq\mathsf{NP}sansserif_P â‰  sansserif_NP (thus OWFs) as well. Note that prior to our work, even mildly quantum variants of these were not known to be separated from OWFs (e.g., public-key encryption with quantum ciphertext, or quantum signatures with standard security). Implications for Quantum Pseudorandomness. Recall that the previous oracle separations of comparable nature are instantiations of pseudorandom quantum states relative to oracles that make classical cryptography easy [Kre21, KQST23, LMW24]. Our result is strictly stronger, then, because quantum-computable one-way functions are also sufficient to construct pseudorandom states since these reductions to one-way functions are fully-black-box [JLS18, BS19, AGQY22]. Specifically, one can use the now standard binary phase construction: |ÏˆkâŸ©â‰”12nâ¢âˆ‘xâˆˆ{0,1}n(âˆ’1)fkâ¢(x)â¢|xâŸ©,â‰”ketsubscriptğœ“ğ‘˜1superscript2ğ‘›subscriptğ‘¥superscript01ğ‘›superscript1subscriptğ‘“ğ‘˜ğ‘¥ketğ‘¥\ket{\psi_{k}}\coloneqq\frac{1}{\sqrt{2^{n}}}\sum_{x\in\{0,1\}^{n}}(-1)^{f_{k}% (x)}\ket{x},| start_ARG italic_Ïˆ start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT end_ARG âŸ© â‰” divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG end_ARG âˆ‘ start_POSTSUBSCRIPT italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( - 1 ) start_POSTSUPERSCRIPT italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_x ) end_POSTSUPERSCRIPT | start_ARG italic_x end_ARG âŸ© , where {fk}subscriptğ‘“ğ‘˜\{f_{k}\}{ italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT } is a keyed family of pseudorandom functions constructed from the one-way functions [Zha21]. This directly answers an open problem from [KQST23]: Corollary 2. There exists a classical oracle relative to which ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP and many-copy-secure pseudorandom states exist. For comparison, [KQST23] only achieved single-copy-secure pseudorandom states. Following more recent advances, one can build even more versatile quantum pseudorandomness primitives from one-way functions, including pseudorandom states of arbitrary polynomial length [BS20] and even pseudorandom unitaries [MPSY24, CBB+24, MH24]. As a corollary, these also exist relative to our oracle as well. 1.2 Technical Overview Warmup: Separating Quantum-Computable PRFs. We first show how to construct an oracle relative to which ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP and quantum-computable pseudorandom functions (PRFs) exist. The analysis in this special case is conceptually simpler, though still rich enough to capture most of the important ideas needed to generalize to trapdoor one-way functions. The main idea behind this oracle separation is to construct a random oracle in a special encoding that is only accessible by ğ–¡ğ–°ğ–¯ğ–¡ğ–°ğ–¯\mathsf{BQP}sansserif_BQP but not ğ–¯ğ–§ğ–¯ğ–§\mathsf{PH}sansserif_PH. This encoding technique was previously seen in the work of Aaronson, Ingram, and Kretschmer [AIK22], although similar ideas have also appeared in even earlier works [BM99, ABDK16]. Then intuitively, the quantum-computable pseudorandom functions can simply be constructed by direct evaluation of this quantum-computable random oracle. We now explain the oracle construction in more detail. Similar to the oracle used in [KQST23], our oracle ğ’ªğ’ª\mathcal{O}caligraphic_O can be thought of as a pair of oracles (A,B)ğ´ğµ(A,B)( italic_A , italic_B ). The oracle Ağ´Aitalic_A encodes the ğ–¡ğ–°ğ–¯ğ–¡ğ–°ğ–¯\mathsf{BQP}sansserif_BQP-accessible random oracle, and the addition of auxiliary oracle BğµBitalic_B has the effect of making ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP. Morally speaking, BğµBitalic_B behaves as if it were an oracle for ğ–¯ğ–§Asuperscriptğ–¯ğ–§ğ´\mathsf{PH}^{A}sansserif_PH start_POSTSUPERSCRIPT italic_A end_POSTSUPERSCRIPT. Thus, showing the security of the quantum-computable PRFs relative to ğ’ªğ’ª\mathcal{O}caligraphic_O amounts to proving security against polynomial-time quantum adversaries that can query any ğ–¯ğ–§Asuperscriptğ–¯ğ–§ğ´\mathsf{PH}^{A}sansserif_PH start_POSTSUPERSCRIPT italic_A end_POSTSUPERSCRIPT language. For brevity, weâ€™ll call these ğ–¡ğ–°ğ–¯ğ–¯ğ–§superscriptğ–¡ğ–°ğ–¯ğ–¯ğ–§\mathsf{BQP^{PH}}sansserif_BQP start_POSTSUPERSCRIPT sansserif_PH end_POSTSUPERSCRIPT (oracular) adversaries in this exposition. The key difference between our oracle construction and that of [KQST23] is in how we build Ağ´Aitalic_A. In [KQST23], Ağ´Aitalic_A is simply a random oracle, whereas in this warmup, Ağ´Aitalic_A is an encoding of a uniformly random oracle. As with many of the oracles constructed in [AIK22], we encode each bit of the oracle using the Forrelation problem [Aar10, RT19]. Recall that Forrelation (in its broadest sense) is the following task: given query access to a pair of functions f,g:{0,1}â„“â†’{0,1}:ğ‘“ğ‘”â†’superscript01â„“01f,g:\{0,1\}^{\ell}\to\{0,1\}italic_f , italic_g : { 0 , 1 } start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT â†’ { 0 , 1 }, distinguish between (NO) fğ‘“fitalic_f and gğ‘”gitalic_g are independent uniformly random functions, or (YES) fğ‘“fitalic_f and gğ‘”gitalic_g are individually random, but sampled in such a way that fğ‘“fitalic_f is noticeably correlated with the Boolean Fourier transform of gğ‘”gitalic_g (i.e., fğ‘“fitalic_f and gğ‘”gitalic_g are â€œForrelatedâ€). In contrast to [KQST23], whose analysis required a carefully-crafted version of Forrelation, we only require black-box use of one key fact from [RT19]: that these two distributions are efficiently distinguishable by ğ–¡ğ–°ğ–¯ğ–¡ğ–°ğ–¯\mathsf{BQP}sansserif_BQP algorithms, but not by ğ–¯ğ–§ğ–¯ğ–§\mathsf{PH}sansserif_PH algorithms. Letting Lğ¿Litalic_L be the random oracle, our strategy for encoding Lğ¿Litalic_L is to hide each bit of its output behind an instance of Forrelation. That is, for each xâˆˆ{0,1}âˆ—ğ‘¥superscript01x\in\{0,1\}^{*}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT, we add a region of Ağ´Aitalic_A that encodes a pair of uniformly random Boolean functions if Lâ¢(x)=0ğ¿ğ‘¥0L(x)=0italic_L ( italic_x ) = 0, or otherwise a pair of Forrelated functions if Lâ¢(x)=1ğ¿ğ‘¥1L(x)=1italic_L ( italic_x ) = 1. It is straightforward to show that oracle access to Ağ´Aitalic_A enables a quantum algorithm to recover any bit of Lğ¿Litalic_L. The candidate quantum-computable PRF family {fk}subscriptğ‘“ğ‘˜\{f_{k}\}{ italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT } is the natural choice defined by fk(x)â‰”L(k||x)f_{k}(x)\coloneqq L(k||x)italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_x ) â‰” italic_L ( italic_k | | italic_x ). The main technical difficulty is to formalize the intuition that this encoding is secure enough against ğ–¯ğ–§ğ–¯ğ–§\mathsf{PH}sansserif_PH that distinguishing the PRFs from random remains hard even against ğ–¡ğ–°ğ–¯ğ–¯ğ–§superscriptğ–¡ğ–°ğ–¯ğ–¯ğ–§\mathsf{BQP^{PH}}sansserif_BQP start_POSTSUPERSCRIPT sansserif_PH end_POSTSUPERSCRIPT adversaries. We expect this to be the case because to ğ–¯ğ–§ğ–¯ğ–§\mathsf{PH}sansserif_PH, the oracle Ağ´Aitalic_A looks completely random and independent of Lğ¿Litalic_L, and therefore a ğ–¡ğ–°ğ–¯ğ–¯ğ–§superscriptğ–¡ğ–°ğ–¯ğ–¯ğ–§\mathsf{BQP^{PH}}sansserif_BQP start_POSTSUPERSCRIPT sansserif_PH end_POSTSUPERSCRIPT adversary should not have much more power than a ğ–¡ğ–°ğ–¯ğ–¡ğ–°ğ–¯\mathsf{BQP}sansserif_BQP adversary. To make this argument rigorous, we have to prove that a ğ–¡ğ–°ğ–¯ğ–¯ğ–§superscriptğ–¡ğ–°ğ–¯ğ–¯ğ–§\mathsf{BQP^{PH}}sansserif_BQP start_POSTSUPERSCRIPT sansserif_PH end_POSTSUPERSCRIPT adversary, given oracle access to an auxiliary function hâ„hitalic_h, cannot distinguish whether hâ„hitalic_h is uniformly random or whether hâ„hitalic_h is one of the pseudorandom functions fksubscriptğ‘“ğ‘˜f_{k}italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT. We establish this by observing that it suffices to show the following: if the adversary is given a uniformly random hâ„hitalic_h, then the adversary is unlikely to detect a change to the oracle Ağ´Aitalic_A so as to make it consistent with h=fkâ„subscriptğ‘“ğ‘˜h=f_{k}italic_h = italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT for a random key kğ‘˜kitalic_k. For the PRF family {fk}kâˆˆ{0,1}nsubscriptsubscriptğ‘“ğ‘˜ğ‘˜superscript01ğ‘›\{f_{k}\}_{k\in\{0,1\}^{n}}{ italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_k âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUBSCRIPT of functions fk:{0,1}nâ†’{0,1}:subscriptğ‘“ğ‘˜â†’superscript01ğ‘›01f_{k}:\{0,1\}^{n}\to\{0,1\}italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT : { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ { 0 , 1 }, we can view the part of Ağ´Aitalic_A encoding these functions as a 2nÃ—2nsuperscript2ğ‘›superscript2ğ‘›2^{n}\times 2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT Ã— 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT matrix of Forrelation instances. In this matrix, the rows are indexed by keys kâˆˆ{0,1}nğ‘˜superscript01ğ‘›k\in\{0,1\}^{n}italic_k âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, the columns by inputs xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, and the corresponding Forrelation instance is Forrelated if fkâ¢(x)=1subscriptğ‘“ğ‘˜ğ‘¥1f_{k}(x)=1italic_f start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_x ) = 1, or uniform otherwise. Given h:{0,1}nâ†’{0,1}:â„â†’superscript01ğ‘›01h:\{0,1\}^{n}\to\{0,1\}italic_h : { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ { 0 , 1 }, the goal of the adversary is to determine whether there is a row of the matrix whose pattern of Forrelated/uniform instances is consistent with hâ„hitalic_h. See Figure 1 for an example. h=â„absenth=italic_h = 0 1 0 1 â‡“â‡“\Downarrowâ‡“ Uniform Forrelated Uniform Uniform Forrelated Uniform Forrelated Forrelated Forrelated Uniform Forrelated Uniform Uniform Uniform Forrelated Forrelated vs. Uniform Forrelated Uniform Uniform Uniform Forrelated Uniform Forrelated Forrelated Uniform Forrelated Uniform Uniform Uniform Forrelated Forrelated Figure 1: An example of the distinguishing task for our quantum-computable PRFs with n=2ğ‘›2n=2italic_n = 2. The goal is to decide (left) whether the Forrelation instances in the matrix are all randomly assigned to either uniform or Forrelated, or (right) whether the pattern of 0s/1s in hâ„hitalic_h matches the pattern of uniform/Forrelated in one of the rows. Our security proof proceeds in a similar fashion to the ğ–¡ğ–°ğ–¯ğ–¯ğ–§superscriptğ–¡ğ–°ğ–¯ğ–¯ğ–§\mathsf{BQP^{PH}}sansserif_BQP start_POSTSUPERSCRIPT sansserif_PH end_POSTSUPERSCRIPT lower bound for the so-called ORâˆ˜ForrelationORForrelation\textsc{OR}\circ\textsc{Forrelation}OR âˆ˜ Forrelation problem that was considered in prior works [AIK22, KQST23]. In ORâˆ˜ForrelationORForrelation\textsc{OR}\circ\textsc{Forrelation}OR âˆ˜ Forrelation, we are given a list of instances of the Forrelation problem, and must decide whether they are all uniform (NO), or whether a single one of the instances is Forrelated (YES). Using the well-known correspondence between ğ–¯ğ–§ğ–¯ğ–§\mathsf{PH}sansserif_PH query algorithms and ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuits [FSS84], the ğ–¡ğ–°ğ–¯ğ–¯ğ–§superscriptğ–¡ğ–°ğ–¯ğ–¯ğ–§\mathsf{BQP^{PH}}sansserif_BQP start_POSTSUPERSCRIPT sansserif_PH end_POSTSUPERSCRIPT lower bound for ORâˆ˜ForrelationORForrelation\textsc{OR}\circ\textsc{Forrelation}OR âˆ˜ Forrelation reduces to a certain type of sensitivity concentration result for ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuits. The key step [AIK22, Lemma 45] shows that for most uniformly random MÃ—Nğ‘€ğ‘M\times Nitalic_M Ã— italic_N Boolean matrices, an ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuit is unlikely to notice the change if we uniformly swap out one of the rows for fresh random bits. We show that security of our PRF ensemble also reduces to a comparable statement about the sensitivity of ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuits, but under a distribution of Boolean matrices that is not uniform. Instead, we have to consider matrices like those sampled in Figure 1, where the blocks are a random pattern of uniform or Forrelated. For this purpose, we are able to show the following main technical lemma, which informally states the following. Consider a quasi-polynomial-size ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuit that takes Kğ¾Kitalic_K blocks of bits, where each block is sampled independently from an arbitrary distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D. Then for sufficiently large Kğ¾Kitalic_K, it is hard for it to notice if any block is resampled from the same distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D. More formally, Lemma 3 (Lemma 15, restated). Let f:{0,1}Kâ¢Mâ†’{0,1}:ğ‘“â†’superscript01ğ¾ğ‘€01f:\{0,1\}^{KM}\to\{0,1\}italic_f : { 0 , 1 } start_POSTSUPERSCRIPT italic_K italic_M end_POSTSUPERSCRIPT â†’ { 0 , 1 } be an ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuit of size sğ‘ sitalic_s and depth dğ‘‘ditalic_d. Let ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D be a distribution over {0,1}Msuperscript01ğ‘€\{0,1\}^{M}{ 0 , 1 } start_POSTSUPERSCRIPT italic_M end_POSTSUPERSCRIPT. Let xâˆ¼ğ’ŸKsimilar-toğ‘¥superscriptğ’Ÿğ¾x\sim\mathcal{D}^{K}italic_x âˆ¼ caligraphic_D start_POSTSUPERSCRIPT italic_K end_POSTSUPERSCRIPT be an input to fğ‘“fitalic_f, viewed as a KÃ—Mğ¾ğ‘€K\times Mitalic_K Ã— italic_M matrix. Let yğ‘¦yitalic_y be sampled depending on xğ‘¥xitalic_x as follows: uniformly select one of the rows of xğ‘¥xitalic_x, resample that row from ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D, and leave the other rows of xğ‘¥xitalic_x unchanged. Then for any p>0ğ‘0p>0italic_p > 0: Prxâˆ¼ğ’ŸKâ¡[Pryâ¡[fâ¢(x)â‰ fâ¢(y)]â‰¥p]â‰¤4â¢Kpâ‹…2âˆ’pâ¢KOâ¢(logâ¡s)dâˆ’1.subscriptPrsimilar-toğ‘¥superscriptğ’Ÿğ¾subscriptPrğ‘¦ğ‘“ğ‘¥ğ‘“ğ‘¦ğ‘â‹…4ğ¾ğ‘superscript2ğ‘ğ¾ğ‘‚superscriptğ‘ ğ‘‘1\Pr_{x\sim\mathcal{D}^{K}}\left[\Pr_{y}\left[f(x)\neq f(y)\right]\geq p\right]% \leq\frac{4K}{p}\cdot 2^{-\frac{pK}{O(\log s)^{d-1}}}.roman_Pr start_POSTSUBSCRIPT italic_x âˆ¼ caligraphic_D start_POSTSUPERSCRIPT italic_K end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ roman_Pr start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT [ italic_f ( italic_x ) â‰  italic_f ( italic_y ) ] â‰¥ italic_p ] â‰¤ divide start_ARG 4 italic_K end_ARG start_ARG italic_p end_ARG â‹… 2 start_POSTSUPERSCRIPT - divide start_ARG italic_p italic_K end_ARG start_ARG italic_O ( roman_log italic_s ) start_POSTSUPERSCRIPT italic_d - 1 end_POSTSUPERSCRIPT end_ARG end_POSTSUPERSCRIPT . Notably, this holds for any distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D, and not merely the distribution of randomly chosen uniform/Forrelated blocks. Previously, Lemma 3 was only known to hold in the special case where ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is the uniform distribution [AIK22, Lemma 45]. The proof of this lemma involves a careful construction of a related ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuit from fğ‘“fitalic_f, whose sensitivity corresponds to the probability of fğ‘“fitalic_f noticing the block being resampled. This then allows us to relate this to known sensitivity bounds on ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT circuits [AIK22]. We refer interested readers to Lemma 15 for the details. Generalization to Trapdoor Functions. Since Lemma 3 morally lets us resample an arbitrary block that can be arbitrarily distributed, we can in fact prove that the distinguishing task in Figure 1 is hard for any distribution of functions instead of just uniform. A natural idea then is to use Forrelation to encode a more structured oracle that allows us to construct more structured cryptographic primitives. However, we also cannot introduce more structure than what Lemma 3 allows us to handle. For example, to get quantum-computable oblivious transfer protocols, a natural idea would be to encode random trapdoored permutations or something similar instead. However, unlike a random function, a random permutation is already problematic since each entry in a random permutation is weakly correlated with the other entries. On the other hand, Lemma 3 only works with product distributions. Inspired by this example, we instead start with random functions and only introduce just enough structure to have a trapdoor. Specifically, to obtain an oracle relative to which some form of quantum-computable trapdoor one-way functions exist but ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP, we utilize a similar Forrelation encoding, but the oracle Ağ´Aitalic_A is no longer random. Instead, Ağ´Aitalic_A encodes a triple of functions G,F,Iğºğ¹ğ¼G,F,Iitalic_G , italic_F , italic_I where â€¢ Gâ¢(tâ¢d)ğºğ‘¡ğ‘‘G(td)italic_G ( italic_t italic_d ) is a random function mapping a trapdoor tâ¢dğ‘¡ğ‘‘tditalic_t italic_d to its public key pâ¢kğ‘ğ‘˜pkitalic_p italic_k; â€¢ Fâ¢(pâ¢k,x)ğ¹ğ‘ğ‘˜ğ‘¥F(pk,x)italic_F ( italic_p italic_k , italic_x ) is also a random function mapping a public key pâ¢kğ‘ğ‘˜pkitalic_p italic_k and input xğ‘¥xitalic_x to an output yğ‘¦yitalic_y; â€¢ Finally, Iâ¢(tâ¢d,y)ğ¼ğ‘¡ğ‘‘ğ‘¦I(td,y)italic_I ( italic_t italic_d , italic_y ) is the only â€œstructuredâ€ function that inverts an image yğ‘¦yitalic_y of Fâ¢(Gâ¢(tâ¢d),â‹…)ğ¹ğºğ‘¡ğ‘‘â‹…F(G(td),\cdot)italic_F ( italic_G ( italic_t italic_d ) , â‹… ) using the trapdoor tâ¢dğ‘¡ğ‘‘tditalic_t italic_d. Then the quantum-computable trapdoor one-way function construction is simply evaluating these three functions G,F,Iğºğ¹ğ¼G,F,Iitalic_G , italic_F , italic_I by a ğ–¡ğ–°ğ–¯ğ–¡ğ–°ğ–¯\mathsf{BQP}sansserif_BQP algorithm that queries the Forrelation encodings in Ağ´Aitalic_A. For security, we want to show that a ğ–¡ğ–°ğ–¯ğ–¯ğ–§superscriptğ–¡ğ–°ğ–¯ğ–¯ğ–§\mathsf{BQP^{PH}}sansserif_BQP start_POSTSUPERSCRIPT sansserif_PH end_POSTSUPERSCRIPT adversary, given pâ¢k=Gâ¢(tâ¢d)ğ‘ğ‘˜ğºğ‘¡ğ‘‘pk=G(td)italic_p italic_k = italic_G ( italic_t italic_d ) and y=Fâ¢(pâ¢k,x)ğ‘¦ğ¹ğ‘ğ‘˜ğ‘¥y=F(pk,x)italic_y = italic_F ( italic_p italic_k , italic_x ) for random trapdoor tâ¢dğ‘¡ğ‘‘tditalic_t italic_d and input xğ‘¥xitalic_x, cannot find a preimage xâ€²superscriptğ‘¥â€²x^{\prime}italic_x start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT such that Fâ¢(pâ¢k,xâ€²)=yğ¹ğ‘ğ‘˜superscriptğ‘¥â€²ğ‘¦F(pk,x^{\prime})=yitalic_F ( italic_p italic_k , italic_x start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) = italic_y. Proving this is more challenging than before since the encoded oracle here is more sophisticated than simply a random function. However, notice that the previous security proof for the PRF reduces to a resampling indistinguishability task (Figure 1). We can similarly reduce security to resampling indistinguishability with some additional steps: 1. Starting with the real experiment (G,F,I)ğºğ¹ğ¼(G,F,I)( italic_G , italic_F , italic_I ), we first argue that GğºGitalic_G and Iğ¼Iitalic_I do not help the adversary in inverting yğ‘¦yitalic_y as follows. (a) First, resample Gâ¢(tâ¢d)=pâ¢kâˆ—ğºğ‘¡ğ‘‘ğ‘superscriptğ‘˜G(td)=pk^{*}italic_G ( italic_t italic_d ) = italic_p italic_k start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT and set Iâ¢(tâ¢d,â‹…)ğ¼ğ‘¡ğ‘‘â‹…I(td,\cdot)italic_I ( italic_t italic_d , â‹… ) to be the inversion table for Fâ¢(pâ¢kâˆ—,â‹…)ğ¹ğ‘superscriptğ‘˜â‹…F(pk^{*},\cdot)italic_F ( italic_p italic_k start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT , â‹… ) instead: this is indistinguishable since we are resampling one of exponentially many blocks of (G,I)ğºğ¼(G,I)( italic_G , italic_I ). (b) Next, we want to claim that Iğ¼Iitalic_I no longer contains the inversion table for Fâ¢(pâ¢k,â‹…)ğ¹ğ‘ğ‘˜â‹…F(pk,\cdot)italic_F ( italic_p italic_k , â‹… ). The idea is to argue that tâ¢dğ‘¡ğ‘‘tditalic_t italic_d was the only trapdoor that inverts Fâ¢(pâ¢k,â‹…)ğ¹ğ‘ğ‘˜â‹…F(pk,\cdot)italic_F ( italic_p italic_k , â‹… ) and after resampling it, there is no trapdoor left to invert Fâ¢(pâ¢k,â‹…)ğ¹ğ‘ğ‘˜â‹…F(pk,\cdot)italic_F ( italic_p italic_k , â‹… ) with overwhelming probability. For this to hold, it suffices to take GğºGitalic_G to be length expanding enough so that it is injective with overwhelming probability. 2. After the first step, Fâ¢(pâ¢k,â‹…)ğ¹ğ‘ğ‘˜â‹…F(pk,\cdot)italic_F ( italic_p italic_k , â‹… ) is essentially a random function independent of the rest of the oracle, which includes Iğ¼Iitalic_I, GğºGitalic_G, and the rest of Fğ¹Fitalic_F. Therefore, we can prove it is one-way using the same approach as before. Morally, we next resample Fâ¢(pâ¢k,x)ğ¹ğ‘ğ‘˜ğ‘¥F(pk,x)italic_F ( italic_p italic_k , italic_x ) indistinguishably so that yğ‘¦yitalic_y is no longer in the image of Fâ¢(pâ¢k,â‹…)ğ¹ğ‘ğ‘˜â‹…F(pk,\cdot)italic_F ( italic_p italic_k , â‹… ), making inversion impossible. Beyond Trapdoor Functions. Observe that this proof sketch actually establishes something stronger. Specifically, the two steps above prove that our trapdoor function construction satisfies two additional properties, which are respectively: (a) the public keys are pseudorandom and (b) the function is one-way under a truly random public key. These properties allow us to construct what is called a fakeable public-key encryption (PKE) scheme [GKM+00] which is â€œessentially equivalentâ€ to semi-honest oblivious transfer. On a high level, a fakeable public-key primitive has a â€œfake modeâ€ of sampling the public key such that security holds even if given the randomness for fakely sampling the public key. In our case, the fake mode sampling would simply be outputting the input randomness as is. Finally, we briefly comment on adapting constructions for trapdoor one-way functions with pseudorandom public keys to the quantum-computable setting, such as constructing fully-secure oblivious transfer from a semi-honest protocol. Building cryptography out of quantum-computable primitives requires additional care, because it is not always possible to mindlessly substitute a classical primitive with a quantum-computable counterpart. For example, consider the scenario where we wish to prove that a one-way function was computed correctly in zero-knowledge.222This is not a contrived example: many oblivious transfer protocol constructions do make use of such functionality. Classically, this could be done just by the assumption that one-way functions exist because the statement above is in ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP. However, if we wish to instead prove that a quantum-computable one-way function was computed correctly in zero-knowledge, then this would appear to be a ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA statement, so the construction breaks down. We resolve this by observing that as long as we have a post-quantum fully black-box reduction [RTV04] then substituting with a quantum-computable primitive works. 1.3 Discussion Explaining Quantum-Classical Separations. There are two high-level reasons why quantum cryptographic primitives are harder to break than classical ones, even if they inherently can only be computationally secure.333We focus on separations of these strictly-computational primitives, unlike statistical-computational separations such as QKD [BB84] vs. classical key exchange. The first is purely complexity-theoretic: because the challenger is quantum rather than classical, adversaries require stronger computational power to detect patterns produced by the challenger. For example, whereas inverting a one-way function is a canonical example of an ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP problem, inverting a quantum-computable one-way function is a ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA problem. The containment ğ–­ğ–¯âŠ†ğ–°ğ–¢ğ–¬ğ– ğ–­ğ–¯ğ–°ğ–¢ğ–¬ğ– \mathsf{NP}\subseteq\mathsf{QCMA}sansserif_NP âŠ† sansserif_QCMA is believed to be strict, and this distinction alone allows for the possibility that quantum cryptography could be beyond the grasp of ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP algorithms. The second reason is information-theoretic: the challenges themselves could be complex and highly-entangled quantum states, rather than classical bit strings that can be readily copied. So, we cannot even express the security games as problems within our usual mathematical framework of complexity classes like ğ–¯ğ–¯\mathsf{P}sansserif_P, ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP, ğ–¡ğ–°ğ–¯ğ–¡ğ–°ğ–¯\mathsf{BQP}sansserif_BQP, or ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA: these classes are only equipped to operate on classical inputs! While some recent efforts have been made to define complexity classes that accept quantum inputs (e.g. ğ—ğ—‡ğ—‚ğ—ğ–ºğ—‹ğ—’ğ–¡ğ–°ğ–¯ğ—ğ—‡ğ—‚ğ—ğ–ºğ—‹ğ—’ğ–¡ğ–°ğ–¯\mathsf{unitaryBQP}sansserif_unitaryBQP [BEM+23]), the connections between these â€œğ—ğ—‡ğ—‚ğ—ğ–ºğ—‹ğ—’ğ—ğ—‡ğ—‚ğ—ğ–ºğ—‹ğ—’\mathsf{unitary}sansserif_unitaryâ€ complexity classes and their classical-input counterparts remain unclear. We point out this distinction because to date, the existing oracle separations between pseudorandom states and classical cryptography [Kre21, KQST23, LMW24] have widely been understood as arising from the second feature. Our Theorem 1 is the first that clearly makes use of the first feature exclusively, because quantum-computable one-way functions output classical security challenges. For comparison, recall: â€¢ [Kre21] constructs a quantum oracle relative to which ğ–¡ğ–°ğ–¯=ğ–°ğ–¬ğ– ğ–¡ğ–°ğ–¯ğ–°ğ–¬ğ– \mathsf{BQP}=\mathsf{QMA}sansserif_BQP = sansserif_QMA and pseudorandom states exist. The proof makes crucial use of the quantum-challenge nature of pseudorandom states. One way to see this is the fact that quantum-computable one-way functions do not exist relative to this oracle. â€¢ [KQST23] constructs an oracle relative to which ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP and single-copy pseudorandom states exist. Here, it is not so clear whether the quantumness of the pseudorandom states is essential for this separation, as quantum-computable one-way functions may or may not exist relative to this oracle. (We discuss this further in the related work section.) â€¢ [LMW24] (implicitly444Take a random language Lğ¿Litalic_L, and let the oracle ğ’ªğ’ª\mathcal{O}caligraphic_O be any ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤Lsuperscriptğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ¿\mathsf{PSPACE}^{L}sansserif_PSPACE start_POSTSUPERSCRIPT italic_L end_POSTSUPERSCRIPT-complete language. Then clearly ğ–¯ğ’ª=ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ’ªsuperscriptğ–¯ğ’ªsuperscriptğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ’ª\mathsf{P}^{\mathcal{O}}=\mathsf{PSPACE}^{\mathcal{O}}sansserif_P start_POSTSUPERSCRIPT caligraphic_O end_POSTSUPERSCRIPT = sansserif_PSPACE start_POSTSUPERSCRIPT caligraphic_O end_POSTSUPERSCRIPT. [LMW24] construct a single-copy pseudorandom state ensemble using queries to Lğ¿Litalic_L (which can certainly be simulated using queries to ğ’ªğ’ª\mathcal{O}caligraphic_O) whose parallel-query security holds relative to any oracle ğ’ªğ’ª\mathcal{O}caligraphic_O. ) constructs a classical oracle relative to which ğ–¯=ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{P}=\mathsf{PSPACE}sansserif_P = sansserif_PSPACE and single-copy pseudorandom states cannot be broken by efficient parallel-query adversaries. But ğ–¯=ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{P}=\mathsf{PSPACE}sansserif_P = sansserif_PSPACE implies (for example) that any one-round classical-communication falsifiable protocol can be broken by an efficient parallel-query adversary, because the optimal adversary strategy can be simulated in ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE. This certainly implies that quantum-computable one-way functions do not exist relative to this oracle. So, the security of the pseudorandom state ensemble here also relies on its use of quantum challenges. Thus, our work is the only one to use the first feature alone, hinting at the possibility of quantum advantage for computing a one-way function. For this reason, a worthwhile direction for future research complementing ours is to give stronger evidence that the second feature (the use of quantum states in computationally-secure cryptography) directly enables separations from classical cryptography. All of the existing separations in this regard have caveats: [Kre21] uses a quantum oracle, [KQST23] might not rely on the use of quantum challenges at all, and [LMW24] only obtains security against parallel-query adversaries. For this purpose, we reiterate the following open problem that was raised in earlier works [Kre21, KQST23]: Problem 4. Construct a classical oracle relative to which ğ–¯=ğ–°ğ–¬ğ– ğ–¯ğ–°ğ–¬ğ– \mathsf{P}=\mathsf{QMA}sansserif_P = sansserif_QMA (or at least ğ–¡ğ–°ğ–¯=ğ–°ğ–¢ğ–¬ğ– ğ–¡ğ–°ğ–¯ğ–°ğ–¢ğ–¬ğ– \mathsf{BQP}=\mathsf{QCMA}sansserif_BQP = sansserif_QCMA) and pseudorandom states (or at least quantum commitments) exist. The main appeal of 4 is that it would answer this conceptual question about the role of quantum challenges in cryptography, without necessarily requiring a resolution to the long-standing unitary synthesis problem in quantum query complexity [AK07, Aar16, LMW24]. Related Work. Compared to [KQST23], who gave a black-box construction of single-copy-secure pseudorandom states relative to an oracle that makes ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP, our work has some advantages. As noted before, our result is strictly stronger, because one can additionally build quantum-computable (trapdoor) one-way functions relative to our oracle. These imply single-copy pseudorandom states but are not necessary for them [Kre21]. Also, our proof is somewhat simpler, because we do not require a special version of the Forrelation problem; hardness against ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT and easiness for quantum algorithms are sufficient for the construction to work. One difference, however, is that our oracle is more structured. Both our oracle and [KQST23]â€™s take the form ğ’ª=(A,B)ğ’ªğ´ğµ\mathcal{O}=(A,B)caligraphic_O = ( italic_A , italic_B ), where in both cases BğµBitalic_B is constructed from Ağ´Aitalic_A in an identical fashion. But, whereas [KQST23] takes Ağ´Aitalic_A to be a random oracle, we do not. The Aaronsonâ€“Ambainis conjecture [AA14] provides some evidence that this difference is necessary: if the Aaronsonâ€“Ambainis conjecture is true, then any pseudo-deterministic quantum algorithm querying the random oracle can be query-efficiently simulated by a classical algorithm as well. Thus, intuitively, a random oracle does not assist in building a quantum-computable one-way function that is not also classically-computable. Our main theorem also improves upon the separation in [AIK22, Theorem 4], which shows that there is an oracle relative to which ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP but ğ–¡ğ–°ğ–¯â‰ ğ–°ğ–¢ğ–¬ğ– ğ–¡ğ–°ğ–¯ğ–°ğ–¢ğ–¬ğ– \mathsf{BQP}\neq\mathsf{QCMA}sansserif_BQP â‰  sansserif_QCMA. The same complexity class separations hold relative to our oracle, because quantum-computable one-way functions cannot exist if ğ–¡ğ–°ğ–¯=ğ–°ğ–¢ğ–¬ğ– ğ–¡ğ–°ğ–¯ğ–°ğ–¢ğ–¬ğ– \mathsf{BQP}=\mathsf{QCMA}sansserif_BQP = sansserif_QCMA. Starting with the work of Ananth, Gulati, Qian, and Yuen [AGQY22], there have been a few works [ALY24, BBO+24, CGG24] aiming to construct classical-communication quantum cryptography without using a one-way function. One might intuitively believe that these constructions do not rely on one-way functions because they are based on logarithmic-output-length pseudorandom states, which seem weaker. Nevertheless, our work is the first to black-box separate these logarithmic-output-length pseudorandom states from one-way functions, as they can be black-box constructed from quantum-computable pseudorandom functions [BS20]. Furthermore, we separate a stronger object, a (pseudo-deterministic) trapdoor one-way function. Pseudorandom state-based constructions are also messier and less elegant due to the use of tomography. Another recent line of works aim to investigate the (im)possibility of constructing quantum public-key encryption (PKE) schemes from one-way functions [ACC+22, BGHD+23, Col23, BGVV24, KMNY24, LLLL24, MW24]. Specifically, it is shown that they can be constructed from OWFs if the public key is allowed to be an uncloneable quantum state. We do consider the stronger notion of quantum-computable classical-communication PKE, but the construction essentially assumes quantum-computable trapdoor OWFs. This assumption (as we have shown) is incomparable to OWFs. Future Directions. One open question is to strengthen our separation to separate quantum-computable collision resistance, quantum-computable one-way permutations, or quantum-computable indistinguishability obfuscation and quantum-computable OWFs from ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP as well. Our oracle construction could be straightforwardly adapted to those settings by replacing the Forrelation-encoded random oracle with a Forrelation encoding of any oracle that instantiates these primitives. However, proving security of these primitives relative to such oracles remains a challenge. It seems one would need a stronger ğ– ğ–¢ğŸ¢superscriptğ– ğ–¢0\mathsf{AC^{0}}sansserif_AC start_POSTSUPERSCRIPT sansserif_0 end_POSTSUPERSCRIPT sensitivity bound (like Lemma 3) capable of handling a more complicated resampling procedure, e.g. where multiple rows may be updated in a correlated fashion. While our work, along with earlier oracle separations, only studies separations between abstract cryptographic primitives, these also reveal a potential pathway towards finding cryptographically-useful concrete assumptions beneath one-way functions. Specifically, this work shows that if we consider a candidate one-way function that we only know how to evaluate with quantum computers, then its security could resist even the proof of ğ–¯=ğ–­ğ–¯ğ–¯ğ–­ğ–¯\mathsf{P}=\mathsf{NP}sansserif_P = sansserif_NP. Unlike the work of [KQST23], however, it is unclear how to heuristically instantiate our oracle, because we do not know of any candidates for non-oracular problems in ğ–¡ğ–°ğ–¯ğ–¡ğ–°ğ–¯\mathsf{BQP}sansserif_BQP that are hard for ğ–¯ğ–§ğ–¯ğ–§\mathsf{PH}sansserif_PH [Aar18]. However, the recent work of Khurana and Tomer [KT24] constructs quantum cryptography from #â¢ğ–¯#ğ–¯\mathsf{\#P}# sansserif_P-hardness and quantum advantage conjectures, and our work hints that quantum-computable classical cryptography could be realized from similar assumptions as well. We leave as a future research direction to investigate concrete quantum-computable classical cryptography instantiations. Finally, we note that our technical contributions may prove useful towards resolving a certain open problem about oracle separations of complexity classes. Aaronson [Aar10] raised the question of whether there exists an oracle relative to which ğ–­ğ–¯âŠ†ğ–¡ğ–°ğ–¯ğ–­ğ–¯ğ–¡ğ–°ğ–¯\mathsf{NP}\subseteq\mathsf{BQP}sansserif_NP âŠ† sansserif_BQP but ğ–¯ğ–§âŠ„ğ–¡ğ–°ğ–¯not-subset-ofğ–¯ğ–§ğ–¡ğ–°ğ–¯\mathsf{PH}\not\subset\mathsf{BQP}sansserif_PH âŠ„ sansserif_BQP. Later work by Aaronson, Ingram, and Kretschmer [AIK22] conjectured the possibility of a more granular separation, namely: an oracle relative to which Î£kğ–¯âŠ†ğ–¡ğ–°ğ–¯superscriptsubscriptsans-serif-Î£ğ‘˜ğ–¯ğ–¡ğ–°ğ–¯\mathsf{\Sigma}_{k}^{\mathsf{P}}\subseteq\mathsf{BQP}sansserif_Î£ start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT start_POSTSUPERSCRIPT sansserif_P end_POSTSUPERSCRIPT âŠ† sansserif_BQP but Î£k+1ğ–¯âŠ„ğ–¡ğ–°ğ–¯not-subset-ofsuperscriptsubscriptsans-serif-Î£ğ‘˜1ğ–¯ğ–¡ğ–°ğ–¯\mathsf{\Sigma}_{k+1}^{\mathsf{P}}\not\subset\mathsf{BQP}sansserif_Î£ start_POSTSUBSCRIPT italic_k + 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT sansserif_P end_POSTSUPERSCRIPT âŠ„ sansserif_BQP, for any desired kâˆˆâ„•ğ‘˜â„•k\in\mathbb{N}italic_k âˆˆ blackboard_N. Moreover, they gave a candidate construction of such an oracle, and sketched a possible route towards showing that this oracle satisfies the desired properties [AIK22, Section 6.2]. We remark that Lemma 3 is precisely one of the steps in their proposed sketch, although it does not seem to be sufficient on its own to achieve the separation."
https://arxiv.org/html/2411.02535v1,Polynomial-Time Classical Simulation of Noisy Circuits with Naturally Fault-Tolerant Gates,"We construct a polynomial-time classical algorithm that samples from the output distribution of low-depth noisy Clifford circuits with any product-state inputs and final single-qubit measurements in any basis. This class of circuits includes Clifford-magic circuits and Conjugated-Clifford circuits, which are important candidates for demonstrating quantum advantage using non-universal gates. Additionally, our results generalize a simulation algorithm for IQP circuits [RWL24] to the case of IQP circuits augmented with CNOT gates, which is another class of non-universal circuits that are relevant to current experiments. Importantly, our results do not require randomness assumptions over the circuit families considered (such as anticoncentration properties) and instead hold for every circuit in each class. This allows us to place tight limitations on the robustness of these circuits to noise. In particular, we show that there is no quantum advantage at large depths with realistically noisy Clifford circuits, even with perfect magic state inputs, or IQP circuits with CNOT gates, even with arbitrary diagonal non-Clifford gates. The key insight behind the algorithm is that interspersed noise causes a decay of long-range entanglement, and at depths beyond a critical threshold, the noise builds up to an extent that most correlations can be classically simulated. To prove our results, we merge techniques from percolation theory with tools from Pauli path analysis.","A first step towards understanding the power of quantum computation is to determine the conditions under which it is possible to perform a quantum computation that cannot be classically simulated or, in other words, to demonstrate â€œquantum advantageâ€. Although there is robust theoretical evidence that this is true for large-scale fault-tolerant quantum computers, this becomes a subtle question when restricted to near-term quantum hardware. These devices are noisy and may lack capabilities that are required for fault tolerance such as the ability to perform intermediate measurements or reset qubits during a computation. To address these questions, a line of research has considered the task of sampling from the output distribution of (random) quantum circuits as a way to demonstrate quantum advantage [TD04]. This is relevant to near-term hardware because even very restricted models of quantum computation can be used to demonstrate such quantum advantages, and the advantage is not contrived in that it tolerates a constant amount of total error [BJS10, BMS16, AA13, GWD17, HKS+17]. Adding realistic noise with constant rate complicates this picture however, since the fidelity with which the targeted task can be performed on a noisy quantum device diminishes exponentially with the system size. An important line of research is therefore to study the computational power of quantum computations with quantitatively realistic noise assumptions [ABOIN96, FT16, BMS17, AGL+23, CCHL22]. Obtaining a precise understanding of the computational power of noisy restricted models of computation can thus yield new insights into whether or not quantum computers can retain robustness to noise and elucidate the ingredients that are necessary for quantum advantage. In this work, we consider noisy quantum circuits with gate sets that are naturally fault-tolerant. These include Clifford circuits with state preparation and measurement in arbitrary product bases, and IQP circuits augmented with CNOT gates. In particular, this allows for magic state inputs in the case of Clifford circuits and arbitrary diagonal non-Clifford gates in the case of IQP+CNOT circuits. The circuit classes we consider do not allow for intermediate measurement and classical feed-forward and are therefore not universal for quantum computation. At the same time, they constitute circuits which are readily implementable in early fault-tolerant quantum devices which can implement non-universal gate sets [BEG+24, EK09], making them good candidates for demonstration of quantum advantage. In particular, these circuit classes include Clifford-magic, conjugated Clifford circuits and hypercube block IQP circuits, which have all been proven to be hard to approximately sample from in the nearly noiseless case assuming certain complexity-theoretic conjectures [YJS19, BFK18, HKB+24]. Thus, it is important to understand the noise and depth regimes in which these circuits maintain their computational power. Providing a lower bound on computational power, Fujii and Tamate have constructed a family of low-depth Clifford-magic circuits for which they give complexity-theoretic evidence that exact simulation is classically intractable even in the presence of sufficiently weak, constant-strength local noise [FT16]. A common way to upper bound the computational power of a class of noisy quantum circuits is to construct a classical simulation algorithm that approximately samples from its output distribution, assuming a general noise model. If the runtime of this algorithm is polynomial, then this circuit class cannot be used to demonstrate quantum advantage. There is a rich landscape of existing work that deals with this task. However, a common proof technique in prior work relies on the randomness of the quantum circuits considered [AGL+23, BMS17, TTT21, GD18, MAG+24, SYGY24, FRD+23]. They show that typical noisy quantum circuits can be simulated. However, such techniques cannot exclude the possibility of a worst-case circuit which is cleverly designed to maintain robustness to noise (e.g. [ABOIN96, FT16]), which is precisely the goal of near-term fault-tolerance. For worst-case noisy circuits, the strongest upper bound on computational complexity is due to Aharonov et al. [ABOIN96], who showed that the output distribution of any noisy quantum circuit converges to uniform after circuit depth which is logarithmic in system size, and is thus trivially simulatable. The same work [ABOIN96] also demonstrates a lower bound on the computational complexity of general quantum circuits by proving that noisy quantum circuits can solve problems in Qâ¢Nâ¢C1ğ‘„ğ‘superscriptğ¶1QNC^{1}italic_Q italic_N italic_C start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT (decision problems solvable by noiseless logarithmic depth quantum circuits) with a quasipolynomial overhead in system size. At the same time, Shorâ€™s factoring algorithm can be implemented using log-depth quantum circuits [CW00]. Together, these results provide some evidence that it is difficult in general to classically simulate noisy quantum circuits at logarithmic depths. This suggests to start by understanding the classical simulatability of restricted families of noisy quantum circuits that correspond to the limitations of near-term hardware, such as 2â¢D2ğ·2D2 italic_D-local or non-universal circuits. In this work, we develop a classical simulation algorithm for noisy Clifford and IQP + CNOT circuits with any product-state input and final single-qubit measurements in any basis. Applied to geometrically local circuits, our algorithm is efficient at low circuit depths above a constant threshold that depends on the noise rate (we assume single-qubit depolarizing channels after every circuit layer), and is efficient for all circuits in this class. Importantly, our results hold even if the magic input states are perfect. Our results thus provide strong evidence that in order to achieve quantum advantage with realistically noisy circuits an additional ingredient is required such as non-Clifford mid-circuit gates, intermediate measurement, or a supply of fresh qubits. Our techniques improve upon the simulation methods of [BMS17, GD18, AGL+23], which require at least logarithmic circuit depth and only work for typical circuit instances, although we assume a restricted circuit model. The only prior work achieving both properties (worst-case and constant-depth simulability) is Ref. [RWL24], which restricts to purely diagonal IQP circuits. 1.1 Overview of Results We summarize our main result informally in the following theorem. Theorem 1 (Informal). There exists an efficient randomized classical algorithm that approximately samples from the output distribution of a noisy quantum circuit Cğ¶Citalic_C with circuit-level local noise rate Î³ğ›¾\gammaitalic_Î³ in the following cases, 1. Cğ¶Citalic_C is a geometrically local Clifford-Magic, Conjugated Clifford, or IQP+CNOT circuit and dâ‰¥Î©â¢(Î³âˆ’1â¢logâ¡Î³âˆ’1)ğ‘‘Î©superscriptğ›¾1superscriptğ›¾1d\geq\Omega(\gamma^{-1}\log\gamma^{-1})italic_d â‰¥ roman_Î© ( italic_Î³ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT roman_log italic_Î³ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) 2. Cğ¶Citalic_C is a Clifford-Magic, Conjugated Clifford, or IQP+CNOT circuit and dâ‰¥Î©â¢(Î³âˆ’1â¢logâ¡n)ğ‘‘Î©superscriptğ›¾1ğ‘›d\geq\Omega(\gamma^{-1}\log n)italic_d â‰¥ roman_Î© ( italic_Î³ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT roman_log italic_n ) . Figure 1: Overview of the simulation algorithm. (a) Depolarizing errors are sampled and propagated to the beginning of the circuit. |AâŸ©ketğ´\ket{A}| start_ARG italic_A end_ARG âŸ© represents a single-qubit magic-state but can be any single-qubit state. (b) The circuit can now equivalently be represented as one error channel followed by the original noiseless circuit. (c) We prove that this input error channel has the effect of depolarizing many of the input qubits and so it remains to simulate the lightcones of qubits that are not depolarized. When these lightcones intersect they must be simulated together but can otherwise be simulated independently. Any measurements that are not in the lightcone of a depolarized qubit can be simulated by a random coin flip. At a high-level, the algorithm works by first propagating errors to the beginning of the circuit. This reformulates the noisy circuit as one layer of noise followed by the ideal circuit, which is pictured in Fig. 1b. Note that it is especially easy to propagate errors since the circuit is Clifford and the errors are Pauli operators. The focus of much of the technical work is to show that this propagated error channel effectively depolarizes many of the input qubits, which is pictured in Fig. 1c. In the geometrically local case, after a critical depth threshold of Oâ¢(Î³âˆ’1â¢logâ¡Î³âˆ’1)ğ‘‚superscriptğ›¾1superscriptğ›¾1O(\gamma^{-1}\log\gamma^{-1})italic_O ( italic_Î³ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT roman_log italic_Î³ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ), enough qubits get depolarized that a percolation effect occurs, and one can independently simulate the non-depolarized input qubits with intersecting lightcones. We expect at most Oâ¢(logâ¡nâ¢d)ğ‘‚ğ‘›ğ‘‘O(\log nd)italic_O ( roman_log italic_n italic_d ) non-depolarized qubits to have intersecting lightcones and so at most Oâ¢(\polyâ¢(d)â¢logâ¡nâ¢d)ğ‘‚\polyğ‘‘ğ‘›ğ‘‘O(\poly(d)\log nd)italic_O ( ( italic_d ) roman_log italic_n italic_d ) qubits must be simulated together at once (since geometric locality restricts each lightcone to be of size \polyâ¢(d)\polyğ‘‘\poly(d)( italic_d )). Although this is efficient when dğ‘‘ditalic_d is constant, we can simulate these lightcones even more efficiently by representing the input in the Pauli basis. This representation is sparse at high depths because many Pauli operators are annihilated by the propagated error channel. In fact, at Oâ¢(Î³âˆ’1â¢logâ¡n)ğ‘‚superscriptğ›¾1ğ‘›O(\gamma^{-1}\log n)italic_O ( italic_Î³ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT roman_log italic_n )-depth the Pauli decomposition is so sparse that it is even efficient to do this simulation on all nğ‘›nitalic_n qubits. This is why our algorithm also works when there is all-to-all connectivity and no lightcones, although this requires the larger depth. To prove that this algorithm is efficient, our analysis merges tools from Pauli path enumeration [BMS17, GD18, AGL+23] and techniques from percolation theory [RWL24, Oh24]. Our algorithm has many desirable properties: (1) it does not require assumptions on the output distribution or distribution from which the circuit is sampled. In particular, in contrast to the results of [BMS17, GD18, AGL+23] it does not require that the output distributions have the anticoncentration property (see [HE23] for details on this property). (2) It performs exact sampling with random runtime which is polynomial in expectation (and this can be modified to give the more common approximate sampler with worst-case polynomial runtime). (3) Only the depth threshold but not the runtime depends on the noise strength. Our tools also turn out to be useful for bounding anticoncentration, which may be of independent interest. In fact, we are able to show that any Clifford circuit acting on a random input bit string anticoncentrates in Oâ¢(Î³âˆ’1â¢logâ¡n)ğ‘‚superscriptğ›¾1ğ‘›O(\gamma^{-1}\log n)italic_O ( italic_Î³ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT roman_log italic_n ) depth, which is proved in Appendix D. This additionally implies that noisy Haar random circuits anticoncentrate in Oâ¢(logâ¡n)ğ‘‚ğ‘›O(\log n)italic_O ( roman_log italic_n )-depth for any architecture, which was only previously known for 1â¢D1ğ·1D1 italic_D and all-to-all connectivity [DHB22, DNS+22]. 1.2 Discussion and Future Work Our work is among the first classical simulatability results for noisy quantum circuits that apply to worst-case circuits, albeit with restrictions on connectivity and gate sets. This is accomplished by removing the need for the anticoncentration property in our analysis. This not only allows for classical simulatability beyond average case, but also shows that our algorithm works even when the circuit output distribution is bounded away from uniform (the distributions we can simulate may be peaked). Peaked circuits have recently been proposed as a potential candidate for quantum advantage [AZ24] and are by definition not amenable to simulation techniques relying on anticoncentration. Our methods do not have the same fundamental restrictions and so it is plausible that similar techniques may be useful in this case 111Note that it is known that constant-depth peaked circuits can be simulated in quasipolynomial time [BGL23] but it is an open question whether they are simulatable at Oâ¢(logâ¡n)ğ‘‚ğ‘›O(\log n)italic_O ( roman_log italic_n )-depth.. If we consider the weaker task of classically simulating random instead of worst-case Clifford circuits, we conjecture that our critical depth threshold for classical simulatability can be lowered significantly. In particular, one would expect random Clifford circuits to spread noise in a manner that causes a larger fraction of qubits to be effectively depolarized. For example, [QSFK+24] construct a family of noisy random Clifford circuits which converge to the maximally mixed state at Oâ¢(logâ¡logâ¡n)ğ‘‚ğ‘›O(\log\log n)italic_O ( roman_log roman_log italic_n ) depth - that is, all qubits are depolarized at sublogarithmic depth. Since our algorithm becomes efficient at low depths, long before all qubits are depolarized, we anticipate simulatability for random Clifford circuits at much shorter depths than our worst-case bounds suggest. Although our results assume Clifford gates, we believe that this is largely a consequence of the analysis since the underlying properties that make the algorithm work are actually quite broad. Thus, it is hoped that our methods may be applicable to a larger class of worst-case circuits. For instance, one of our key techniques is motivated by the general property of unitarity. By using a careful counting argument in place of assuming anticoncentration as done in prior work [BMS17, GD18, AGL+23] , we are able to tightly upper bound the contributions of high-weight Pauli paths. In this analysis, we use unitarity to argue that not all high-weight Pauli operators can be mapped by the circuit to low-weight operators since this is a strictly smaller space and thus violates unitarity. This suggests that high-weight Pauli operators maintain their approximate weight throughout the circuit and thus are evenly suppressed by errors at various timesteps, which turns out to be crucial for the analysis. Since this is largely a consequence of unitarity, we believe similar arguments may prove fruitful for circuit classes beyond Clifford circuits. Another ingredient in our simulation result that may apply more generally is the existence of a constant depth threshold for noise percolation. In recent prior work, noise percolation was shown to exist in noisy IQP circuits [RWL24] also resulting in classical simulation. For these IQP circuits, the analysis relies on the special property that the noise operators commute with the gate-set, which may give reason to believe that this percolation is unique to IQP circuits. Instead, our result shows that this phenomenon is actually quite general in that it also arises in Clifford circuits. Since noisy Clifford circuits exhibit many general features of noisy quantum dynamics [LCF18, CBQA20, LCF19, GKH+21, NBFG23], this provides evidence that this entanglement breakdown may occur in even broader classes of noisy circuits such as Haar random circuits. This would give a simulatability result that improves the depth restriction of [AGL+23]. Thus, we believe that our algorithm may have broad applications to simulating other circuit classes at constant depth. We also conjecture that the depth threshold for classical simulatability in the geometrically local case corresponds directly to a phase transition in computational complexity. That is, it may be possible to construct hard-to-sample quantum circuits at depths right below the threshold (at least for exact sampling). For example, [RWL24] construct IQP circuits which are hard to sample up until depths that asymptotically match their depth threshold for efficient classical simulatability. We leave it to future work to check whether similar techniques will allow us to prove hardness for noisy geometrically local Clifford-Magic or IQP+CNOT circuits as well. Such results could have important consequences for demonstrating near-term quantum advantage. Our results may also provide avenues to classically simulate real quantum experiments. For example, going beyond geometric locality, can we use percolation to prove a sublogarithmic depth threshold for classical simulatability on partially constrained architectures, such as the hypercube connectivity of [HKB+24]? Note that the IQP+CNOT circuits of [HKB+24] require Oâ¢(logâ¡n)ğ‘‚ğ‘›O(\log n)italic_O ( roman_log italic_n ) depth. Our algorithm for the all-to-all connectivity case shows that these circuits will be classically simulatable if they are scaled past a Oâ¢(Î³âˆ’1â¢logâ¡n)ğ‘‚superscriptğ›¾1ğ‘›O(\gamma^{-1}\log n)italic_O ( italic_Î³ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT roman_log italic_n ) depth (for noise strength Î³ğ›¾\gammaitalic_Î³). It would be of practical interest to see if this bound can be improved by considering the locality structure of the hypercube. Similarly, removing the depolarizing noise assumption, it may be possible using our techniques to understand the onset of classical simulatability for more realistic noise models such as non-unital [Got16, FGG+23, MAG+24]? Paper Outline In Section 2 we give the preliminaries and notation. In Section 3 we describe the algorithm. In Section 4, we describe how these results directly apply to IQP+CNOT circuits and to conjugated Clifford circuits."
https://arxiv.org/html/2411.02392v1,One-Way Functions and Polynomial Time Dimension,"This work solves an open problem regarding the rate of time-bounded Kolmogorov complexity and polynomial-time dimension, conditioned on a hardness assumption. Hitchcock and Vinodchandran in 2004 [HV04] show that the polynomial-time dimension of infinite sequences (denoted cdimPsubscriptcdimP{\mathrm{cdim}}_{\mathrm{P}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT) defined using betting algorithms called sğ‘ sitalic_s-gales, is greater than or equal to the asymptotic lower rate of polynomial-time Kolmogorov complexity (denoted ğ’¦polysubscriptğ’¦poly\mathcal{K}_{\text{poly}}caligraphic_K start_POSTSUBSCRIPT poly end_POSTSUBSCRIPT). They asked ([HV04], see also Stull [Stu20]) whether the converse relationship, cdimPâ‰¤ğ’¦polysubscriptcdimPsubscriptğ’¦poly{\mathrm{cdim}}_{\mathrm{P}}\leq\mathcal{K}_{\text{poly}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT â‰¤ caligraphic_K start_POSTSUBSCRIPT poly end_POSTSUBSCRIPT also holds. This question has thus far resisted resolution. The corresponding unbounded notions, namely, the constructive dimension and the asymptotic lower rate of unbounded Kolmogorov complexity are equal for every sequence. Analogous notions are equal even at finite-state level [BHV05]. In view of these results, it is reasonable to conjecture that the polynomial-time quantities are identical for every sequence and set of sequences.However, under a plausible assumption which underlies modern cryptography - namely the existence of one-way functions, we refute the conjecture thereby giving a negative answer to the open question posed by Hitchcock and Vinodchandran [HV04] and Stull [Stu20].We show the following, conditioned on the existence of one-way functions:There are sets â„±â„±\mathcal{F}caligraphic_F of infinite sequences whose polytime dimension strictly exceeds ğ’¦polyâ¢(â„±)subscriptğ’¦polyâ„±\mathcal{K}_{\text{poly}}(\mathcal{F})caligraphic_K start_POSTSUBSCRIPT poly end_POSTSUBSCRIPT ( caligraphic_F ), that is cdimPâ¢(â„±)>ğ’¦polyâ¢(â„±)subscriptcdimPâ„±subscriptğ’¦polyâ„±{\mathrm{cdim}}_{\mathrm{P}}(\mathcal{F})>\mathcal{K}_{{\mathrm{poly}}}(% \mathcal{F})roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) > caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ).We establish a stronger version of this result, that there are individual sequences Xğ‘‹Xitalic_X whose poly-time dimension strictly exceeds ğ’¦polyâ¢(X)subscriptğ’¦polyğ‘‹\mathcal{K}_{\text{poly}}(X)caligraphic_K start_POSTSUBSCRIPT poly end_POSTSUBSCRIPT ( italic_X ), that is cdimPâ¢(X)>ğ’¦polyâ¢(X)subscriptcdimPğ‘‹subscriptğ’¦polyğ‘‹{\mathrm{cdim}}_{\mathrm{P}}(X)>\mathcal{K}_{{\mathrm{poly}}}(X)roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) > caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ).Further, we show that the gap between these quantities can be made as large as possible (i.e. close to 1).We also establish similar bounds for strong poly-time dimension (denoted cDimPsubscriptcDimP{{\mathrm{cDim}}}_{\mathrm{P}}roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT) versus asymptotic upper Kolmogorov complexity rates (denoted ğ’¦polystrsubscriptsuperscriptğ’¦strpoly\mathcal{K}^{\mathrm{str}}_{{\mathrm{poly}}}caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT).Thus, if one-way functions exist, there are infinite sequences whose prefixes are output by short polynomial time algorithms, but polytime betting algorithms are unable to capitalize on this to succeed over them.Our proof techniques involve explicit constructions by concatenating the outputs of pseudorandom generators to form sequences whose prefixes are output by short polynomial time algorithms, but resist betting by polytime sğ‘ sitalic_s-gales. Our proof uses several new constructions and arguments involving probabilistic tools such as the Borel-Cantelli Lemma and the Kolmogorov inequality for martingales. This work shows that the question of non-robustness of polynomial-time information density notions, which is prima facie different, is intimately related to questions which are of current interest in cryptography and meta-complexity.","1.1 Context and Motivation Problems related to the minimum circuit-size (MCSP) and minimum time-bounded Kolmogorov complexity (MKtâ¢PsuperscriptMKğ‘¡P\mathrm{MK}^{t}\mathrm{P}roman_MK start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT roman_P) have been extensively studied in recent years. Kabanets and Cai [KC00] established that if one-way functions exist, then MCSP is NP-hard, using the framework of natural proofs. This result establishes a connection between cryptographic primitives and hardness of decision problems, leading to the establishment of meta-complexity, the study of the complexity of computing various computational complexity measures. By using the notion of average-case meta-complexity, strong converses have been established, which show that average-case hardness, hardness of approximation, or the average-case hardness of â€œgapâ€ versions of related meta-complexity problems suffice to establish the existence of important cryptographic primitives such as one-way functions, and pseudorandom functions, often yielding explicit constructions [IRS22]. In this work, we initiate another related line of investigation - namely the connection between cryptographic primitives and the robustness of complexity notions of infinite sequences. We provide a negative resolution to an open question by Hitchcock, Vinodchandran and Stull [HV04, HV06, Stu20] by showing that polynomial-time dimension is not robust, assuming the existence of one-way functions. Polynomial-time dimension quantifies the asymptotic rate of information in an infinite sequence of bits. There are several approaches towards defining polynomial time dimension. The first approach analyzes the asymptotic compressibility of the finite prefixes of the given infinite sequence. The polynomial-time bounded Kolmogorov Complexity of a string xğ‘¥xitalic_x is the length of the shortest program that can output xğ‘¥xitalic_x in at most polynomial number of time steps. In the compressibility approach, the polynomial time density of information is defined in terms of the polynomial-time bounded Kolmogorov Complexity of the prefixes of the string, denoted ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT. In the predictability approach, polynomial-time dimension, denoted cdimPsubscriptcdimP{\mathrm{cdim}}_{\mathrm{P}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT, is defined in terms of polynomial-time betting algorithms called sğ‘ sitalic_s-gales, as they attempt to profit by placing successive bets on the bits in the sequence 111The formal equivalence between polynomial time predictors with log-loss functions and polynomial time sğ‘ sitalic_s-gales was established by Hitchcock [Hit03b]. The bets placed by the gale on each bit reflects its confidence of prediction on that bit appearing. The unbounded analogue of time-bounded dimension is known to be robust - markedly different approaches to its definition, via predictors, via unbounded time sğ‘ sitalic_s-gales, and via unbounded Kolmogorov complexity rates are known to be equivalent [May02] [Lut03a]. At the other extreme, finite-state analogues of these notions are also known to be robust - there are equivalent characterizations of dimension at finite-state level, using diverse characterizations such as block entropy rates, information-lossless finite-state compressors, and finite-state sğ‘ sitalic_s-gales ([DLLM04, BHV05]). However, the robustness of dimension at the important â€œintermediateâ€ resource-bounded level of polynomial time dimension, has been open for a long time. The robustness question is the following: 1. For every infinite sequence Xğ‘‹Xitalic_X, does the polynomial-time dimension of Xğ‘‹Xitalic_X, cdimPâ¢(X)subscriptcdimPğ‘‹{\mathrm{cdim}}_{\mathrm{P}}(X)roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) as measured by sğ‘ sitalic_s-gales equal ğ’¦polyâ¢(X)subscriptğ’¦polyğ‘‹\mathcal{K}_{{\mathrm{poly}}}(X)caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X )? 2. For every set â„±â„±\mathcal{F}caligraphic_F of infinite sequences, does the polynomial-time dimension of â„±â„±\mathcal{F}caligraphic_F, cdimPâ¢(â„±)subscriptcdimPâ„±{\mathrm{cdim}}_{\mathrm{P}}(\mathcal{F})roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) equal ğ’¦polyâ¢(â„±)subscriptğ’¦polyâ„±\mathcal{K}_{{\mathrm{poly}}}(\mathcal{F})caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F )? In other words, if infinitely many prefixes of sequences have short polynomial-time programs, then can polynomial-time sğ‘ sitalic_s-gales bet and win on them? Hitchcock and Vinodchandran [HV04] show that the polynomial-dimension of every sequence is at least the asymptotic lower density of the Kolmogorov complexity of its prefixes. Given the evidence of robustness at other levels, and the fact that the inequality holds in one direction, it is natural to conjecture that the opposite inequality holds as well. This would establish the robustness of polynomial time-bounded dimension. Surprisingly, we show that under the plausible assumption that one-way functions exist, the converse inequality does not hold either for sequences or for sets. Thus polynomial time-bounded dimension is non-robust if one-way functions exist. Further, we show that strong polynomial time-bounded dimension is also non-robust. The reason why one-way functions imply non-robustness is quite fundamental. The existence of one-way functions is equivalent to that of pseudorandom generators [HILL99]. This implies the existence of ensembles generated by polynomial time algorithms from short seeds which are, crucially, hard to distinguish from uniform randoms using any probabilistic polynomial time algorithm. The outputs of a pseudorandom generator are highly compressible using its seeds, unlike true randoms. The main insight of our results is that if polynomial-time dimension is robust, then there are predictors, or sğ‘ sitalic_s-gales, that succeed on a sequence of pseudorandom generator outputs. We then modify these sğ‘ sitalic_s-gales to obtain probabilistic algorithms to distinguish pseudorandom outputs from uniform randoms. Thus robustness of polynomial-time dimension contradicts the existence of one-way functions. The notion of meta-complexity - the complexity of computing various complexity measures - has been shown to have close connections to cryptographic notions. Our work broadens the scope of this connection, showing that other foundational questions in Kolmogorov complexity which seemingly bear only a tangential relation to hardness, also have provably close connections to cryptographic primitives, while showing an unexpected resolution to a long-standing open problem. 1.2 One-way functions, meta-complexity and time bounded Kolmogorov complexity One-way functions [DH76, Gol01, Lev03] are functions on finite strings that are easy to compute but are hard to invert, except possibly on a negligible fraction of the input strings of a given length. The concept of a one-way function is central in cryptography, since the existence of such functions are both necessary and sufficient for the existence of essential cryptographic primitives like pseudorandom generators [HILL99], digital signatures [Rom90], private key encryption [HILL99] [GM84], authentication schemes [FS90] and commitment schemes [Nao91]. In their seminal paper, HÃ¥stad, Impagliazzo, Levin and Luby [HILL99] show that one-way functions exist if and only if pseudorandom generators exist (see also [MP23, Gol08, Gol01]). Several recent advancements in meta-complexity reveal intriguing connections between one-way functions and the computational hardness of various problems in complexity. Kabanets and Cai [KC00] showed that if one-way functions exist, then Minimum Circuit Size Problem (MCSP) is NP-hard. Liu and Pass [LP20, LP21] established the first natural computational problem characterizing cryptographic primitives using time bounded Kolmogorov complexity Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT. The tğ‘¡titalic_t-time bounded Kolmogorov complexity Ktâ¢(x)subscriptğ¾ğ‘¡ğ‘¥K_{t}(x)italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x ) [Kol65, LV08] of a string xğ‘¥xitalic_x is the length of the shortest program Î Î \Piroman_Î  which outputs xğ‘¥xitalic_x in at most tğ‘¡titalic_t time steps when fed to a fixed universal Turing machine ğ’°ğ’°\mathcal{U}caligraphic_U. In [LP20], Liu and Pass proved that one-way functions exist if and only if the tğ‘¡titalic_t-time bounded Kolmogorov complexity problem MKtâ¢PsuperscriptMKğ‘¡P\mathrm{MK}^{t}\mathrm{P}roman_MK start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT roman_P, is mildly hard on average. In a follow-up work [LP21] they define a problem that is NPNP{\mathrm{NP}}roman_NP-complete under randomized reductions (the tğ‘¡titalic_t-time bounded conditional Kolmogorov complexity problem McKtâ¢PsuperscriptMcKğ‘¡P\mathrm{McK}^{t}\mathrm{P}roman_McK start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT roman_P) whose mild average case hardness is equivalent to existence of one-way functions. Allender, Cheraghchi, Myrisiotis, Tirumala and Volkovich [ACM+21] showed similar results in the setting of KTKT\mathrm{KT}roman_KT complexity. They proved that average case hardness for a polynomial fraction of instances of McKTPMcKTP\mathrm{McKTP}roman_McKTP (an analogue of McKtâ¢PsuperscriptMcKğ‘¡P\mathrm{McK}^{t}\mathrm{P}roman_McK start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT roman_P for KTKT\mathrm{KT}roman_KT-complexity) implies the existence of one-way functions. In the converse direction, they showed that if one-way functions exist then McKTPMcKTP\mathrm{McKTP}roman_McKTP is hard-on-average on an exponential fraction of its instances. Considerable research has been devoted to understanding whether fundamental properties of unbounded Kolmogorov complexity survive in the time bounded setting. One of the important properties that was studied in this context is the symmetry of information of Kolmogorov complexity [LV08, SUV22, DH10, Nie09]. LongprÃ© and Mocas [LM93] (also LongprÃ© and Watanabe [LW92]) showed that if one-way functions exist then symmetry of information does not hold for time bounded Kolmogorov complexity. In [Hir22] and [GK22], symmetry of information for polynomial time bounded probabilistic Kolmogorov complexity pKtsuperscriptpKğ‘¡\mathrm{pK}^{t}roman_pK start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT (see [GKLO22, LO22]) was derived from the stronger assumption DistNPâŠ†AvgBPPDistNPAvgBPP\mathrm{DistNP}\subseteq\mathrm{AvgBPP}roman_DistNP âŠ† roman_AvgBPP. A recent work [HIL+23] gave a complete characterization of one-way functions in terms of the average case failure of symmetry of information (and related properties like the conditional coding theorem) for pKtsuperscriptpKğ‘¡\mathrm{pK}^{t}roman_pK start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT. Along similar lines, we investigate whether the characterization of constructive dimension in terms of Kolmogorov complexity [Lut03a, May02] survives in the time bounded setting. We show that if one-way functions exist then polynomial time bounded Kolmogorov complexity does not yield a characterization of polynomial time dimension of infinite sequences, thereby refuting an open question posed by Hitchcock and Vinodchandran in [HV04] and by Stull in [Stu20]. In the following sub-section we give an informal account of constructive dimension and its history. 1.3 Constructive Dimension Constructive dimension was introduced by Lutz [Lut03a, Lut03b] as a complexity-theoretic formulation of the classical Hausdorff dimension [Hau19]. It is a quantification of the density of information present in an infinite sequence. Constructive dimension was originally defined in [Lut03a] in terms of unfair betting strategies over infinite sequences called sğ‘ sitalic_s-gales. Resource bounded dimension is the analogue of constructive dimension, where a resource bound, either of time or of space used in computation of the betting strategy is imposed. Resource bounded dimension is an effective tool that has yielded several interesting results in the study of complexity classes [Lut03a, AHLM07, HLM05, May08, Stu20]. An important paradigm that is useful in the study of constructive dimension and measure is that of compressibility [DH10, Nie09]. Lutz [Lut03b] and Mayordomo [May02] gave an equivalent characterization of constructive dimension of infinite sequences in terms of the Kolmogorov complexity of its prefixes. These equivalent characterizations offer multiple viewpoints that are useful under different contexts for studying constructive dimension. Furthermore, these characterizations establish the robustness of constructive dimension as a mathematical concept. One of our main results is that if one-way functions exist, then these characterizations of polynomial time dimension- one in terms of polynomial-time computable sğ‘ sitalic_s-gales and the other in terms of density of polynomial-time bounded Kolmogorov complexity are not equivalent. We now give an informal account of the definition of constructive dimension using sğ‘ sitalic_s-gales from [Lut03a]. sğ‘ sitalic_s-gales are betting strategies on infinite sequences. The betting game on an infinite binary sequence XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT can be understood as follows. The player starts with an initial capital of dâ¢(Î»)=1ğ‘‘ğœ†1d(\lambda)=1italic_d ( italic_Î» ) = 1 on the empty string. Here dğ‘‘ditalic_d is the betting function (capital) of the sğ‘ sitalic_s-gale. At the nğ‘›nitalic_nth stage, having accumulated a capital dâ¢(x1â¢x2â¢â€¦â¢xn)ğ‘‘subscriptğ‘¥1subscriptğ‘¥2â€¦subscriptğ‘¥ğ‘›d(x_{1}x_{2}\dots x_{n})italic_d ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT â€¦ italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) on the first nğ‘›nitalic_n bits of the sequence, the player is allowed to place an amount as a â€œbetâ€ on the next bit xn+1subscriptğ‘¥ğ‘›1x_{n+1}italic_x start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT of the sequence. The rule of the game is that the expected value of capital received by the player after the bet is 2ssuperscript2ğ‘ 2^{s}2 start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT times the capital they started with, that is 2s.dâ¢(w)=dâ¢(wâ¢0)+dâ¢(wâ¢1)formulae-sequencesuperscript2ğ‘ ğ‘‘ğ‘¤ğ‘‘ğ‘¤0ğ‘‘ğ‘¤12^{s}.d(w)=d(w0)+d(w1)2 start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT . italic_d ( italic_w ) = italic_d ( italic_w 0 ) + italic_d ( italic_w 1 ), for any finite string wâˆˆÎ£âˆ—ğ‘¤superscriptÎ£w\in\Sigma^{*}italic_w âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT. The player dğ‘‘ditalic_d succeeds on the sequence XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT if they can secure an arbitrary amount of capital over the course of betting on the infinite sequence, more precisely if lim supnâ†’âˆdâ¢(x1â¢x2â¢â€¦â¢xn)=âˆsubscriptlimit-supremumâ†’ğ‘›ğ‘‘subscriptğ‘¥1subscriptğ‘¥2â€¦subscriptğ‘¥ğ‘›\limsup_{n\to\infty}d(x_{1}x_{2}\dots x_{n})=\inftylim sup start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT italic_d ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT â€¦ italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) = âˆ. When s=1ğ‘ 1s=1italic_s = 1, the average capital after the bet on wâ¢0ğ‘¤0w0italic_w 0 or wâ¢1ğ‘¤1w1italic_w 1 is equal to the previous capital dâ¢(w)ğ‘‘ğ‘¤d(w)italic_d ( italic_w ) (when s=1ğ‘ 1s=1italic_s = 1, such sğ‘ sitalic_s-gales are referred to as martingales). Therefore, the betting strategy is fair. When s<1ğ‘ 1s<1italic_s < 1, the average capital after the bet is strictly less than the previous capital dâ¢(w)ğ‘‘ğ‘¤d(w)italic_d ( italic_w ). Therefore, such betting strategies are inherently unfair to the player. When s=1ğ‘ 1s=1italic_s = 1, the player can bet â€œevenlyâ€ on the next bit if they are unsure. But as sğ‘ sitalic_s decreases, the setting becomes more unfavorable and the player needs to bet more aggressively, or â€œpredictâ€ the bits more efficiently to keep increasing their capital. In simple terms, the Constructive Dimension of a set â„±âˆˆÎ£âˆâ„±superscriptÎ£\mathcal{F}\in\Sigma^{\infty}caligraphic_F âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT is the least value of sğ‘ sitalic_s (or the infimum over sğ‘ sitalic_s) for which there exists a lower-semi computable sğ‘ sitalic_s-gale that can win on all Xâˆˆâ„±ğ‘‹â„±X\in\mathcal{F}italic_X âˆˆ caligraphic_F. Lower semi-computability is a weak notion of computability where the bets of the sğ‘ sitalic_s-gale can be computably enumerated from below, with no resource bounds put on the computation. Definition 1 ([Lut03a, Lut03b]). The constructive dimension of â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT is defined as cdimâ¢(â„±)=inf{sâˆ£âˆƒ a lower semi-computable â¢sâ¢-gale â¢dâ¢ such that d succeeds on all â¢Xâˆˆâ„±}.cdimâ„±infimumconditional-setğ‘  a lower semi-computable ğ‘ -gale ğ‘‘ such that d succeeds on all ğ‘‹â„±\mathrm{cdim}(\mathcal{F})=\inf\{s\mid\exists\text{ a lower semi-computable }s% \text{-gale }d\text{ such that d succeeds on all }X\in\mathcal{F}\}.roman_cdim ( caligraphic_F ) = roman_inf { italic_s âˆ£ âˆƒ a lower semi-computable italic_s -gale italic_d such that d succeeds on all italic_X âˆˆ caligraphic_F } . The constructive dimension of an individual sequence XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT is defined as cdimâ¢(X)=cdimâ¢({X})cdimğ‘‹cdimğ‘‹\mathrm{cdim}(X)=\mathrm{cdim}(\{X\})roman_cdim ( italic_X ) = roman_cdim ( { italic_X } ). Mayordomo [May02] and Lutz [Lut03b] showed that constructive dimension of XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT has an equivalent characterization in terms of the rate of information of the prefixes of Xğ‘‹Xitalic_X. The Kolmogorov Complexity of a finite string xğ‘¥xitalic_x, denoted by Kâ¢(x)ğ¾ğ‘¥K(x)italic_K ( italic_x ), is the length of the shortest program that produces the string as the output. Any string xğ‘¥xitalic_x can be produced by a program that trivially outputs the string xğ‘¥xitalic_x, and therefore the Kolmogorov complexity of a string xğ‘¥xitalic_x is less than or equal to its length, up to an additive constant. However, if the string has lesser amount of information, there may be programs of shorter length that outputs it. For instance, if all the even bits of the string are 00, the program needs to encode only the bits at the odd indices to produce the string. Therefore, its Kolmogorov complexity is at most half its length, up to additive constants. The quantity Kâ¢(x)/nğ¾ğ‘¥ğ‘›K(x)/nitalic_K ( italic_x ) / italic_n is the rate of information in a finite string xğ‘¥xitalic_x. To define rate of information for an infinite string XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, we consider the nğ‘›nitalic_n-length prefixes of Xğ‘‹Xitalic_X, denoted Xâ†¾nâ†¾ğ‘‹ğ‘›X\upharpoonright nitalic_X â†¾ italic_n, and take the Kolmogorov complexity Kâ¢(Xâ†¾n)ğ¾â†¾ğ‘‹ğ‘›K(X\upharpoonright n)italic_K ( italic_X â†¾ italic_n ). The quantity lim infnâ†’âˆKâ¢(Xâ†¾n)nsubscriptlimit-infimumâ†’ğ‘›ğ¾â†¾ğ‘‹ğ‘›ğ‘›\liminf_{n\rightarrow\infty}\frac{K(X\upharpoonright n)}{n}lim inf start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT divide start_ARG italic_K ( italic_X â†¾ italic_n ) end_ARG start_ARG italic_n end_ARG denotes the asymptotic lower bound of rate of information over all the finite prefixes of Xğ‘‹Xitalic_X. For a set â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, let ğ’¦â¢(â„±)ğ’¦â„±\mathcal{K}(\mathcal{F})caligraphic_K ( caligraphic_F ) denote the supremum of this quantity over all Xâˆˆâ„±ğ‘‹â„±X\in\mathcal{F}italic_X âˆˆ caligraphic_F. Definition 2 ([May02, HV04, HV06]). For any â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, ğ’¦â¢(â„±)=supXâˆˆâ„±lim infnâ†’âˆKâ¢(Xâ†¾n)n.ğ’¦â„±subscriptsupremumğ‘‹â„±subscriptlimit-infimumâ†’ğ‘›ğ¾â†¾ğ‘‹ğ‘›ğ‘›\mathcal{K}(\mathcal{F})=\sup\limits_{X\in\mathcal{F}}\liminf\limits_{n% \rightarrow\infty}\frac{K(X\upharpoonright n)}{n}.caligraphic_K ( caligraphic_F ) = roman_sup start_POSTSUBSCRIPT italic_X âˆˆ caligraphic_F end_POSTSUBSCRIPT lim inf start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT divide start_ARG italic_K ( italic_X â†¾ italic_n ) end_ARG start_ARG italic_n end_ARG . Mayordomo [May02] and Lutz [Lut03b] gave the following equivalent characterization of constructive dimension in terms of Kolmogorov complexity. Theorem 1 (Mayordomo [May02] and Lutz [Lut03b]). For every â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, cdimâ¢(â„±)=ğ’¦â¢(â„±).cdimâ„±ğ’¦â„±\mathrm{cdim}(\mathcal{F})=\mathcal{K}(\mathcal{F}).roman_cdim ( caligraphic_F ) = caligraphic_K ( caligraphic_F ) . 1.4 Polynomial-time Dimension Resource bounded dimension is defined by placing resource bounds on the computation of the sğ‘ sitalic_s-gale. Analogously, resource bounded Kolmogorov complexity is defined by placing resource bounds on the programs that can print a string. PSPACEPSPACE{\rm PSPACE}roman_PSPACE analogues of cdimcdim\mathrm{cdim}roman_cdim and ğ’¦ğ’¦\mathcal{K}caligraphic_K are defined by restricting the sğ‘ sitalic_s-gales in the definition of cdimcdim\mathrm{cdim}roman_cdim to be polynomial space computable and by using polynomial space bounded Kolmogorov complexity in the definition of ğ’¦ğ’¦\mathcal{K}caligraphic_K. Hitchcock and Vinodchandran [HV04, HV06] showed that these notions of resource bounded dimension coincide in the PSPACEPSPACE{\rm PSPACE}roman_PSPACE setting. Theorem 2 ([HV04, HV06]). For every â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, cdimPSPACEâ¢(â„±)=ğ’¦PSPACEâ¢(â„±)subscriptcdimPSPACEâ„±subscriptğ’¦PSPACEâ„±\mathrm{cdim}_{{\rm PSPACE}}(\mathcal{F})=\mathcal{K}_{{\rm PSPACE}}(\mathcal{% F})roman_cdim start_POSTSUBSCRIPT roman_PSPACE end_POSTSUBSCRIPT ( caligraphic_F ) = caligraphic_K start_POSTSUBSCRIPT roman_PSPACE end_POSTSUBSCRIPT ( caligraphic_F ). The Polynomial time dimension quantifies the rate of information in an infinite sequence, measured with respect to polynomial time bounded computation. It is formulated using polynomial time sğ‘ sitalic_s-gales. An sğ‘ sitalic_s-gale dğ‘‘ditalic_d wins on an infinite sequence if Xğ‘‹Xitalic_X lim supnâ†’âˆdâ¢(Xâ†¾n)=âˆsubscriptlimit-supremumâ†’ğ‘›ğ‘‘â†¾ğ‘‹ğ‘›\limsup_{n\to\infty}d(X\upharpoonright n)=\inftylim sup start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT italic_d ( italic_X â†¾ italic_n ) = âˆ. dğ‘‘ditalic_d is said to be polynomial-time computable if for some pâ¢(n)âˆˆpolyâ¢(n)ğ‘ğ‘›polyğ‘›p(n)\in{\mathrm{poly}}(n)italic_p ( italic_n ) âˆˆ roman_poly ( italic_n ), dğ‘‘ditalic_d takes at most pâ¢(n)ğ‘ğ‘›p(n)italic_p ( italic_n ) time to compute dâ¢(w)ğ‘‘ğ‘¤d(w)italic_d ( italic_w ), where nğ‘›nitalic_n is the length of wğ‘¤witalic_w. Definition 3 (Polynomial-time dimension [Lut03a]). The polynomial-time dimension of â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT is defined as cdimPâ¢(â„±)=inf{sâˆ£âˆƒ a polynomial-time â¢sâ¢-gale â¢dâ¢ such that d succeeds on all â¢Xâˆˆâ„±}.subscriptcdimPâ„±infimumconditional-setğ‘  a polynomial-time ğ‘ -gale ğ‘‘ such that d succeeds on all ğ‘‹â„±\displaystyle{\mathrm{cdim}}_{\mathrm{P}}(\mathcal{F})=\inf\{s\mid\exists\text% { a polynomial-time }s\text{-gale }d\text{ such that d succeeds on all }X\in% \mathcal{F}\}.roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) = roman_inf { italic_s âˆ£ âˆƒ a polynomial-time italic_s -gale italic_d such that d succeeds on all italic_X âˆˆ caligraphic_F } . For a sequence XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, define cdimPâ¢(X)=cdimPâ¢({X})subscriptcdimPğ‘‹subscriptcdimPğ‘‹{\mathrm{cdim}}_{\mathrm{P}}(X)={\mathrm{cdim}}_{\mathrm{P}}(\{X\})roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) = roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( { italic_X } ). That is cdimPâ¢(X)subscriptcdimPğ‘‹{\mathrm{cdim}}_{\mathrm{P}}(X)roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) is the â€œlowestâ€ sğ‘ sitalic_s for which there exists a polynomial time sğ‘ sitalic_s-gale dğ‘‘ditalic_d that succeeds on Xğ‘‹Xitalic_X. On the other hand, we can use time bounded Kolmogorov complexity to define a polynomial time analogue of ğ’¦ğ’¦\mathcal{K}caligraphic_K. The run time of the shortest program of size Kâ¢(x)ğ¾ğ‘¥K(x)italic_K ( italic_x ) that produces a string xğ‘¥xitalic_x can be very large relative to the length of xğ‘¥xitalic_x. For a given time bound tâ¢(n)ğ‘¡ğ‘›t(n)italic_t ( italic_n ), the tğ‘¡titalic_t-time bounded Kolmogorov complexity Ktâ¢(x)subscriptğ¾ğ‘¡ğ‘¥K_{t}(x)italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x ) of a string xğ‘¥xitalic_x is the length of the shortest program that generates xğ‘¥xitalic_x in at most tâ¢(|x|)ğ‘¡ğ‘¥t(\lvert x\rvert)italic_t ( | italic_x | ) time steps (see [LV08]). In this paper we are mostly concerned with the polynomial time bounded Kolmogorov complexity of strings xâˆˆÎ£âˆ—ğ‘¥superscriptÎ£x\in\Sigma^{*}italic_x âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT, that is Kpâ¢(n)â¢(x)subscriptğ¾ğ‘ğ‘›ğ‘¥K_{p(n)}(x)italic_K start_POSTSUBSCRIPT italic_p ( italic_n ) end_POSTSUBSCRIPT ( italic_x ) for some polynomial pğ‘pitalic_p where nğ‘›nitalic_n is the length of xğ‘¥xitalic_x. For a given time bound tâ¢(n)ğ‘¡ğ‘›t(n)italic_t ( italic_n ), the quantity lim infnâ†’âˆKtâ¢(Xâ†¾n)/nsubscriptlimit-infimumâ†’ğ‘›subscriptğ¾ğ‘¡â†¾ğ‘‹ğ‘›ğ‘›\liminf_{n\rightarrow\infty}K_{t}(X\upharpoonright n)/nlim inf start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_X â†¾ italic_n ) / italic_n gives the tğ‘¡titalic_t-time bounded rate of information in an infinite string Xğ‘‹Xitalic_X. The polynomial time analogue of ğ’¦ğ’¦\mathcal{K}caligraphic_K (Definition 4) is the infimum of this quantity over all polynomial time bounds tğ‘¡titalic_t. Definition 4 ([HV04, HV06]). For any â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, ğ’¦polyâ¢(â„±)=inftâˆˆpolysupXâˆˆâ„±lim infnâ†’âˆKtâ¢(Xâ†¾n)n.subscriptğ’¦polyâ„±subscriptinfimumğ‘¡polysubscriptsupremumğ‘‹â„±subscriptlimit-infimumâ†’ğ‘›subscriptğ¾ğ‘¡â†¾ğ‘‹ğ‘›ğ‘›\displaystyle\mathcal{K}_{{\mathrm{poly}}}(\mathcal{F})=\inf\limits_{t\in{% \mathrm{poly}}}\sup\limits_{X\in\mathcal{F}}\liminf\limits_{n\rightarrow\infty% }\frac{K_{t}(X\upharpoonright n)}{n}.caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ) = roman_inf start_POSTSUBSCRIPT italic_t âˆˆ roman_poly end_POSTSUBSCRIPT roman_sup start_POSTSUBSCRIPT italic_X âˆˆ caligraphic_F end_POSTSUBSCRIPT lim inf start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT divide start_ARG italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_X â†¾ italic_n ) end_ARG start_ARG italic_n end_ARG . This leads to the question: Are the notions of polynomial time dimension formulated using sğ‘ sitalic_s-gales (cdimPsubscriptcdimP{\mathrm{cdim}}_{\mathrm{P}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT) and time bounded Kolmogorov complexity (ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT) equivalent?. Hitchcock and Vinodchandran [HV06] showed that cdimPsubscriptcdimP{\mathrm{cdim}}_{\mathrm{P}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT is always greater than or equal to ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT222See Section 8 for alternate proofs of Theorems 3 and 4.. Theorem 3 ([HV04, HV06]). For every â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, ğ’¦polyâ¢(â„±)â‰¤cdimPâ¢(â„±)subscriptğ’¦polyâ„±subscriptcdimPâ„±\mathcal{K}_{{\mathrm{poly}}}(\mathcal{F})\leq{\mathrm{cdim}}_{\mathrm{P}}(% \mathcal{F})caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ) â‰¤ roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ). LÃ³pez and Mayordomo in [LVM05] showed a characterization of polynomial time dimension in terms of compression schemes that do not start from the scratch. But the question whether the above notions of polynomial time dimensions defined using polynomial time sğ‘ sitalic_s-gales and polynomial time bounded Kolmogorov complexity are equivalent remained elusive. Hitchcock and Vinodchandran [HV04, HV06] and later Stull in [Stu20] posed the following open question: Question 1 ([HV04, HV06, Stu20]). Is it true that, for every sequence XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT cdimPâ¢(X)=ğ’¦polyâ¢(X)â¢?subscriptcdimPğ‘‹subscriptğ’¦polyğ‘‹?\displaystyle{\mathrm{cdim}}_{\mathrm{P}}(X)=\mathcal{K}_{{\mathrm{poly}}}(X)\;?roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) = caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) ? A analogous question can be asked for sets of sequences, â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT. Question 2 ([HV04, HV06, Stu20]). Is it true that, for every â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT cdimPâ¢(â„±)=ğ’¦polyâ¢(â„±)â¢?subscriptcdimPâ„±subscriptğ’¦polyâ„±?\displaystyle{\mathrm{cdim}}_{\mathrm{P}}(\mathcal{F})=\mathcal{K}_{{\mathrm{% poly}}}(\mathcal{F})\;?roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) = caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ) ? Note that an affirmative answer to Question 2 trivially implies an affirmative answer to Question 1. However, a positive answer to Question 1 does not necessarily imply a positive answer to Question 2. For an arbitrary set â„±â„±\mathcal{F}caligraphic_F, assume that cdimPâ¢(X)=ğ’¦polyâ¢(X)subscriptcdimPğ‘‹subscriptğ’¦polyğ‘‹{\mathrm{cdim}}_{\mathrm{P}}(X)=\mathcal{K}_{{\mathrm{poly}}}(X)roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) = caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) for every Xâˆˆâ„±ğ‘‹â„±X\in\mathcal{F}italic_X âˆˆ caligraphic_F. Then, for any s>ğ’¦polyâ¢(â„±)ğ‘ subscriptğ’¦polyâ„±s>\mathcal{K}_{{\mathrm{poly}}}(\mathcal{F})italic_s > caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ) and Xâˆˆâ„±ğ‘‹â„±X\in\mathcal{F}italic_X âˆˆ caligraphic_F, there exists a polytime sğ‘ sitalic_s-gale that wins on the point Xğ‘‹Xitalic_X. However, there need not exist a single sğ‘ sitalic_s-gale that wins on every point in â„±â„±\mathcal{F}caligraphic_F. Polynomial-time strong dimension is a dual notion of polynomial time dimension [AHLM07, Stu20]. As in the case of polynomial time dimension, there exist two notions, one defined using sğ‘ sitalic_s-gales and the other defined in terms of time bounded Kolmogorov complexity. An sğ‘ sitalic_s-gale dğ‘‘ditalic_d strongly succeeds on an infinite sequence Xğ‘‹Xitalic_X if lim infnâ†’âˆdâ¢(X1â¢X2â¢â€¦â¢Xn)=âˆsubscriptlimit-infimumâ†’ğ‘›ğ‘‘subscriptğ‘‹1subscriptğ‘‹2â€¦subscriptğ‘‹ğ‘›\liminf\limits_{n\to\infty}d(X_{1}X_{2}\dots X_{n})=\inftylim inf start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT italic_d ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT â€¦ italic_X start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) = âˆ. Definition 5 (Polynomial-time strong dimension [AHLM07, Stu20]). The polynomial-time dimension of â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT is defined as cDimPâ¢(â„±)=inf{sâˆ£âˆƒ a polynomial-time â¢sâ¢-gale â¢dâ¢ such that d strongly succeeds on all â¢Xâˆˆâ„±}.subscriptcDimPâ„±infimumconditional-setğ‘  a polynomial-time ğ‘ -gale ğ‘‘ such that d strongly succeeds on all ğ‘‹â„±\displaystyle{{\mathrm{cDim}}}_{\mathrm{P}}(\mathcal{F})=\inf\{s\mid\exists% \text{ a polynomial-time }s\text{-gale }d\text{ such that d strongly succeeds % on all }X\in\mathcal{F}\}.roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) = roman_inf { italic_s âˆ£ âˆƒ a polynomial-time italic_s -gale italic_d such that d strongly succeeds on all italic_X âˆˆ caligraphic_F } . For a sequence XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, define cDimPâ¢(X)=cDimPâ¢({X})subscriptcDimPğ‘‹subscriptcDimPğ‘‹{{\mathrm{cDim}}}_{\mathrm{P}}(X)={{\mathrm{cDim}}}_{\mathrm{P}}(\{X\})roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) = roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( { italic_X } ). The strong dimension analogue of ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT is defined by replacing the lim inflimit-infimum\liminflim inf in the definition of ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT with lim suplimit-supremum\limsuplim sup. Definition 6 ([HV04, HV06]). For any â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, ğ’¦polystrâ¢(â„±)=inftâˆˆpolysupXâˆˆâ„±lim supnâ†’âˆKtâ¢(Xâ†¾n)n.subscriptsuperscriptğ’¦strpolyâ„±subscriptinfimumğ‘¡polysubscriptsupremumğ‘‹â„±subscriptlimit-supremumâ†’ğ‘›subscriptğ¾ğ‘¡â†¾ğ‘‹ğ‘›ğ‘›\displaystyle\mathcal{K}^{\mathrm{str}}_{{\mathrm{poly}}}(\mathcal{F})=\inf% \limits_{t\in{\mathrm{poly}}}\sup\limits_{X\in\mathcal{F}}\limsup\limits_{n% \rightarrow\infty}\frac{K_{t}(X\upharpoonright n)}{n}.caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ) = roman_inf start_POSTSUBSCRIPT italic_t âˆˆ roman_poly end_POSTSUBSCRIPT roman_sup start_POSTSUBSCRIPT italic_X âˆˆ caligraphic_F end_POSTSUBSCRIPT lim sup start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT divide start_ARG italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_X â†¾ italic_n ) end_ARG start_ARG italic_n end_ARG . Similar to the conclusion of Theorem 3, cDimPsubscriptcDimP{{\mathrm{cDim}}}_{\mathrm{P}}roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT is always greater than or equal to ğ’¦polystrsubscriptsuperscriptğ’¦strpoly\mathcal{K}^{\mathrm{str}}_{{\mathrm{poly}}}caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT. Theorem 4 ([HV04, HV06]). For every â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, ğ’¦polystrâ¢(â„±)â‰¤cDimPâ¢(â„±)subscriptsuperscriptğ’¦strpolyâ„±subscriptcDimPâ„±\mathcal{K}^{\mathrm{str}}_{{\mathrm{poly}}}(\mathcal{F})\leq{{\mathrm{cDim}}}% _{\mathrm{P}}(\mathcal{F})caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ) â‰¤ roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ). Stull in [Stu20] posed the following question: Are the notions of polynomial time strong dimension formulated using sğ‘ sitalic_s-gales (cDimPsubscriptcDimP{{\mathrm{cDim}}}_{\mathrm{P}}roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT) and time bounded Kolmogorov complexity (ğ’¦polystrsubscriptsuperscriptğ’¦strpoly\mathcal{K}^{\mathrm{str}}_{{\mathrm{poly}}}caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT) equivalent?. 1.5 Our Results We show that if one-way functions exist then equality does not hold in Question 2. In order to show this, we prove the contrapositive of the statement. Theorem 5. If for all â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, cdimPâ¢(â„±)=ğ’¦polyâ¢(â„±),subscriptcdimPâ„±subscriptğ’¦polyâ„±{\mathrm{cdim}}_{\mathrm{P}}(\mathcal{F})=\mathcal{K}_{{\mathrm{poly}}}(% \mathcal{F}),roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) = caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ) , then one-way functions do not exist. We then show the stronger result that if one-way functions exist then Question 1 has a negative answer, by proving the following contrapositive statement. Theorem 6. If for all XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, cdimPâ¢(X)=ğ’¦polyâ¢(X),subscriptcdimPğ‘‹subscriptğ’¦polyğ‘‹{\mathrm{cdim}}_{\mathrm{P}}(X)=\mathcal{K}_{{\mathrm{poly}}}(X),roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) = caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) , then one-way functions do not exist. Conditioned on the existence of one-way functions, we demonstrate the existence of sets â„±â„±\mathcal{F}caligraphic_F and sequences Xğ‘‹Xitalic_X such that ğ’¦polyâ¢(â„±)<cdimPâ¢(â„±)subscriptğ’¦polyâ„±subscriptcdimPâ„±\mathcal{K}_{{\mathrm{poly}}}(\mathcal{F})<{\mathrm{cdim}}_{\mathrm{P}}(% \mathcal{F})caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ) < roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) and ğ’¦polyâ¢(X)<cdimPâ¢(X)subscriptğ’¦polyğ‘‹subscriptcdimPğ‘‹\mathcal{K}_{{\mathrm{poly}}}(X)<{\mathrm{cdim}}_{\mathrm{P}}(X)caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) < roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ). In the last section of the paper we demonstrate how the proof of Theorem 6 can be extended to show that if one-way functions exist, then the distance between these quantities can be arbitrarily close to the maximum possible value of 1111. An analogous theorem for sets follows from Theorem 7. Theorem 7. If one-way functions exist then for any Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0, there exists XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT such that, cdimPâ¢(X)âˆ’ğ’¦polyâ¢(X)â‰¥1âˆ’Ïµ.subscriptcdimPğ‘‹subscriptğ’¦polyğ‘‹1italic-Ïµ\displaystyle{\mathrm{cdim}}_{\mathrm{P}}(X)-\mathcal{K}_{{\mathrm{poly}}}(X)% \geq 1-\epsilon.roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) - caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) â‰¥ 1 - italic_Ïµ . For polynomial time strong dimension, we show that if one-way functions exist, then there exist sequences for which the gap between ğ’¦polystrsubscriptsuperscriptğ’¦strpoly\mathcal{K}^{\mathrm{str}}_{{\mathrm{poly}}}caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT and cDimPsubscriptcDimP{{\mathrm{cDim}}}_{\mathrm{P}}roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT is arbitrarily close to 1111. An analogous theorem for sets follows from Theorem 8. Theorem 8. If one-way functions exist then for any Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0, there exists XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT such that, cDimPâ¢(X)âˆ’ğ’¦polystrâ¢(X)â‰¥1âˆ’Ïµ.subscriptcDimPğ‘‹subscriptsuperscriptğ’¦strpolyğ‘‹1italic-Ïµ\displaystyle{{\mathrm{cDim}}}_{\mathrm{P}}(X)-\mathcal{K}^{\mathrm{str}}_{{% \mathrm{poly}}}(X)\geq 1-\epsilon.roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) - caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) â‰¥ 1 - italic_Ïµ . Therefore, we show that if one-way functions exist, the answers to both parts of Open Question 3.71 from [Stu20] are negative. 1.6 Proof Outline In this section we give an informal account of the proofs of the main results from section 1.5. The full proofs are given in section 4 and Section 5. One-way functions and polynomial time dimension of sets We first show that if one-way functions exist, then there exist sets of sequences â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT such that the cdimPâ¢(â„±)subscriptcdimPâ„±{\mathrm{cdim}}_{\mathrm{P}}(\mathcal{F})roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) is strictly greater than ğ’¦polyâ¢(â„±)subscriptğ’¦polyâ„±\mathcal{K}_{{\mathrm{poly}}}(\mathcal{F})caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ). This proves Theorem 5 thereby refuting Question 2. See 5 We start with the assumption that one-way functions exist. This implies the existence of pseudorandom generators {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT mapping strings of length sâ¢nğ‘ ğ‘›snitalic_s italic_n to strings of length nğ‘›nitalic_n for every s<1ğ‘ 1s<1italic_s < 1. Let tâ¢(n)âˆˆpolyâ¢(n)ğ‘¡ğ‘›polyğ‘›t(n)\in{\mathrm{poly}}(n)italic_t ( italic_n ) âˆˆ roman_poly ( italic_n ) be the running time complexity of Gnsubscriptğºğ‘›G_{n}italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT. To prove Theorem 5, we only need to consider the case when s=2âˆ’mğ‘ superscript2ğ‘šs=2^{-m}italic_s = 2 start_POSTSUPERSCRIPT - italic_m end_POSTSUPERSCRIPT for some m>1ğ‘š1m>1italic_m > 1. Now, we consider the set â„±ssubscriptâ„±ğ‘ \mathcal{F}_{s}caligraphic_F start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT which consists of all infinite sequences Xğ‘‹Xitalic_X such that Ktâ¢(Xâ†¾n)â‰¤sâ¢nsubscriptğ¾ğ‘¡â†¾ğ‘‹ğ‘›ğ‘ ğ‘›K_{t}(X\upharpoonright n)\leq snitalic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_X â†¾ italic_n ) â‰¤ italic_s italic_n for infinitely many nğ‘›nitalic_n. Here Xâ†¾nâ†¾ğ‘‹ğ‘›X\upharpoonright nitalic_X â†¾ italic_n denotes the first nğ‘›nitalic_n bits of Xğ‘‹Xitalic_X. Therefore, the limit inferior of density of information Ktâ¢(Xâ†¾n)/nsubscriptğ¾ğ‘¡â†¾ğ‘‹ğ‘›ğ‘›K_{t}(X\upharpoonright n)/nitalic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_X â†¾ italic_n ) / italic_n for any such sequence is less than or equal to sğ‘ sitalic_s. It follows from the definition of ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT for sets, that ğ’¦polyâ¢(â„±s)â‰¤ssubscriptğ’¦polysubscriptâ„±ğ‘ ğ‘ \mathcal{K}_{{\mathrm{poly}}}(\mathcal{F}_{s})\leq scaligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT ) â‰¤ italic_s. In order to prove Theorem 5, assume the hypothesis that for all â„±âŠ†Î£âˆâ„±superscriptÎ£\mathcal{F}\subseteq\Sigma^{\infty}caligraphic_F âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, cdimPâ¢(â„±)=ğ’¦polyâ¢(â„±)subscriptcdimPâ„±subscriptğ’¦polyâ„±{\mathrm{cdim}}_{\mathrm{P}}(\mathcal{F})=\mathcal{K}_{{\mathrm{poly}}}(% \mathcal{F})roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F ) = caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F ), which in particular implies that cdimPâ¢(â„±s)=ğ’¦polyâ¢(â„±s)â‰¤ssubscriptcdimPsubscriptâ„±ğ‘ subscriptğ’¦polysubscriptâ„±ğ‘ ğ‘ {\mathrm{cdim}}_{\mathrm{P}}(\mathcal{F}_{s})=\mathcal{K}_{{\mathrm{poly}}}(% \mathcal{F}_{s})\leq sroman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT ) = caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT ) â‰¤ italic_s. From this, we show that for every sâ€²âˆˆ(s,1/2)superscriptğ‘ â€²ğ‘ 12s^{\prime}\in(s,1/2)italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ ( italic_s , 1 / 2 ) such that 2sâ€²superscript2superscriptğ‘ â€²2^{s^{\prime}}2 start_POSTSUPERSCRIPT italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT is rational, there exists an exact computable polynomial time sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT-gale dâ€²superscriptğ‘‘â€²d^{\prime}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT that succeeds on all sequences Xğ‘‹Xitalic_X such that Ktâ¢(Xâ†¾n)â‰¤sâ¢nsubscriptğ¾ğ‘¡â†¾ğ‘‹ğ‘›ğ‘ ğ‘›K_{t}(X\upharpoonright n)\leq snitalic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_X â†¾ italic_n ) â‰¤ italic_s italic_n. In the rest of the proof, we modify this gale dâ€²superscriptğ‘‘â€²d^{\prime}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT and construct a distinguisher algorithm Ağ´Aitalic_A which can distinguish between the outputs of the PRG {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT and uniform random strings with non-negligible probability for infinitely many input lengths nğ‘›nitalic_n. Now we are faced with a technical hurdle. Pseudorandom generators are defined as mapping between finite strings. On the other hand, polynomial time dimension is defined over infinite sequences. To connect these notions, we first extend the PRG {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT to a mapping between infinite sequences, g:Î£âˆâ†’Î£âˆ:ğ‘”â†’superscriptÎ£superscriptÎ£g:\Sigma^{\infty}\to\Sigma^{\infty}italic_g : roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT â†’ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT. The mapping gğ‘”gitalic_g is constructed as follows. We first define mappings gksubscriptğ‘”ğ‘˜g_{k}italic_g start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT from Î£ksuperscriptÎ£ğ‘˜\Sigma^{k}roman_Î£ start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT to Î£âˆ—superscriptÎ£\Sigma^{*}roman_Î£ start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT and gğ‘”gitalic_g is defined to be the limit of the mappings gksubscriptğ‘”ğ‘˜g_{k}italic_g start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT as kâ†’âˆâ†’ğ‘˜k\to\inftyitalic_k â†’ âˆ. On an input wâˆˆÎ£kğ‘¤superscriptÎ£ğ‘˜w\in\Sigma^{k}italic_w âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT, gksubscriptğ‘”ğ‘˜g_{k}italic_g start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT first divides wğ‘¤witalic_w into blocks xnsubscriptğ‘¥ğ‘›x_{n}italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT of size sâ¢.2nğ‘ superscript.2ğ‘›s.2^{n}italic_s .2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT for every nâ‰¤logâ¡(k/s)ğ‘›ğ‘˜ğ‘ n\leq\log(k/s)italic_n â‰¤ roman_log ( italic_k / italic_s ). Then, for every block xnsubscriptğ‘¥ğ‘›x_{n}italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT in wğ‘¤witalic_w, gğ‘”gitalic_g applies the function Gnsubscriptğºğ‘›G_{n}italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT to obtain an output block ynsubscriptğ‘¦ğ‘›y_{n}italic_y start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT of length 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. Now gkâ¢(w)subscriptğ‘”ğ‘˜ğ‘¤g_{k}(w)italic_g start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_w ) is defined as the concatenation of blocks ynsubscriptğ‘¦ğ‘›y_{n}italic_y start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT for each nâˆˆâ„•ğ‘›â„•n\in\mathbb{N}italic_n âˆˆ blackboard_N. The mappings gksubscriptğ‘”ğ‘˜g_{k}italic_g start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT preserves the prefix ordering among strings (i.e. if wâ€²âŠ‘wsquare-image-of-or-equalssuperscriptğ‘¤â€²ğ‘¤w^{\prime}\sqsubseteq witalic_w start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âŠ‘ italic_w then g|wâ€²|â¢(wâ€²)âŠ‘g|w|â¢(w)square-image-of-or-equalssubscriptğ‘”superscriptğ‘¤â€²superscriptğ‘¤â€²subscriptğ‘”ğ‘¤ğ‘¤g_{\lvert w^{\prime}\rvert}(w^{\prime})\sqsubseteq g_{\lvert w\rvert}(w)italic_g start_POSTSUBSCRIPT | italic_w start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT | end_POSTSUBSCRIPT ( italic_w start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) âŠ‘ italic_g start_POSTSUBSCRIPT | italic_w | end_POSTSUBSCRIPT ( italic_w )). Now, for any XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT we define gâ¢(X)=limkâ†’âˆgkâ¢(Xâ†¾k)ğ‘”ğ‘‹subscriptâ†’ğ‘˜subscriptğ‘”ğ‘˜â†¾ğ‘‹ğ‘˜g(X)=\lim_{k\to\infty}g_{k}(X\upharpoonright k)italic_g ( italic_X ) = roman_lim start_POSTSUBSCRIPT italic_k â†’ âˆ end_POSTSUBSCRIPT italic_g start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_X â†¾ italic_k ) (see the precise definition in section 3). We abuse the notation and use gğ‘”gitalic_g instead of gksubscriptğ‘”ğ‘˜g_{k}italic_g start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT when the context is clear. Figure 1 gives a detailed illustration of the construction of gğ‘”gitalic_g. Figure 1: Illustration of the construction of gâ¢(X)ğ‘”ğ‘‹g(X)italic_g ( italic_X ). The first 2msuperscript2ğ‘š2^{m}2 start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT bits of the gâ¢(X)ğ‘”ğ‘‹g(X)italic_g ( italic_X ) are 0. Thereafter, for every for every n>mğ‘›ğ‘šn>mitalic_n > italic_m, the block Xâ¢[sâ¢.2nâˆ’1,sâ¢.2nâˆ’1]ğ‘‹ğ‘ superscript.2ğ‘›1ğ‘ superscript.2ğ‘›1X[s.2^{{n-1}},s.2^{n}-1]italic_X [ italic_s .2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT , italic_s .2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ] is mapped to G2nâˆ’1â¢(Xâ¢[sâ¢.2nâˆ’1,sâ¢.2nâˆ’1])subscriptğºsuperscript2ğ‘›1ğ‘‹ğ‘ superscript.2ğ‘›1ğ‘ superscript.2ğ‘›1G_{2^{n-1}}(X[s.2^{{n-1}},s.2^{n}-1])italic_G start_POSTSUBSCRIPT 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( italic_X [ italic_s .2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT , italic_s .2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ] ) in the output string gâ¢(X)ğ‘”ğ‘‹g(X)italic_g ( italic_X ). Let gâ¢(Î£âˆ)ğ‘”superscriptÎ£g(\Sigma^{\infty})italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ) denote the set {gâ¢(X):XâˆˆÎ£âˆ}conditional-setğ‘”ğ‘‹ğ‘‹superscriptÎ£\{g(X):X\in\Sigma^{\infty}\}{ italic_g ( italic_X ) : italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT }. Now we analyze the density of information of the sequences in gâ¢(Î£âˆ)ğ‘”superscriptÎ£g(\Sigma^{\infty})italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ). An important observation is that for any yâˆˆÎ£nğ‘¦superscriptÎ£ğ‘›y\in\Sigma^{n}italic_y âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT such that y=Gnâ¢(x)ğ‘¦subscriptğºğ‘›ğ‘¥y=G_{n}(x)italic_y = italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ), yğ‘¦yitalic_y has a short description in terms of xğ‘¥xitalic_x and the description of the algorithm computing the PRG Gnsubscriptğºğ‘›G_{n}italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT. Therefore, it follows that Ktâ¢(y)â‰²|x|+Oâ¢(1)â‰¤sâ¢n+Oâ¢(1)less-than-or-similar-tosubscriptğ¾ğ‘¡ğ‘¦ğ‘¥ğ‘‚1ğ‘ ğ‘›ğ‘‚1K_{t}(y)\lesssim\lvert x\rvert+O(1)\leq sn+O(1)italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_y ) â‰² | italic_x | + italic_O ( 1 ) â‰¤ italic_s italic_n + italic_O ( 1 ). Now, if Y=gâ¢(X)ğ‘Œğ‘”ğ‘‹Y=g(X)italic_Y = italic_g ( italic_X ) for some XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, it follows that the first 2msuperscript2ğ‘š2^{m}2 start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT bits of Yğ‘ŒYitalic_Y has a short description in terms of the first sâ¢.2mğ‘ superscript.2ğ‘šs.2^{m}italic_s .2 start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT bits of Xğ‘‹Xitalic_X along with the description of the algorithm which computes the PRG {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT. Therefore we obtain that for infinitely many nâˆˆâ„•ğ‘›â„•n\in\mathbb{N}italic_n âˆˆ blackboard_N, Ktâ¢(Yâ†¾2n)â‰²sâ¢.2n+Oâ¢(1)less-than-or-similar-tosubscriptğ¾ğ‘¡â†¾ğ‘Œsuperscript2ğ‘›ğ‘ superscript.2ğ‘›ğ‘‚1K_{t}(Y\upharpoonright 2^{n})\lesssim s.2^{n}+O(1)italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) â‰² italic_s .2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + italic_O ( 1 ). This implies that lim infnâ†’âˆKtâ¢(Yâ†¾n)/nâ‰¤ssubscriptlimit-infimumâ†’ğ‘›subscriptğ¾ğ‘¡â†¾ğ‘Œğ‘›ğ‘›ğ‘ \liminf_{n\to\infty}K_{t}(Y\upharpoonright n)/n\leq slim inf start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_Y â†¾ italic_n ) / italic_n â‰¤ italic_s and hence Yâˆˆâ„±sğ‘Œsubscriptâ„±ğ‘ Y\in\mathcal{F}_{s}italic_Y âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT. Hence, it follows that gâ¢(Î£âˆ)âŠ†â„±sğ‘”superscriptÎ£subscriptâ„±ğ‘ g(\Sigma^{\infty})\subseteq\mathcal{F}_{s}italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ) âŠ† caligraphic_F start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT. Therefore the sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT-gale dâ€²superscriptğ‘‘â€²d^{\prime}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT succeeds on every sequence in the set gâ¢(Î£âˆ)ğ‘”superscriptÎ£g(\Sigma^{\infty})italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ). Using standard techniques on gales, we transform dâ€²superscriptğ‘‘â€²d^{\prime}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT into a polynomial time martingale d~~ğ‘‘\tilde{d}over~ start_ARG italic_d end_ARG that gains a significant amount of money over blocks of length 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT for infinitely many nğ‘›nitalic_n. More precisely, for some s~âˆˆ(2â¢sâ€²,1)~ğ‘ 2superscriptğ‘ â€²1\tilde{s}\in(2s^{\prime},1)over~ start_ARG italic_s end_ARG âˆˆ ( 2 italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT , 1 ), for all Yâˆˆgâ¢(Î£âˆ)ğ‘Œğ‘”superscriptÎ£Y\in g(\Sigma^{\infty})italic_Y âˆˆ italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ), there exist infinitely many nğ‘›nitalic_n such that d~â¢(Yâ†¾2n+1)>2(1âˆ’s~)â¢2nâ¢d~â¢(Yâ†¾2n).~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›1superscript21~ğ‘ superscript2ğ‘›~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›\displaystyle\tilde{d}(Y\upharpoonright 2^{n+1})>2^{(1-\tilde{s})2^{n}}\tilde{% d}(Y\upharpoonright 2^{n}).over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n + 1 end_POSTSUPERSCRIPT ) > 2 start_POSTSUPERSCRIPT ( 1 - over~ start_ARG italic_s end_ARG ) 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) . (1) We now design a probabilistic distinguisher algorithm Ağ´Aitalic_A that breaks the PRG {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT. We describe the behavior of Ağ´Aitalic_A on inputs of length 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. Let yğ‘¦yitalic_y be an input of size 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. The distinguisher randomly chooses sâ¢.2nğ‘ superscript.2ğ‘›s.2^{n}italic_s .2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT bits xâ€²superscriptğ‘¥â€²x^{\prime}italic_x start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT and takes yâ€²=gâ¢(xâ€²)superscriptğ‘¦â€²ğ‘”superscriptğ‘¥â€²y^{\prime}=g(x^{\prime})italic_y start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT = italic_g ( italic_x start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ). Now Ağ´Aitalic_A outputs 1111 if and only if: d~â¢(yâ€²â¢y)>2(1âˆ’s~)â¢2nâ¢d~â¢(y)~ğ‘‘superscriptğ‘¦â€²ğ‘¦superscript21~ğ‘ superscript2ğ‘›~ğ‘‘ğ‘¦\displaystyle\tilde{d}(y^{\prime}y)>2^{(1-\tilde{s})2^{n}}\tilde{d}(y)over~ start_ARG italic_d end_ARG ( italic_y start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT italic_y ) > 2 start_POSTSUPERSCRIPT ( 1 - over~ start_ARG italic_s end_ARG ) 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT over~ start_ARG italic_d end_ARG ( italic_y ) Otherwise Ağ´Aitalic_A outputs 00. Here Ağ´Aitalic_A evaluates d~~ğ‘‘\tilde{d}over~ start_ARG italic_d end_ARG on the string yâ€²â¢ysuperscriptğ‘¦â€²ğ‘¦y^{\prime}yitalic_y start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT italic_y instead of yâ¢yâ€²ğ‘¦superscriptğ‘¦â€²yy^{\prime}italic_y italic_y start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT because the construction of yâ€²â¢ysuperscriptğ‘¦â€²ğ‘¦y^{\prime}yitalic_y start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT italic_y is consistent with the structure of the mapping gğ‘”gitalic_g. Since d~~ğ‘‘\tilde{d}over~ start_ARG italic_d end_ARG is polynomial time computable, Ağ´Aitalic_A is a polynomial time algorithm. We have shown that d~~ğ‘‘\tilde{d}over~ start_ARG italic_d end_ARG satisfies the condition (1) over Yâˆˆgâ¢(Î£âˆ)ğ‘Œğ‘”superscriptÎ£Y\in g(\Sigma^{\infty})italic_Y âˆˆ italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ) for infinitely many nğ‘›nitalic_n. But the fraction of strings of a particular length nğ‘›nitalic_n satisfying (1) may in fact be negligible. In order to overcome this difficulty, we use an argument involving the Borel Cantelli Lemma to show that there exist infinitely many nâˆˆâ„•ğ‘›â„•n\in\mathbb{N}italic_n âˆˆ blackboard_N, such that over at least a 1/n21superscriptğ‘›21/n^{2}1 / italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT fraction of strings wâˆˆÎ£sâ¢.2nğ‘¤superscriptÎ£ğ‘ superscript.2ğ‘›w\in\Sigma^{s.2^{n}}italic_w âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_s .2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT, d~(g(w))>2(1âˆ’s~)â¢2nd~(g(w)â†¾2nâˆ’1)).\displaystyle\tilde{d}(g(w))>2^{(1-\tilde{s})2^{n}}\tilde{d}(g(w)% \upharpoonright 2^{n-1})).over~ start_ARG italic_d end_ARG ( italic_g ( italic_w ) ) > 2 start_POSTSUPERSCRIPT ( 1 - over~ start_ARG italic_s end_ARG ) 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT over~ start_ARG italic_d end_ARG ( italic_g ( italic_w ) â†¾ 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT ) ) . Letting N=2nğ‘superscript2ğ‘›N=2^{n}italic_N = 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, from the above it follows that for infinitely many Nâˆˆâ„•ğ‘â„•N\in\mathbb{N}italic_N âˆˆ blackboard_N, PrxâˆˆÎ£s.Nâ¢[Aâ¢(gâ¢(x))=1]â‰¥1N2.subscriptPrğ‘¥superscriptÎ£formulae-sequenceğ‘ ğ‘delimited-[]ğ´ğ‘”ğ‘¥11superscriptğ‘2\displaystyle\mathrm{Pr}_{x\in\Sigma^{s.N}}[A(g(x))=1]\geq\frac{1}{N^{2}}.roman_Pr start_POSTSUBSCRIPT italic_x âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_s . italic_N end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_A ( italic_g ( italic_x ) ) = 1 ] â‰¥ divide start_ARG 1 end_ARG start_ARG italic_N start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG . On the other hand, for uniformly random inputs, the Kolmogorov inequality for martingales implies that the probability that condition (1) holds is exponentially low. For all nâˆˆâ„•ğ‘›â„•n\in\mathbb{N}italic_n âˆˆ blackboard_N, taking N=2nğ‘superscript2ğ‘›N=2^{n}italic_N = 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, we have PryâˆˆÎ£Nâ¢[Aâ¢(y)=1]<12N.(1âˆ’s~).subscriptPrğ‘¦superscriptÎ£ğ‘delimited-[]ğ´ğ‘¦11superscript2formulae-sequenceğ‘1~ğ‘ \displaystyle\mathrm{Pr}_{y\in\Sigma^{N}}[A(y)=1]<\frac{1}{2^{N.(1-\tilde{s})}}.roman_Pr start_POSTSUBSCRIPT italic_y âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_A ( italic_y ) = 1 ] < divide start_ARG 1 end_ARG start_ARG 2 start_POSTSUPERSCRIPT italic_N . ( 1 - over~ start_ARG italic_s end_ARG ) end_POSTSUPERSCRIPT end_ARG . (2) Therefore there exist infinitely many Nâˆˆâ„•ğ‘â„•N\in\mathbb{N}italic_N âˆˆ blackboard_N such that, PrxâˆˆÎ£s.Nâ¢[Aâ¢(gâ¢(x))=1]âˆ’PryâˆˆÎ£Nâ¢[Aâ¢(y)=1]â‰¥1N2âˆ’12N.(1âˆ’sâ€²)>1NcsubscriptPrğ‘¥superscriptÎ£formulae-sequenceğ‘ ğ‘delimited-[]ğ´ğ‘”ğ‘¥1subscriptPrğ‘¦superscriptÎ£ğ‘delimited-[]ğ´ğ‘¦11superscriptğ‘21superscript2formulae-sequenceğ‘1superscriptğ‘ â€²1superscriptğ‘ğ‘\displaystyle\mathrm{Pr}_{x\in\Sigma^{s.N}}[A(g(x))=1]-\mathrm{Pr}_{y\in\Sigma% ^{N}}[A(y)=1]\geq\frac{1}{N^{2}}-\frac{1}{2^{N.(1-s^{\prime})}}>\frac{1}{N^{c}}roman_Pr start_POSTSUBSCRIPT italic_x âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_s . italic_N end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_A ( italic_g ( italic_x ) ) = 1 ] - roman_Pr start_POSTSUBSCRIPT italic_y âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_A ( italic_y ) = 1 ] â‰¥ divide start_ARG 1 end_ARG start_ARG italic_N start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG - divide start_ARG 1 end_ARG start_ARG 2 start_POSTSUPERSCRIPT italic_N . ( 1 - italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT end_ARG > divide start_ARG 1 end_ARG start_ARG italic_N start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT end_ARG (3) for some large enough c>0ğ‘0c>0italic_c > 0. Therefore the algorithm Ağ´Aitalic_A is a distinguisher for the PRG {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT. Thus, we obtain a contradiction. Therefore, under the assumption that one-way functions exist, it must be the case that ğ’¦polyâ¢(â„±s)<cdimPâ¢(â„±s)subscriptğ’¦polysubscriptâ„±ğ‘ subscriptcdimPsubscriptâ„±ğ‘ \mathcal{K}_{{\mathrm{poly}}}(\mathcal{F}_{s})<{\mathrm{cdim}}_{\mathrm{P}}(% \mathcal{F}_{s})caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( caligraphic_F start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT ) < roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( caligraphic_F start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT ) which proves Theorem 5. Figure 2 gives an illustration of the implications used in the proof of Theorem 5. Figure 2: Block diagram illustrating outline of proof of Theorem 5. One-way functions and polynomial time dimension of sequences We show the stronger claim that if one-way functions exist, then cdimPâ¢(X)=ğ’¦polyâ¢(X)subscriptcdimPğ‘‹subscriptğ’¦polyğ‘‹{\mathrm{cdim}}_{\mathrm{P}}(X)=\mathcal{K}_{{\mathrm{poly}}}(X)roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) = caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) does not hold for all sequences XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT. See 6 We start with the assumption that one-way functions exist. This implies the existence of pseudorandom generators {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT mapping strings of length sâ¢nğ‘ ğ‘›snitalic_s italic_n to strings of length nğ‘›nitalic_n for every s<1ğ‘ 1s<1italic_s < 1. Let tâ¢(n)âˆˆpolyâ¢(n)ğ‘¡ğ‘›polyğ‘›t(n)\in{\mathrm{poly}}(n)italic_t ( italic_n ) âˆˆ roman_poly ( italic_n ) be the running time of Gnsubscriptğºğ‘›G_{n}italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT. To prove Theorem 6, we only need to consider the case when s=2âˆ’mğ‘ superscript2ğ‘šs=2^{-m}italic_s = 2 start_POSTSUPERSCRIPT - italic_m end_POSTSUPERSCRIPT for some m>1ğ‘š1m>1italic_m > 1. Many elements in the proof of Theorem 6 are similar to those in the proof of Theorem 5. Consider the mapping gğ‘”gitalic_g from the proof of Theorem 5. From section 1.6, we obtain that lim infnâ†’âˆKtâ¢(Yâ†¾n)/nâ‰¤ssubscriptlimit-infimumâ†’ğ‘›subscriptğ¾ğ‘¡â†¾ğ‘Œğ‘›ğ‘›ğ‘ \liminf_{n\to\infty}K_{t}(Y\upharpoonright n)/n\leq slim inf start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_Y â†¾ italic_n ) / italic_n â‰¤ italic_s for every Yâˆˆgâ¢(Î£âˆ)ğ‘Œğ‘”superscriptÎ£Y\in g(\Sigma^{\infty})italic_Y âˆˆ italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ). By the assumption, for any XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT and sâ€²>ssuperscriptğ‘ â€²ğ‘ s^{\prime}>sitalic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT > italic_s, there is a polynomial time computable sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT-gale dXâ€²subscriptsuperscriptğ‘‘â€²ğ‘‹d^{\prime}_{X}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_X end_POSTSUBSCRIPT that succeeds on gâ¢(X)ğ‘”ğ‘‹g(X)italic_g ( italic_X ). The major technical obstacle here is that we do not have a single sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT-gale dâ€²superscriptğ‘‘â€²d^{\prime}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT that succeeds on gâ¢(X)ğ‘”ğ‘‹g(X)italic_g ( italic_X ) for all XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT. We overcome this difficulty using a gale combination technique we construct a single polynomial time sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT-gale dâ€²superscriptğ‘‘â€²d^{\prime}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT that succeeds on gâ¢(X)ğ‘”ğ‘‹g(X)italic_g ( italic_X ) for every Xâˆˆğ’®ğ‘‹ğ’®X\in\mathcal{S}italic_X âˆˆ caligraphic_S some ğ’®âŠ†Î£âˆğ’®superscriptÎ£\mathcal{S}\subseteq\Sigma^{\infty}caligraphic_S âŠ† roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT satisfying Î¼â¢(ğ’®)>0ğœ‡ğ’®0\mu(\mathcal{S})>0italic_Î¼ ( caligraphic_S ) > 0. The rest of the proof is similar to that of Theorem 5. We convert the sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT-gale dâ€²superscriptğ‘‘â€²d^{\prime}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT into a polynomial time martingale d~~ğ‘‘\tilde{d}over~ start_ARG italic_d end_ARG such that for some s~<1~ğ‘ 1\tilde{s}<1over~ start_ARG italic_s end_ARG < 1 and every Yğ‘ŒYitalic_Y in gâ¢(ğ’®)ğ‘”ğ’®g(\mathcal{S})italic_g ( caligraphic_S ), there exist infinitely many nâ‰¥0ğ‘›0n\geq 0italic_n â‰¥ 0 such that d~â¢(Yâ†¾2n+1)>2(1âˆ’s~)â¢2nâ¢d~â¢(Yâ†¾2n).~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›1superscript21~ğ‘ superscript2ğ‘›~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›\displaystyle\tilde{d}(Y\upharpoonright 2^{n+1})>2^{(1-\tilde{s})2^{n}}\tilde{% d}(Y\upharpoonright 2^{n}).over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n + 1 end_POSTSUPERSCRIPT ) > 2 start_POSTSUPERSCRIPT ( 1 - over~ start_ARG italic_s end_ARG ) 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) . We use the same distinguisher algorithm Ağ´Aitalic_A from section 1.6. The analysis of the algorithm is similar to that in the proof of Theorem 5. Finally, we obtain that there exist infinitely many Nâˆˆâ„•ğ‘â„•N\in\mathbb{N}italic_N âˆˆ blackboard_N such that, PrxâˆˆÎ£s.Nâ¢[Aâ¢(gâ¢(x))=1]âˆ’PryâˆˆÎ£Nâ¢[Aâ¢(y)=1]â‰¥1NcsubscriptPrğ‘¥superscriptÎ£formulae-sequenceğ‘ ğ‘delimited-[]ğ´ğ‘”ğ‘¥1subscriptPrğ‘¦superscriptÎ£ğ‘delimited-[]ğ´ğ‘¦11superscriptğ‘ğ‘\displaystyle\mathrm{Pr}_{x\in\Sigma^{s.N}}[A(g(x))=1]-\mathrm{Pr}_{y\in\Sigma% ^{N}}[A(y)=1]\geq\frac{1}{N^{c}}roman_Pr start_POSTSUBSCRIPT italic_x âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_s . italic_N end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_A ( italic_g ( italic_x ) ) = 1 ] - roman_Pr start_POSTSUBSCRIPT italic_y âˆˆ roman_Î£ start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_A ( italic_y ) = 1 ] â‰¥ divide start_ARG 1 end_ARG start_ARG italic_N start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT end_ARG (4) for some large enough c>0ğ‘0c>0italic_c > 0. The algorithm Ağ´Aitalic_A is a distinguisher for the PRG {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT. Thus, we obtain a contradiction. Therefore, under the assumption that one-way functions exist, there exists sequences XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT such that ğ’¦polyâ¢(X)<cdimPâ¢(X)subscriptğ’¦polyğ‘‹subscriptcdimPğ‘‹\mathcal{K}_{{\mathrm{poly}}}(X)<{\mathrm{cdim}}_{\mathrm{P}}(X)caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) < roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) which proves Theorem 5. Gap between ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT and cdimPsubscriptcdimP{\mathrm{cdim}}_{\mathrm{P}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT The techniques in the proof of Theorem 6 yields the following gaps between cdimPsubscriptcdimP{\mathrm{cdim}}_{\mathrm{P}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT and ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT. Theorem 9. If one-way functions exist then for any Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0, there exists XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT such that, cdimPâ¢(X)âˆ’ğ’¦polyâ¢(X)â‰¥1/2âˆ’ÏµsubscriptcdimPğ‘‹subscriptğ’¦polyğ‘‹12italic-Ïµ{\mathrm{cdim}}_{\mathrm{P}}(X)-\mathcal{K}_{{\mathrm{poly}}}(X)\geq 1/2-\epsilonroman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) - caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) â‰¥ 1 / 2 - italic_Ïµ. In this section, we demonstrate how this gap can be increased to 1âˆ’Ïµ1italic-Ïµ1-\epsilon1 - italic_Ïµ for any Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0. See 7 Therefore, if one-way functions exist then the gap between Kpolysubscriptğ¾polyK_{{\mathrm{poly}}}italic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT dimension and cdimPsubscriptcdimP{\mathrm{cdim}}_{\mathrm{P}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT can be as close as required to the maximum gap of 1111. Below we give an outline of the proof of Theorem 7. While constructing the martingale d~~ğ‘‘\tilde{d}over~ start_ARG italic_d end_ARG in the proof of Theorem 6, we used the assumption that sâ€²<1/2superscriptğ‘ â€²12s^{\prime}<1/2italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT < 1 / 2. This is important because in order to obtain the condition d~â¢(Yâ†¾2n+1)>2(1âˆ’s~)â¢2nâ¢d~â¢(Yâ†¾2n)~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›1superscript21~ğ‘ superscript2ğ‘›~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›\tilde{d}(Y\upharpoonright 2^{n+1})>2^{(1-\tilde{s})2^{n}}\tilde{d}(Y% \upharpoonright 2^{n})over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n + 1 end_POSTSUPERSCRIPT ) > 2 start_POSTSUPERSCRIPT ( 1 - over~ start_ARG italic_s end_ARG ) 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) for infinitely many nğ‘›nitalic_n over any Yâˆˆgâ¢(ğ’®)ğ‘Œğ‘”ğ’®Y\in g(\mathcal{S})italic_Y âˆˆ italic_g ( caligraphic_S ), we require s~>2â¢sâ€²~ğ‘ 2superscriptğ‘ â€²\tilde{s}>2s^{\prime}over~ start_ARG italic_s end_ARG > 2 italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT (see Lemma 4 for the formal proof). The major tool we need to overcome this hurdle is a generalization of the construction of martingale d~~ğ‘‘\tilde{d}over~ start_ARG italic_d end_ARG to every sâ€²<1superscriptğ‘ â€²1s^{\prime}<1italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT < 1 (see Lemma 11). We transform dâ€²superscriptğ‘‘â€²d^{\prime}italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT into a polynomial time martingale d~~ğ‘‘\tilde{d}over~ start_ARG italic_d end_ARG satisfying the following property: let s~~ğ‘ \tilde{s}over~ start_ARG italic_s end_ARG and sâ€²â€²superscriptğ‘ â€²â€²s^{\prime\prime}italic_s start_POSTSUPERSCRIPT â€² â€² end_POSTSUPERSCRIPT be such that s~>sâ€²â€²>sâ€²~ğ‘ superscriptğ‘ â€²â€²superscriptğ‘ â€²\tilde{s}>s^{\prime\prime}>s^{\prime}over~ start_ARG italic_s end_ARG > italic_s start_POSTSUPERSCRIPT â€² â€² end_POSTSUPERSCRIPT > italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. Then for any Yâˆˆgâ¢(ğ’®)ğ‘Œğ‘”ğ’®Y\in g(\mathcal{S})italic_Y âˆˆ italic_g ( caligraphic_S ) there exist infinitely many nğ‘›nitalic_n satisfying either of the following conditions: 1. d~â¢(Yâ†¾2n)>2(1âˆ’s~)â¢2nâˆ’1â¢d~â¢(Yâ†¾2nâˆ’1)~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›superscript21~ğ‘ superscript2ğ‘›1~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›1\tilde{d}(Y\upharpoonright 2^{n})>2^{(1-\tilde{s})2^{n-1}}\tilde{d}(Y% \upharpoonright 2^{n-1})over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) > 2 start_POSTSUPERSCRIPT ( 1 - over~ start_ARG italic_s end_ARG ) 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT ). 2. There exists â„“â„“\ellroman_â„“ satisfying ((s~âˆ’sâ€²â€²)/sâ€²â€²)â‹…2nâˆ’1â‰¤â„“â‰¤2nâˆ’1â‹…~ğ‘ superscriptğ‘ â€²â€²superscriptğ‘ â€²â€²superscript2ğ‘›1â„“superscript2ğ‘›1((\tilde{s}-s^{\prime\prime})/s^{\prime\prime})\cdot 2^{n-1}\leq\ell\leq 2^{n-1}( ( over~ start_ARG italic_s end_ARG - italic_s start_POSTSUPERSCRIPT â€² â€² end_POSTSUPERSCRIPT ) / italic_s start_POSTSUPERSCRIPT â€² â€² end_POSTSUPERSCRIPT ) â‹… 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT â‰¤ roman_â„“ â‰¤ 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT such that d~â¢(Yâ†¾2nâˆ’1+â„“)>2(1âˆ’sâ€²â€²)â¢(2nâˆ’1+â„“)~ğ‘‘â†¾ğ‘Œsuperscript2ğ‘›1â„“superscript21superscriptğ‘ â€²â€²superscript2ğ‘›1â„“\tilde{d}(Y\upharpoonright 2^{n-1}+\ell)>2^{(1-s^{\prime\prime})(2^{n-1}+\ell)}over~ start_ARG italic_d end_ARG ( italic_Y â†¾ 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT + roman_â„“ ) > 2 start_POSTSUPERSCRIPT ( 1 - italic_s start_POSTSUPERSCRIPT â€² â€² end_POSTSUPERSCRIPT ) ( 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT + roman_â„“ ) end_POSTSUPERSCRIPT. We need the second condition above to handle the case when sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT may be between 1/2121/21 / 2 and 1111. Finally, we modify Algorithm A from the proof of Theorem 6 to incorporate the second condition above. We adapt the analysis of the algorithm and the arguments involving the Borel Cantelli lemma appropriately to show that Ağ´Aitalic_A is a distinguisher for the PRG {Gn}nâˆˆâ„•subscriptsubscriptğºğ‘›ğ‘›â„•\{G_{n}\}_{n\in\mathbb{N}}{ italic_G start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_n âˆˆ blackboard_N end_POSTSUBSCRIPT. One way functions and polynomial time strong dimension In this section we show that under the existence of one-way functions, there exist sets for which polynomial time strong dimension defined using sğ‘ sitalic_s-gales is strictly greater than the analogous notion defined using time bounded Kolmogorov complexity. These results provide a negative answer to the open question posed by Stull in [Stu20] under the assumption that one-way functions exist. We accomplish this by constructing sets and sequences exhibiting a gap arbitrarily close to 1111 between these quantities. See 8 Below, we give a summary of the proof of Theorem 8. To deal with strong dimension, we require a few new technical tools. First we show the following: if Y=gâ¢(X)ğ‘Œğ‘”ğ‘‹Y=g(X)italic_Y = italic_g ( italic_X ) for some XâˆˆÎ£âˆğ‘‹superscriptÎ£X\in\Sigma^{\infty}italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT, for every i>0ğ‘–0i>0italic_i > 0, Ktâ¢(Yâ†¾i)â‰²(2â¢s).i+Oâ¢(1)formulae-sequenceless-than-or-similar-tosubscriptğ¾ğ‘¡â†¾ğ‘Œğ‘–2ğ‘ ğ‘–ğ‘‚1K_{t}(Y\upharpoonright i)\lesssim(2s).i+O(1)italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_Y â†¾ italic_i ) â‰² ( 2 italic_s ) . italic_i + italic_O ( 1 ). This implies that lim supnâ†’âˆKtâ¢(Yâ†¾n)/nâ‰¤2â¢ssubscriptlimit-supremumâ†’ğ‘›subscriptğ¾ğ‘¡â†¾ğ‘Œğ‘›ğ‘›2ğ‘ \limsup_{n\to\infty}K_{t}(Y\upharpoonright n)/n\leq 2slim sup start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_Y â†¾ italic_n ) / italic_n â‰¤ 2 italic_s for every Yâˆˆgâ¢(Î£âˆ)ğ‘Œğ‘”superscriptÎ£Y\in g(\Sigma^{\infty})italic_Y âˆˆ italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ). Let s=2âˆ’mğ‘ superscript2ğ‘šs=2^{-m}italic_s = 2 start_POSTSUPERSCRIPT - italic_m end_POSTSUPERSCRIPT for some m>1ğ‘š1m>1italic_m > 1. We have s<1/2ğ‘ 12s<1/2italic_s < 1 / 2 and therefore 2â¢s<12ğ‘ 12s<12 italic_s < 1. Consider the set â„±2â¢sâ€²={XâˆˆÎ£âˆ:lim supnâ†’âˆKtgâ¢(Xâ†¾n)nâ‰¤2â¢s}subscriptsuperscriptâ„±â€²2ğ‘ conditional-setğ‘‹superscriptÎ£subscriptlimit-supremumâ†’ğ‘›subscriptğ¾subscriptğ‘¡ğ‘”â†¾ğ‘‹ğ‘›ğ‘›2ğ‘ \mathcal{F}^{\prime}_{2s}=\{X\in\Sigma^{\infty}:\limsup_{n\rightarrow\infty}% \frac{K_{t_{g}}({X}\upharpoonright n)}{n}\leq 2s\}caligraphic_F start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 2 italic_s end_POSTSUBSCRIPT = { italic_X âˆˆ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT : lim sup start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT divide start_ARG italic_K start_POSTSUBSCRIPT italic_t start_POSTSUBSCRIPT italic_g end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( italic_X â†¾ italic_n ) end_ARG start_ARG italic_n end_ARG â‰¤ 2 italic_s }. From the above observation, it follows that gâ¢(Î£âˆ)âŠ†â„±2â¢sâ€²ğ‘”superscriptÎ£subscriptsuperscriptâ„±â€²2ğ‘ g(\Sigma^{\infty})\subseteq\mathcal{F}^{\prime}_{2s}italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ) âŠ† caligraphic_F start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 2 italic_s end_POSTSUBSCRIPT. For any Xâˆˆâ„±2â¢sâ€²ğ‘‹subscriptsuperscriptâ„±â€²2ğ‘ X\in\mathcal{F}^{\prime}_{2s}italic_X âˆˆ caligraphic_F start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 2 italic_s end_POSTSUBSCRIPT, ğ’¦polystrâ¢(X)=inftâˆˆpâ¢oâ¢lâ¢ylim supnâ†’âˆKtâ¢(Xâ†¾n)nâ‰¤2â¢s.subscriptsuperscriptğ’¦strpolyğ‘‹subscriptinfimumğ‘¡ğ‘ğ‘œğ‘™ğ‘¦subscriptlimit-supremumâ†’ğ‘›subscriptğ¾ğ‘¡â†¾ğ‘‹ğ‘›ğ‘›2ğ‘ \displaystyle\mathcal{K}^{\mathrm{str}}_{{\mathrm{poly}}}(X)=\inf_{t\in poly}% \limsup_{n\rightarrow\infty}\frac{K_{t}(X\upharpoonright n)}{n}\leq 2s.caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT ( italic_X ) = roman_inf start_POSTSUBSCRIPT italic_t âˆˆ italic_p italic_o italic_l italic_y end_POSTSUBSCRIPT lim sup start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT divide start_ARG italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_X â†¾ italic_n ) end_ARG start_ARG italic_n end_ARG â‰¤ 2 italic_s . We argue that there does exist any sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT satisfying 2â¢s<sâ€²<12ğ‘ superscriptğ‘ â€²12s<s^{\prime}<12 italic_s < italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT < 1 and 2sâ€²âˆˆâ„šsuperscript2superscriptğ‘ â€²â„š2^{s^{\prime}}\in\mathbb{Q}2 start_POSTSUPERSCRIPT italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT âˆˆ blackboard_Q such that cdimPâ¢(X)<sâ€²subscriptcdimPğ‘‹superscriptğ‘ â€²{\mathrm{cdim}}_{\mathrm{P}}({X})<s^{\prime}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT ( italic_X ) < italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT for every Xâˆˆgâ¢(Î£âˆ)ğ‘‹ğ‘”superscriptÎ£X\in g(\Sigma^{\infty})italic_X âˆˆ italic_g ( roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT ). This is accomplished using similar arguments as in the proof of Theorem 6 and Theorem 7. Since sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT need not be below half, the distinguisher algorithm checks the same condition in the proof of Theorem 7. Now, Theorem 8 follows from the observation that by taking mğ‘šmitalic_m large enough and choosing an appropriate sâ€²superscriptğ‘ â€²s^{\prime}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, the quantity sâ€²âˆ’2â¢s=sâ€²âˆ’2âˆ’mâˆ’1superscriptğ‘ â€²2ğ‘ superscriptğ‘ â€²superscript2ğ‘š1s^{\prime}-2s=s^{\prime}-2^{-{m-1}}italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT - 2 italic_s = italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT - 2 start_POSTSUPERSCRIPT - italic_m - 1 end_POSTSUPERSCRIPT can be made arbitrarily close to 1111. 1.7 Open Problems Our results highlight several potential directions for future research. It is open whether weaker hardness assumptions like Pâ‰ NPPNP{\mathrm{P}}\neq{\mathrm{NP}}roman_P â‰  roman_NP, DistNPâŠˆAvgPnot-subset-of-or-equalsDistNPAvgP\mathrm{DistNP}\not\subseteq\mathrm{AvgP}roman_DistNP âŠˆ roman_AvgP and DistNPâŠˆAvgBPPnot-subset-of-or-equalsDistNPAvgBPP\mathrm{DistNP}\not\subseteq\mathrm{AvgBPP}roman_DistNP âŠˆ roman_AvgBPP imply the separation of polynomial time dimension defined using time bounded sğ‘ sitalic_s-gales and time bounded Kolmogorov complexity in appropriate settings. The relationship between time bounded symmetry of information, coding theorems and the existence of one-way functions were investigated in several works [LW92, LM93, HIL+23, GKLO22]. The relationships between time bounded dimension relative dimension or mutual dimension [CL18, Stu22, LL18] and existence of cryptographic primitives like one-way functions also remain unexplored. 1.8 Organization of the article The rest of the paper is organized as follows. In section 2, we introduce the basic notation and definitions. In section 3, we give the formal construction of the mapping g:Î£âˆâ†’Î£âˆ:ğ‘”â†’superscriptÎ£superscriptÎ£g:\Sigma^{\infty}\to\Sigma^{\infty}italic_g : roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT â†’ roman_Î£ start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT outlined in the introduction. In section 4, we give a proof of Theorem 5 which proves that if one-way functions exist then there exists subsets of the Cantor space such that ğ’¦poly<cdimPsubscriptğ’¦polysubscriptcdimP\mathcal{K}_{{\mathrm{poly}}}<{\mathrm{cdim}}_{\mathrm{P}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT < roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT. In section 5, we give a proof of Theorem 6 which proves that if one-way functions exist then there exists sequences in the Cantor space such that ğ’¦poly<cdimPsubscriptğ’¦polysubscriptcdimP\mathcal{K}_{{\mathrm{poly}}}<{\mathrm{cdim}}_{\mathrm{P}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT < roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT. In section 6, we prove Theorems 11 and 7 thereby establishing optimal gaps between ğ’¦polysubscriptğ’¦poly\mathcal{K}_{{\mathrm{poly}}}caligraphic_K start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT and cdimPsubscriptcdimP{\mathrm{cdim}}_{\mathrm{P}}roman_cdim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT for sets and sequences. In section 7 we establish the non-equivalence of ğ’¦polystrsubscriptsuperscriptğ’¦strpoly\mathcal{K}^{\mathrm{str}}_{{\mathrm{poly}}}caligraphic_K start_POSTSUPERSCRIPT roman_str end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_poly end_POSTSUBSCRIPT and cDimPsubscriptcDimP{{\mathrm{cDim}}}_{\mathrm{P}}roman_cDim start_POSTSUBSCRIPT roman_P end_POSTSUBSCRIPT. In section 8 we give the proofs of certain technical lemmas used in proving the main results."
https://arxiv.org/html/2411.02251v1,Parks: A Doubly Infinite Family of NP-Complete Puzzles and Generalizations of A002464,"The Parks Puzzle is a paper-and-pencil puzzle game that is classically played on a square grid with different colored regions (the parks). The player needs to place a certain number of â€œtreesâ€ in each row, column, and park such that none are adjacent, even diagonally. We define a doubly-infinite family of such puzzles, the (c,r)ğ‘ğ‘Ÿ(c,r)( italic_c , italic_r )-tree Parks puzzles, where there need be cğ‘citalic_c trees per column and rğ‘Ÿritalic_r per row. We then prove that for each cğ‘citalic_c and rğ‘Ÿritalic_r the set of (c,r)ğ‘ğ‘Ÿ(c,r)( italic_c , italic_r )-tree puzzles is NP-complete. For each cğ‘citalic_c and rğ‘Ÿritalic_r, there is a sequence of possible board sizes mÃ—nğ‘šğ‘›m\times nitalic_m Ã— italic_n, and the number of possible puzzle solutions for these board sizes is a doubly-infinite generalization of OEIS sequence A002464, which itself describes the case c=r=1ğ‘ğ‘Ÿ1c=r=1italic_c = italic_r = 1. This connects the Parks puzzle to chess-based puzzle problems, as the sequence describes the number of ways to place non-attacking kings on a chessboard so that there is exactly one in each column and row (i.e. to place non-attacking dragon kings in shogi). These findings add yet another puzzle to the set of chess puzzles and expands the list of known NP-complete problems described.","The P versus NP problem is a major open problem in computer science, and one of the seven Millennium Problems posed by the Clay Mathematical Institute in the year 2000, with a $1,000,000 prize for a solution. As of this writing, only one of the seven Millennium Problems has been solved [1, 2, 3]. Despite decades of research into computational complexity, the current state of the theoretical understanding leaves much to be desired. For a detailed exposition on the P vs. NP problem itself, as well as its place in computer science research, see [4, 5, 6]. The problem of determining the complexity class of a computational problem is an important aspect of the study of complexity classes, of which P and NP have taken center stage due to the practical outcomes associated with their study. The study of the P and NP complexity classes is a very mature field. The study of puzzles in NP is also quite mature, with several decades worth of work related to identifying NP-complete puzzles, developing strategies for proving reductions, and advancing algorithmic techniques to create practical solvers for these puzzles [7, 8]. A large number of common puzzles such as Minesweeper [9], Sudoku [10], Kakuro [11] and Yosenabe [12] have been proven NP-complete. A relatively large number of lesser known puzzles have also been shown to be NP-complete, such as Light Up, Numberlink, and KPlumber [13]. In 2012, Andrea Sabbatini released a cell phone app called â€œ100 Logic Games - Time Killersâ€ that contains 100 different types of puzzles, most of which have been proven to be NP-complete already: Tents [14], Nurikabe [15], Skyscrapers [16], Battleships [17], Hitori, and Kakuro just to name a few; see [7] for a list of many such and more. Yet the authors are not aware of a rigorous proof of the NP-completeness of the Parks puzzle, at least not in its full generality (the senior thesis of the third author contains a proof in a particular case [18]). The Parks Puzzle is a logic puzzle akin to Sudoku that has not to our knowledge been rigorously shown to be NP-complete, at least not in its full generalization. This puzzle challenges players to determine the placement of a certain number of trees in a grid, adhering to simple rules: place exactly cğ‘citalic_c trees in each column, exactly rğ‘Ÿritalic_r in each row, and exactly rğ‘Ÿritalic_r in each park, making sure no two trees are adjacent, not even diagonally (see Figures 1, 2, 3, and 4; the â€œparksâ€ are recognized by their own distinct colors). This puzzle is growing in popularity via several mobile apps made by Andrea Sabbatini [19, 20, 21, 22], yet the analysis of its difficulty and fascinating underlying combinatorics remains unstudied. We start by defining the Parks puzzles and giving a few examples in Section II. Notice that in so doing we are presenting a more general version of the puzzle than those in the aforementioned apps111The mobile apps listed above generalize the puzzle a bit less, with (t,t)ğ‘¡ğ‘¡(t,t)( italic_t , italic_t )-tree puzzles where we must place tğ‘¡titalic_t trees in each column, row, and park.. This generalization presents new possibilities for creating interesting puzzles, and has wider mathematical and computer science implications. Then we review a bit of background on the P vs. NP Millennium Prize Problem and the 3-SAT logic problem; for a thorough understanding of the first problem, we refer the reader to [4] or [5]. Next, we prove Parks is in NP (Section IV), present a proof of the NP-completeness of the (1,1)11(1,1)( 1 , 1 )-tree puzzle in Section V, and finally a proof of the NP-completeness of the general (c,r)ğ‘ğ‘Ÿ(c,r)( italic_c , italic_r )-tree puzzle in Section VI. The proofs of Sections V and VI are reductions from 3-SAT. This shows that while the puzzle is easy to describe and every puzzle in the aforementioned mobile apps is solvable without the need for guessing, since there is a unique solution (as claimed in the apps), there is probably222This is assuming Pâ‰ Nâ¢Pğ‘ƒğ‘ğ‘ƒP\neq NPitalic_P â‰  italic_N italic_P. no algorithm possible for a classical computer that would solve an arbitrary-sized puzzle without essentially some amount of brute-force guessing. Next, we dive into the combinatorics underlying the puzzle, namely the number of puzzles of a given size and the number of possible solutions, primarily focusing on the latter. It turns out that the smallest size (c,r)ğ‘ğ‘Ÿ(c,r)( italic_c , italic_r )-tree puzzle is 4â¢cÃ—4â¢r4ğ‘4ğ‘Ÿ4c\times 4r4 italic_c Ã— 4 italic_r (Theorem 3), and there are exactly 2 tree configurations possible for that size. Thus, for the construction of non-trivial puzzles it would seem prudent to choose larger puzzles. For any pair of cğ‘citalic_c and rğ‘Ÿritalic_r there is a sequence of relevant board sizes and the number of (c,r)ğ‘ğ‘Ÿ(c,r)( italic_c , italic_r )-tree configurations for these board sizes could be a new OEIS sequence, except for the case of c=r=1ğ‘ğ‘Ÿ1c=r=1italic_c = italic_r = 1, which is OEIS sequence A002464 and counts the number of tree arrangements for the basic (1,1)11(1,1)( 1 , 1 )-tree puzzle. Thus we relate the ever-developing study of complexity theory to combinatorics in a new way and open the door to interesting combinatorial questions related to a doubly-infinite family of NP-complete puzzles."
https://arxiv.org/html/2411.01630v1,"Optimal Inapproximability of Promise Equationsover Finite Groupsâ€ â€ thanks:This work was supported by UKRI EP/X024431/1. For the purpose of Open Access, the authors have applied a CC BY public copyright licence to any Author Accepted Manuscript version arising from this submission. All data is provided in full in the results section of this paper.","A celebrated result of HÃ¥stad established that, for any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, it is NP-hard to find an assignment satisfying a (1/|ğ’¢|+Îµ)1ğ’¢ğœ€(1/|\mathscr{G}|+\varepsilon)( 1 / | script_G | + italic_Îµ )-fraction of the constraints of a given 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance over an Abelian group ğ’¢ğ’¢\mathscr{G}script_G even if one is promised that an assignment satisfying a (1âˆ’Îµ)1ğœ€(1-\varepsilon)( 1 - italic_Îµ )-fraction of the constraints exists. Engebretsen, Holmerin, and Russell showed the same result for 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instances over any finite (not necessarily Abelian) group. In other words, for almost-satisfiable instances of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN the random assignment achieves an optimal approximation guarantee. We prove that the random assignment algorithm is still best possible under a stronger promise that the 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance is almost satisfiable over an arbitrarily more restrictive group.","The PCP theorem [AS98, ALM+98, Din07] is one of the jewels of computational complexity and theoretical computer science more broadly [AB09]. One of its equivalent statements is as follows: The maximum number of simultaneously satisfiable constraints of a Constraint Satisfaction Problem, or CSP for short, is NP-hard to approximate within some constant factor. That is, while NP-hardness of CSPs means that it is NP-hard to distinguish instances that are satisfiable from those that are unsatisfiable, the PCP theorem shows that there is an absolute constant Î±<1ğ›¼1\alpha<1italic_Î± < 1 such that it is NP-hard to distinguish satisfiable CSP instances from those in which strictly fewer than an Î±ğ›¼\alphaitalic_Î±-fraction of the constraints can be simultaneously satisfied. Thus it is NP-hard to find an assignment that satisfies an Î±ğ›¼\alphaitalic_Î±-fraction of the constraints even if one is promised that a satisfying assignment exists. For some CSPs, as we shall see shortly, the optimal value of Î±ğ›¼\alphaitalic_Î± is known. A classic example of a CSP is 3-SAT, the satisfiability problem of CNF-formulas in which each clause contains 3 literals. The random assignment gives a method to find an assignment that satisfies a 7/8787/87 / 8-fraction of the clauses. HÃ¥stad famously showed that this is optimal in the following sense: For any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, it is NP-hard to find an assignment satisfying a (7/8+Îµ)78ğœ€(7/8+\varepsilon)( 7 / 8 + italic_Îµ )-fraction of the clauses of a 3-SAT instance even if one is promised that a satisfying assignment exists [HÃ¥s01]. Another classic CSP is 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN, the problem of solving linear equations in 3 variables over the Boolean domain {0,1}01\{0,1\}{ 0 , 1 }. If all equations can be satisfied simultaneously then a satisfying assignment can be found in polynomial time by Gaussian elimination. What can be done if no satisfying assignment exists? As for 3-SAT, the random assignment gives a method to find a somewhat satisfying assignment, namely one that satisfies a 1/2121/21 / 2-fraction of the constraints. As it turns out, this is best possible even for instances of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN that are almost satisfiable. In detail, HÃ¥stad showed that for any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, it is NP-hard to find an assignment satisfying a (1/2+Îµ)12ğœ€(1/2+\varepsilon)( 1 / 2 + italic_Îµ )-fraction of the constraints of a 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance even if one is promised that an assignment satisfying a (1âˆ’Îµ)1ğœ€(1-\varepsilon)( 1 - italic_Îµ )-fraction of the constraints exists. In fact, HÃ¥stad established optimal inapproximability results for 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over any finite Abelian group, not just {0,1}01\{0,1\}{ 0 , 1 }. This result was later extended by Engebretsen, Holmerin, and Russell to all finite groups [EHR04]. Since these foundational works, Guruswami and Raghavendra [GR09] showed NP-hardness of finding a barely satisfying assignment for a 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance over the reals (and thus also over the integers) even if a nearly satisfying assignment is promised to exist over the integers. The same result was later established for 2âˆ’LIN2LIN\operatorname{2-LIN}2 - roman_LIN for large enough cyclic groups [OWZ15]. Khot and Moshkovitz [KM13] studied inapproximability of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over the reals. In this work, we strengthen the optimal inapproximability results for 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over finite groups by establishing NP-hardness of beating the random assignment threshold even if the instance is almost satisfiable in an arbitrarily more restrictive setting. Formally, this is captured by fixing (not one but) two groups and a homomorphism between them, following the framework of promise CSPs [AGH17, BBKO21]. In detail, (decision) promise CSPs [BBKO21] can be seen as a qualitative form of approximation: Each constraint comes in two forms, a strong one and a weak one. The promise is that there is a solution satisfying all constraints in the strong form while the (potentially easier) goal is to find a solution satisfying all constraints in the weak form. An example of a strong vs. weak constraint on the same, say Boolean, domain is 1111-in-3333 vs NAE, where the former is {(0,0,1),(0,1,0),(1,0,0)}001010100\{(0,0,1),(0,1,0),(1,0,0)\}{ ( 0 , 0 , 1 ) , ( 0 , 1 , 0 ) , ( 1 , 0 , 0 ) } and the latter is {(0,0,1),(0,1,0),(1,0,0),(1,1,0),(1,0,1),(0,1,1)}001010100110101011\{(0,0,1),(0,1,0),(1,0,0),(1,1,0),(1,0,1),(0,1,1)\}{ ( 0 , 0 , 1 ) , ( 0 , 1 , 0 ) , ( 1 , 0 , 0 ) , ( 1 , 1 , 0 ) , ( 1 , 0 , 1 ) , ( 0 , 1 , 1 ) }. NAE is weaker as the relation contains more tuples. While these two constraint relations capture the well-known NP-hard problems of 1-in-3-SAT and Not-All-Equal-SAT respectively [Sch78], finding an NAE-assignment turns out to be doable in polynomial time under the promise that a 1-in-3-assignment exists [BG21]! For constraints on different domains, the notion of strong vs. weak constraint is captured by a homomorphism between the (sets of all) constraint relations; in the example above, the homomorphism is just the identity function. The exact solvability of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN in the promise setting was resolved in [LÅ½24]. Recent work of Barto et al. [BBK+24] considered (quantitative) approximation of promise CSPs. In the context of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN, here are two simple examples captured by this framework. First, let ğ’¢ğ’¢\mathscr{G}script_G be a group and â„‹â„‹\mathscr{H}script_H be a subgroup of ğ’¢ğ’¢\mathscr{G}script_G. Given an almost-satisfiable system over the subgroup â„‹â„‹\mathscr{H}script_H, maximise the number of satisfied equations over ğ’¢ğ’¢\mathscr{G}script_G. Our results imply that beating the random assignment over â„‹â„‹\mathscr{H}script_H is NP-hard. In the second example, consider a group ğ’¢ğ’¢\mathscr{G}script_G, a normal subgroup â„‹â„‹\mathscr{H}script_H, and an almost-satisfiable system over ğ’¢ğ’¢\mathscr{G}script_G. The goal this time is to maximise the number of satisfied equations in the system over the quotient ğ’¢/â„‹ğ’¢â„‹\mathscr{G}/\mathscr{H}script_G / script_H. Our results show that doing better than the random assignment over ğ’¢/â„‹ğ’¢â„‹\mathscr{G}/\mathscr{H}script_G / script_H is NP-hard. More generally, going beyond subgroups and quotients of a given group, we fix two groups ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and a group homomorphism Ï†ğœ‘\varphiitalic_Ï† from a subgroup â„‹1subscriptâ„‹1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT of ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to a subgroup â„‹2subscriptâ„‹2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT with the property that Ï†ğœ‘\varphiitalic_Ï† extend to a group homomorphism from ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Given an almost-satisfiable system of equations over ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT with constants in â„‹1subscriptâ„‹1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, the goal is to maximise the number of satisfied equations over ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT where the constants are interpreted in â„‹2subscriptâ„‹2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT via Ï†ğœ‘\varphiitalic_Ï†. Our main result establishes that doing better than the random assignment over â„‹2subscriptâ„‹2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is NP-hard, cf. Theorem 1.3. Thus we give an optimal inapproximability result for a natural and fundamental fragment of promise CSPs, systems of linear equations. The general approach for establishing inapproximability of systems of equations, going back to [HÃ¥s01, EHR04], can be seen as a reduction from another CSP that is hard to approximate. In this reduction, one initially transforms an instance of the original CSP to a system of equations of the form xâ¢yâ¢z=1ğ‘¥ğ‘¦ğ‘§1xyz=1italic_x italic_y italic_z = 1. To guarantee the soundness of this reduction, one needs to show that any assignment that beats the random assignment in the target system of equations can be transformed into a â€œgoodâ€ assignment of the original instance. To do this it is necessary to rule out vacuous assignments (e.g., the assignment that sends all variables to the group identity) through a procedure called folding, which introduces constants in the system of equations. Afterwards, the soundness bounds are shown by performing Fourier analysis on certain functions derived from the system. Our proof follows this general approach. The main obstacle to applying the techniques of [EHR04] directly is the fact that in our setting the constants lie in a proper subgroup of the ambient group, which precludes us from applying classical folding over groups. Instead, we use a weaker notion of folding. This, however, implies that in the soundness analysis we have to take care of functions whose Fourier expansion has non-zero value for the trivial term. To tackle this issue, we consider the behaviour of irreducible group representations when they are restricted to the subgroup of constants via Frobenius Reciprocity. Before formal description of our results, we mention other related work. First, extending the work from [HÃ¥s01], Austrin, Brown-Cohen, and HÃ¥stad established optimal inapproximability of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over Abelian groups with a universal factor graph [ABCH23]. Similarly, Bhangale and Stankovic established optimal inapproximability of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over non-Abelian groups with a universal factor graph [BS23]. Second, unlike over Abelian groups, for 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over non-Abelian groups finding a satisfying assignment is NP-hard even under the promise that one exists. There is a folklore randomised algorithm for satisfiable 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instances over non-Abelian groups (whose approximation factor depends on the group ğ’¢ğ’¢\mathscr{G}script_G and is 1/|ğ’¢|1ğ’¢1/|\mathscr{G}|1 / | script_G | if ğ’¢ğ’¢\mathscr{G}script_G is a so-called perfect group but can beat the naive random assignment for non-perfect groups). Bhangale and Khot showed that this algorithm is optimal [BK21]. Third, going beyond 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN, building on a long line of work Chan established optimal (up to a constant factor) NP-hardness for CSPs [Cha16]. There are other works on various inapproximability notions for CSPs, e.g., [AH13, KTW14a, KTW14b]. Finally, we mention that Khotâ€™s influential Unique Games Conjecture [Kho02] postulates, in one of its equivalent forms, NP-hardness of finding a barely satisfying solution to a 2âˆ’LIN2LIN\operatorname{2-LIN}2 - roman_LIN instance given that an almost-satisfying assignment exists (for a large enough domain size). 1.1 Preliminaries and notation We use âŸ¦â‹…âŸ§delimited-âŸ¦âŸ§â‹…\llbracket\cdot\rrbracketâŸ¦ â‹… âŸ§ to denote the Iverson bracket; i.e., âŸ¦PâŸ§delimited-âŸ¦âŸ§ğ‘ƒ\llbracket P\rrbracketâŸ¦ italic_P âŸ§ is 1 if Pğ‘ƒPitalic_P is true and 00 otherwise. As usual, [n]delimited-[]ğ‘›[n][ italic_n ] denotes the set {1,2,â€¦,n}12â€¦ğ‘›\{1,2,\ldots,n\}{ 1 , 2 , â€¦ , italic_n }. We consider matrices whose sets of indices are arbitrary finite sets. Given two finite sets Nğ‘Nitalic_N and Mğ‘€Mitalic_M, an NÃ—Mğ‘ğ‘€N\times Mitalic_N Ã— italic_M complex matrix Ağ´Aitalic_A consists of a family of complex numbers Ai,jsubscriptğ´ğ‘–ğ‘—A_{i,j}italic_A start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT indexed by pairs iâˆˆNğ‘–ğ‘i\in Nitalic_i âˆˆ italic_N, jâˆˆMğ‘—ğ‘€j\in Mitalic_j âˆˆ italic_M. Algebraic notions such as matrix product, trace, and transpose are defined in the natural way. Given an N1Ã—N2subscriptğ‘1subscriptğ‘2N_{1}\times N_{2}italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT complex matrix Ağ´Aitalic_A, and an M1Ã—M2subscriptğ‘€1subscriptğ‘€2M_{1}\times M_{2}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT complex matrix BğµBitalic_B, the tensor product AâŠ—Btensor-productğ´ğµA\otimes Bitalic_A âŠ— italic_B is an (N1Ã—M1)Ã—(N2Ã—M2)subscriptğ‘1subscriptğ‘€1subscriptğ‘2subscriptğ‘€2(N_{1}\times M_{1})\times(N_{2}\times M_{2})( italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) Ã— ( italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT Ã— italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) matrix, where (AâŠ—B)(i,s)â¢(j,t)=Ai,jâ¢Bs,tsubscripttensor-productğ´ğµğ‘–ğ‘ ğ‘—ğ‘¡subscriptğ´ğ‘–ğ‘—subscriptğµğ‘ ğ‘¡(A\otimes B)_{(i,s)(j,t)}=A_{i,j}B_{s,t}( italic_A âŠ— italic_B ) start_POSTSUBSCRIPT ( italic_i , italic_s ) ( italic_j , italic_t ) end_POSTSUBSCRIPT = italic_A start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT italic_B start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT for each iâˆˆN1,jâˆˆN2,sâˆˆM1,tâˆˆM2formulae-sequenceğ‘–subscriptğ‘1formulae-sequenceğ‘—subscriptğ‘2formulae-sequenceğ‘ subscriptğ‘€1ğ‘¡subscriptğ‘€2i\in N_{1},j\in N_{2},s\in M_{1},t\in M_{2}italic_i âˆˆ italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_j âˆˆ italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_s âˆˆ italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t âˆˆ italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. The group of invertible NÃ—Nğ‘ğ‘N\times Nitalic_N Ã— italic_N complex matrices (equipped with matrix multiplication and matrix inversion) is denoted by GLâ¢(N)GLğ‘\mathrm{GL}(N)roman_GL ( italic_N ), and the set of NÃ—Mğ‘ğ‘€N\times Mitalic_N Ã— italic_M complex matrices is denoted by â„‚NÃ—Msuperscriptâ„‚ğ‘ğ‘€\mathbb{C}^{N\times M}blackboard_C start_POSTSUPERSCRIPT italic_N Ã— italic_M end_POSTSUPERSCRIPT. A subset â„‹âŠ†ğ’¢â„‹ğ’¢\mathscr{H}\subseteq\mathscr{G}script_H âŠ† script_G of a group ğ’¢ğ’¢\mathscr{G}script_G is called a subgroup of ğ’¢ğ’¢\mathscr{G}script_G, denoted by â„‹â‰¤ğ’¢â„‹ğ’¢\mathscr{H}\leq\mathscr{G}script_H â‰¤ script_G, if â„‹â„‹\mathscr{H}script_H equipped with the group operation of ğ’¢ğ’¢\mathscr{G}script_G forms a group. Given a group ğ’¢ğ’¢\mathscr{G}script_G, a subgroup â„‹â„‹\mathscr{H}script_H of ğ’¢ğ’¢\mathscr{G}script_G, and an element gâˆˆğ’¢ğ‘”ğ’¢g\in\mathscr{G}italic_g âˆˆ script_G, the right coset of â„‹â„‹\mathscr{H}script_H in ğ’¢ğ’¢\mathscr{G}script_G by gğ‘”gitalic_g is the set â„‹â¢g:={hâ¢gâˆ£hâˆˆâ„‹}assignâ„‹ğ‘”conditional-setâ„ğ‘”â„â„‹\mathscr{H}g:=\{hg\mid h\in\mathscr{H}\}script_H italic_g := { italic_h italic_g âˆ£ italic_h âˆˆ script_H }. The set of right cosets of â„‹â„‹\mathscr{H}script_H in ğ’¢ğ’¢\mathscr{G}script_G is denoted by â„‹\ğ’¢\â„‹ğ’¢\mathscr{H}\backslash\mathscr{G}script_H \ script_G. Let Nğ‘Nitalic_N be a finite set. The Nthsuperscriptğ‘thN^{\text{th}}italic_N start_POSTSUPERSCRIPT th end_POSTSUPERSCRIPT direct power of ğ’¢ğ’¢\mathscr{G}script_G, denoted by ğ’¢Nsuperscriptğ’¢ğ‘\mathscr{G}^{N}script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT, is the group whose elements are Nğ‘Nitalic_N-tuples ğ âˆˆğ’¢Nğ superscriptğ’¢ğ‘\mathbf{g}\in\mathscr{G}^{N}bold_g âˆˆ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT of elements from ğ’¢ğ’¢\mathscr{G}script_G, and where the group operation is taken component-wise, i.e., ğ â‹…ğ¡â¢(n)=ğ â¢(n)â‹…ğ¡â¢(n)â‹…ğ ğ¡ğ‘›â‹…ğ ğ‘›ğ¡ğ‘›\mathbf{g}\cdot\mathbf{h}(n)=\mathbf{g}(n)\cdot\mathbf{h}(n)bold_g â‹… bold_h ( italic_n ) = bold_g ( italic_n ) â‹… bold_h ( italic_n ) for each nâˆˆNğ‘›ğ‘n\in Nitalic_n âˆˆ italic_N. If â„‹â‰¤ğ’¢â„‹ğ’¢\mathscr{H}\leq\mathscr{G}script_H â‰¤ script_G, we define (hâ‹…ğ )â¢(n)=hâ‹…ğ â¢(n)â‹…â„ğ ğ‘›â‹…â„ğ ğ‘›(h\cdot\mathbf{g})(n)=h\cdot\mathbf{g}(n)( italic_h â‹… bold_g ) ( italic_n ) = italic_h â‹… bold_g ( italic_n ) for each hâˆˆâ„‹â„â„‹h\in\mathscr{H}italic_h âˆˆ script_H and ğ âˆˆğ’¢Nğ superscriptğ’¢ğ‘\mathbf{g}\in\mathscr{G}^{N}bold_g âˆˆ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. With this notation, the notion of coset extends to include the right cosets of â„‹â„‹\mathscr{H}script_H in ğ’¢Nsuperscriptğ’¢ğ‘\mathscr{G}^{N}script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT in a natural way. A homomorphism from a group ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to a group ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is a map Ï†:ğ’¢1â†’ğ’¢2:ğœ‘â†’subscriptğ’¢1subscriptğ’¢2\varphi:\mathscr{G}_{1}\to\mathscr{G}_{2}italic_Ï† : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT which satisfies that Ï†â¢(gâ‹…h)=Ï†â¢(g)â‹…Ï†â¢(h)ğœ‘â‹…ğ‘”â„â‹…ğœ‘ğ‘”ğœ‘â„\varphi(g\cdot h)=\varphi(g)\cdot\varphi(h)italic_Ï† ( italic_g â‹… italic_h ) = italic_Ï† ( italic_g ) â‹… italic_Ï† ( italic_h ) for every g,hâˆˆğ’¢1ğ‘”â„subscriptğ’¢1g,h\in\mathscr{G}_{1}italic_g , italic_h âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. The domain and image of Ï†ğœ‘\varphiitalic_Ï† are denoted Domâ¢(Ï†)Domğœ‘\textnormal{Dom}(\varphi)Dom ( italic_Ï† ) and Imâ¢(Ï†)Imğœ‘\textnormal{Im}(\varphi)Im ( italic_Ï† ) respectively. Let Nğ‘Nitalic_N be a finite set, ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT groups, iâˆˆ[2]ğ‘–delimited-[]2i\in[2]italic_i âˆˆ [ 2 ], â„‹iâ‰¤ğ’¢isubscriptâ„‹ğ‘–subscriptğ’¢ğ‘–\mathscr{H}_{i}\leq\mathscr{G}_{i}script_H start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‰¤ script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, and Ï†:â„‹1â†’â„‹2:ğœ‘â†’subscriptâ„‹1subscriptâ„‹2\varphi:\mathscr{H}_{1}\to\mathscr{H}_{2}italic_Ï† : script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â†’ script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT be a homomorphism. We say that a function f:ğ’¢1Nâ†’ğ’¢2:ğ‘“â†’superscriptsubscriptğ’¢1ğ‘subscriptğ’¢2f:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is folded over Ï†ğœ‘\varphiitalic_Ï† if fâ¢(hâ¢ğ )=Ï†â¢(h)â¢fâ¢(ğ )ğ‘“â„ğ ğœ‘â„ğ‘“ğ f(h\mathbf{g})=\varphi(h)f(\mathbf{g})italic_f ( italic_h bold_g ) = italic_Ï† ( italic_h ) italic_f ( bold_g ) for all hâˆˆâ„‹1â„subscriptâ„‹1h\in\mathscr{H}_{1}italic_h âˆˆ script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and ğ âˆˆğ’¢1Nğ superscriptsubscriptğ’¢1ğ‘\mathbf{g}\in\mathscr{G}_{1}^{N}bold_g âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. Given an arbitrary function f:ğ’¢1Nâ†’ğ’¢2:ğ‘“â†’superscriptsubscriptğ’¢1ğ‘subscriptğ’¢2f:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and a homomorphism between subgroups, there is a natural way to construct a folded function that resembles fğ‘“fitalic_f. Fix an arbitrary representative from each right coset of â„‹1subscriptâ„‹1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT in ğ’¢1Nsuperscriptsubscriptğ’¢1ğ‘\mathscr{G}_{1}^{N}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. For each ğ âˆˆğ’¢Nğ superscriptğ’¢ğ‘\mathbf{g}\in\mathscr{G}^{N}bold_g âˆˆ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT, denote by ğ â€ superscriptğ â€ \mathbf{g}^{\dagger}bold_g start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT the representative of â„‹1â¢ğ subscriptâ„‹1ğ \mathscr{H}_{1}\mathbf{g}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT bold_g, and let hğ âˆˆâ„‹1subscriptâ„ğ subscriptâ„‹1h_{\mathbf{g}}\in\mathscr{H}_{1}italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT âˆˆ script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT be such that ğ â€ =hğ â¢ğ superscriptğ â€ subscriptâ„ğ ğ \mathbf{g}^{\dagger}=h_{\mathbf{g}}\mathbf{g}bold_g start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT = italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT bold_g. Then the folding of fğ‘“fitalic_f over Ï†ğœ‘\varphiitalic_Ï† (with respect to this choice of representatives) is the map fÏ†:ğ’¢1Nâ†’ğ’¢2:subscriptğ‘“ğœ‘â†’superscriptsubscriptğ’¢1ğ‘subscriptğ’¢2f_{\varphi}:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT given by fÏ†â¢(ğ )=Ï†â¢(hğ âˆ’1)â¢fâ¢(ğ â€ )subscriptğ‘“ğœ‘ğ ğœ‘superscriptsubscriptâ„ğ 1ğ‘“superscriptğ â€ f_{\varphi}(\mathbf{g})=\varphi(h_{\mathbf{g}}^{-1})f(\mathbf{g}^{\dagger})italic_f start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_g ) = italic_Ï† ( italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) italic_f ( bold_g start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT ). Fix a pair of disjoint finite sets Dğ·Ditalic_D, Eğ¸Eitalic_E, called the label sets, and a subset Î âŠ†EDÎ superscriptğ¸ğ·\Pi\subseteq E^{D}roman_Î  âŠ† italic_E start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT of labeling functions. An instance of the Label Cover problem is a bipartite graph with vertex set UâŠ”Vsquare-unionğ‘ˆğ‘‰U\sqcup Vitalic_U âŠ” italic_V and a labeling function Ï€uâ¢vâˆˆÎ subscriptğœ‹ğ‘¢ğ‘£Î \pi_{uv}\in\Piitalic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT âˆˆ roman_Î  for each edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v } in the graph. The task is to decide whether there is a pair of assignments hD:Uâ†’D:subscriptâ„ğ·â†’ğ‘ˆğ·h_{D}:U\to Ditalic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT : italic_U â†’ italic_D, hE:Vâ†’E:subscriptâ„ğ¸â†’ğ‘‰ğ¸h_{E}:V\to Eitalic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT : italic_V â†’ italic_E that satisfies all the constraints, i.e., such that Ï€uâ¢vâ¢(hDâ¢(u))=hEâ¢(v)subscriptğœ‹ğ‘¢ğ‘£subscriptâ„ğ·ğ‘¢subscriptâ„ğ¸ğ‘£\pi_{uv}(h_{D}(u))=h_{E}(v)italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_u ) ) = italic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT ( italic_v ) for each edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v }. Given additionally a pair of rational constants 0<sâ‰¤câ‰¤10ğ‘ ğ‘10<s\leq c\leq 10 < italic_s â‰¤ italic_c â‰¤ 1, the gap version of this problem, known as the Gap Label Cover problem with completeness cğ‘citalic_c and soundness sğ‘ sitalic_s and denoted GLCD,Eâ¢(c,s)subscriptGLCğ·ğ¸ğ‘ğ‘ \mathrm{GLC}_{D,E}(c,s)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( italic_c , italic_s ), is the problem of distinguishing instances where a cğ‘citalic_c-fraction of the constraints can be satisfied from instances where not even an sğ‘ sitalic_s-fraction of the constraints can be satisfied. The hardness of Gap Label Cover with perfect completeness stated below is a consequence of the PCP theorem [ALM+98, AS98] and the Parallel Repetition Theorem [Raz98]. Theorem 1.1. For every Î±>0ğ›¼0\alpha>0italic_Î± > 0 there exist finite sets Dğ·Ditalic_D, Eğ¸Eitalic_E such that GLCD,Eâ¢(1,Î±)subscriptGLCğ·ğ¸1ğ›¼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_Î± ) is NP-hard. Fourier Analysis We follow closely [Ter99] for our main definitions and preliminary results. A representation of a group ğ’¢ğ’¢\mathscr{G}script_G is a group homomorphism Î³:ğ’¢â†’GLâ¢(NÎ³):ğ›¾â†’ğ’¢GLsubscriptğ‘ğ›¾\gamma:\mathscr{G}\to\mathrm{GL}(N_{\gamma})italic_Î³ : script_G â†’ roman_GL ( italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT ) for some finite set NÎ³subscriptğ‘ğ›¾N_{\gamma}italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT. We call |NÎ³|subscriptğ‘ğ›¾|N_{\gamma}|| italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT | the dimension of Î³ğ›¾\gammaitalic_Î³ and write dimÎ³=|NÎ³|subscriptdimensionğ›¾subscriptğ‘ğ›¾\dim_{\gamma}=|N_{\gamma}|roman_dim start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT = | italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT |. Given a pair of indices i,jâˆˆNÎ³2ğ‘–ğ‘—superscriptsubscriptğ‘ğ›¾2i,j\in N_{\gamma}^{2}italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, Î³i,jsubscriptğ›¾ğ‘–ğ‘—\gamma_{i,j}italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT denotes the (i,j)ğ‘–ğ‘—(i,j)( italic_i , italic_j )-th entry of Î³ğ›¾\gammaitalic_Î³. The character of a representation Î³ğ›¾\gammaitalic_Î³, denoted by Ï‡Î³subscriptğœ’ğ›¾\chi_{\gamma}italic_Ï‡ start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT, is its trace. The trivial representation, denoted 1111, maps all group elements to the number one (i.e., the one-dimensional identity matrix). A representation Î³ğ›¾\gammaitalic_Î³ is said to be unitary if its image contains only unitary matrices. We say that two representations Î±ğ›¼\alphaitalic_Î± and Î²ğ›½\betaitalic_Î² of some group ğ’¢ğ’¢\mathscr{G}script_G are equivalent, written Î±â‰ƒÎ²similar-to-or-equalsğ›¼ğ›½\alpha\simeq\betaitalic_Î± â‰ƒ italic_Î², if there is an invertible NÎ²Ã—NÎ±subscriptğ‘ğ›½subscriptğ‘ğ›¼N_{\beta}\times N_{\alpha}italic_N start_POSTSUBSCRIPT italic_Î² end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT complex matrix Tğ‘‡Titalic_T such that Î±â¢(g)=Tâˆ’1â¢Î²â¢(g)â¢Tğ›¼ğ‘”superscriptğ‘‡1ğ›½ğ‘”ğ‘‡\alpha(g)=T^{-1}\beta(g)Titalic_Î± ( italic_g ) = italic_T start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_Î² ( italic_g ) italic_T for all gâˆˆğ’¢ğ‘”ğ’¢g\in\mathscr{G}italic_g âˆˆ script_G. In particular, dimÎ±=dimÎ²subscriptdimensionğ›¼subscriptdimensionğ›½\dim_{\alpha}=\dim_{\beta}roman_dim start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT = roman_dim start_POSTSUBSCRIPT italic_Î² end_POSTSUBSCRIPT. Similarly, the representation Î²ğ›½\betaitalic_Î² is said to be a sub-representation of Î±ğ›¼\alphaitalic_Î± if there is an invertible matrix Tğ‘‡Titalic_T, such that Tâˆ’1â¢Î±â¢(g)â¢Tsuperscriptğ‘‡1ğ›¼ğ‘”ğ‘‡T^{-1}\alpha(g)Titalic_T start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_Î± ( italic_g ) italic_T can be written as (Î²â¢(g)âˆ—0âˆ—)matrixğ›½ğ‘”0\begin{pmatrix}\beta(g)&*\\ 0&*\end{pmatrix}( start_ARG start_ROW start_CELL italic_Î² ( italic_g ) end_CELL start_CELL âˆ— end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL âˆ— end_CELL end_ROW end_ARG ) for all gâˆˆğ’¢ğ‘”ğ’¢g\in\mathscr{G}italic_g âˆˆ script_G. The representation Î²ğ›½\betaitalic_Î² is said to be irreducible if all its sub-representations are equivalent to itself. If Î²ğ›½\betaitalic_Î² is irreducible, its multiplicity in Î±ğ›¼\alphaitalic_Î± is the non-negative integer nğ‘›nitalic_n satisfying that Î±ğ›¼\alphaitalic_Î± is equivalent to a block diagonal representation with two diagonal blocks Î±1,Î±2subscriptğ›¼1subscriptğ›¼2\alpha_{1},\alpha_{2}italic_Î± start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Î± start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, where (1) Î±1subscriptğ›¼1\alpha_{1}italic_Î± start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT is another block-diagonal representation consisting of nğ‘›nitalic_n diagonal blocks equal to Î²ğ›½\betaitalic_Î², and (2) Î±2subscriptğ›¼2\alpha_{2}italic_Î± start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT does not have Î²ğ›½\betaitalic_Î² as a sub-representation. Given a group ğ’¢ğ’¢\mathscr{G}script_G, we use ğ’¢^^ğ’¢\widehat{\mathscr{G}}over^ start_ARG script_G end_ARG to denote some arbitrary and fixed complete set of inequivalent irreducible unitary representations of ğ’¢ğ’¢\mathscr{G}script_G; such a set exists by, e.g., [Ter99, Proposition 1]. The space â„’2â¢(ğ’¢)superscriptâ„’2ğ’¢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ) is the vector space of complex-valued functions over ğ’¢ğ’¢\mathscr{G}script_G, equipped with the following inner product:111Note the additional normalising factor of 1|ğ’¢|1ğ’¢\frac{1}{|\mathscr{G}|}divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG compared to [Ter99]. âŸ¨F,HâŸ©=1|ğ’¢|â¢âˆ‘gâˆˆğ’¢Fâ¢(g)â¢Hâ¢(g)Â¯.ğ¹ğ»1ğ’¢subscriptğ‘”ğ’¢ğ¹ğ‘”Â¯ğ»ğ‘”\langle F,H\rangle=\frac{1}{|\mathscr{G}|}\sum_{g\in\mathscr{G}}F(g)\overline{% H(g)}.âŸ¨ italic_F , italic_H âŸ© = divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG âˆ‘ start_POSTSUBSCRIPT italic_g âˆˆ script_G end_POSTSUBSCRIPT italic_F ( italic_g ) overÂ¯ start_ARG italic_H ( italic_g ) end_ARG . Let ğ’¢ğ’¢\mathscr{G}script_G be a group, and let F:ğ’¢â†’â„‚:ğ¹â†’ğ’¢â„‚F:\mathscr{G}\rightarrow\mathbb{C}italic_F : script_G â†’ blackboard_C be a complex-valued function. Given Î³âˆˆğ’¢^ğ›¾^ğ’¢\gamma\in\widehat{\mathscr{G}}italic_Î³ âˆˆ over^ start_ARG script_G end_ARG and i,jâˆˆNÎ³ğ‘–ğ‘—subscriptğ‘ğ›¾i,j\in N_{\gamma}italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT, the Fourier coefficient F^â¢(Î³i,j)^ğ¹subscriptğ›¾ğ‘–ğ‘—\widehat{F}(\gamma_{i,j})over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) is defined as the product âŸ¨F,Î³i,jâŸ©ğ¹subscriptğ›¾ğ‘–ğ‘—\langle F,\gamma_{i,j}\rangleâŸ¨ italic_F , italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT âŸ©. The matrix entries of the representations Î³âˆˆğ’¢^ğ›¾^ğ’¢\gamma\in\widehat{\mathscr{G}}italic_Î³ âˆˆ over^ start_ARG script_G end_ARG form an orthogonal basis of â„’2â¢(ğ’¢)superscriptâ„’2ğ’¢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), and allow us to perform Fourier analysis on this space, as stated in the following theorem [Ter99, Theorem 2]. Theorem 1.2. Let ğ’¢ğ’¢\mathscr{G}script_G be a finite group. Then the set {Î³i,jâˆ£Î³âˆˆğ’¢^,i,jâˆˆNÎ³}conditional-setsubscriptğ›¾ğ‘–ğ‘—formulae-sequenceğ›¾^ğ’¢ğ‘–ğ‘—subscriptğ‘ğ›¾\{\gamma_{i,j}\mid\gamma\in\widehat{\mathscr{G}},\ i,j\in N_{\gamma}\}{ italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT âˆ£ italic_Î³ âˆˆ over^ start_ARG script_G end_ARG , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT } is an orthogonal basis of â„’2â¢(ğ’¢)superscriptâ„’2ğ’¢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), and dimÎ³âˆ¥Î³i,jâˆ¥2=1subscriptdimensionğ›¾superscriptdelimited-âˆ¥âˆ¥subscriptğ›¾ğ‘–ğ‘—21\dim_{\gamma}\lVert\gamma_{i,j}\rVert^{2}=1roman_dim start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT âˆ¥ italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = 1 for all Î³i,jsubscriptğ›¾ğ‘–ğ‘—\gamma_{i,j}italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT. Moreover, the following hold: 1. Plancherelâ€™s Theorem: Given Fâˆˆâ„’2â¢(ğ’¢)ğ¹superscriptâ„’2ğ’¢F\in\mathcal{L}^{2}(\mathscr{G})italic_F âˆˆ caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), âˆ¥Fâˆ¥2=âˆ‘Î³âˆˆğ’¢^,i,jâˆˆNÎ³dimÎ³|F^â¢(Î³i,j)|2.superscriptdelimited-âˆ¥âˆ¥ğ¹2subscriptformulae-sequenceğ›¾^ğ’¢ğ‘–ğ‘—subscriptğ‘ğ›¾subscriptdimensionğ›¾superscript^ğ¹subscriptğ›¾ğ‘–ğ‘—2\lVert F\rVert^{2}=\sum_{\gamma\in\widehat{\mathscr{G}},i,j\in N_{\gamma}}\dim% _{\gamma}|\widehat{F}(\gamma_{i,j})|^{2}.âˆ¥ italic_F âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = âˆ‘ start_POSTSUBSCRIPT italic_Î³ âˆˆ over^ start_ARG script_G end_ARG , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT | over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . 2. Fourier Inversion: Given Fâˆˆâ„’2â¢(ğ’¢)ğ¹superscriptâ„’2ğ’¢F\in\mathcal{L}^{2}(\mathscr{G})italic_F âˆˆ caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), Fâ¢(g)=âˆ‘Î³âˆˆğ’¢^,i,jâˆˆNÎ³dimÎ³F^â¢(Î³i,j)â¢Î³i,jâ¢(g) for all â¢gâˆˆğ’¢.formulae-sequenceğ¹ğ‘”subscriptformulae-sequenceğ›¾^ğ’¢ğ‘–ğ‘—subscriptğ‘ğ›¾subscriptdimensionğ›¾^ğ¹subscriptğ›¾ğ‘–ğ‘—subscriptğ›¾ğ‘–ğ‘—ğ‘” for all ğ‘”ğ’¢F(g)=\sum_{\gamma\in\widehat{\mathscr{G}},i,j\in N_{\gamma}}\dim_{\gamma}% \widehat{F}(\gamma_{i,j})\gamma_{i,j}(g)\qquad\text{ for all }g\in\mathscr{G}.italic_F ( italic_g ) = âˆ‘ start_POSTSUBSCRIPT italic_Î³ âˆˆ over^ start_ARG script_G end_ARG , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( italic_g ) for all italic_g âˆˆ script_G . We also consider Fourier transforms of matrix-valued functions F:ğ’¢â†’â„‚NFÃ—NF:ğ¹â†’ğ’¢superscriptâ„‚subscriptğ‘ğ¹subscriptğ‘ğ¹F:\mathscr{G}\rightarrow\mathbb{C}^{N_{F}\times N_{F}}italic_F : script_G â†’ blackboard_C start_POSTSUPERSCRIPT italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT end_POSTSUPERSCRIPT. Given Î³âˆˆğ’¢^ğ›¾^ğ’¢\gamma\in\widehat{\mathscr{G}}italic_Î³ âˆˆ over^ start_ARG script_G end_ARG and indices i,jâˆˆNÎ³ğ‘–ğ‘—subscriptğ‘ğ›¾i,j\in N_{\gamma}italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT, we define the NFÃ—NFsubscriptğ‘ğ¹subscriptğ‘ğ¹N_{F}\times N_{F}italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT matrix F^â¢(Î³i,j)^ğ¹subscriptğ›¾ğ‘–ğ‘—\widehat{F}(\gamma_{i,j})over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) as the one whose (s,t)ğ‘ ğ‘¡(s,t)( italic_s , italic_t )-th entry is Fs,t^â¢(Î³i,j)^subscriptğ¹ğ‘ ğ‘¡subscriptğ›¾ğ‘–ğ‘—\widehat{F_{s,t}}(\gamma_{i,j})over^ start_ARG italic_F start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) for each s,tâˆˆNFğ‘ ğ‘¡subscriptğ‘ğ¹s,t\in N_{F}italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT. In other words, F^â¢(Î³i,j)=1|ğ’¢|â¢âˆ‘gâˆˆğ’¢Fâ¢(g)â¢Î³i,jâ¢(g)Â¯.^ğ¹subscriptğ›¾ğ‘–ğ‘—1ğ’¢subscriptğ‘”ğ’¢ğ¹ğ‘”Â¯subscriptğ›¾ğ‘–ğ‘—ğ‘”\widehat{F}(\gamma_{i,j})=\frac{1}{|\mathscr{G}|}\sum_{g\in\mathscr{G}}F(g)% \overline{\gamma_{i,j}(g)}.over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) = divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG âˆ‘ start_POSTSUBSCRIPT italic_g âˆˆ script_G end_POSTSUBSCRIPT italic_F ( italic_g ) overÂ¯ start_ARG italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( italic_g ) end_ARG . Let Nğ‘Nitalic_N be a finite set. Given a pair of functions function F,H:ğ’¢â†’â„‚NÃ—N:ğ¹ğ»â†’ğ’¢superscriptâ„‚ğ‘ğ‘F,H:\mathscr{G}\to\mathbb{C}^{N\times N}italic_F , italic_H : script_G â†’ blackboard_C start_POSTSUPERSCRIPT italic_N Ã— italic_N end_POSTSUPERSCRIPT, we define their convolution Fâˆ—Hğ¹ğ»F*Hitalic_F âˆ— italic_H by (Fâˆ—H)â¢(g):=1|ğ’¢|â¢âˆ‘hâˆˆğ’¢Fâ¢(h)â¢Hâ¢(hâˆ’1â¢g).assignğ¹ğ»ğ‘”1ğ’¢subscriptâ„ğ’¢ğ¹â„ğ»superscriptâ„1ğ‘”(F*H)(g):=\frac{1}{|\mathscr{G}|}\sum_{h\in\mathscr{G}}F(h)H(h^{-1}g).( italic_F âˆ— italic_H ) ( italic_g ) := divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG âˆ‘ start_POSTSUBSCRIPT italic_h âˆˆ script_G end_POSTSUBSCRIPT italic_F ( italic_h ) italic_H ( italic_h start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_g ) . We will also need to perform Fourier analysis over powers of the form ğ’¢Dsuperscriptğ’¢ğ·\mathscr{G}^{D}script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT for a given group ğ’¢ğ’¢\mathscr{G}script_G and finite set Dğ·Ditalic_D. It is possible to identify ğ’¢D^^superscriptğ’¢ğ·\widehat{\mathscr{G}^{D}}over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG with (ğ’¢^)Dsuperscript^ğ’¢ğ·(\widehat{\mathscr{G}})^{D}( over^ start_ARG script_G end_ARG ) start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT [Ter99]. This way, an element Ïâˆˆğ’¢D^ğœŒ^superscriptğ’¢ğ·\rho\in\widehat{\mathscr{G}^{D}}italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG is given by a tuple (Ïd)dâˆˆDsubscriptsuperscriptğœŒğ‘‘ğ‘‘ğ·(\rho^{d})_{d\in D}( italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ) start_POSTSUBSCRIPT italic_d âˆˆ italic_D end_POSTSUBSCRIPT where Ïdâˆˆğ’¢^superscriptğœŒğ‘‘^ğ’¢\rho^{d}\in\widehat{\mathscr{G}}italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT âˆˆ over^ start_ARG script_G end_ARG for each dâˆˆDğ‘‘ğ·d\in Ditalic_d âˆˆ italic_D in such a way that Ïâ¢(ğ )=â¨‚dâˆˆDÏdâ¢(ğ â¢(d))ğœŒğ subscripttensor-productğ‘‘ğ·superscriptğœŒğ‘‘ğ ğ‘‘\rho(\mathbf{g})=\bigotimes_{d\in D}\rho^{d}(\mathbf{g}(d))italic_Ï ( bold_g ) = â¨‚ start_POSTSUBSCRIPT italic_d âˆˆ italic_D end_POSTSUBSCRIPT italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ( bold_g ( italic_d ) ) for all ğ âˆˆğ’¢Dğ superscriptğ’¢ğ·\mathbf{g}\in\mathscr{G}^{D}bold_g âˆˆ script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT. Observe we use superscripts for the â€œcomponentsâ€ of the representation ÏğœŒ\rhoitalic_Ï on the power group ğ’¢Dsuperscriptğ’¢ğ·\mathscr{G}^{D}script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT, rather than subscripts, which we utilise to denote matrix entries. The degree of ÏğœŒ\rhoitalic_Ï, written |Ï|ğœŒ|\rho|| italic_Ï |, is the number of indices dâˆˆDğ‘‘ğ·d\in Ditalic_d âˆˆ italic_D for which ÏdsuperscriptğœŒğ‘‘\rho^{d}italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT is non-trivial.222This quantity is called â€œweightâ€ in [EHR04, BS23]. 1.2 Results Let ğ’¢1,ğ’¢2subscriptğ’¢1subscriptğ’¢2\mathscr{G}_{1},\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT be two groups and Ï†ğœ‘\varphiitalic_Ï† a group homomorphism with domain Domâ¢(Ï†)â‰¤ğ’¢1Domğœ‘subscriptğ’¢1\textnormal{Dom}(\varphi)\leq\mathscr{G}_{1}Dom ( italic_Ï† ) â‰¤ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and image Imâ¢(Ï†)â‰¤ğ’¢2Imğœ‘subscriptğ’¢2\textnormal{Im}(\varphi)\leq\mathscr{G}_{2}Im ( italic_Ï† ) â‰¤ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT that extends to a full homomorphism from ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. We shall refer to triples (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) of this kind as templates. Further, let 0<sâ‰¤câ‰¤10ğ‘ ğ‘10<s\leq c\leq 10 < italic_s â‰¤ italic_c â‰¤ 1 be rational constants. We consider the problem 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) which asks, given a weighted system of linear equations with exactly three variables in each equation and constants in Domâ¢(Ï†)Domğœ‘\textnormal{Dom}(\varphi)Dom ( italic_Ï† ) that is cğ‘citalic_c-satisfiable in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, to decide whether there exists an sğ‘ sitalic_s-approximation in ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, where the constants are interpreted through Ï†ğœ‘\varphiitalic_Ï†. To be more precise, an instance to 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) over a set of variables Xğ‘‹Xitalic_X is a weighted systems of linear equations where each equation is of the form xiâ¢yjâ¢zk=gsuperscriptğ‘¥ğ‘–superscriptğ‘¦ğ‘—superscriptğ‘§ğ‘˜ğ‘”x^{i}y^{j}z^{k}=gitalic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_y start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_z start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g for some x,y,zâˆˆXğ‘¥ğ‘¦ğ‘§ğ‘‹x,y,z\in Xitalic_x , italic_y , italic_z âˆˆ italic_X, gâˆˆDomâ¢(Ï†)ğ‘”Domğœ‘g\in\textnormal{Dom}(\varphi)italic_g âˆˆ Dom ( italic_Ï† ), i,j,kâˆˆ{âˆ’1,1}ğ‘–ğ‘—ğ‘˜11i,j,k\in\{-1,1\}italic_i , italic_j , italic_k âˆˆ { - 1 , 1 }, and each equation has a non-negative rational weight. Without loss of generality, we assume that the weights are normalised, i.e., sum up to 1. For tâˆˆ[2]ğ‘¡delimited-[]2t\in[2]italic_t âˆˆ [ 2 ], an assignment f:Xâ†’ğ’¢t:ğ‘“â†’ğ‘‹subscriptğ’¢ğ‘¡f:X\to\mathscr{G}_{t}italic_f : italic_X â†’ script_G start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT satisfies an equation xiâ¢yjâ¢zk=gsuperscriptğ‘¥ğ‘–superscriptğ‘¦ğ‘—superscriptğ‘§ğ‘˜ğ‘”x^{i}y^{j}z^{k}=gitalic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_y start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_z start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g in ğ’¢tsubscriptğ’¢ğ‘¡\mathscr{G}_{t}script_G start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT if fâ¢(x)iâ¢fâ¢(y)jâ¢fâ¢(z)k=gğ‘“superscriptğ‘¥ğ‘–ğ‘“superscriptğ‘¦ğ‘—ğ‘“superscriptğ‘§ğ‘˜ğ‘”f(x)^{i}f(y)^{j}f(z)^{k}=gitalic_f ( italic_x ) start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_f ( italic_y ) start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_f ( italic_z ) start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g for t=1ğ‘¡1t=1italic_t = 1, and fâ¢(x)iâ¢fâ¢(y)jâ¢fâ¢(z)k=Ï†â¢(g)ğ‘“superscriptğ‘¥ğ‘–ğ‘“superscriptğ‘¦ğ‘—ğ‘“superscriptğ‘§ğ‘˜ğœ‘ğ‘”f(x)^{i}f(y)^{j}f(z)^{k}=\varphi(g)italic_f ( italic_x ) start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_f ( italic_y ) start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_f ( italic_z ) start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_Ï† ( italic_g ) for t=2ğ‘¡2t=2italic_t = 2. The task then is to accept if there is an assignment that satisfies a cğ‘citalic_c-fraction (i.e., a fraction of total weight cğ‘citalic_c) of equations in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, and to reject if there is no assignment that satisfies an sğ‘ sitalic_s-fraction of the equations in ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. It is easy to verify that, if (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) is a template and sâ‰¤cğ‘ ğ‘s\leq citalic_s â‰¤ italic_c, then the sets of accept and reject instances are, in fact, disjoint.3333âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN can be alternatively phrased as a promise constraint satisfaction problem, cf. Section 4 for details. 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) is trivially tractable when Imâ¢(Ï†)={1}Imğœ‘1\textnormal{Im}(\varphi)=\{1\}Im ( italic_Ï† ) = { 1 }, so we focus on the case where |Imâ¢(Ï†)|â‰¥2Imğœ‘2|\textnormal{Im}(\varphi)|\geq 2| Im ( italic_Ï† ) | â‰¥ 2. The main result of this paper is that 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,1âˆ’Ïµ,1/|Imâ¢(Ï†)|+Î´)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘1italic-Ïµ1Imğœ‘ğ›¿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , 1 - italic_Ïµ , 1 / | Im ( italic_Ï† ) | + italic_Î´ ) in NP-hard for all Ïµ,Î´>0italic-Ïµğ›¿0\epsilon,\delta>0italic_Ïµ , italic_Î´ > 0 for which the problem is well-defined. This is achieved by a reduction from the Gap Label Cover problem with perfect completeness and soundness Î±=Î´2/(4â¢Îºâ¢|ğ’¢1|Îºâ¢|ğ’¢2|4)ğ›¼superscriptğ›¿24ğœ…superscriptsubscriptğ’¢1ğœ…superscriptsubscriptğ’¢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_Î± = italic_Î´ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_Îº | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_Îº end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ), where Îº=âŒˆ(log2â¡Î´âˆ’2)/(log2â¡(1âˆ’Ïµ))âŒ‰ğœ…subscript2ğ›¿2subscript21italic-Ïµ\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon))\rceilitalic_Îº = âŒˆ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_Î´ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_Ïµ ) ) âŒ‰. Theorem 1.3 (Main). Let Ïµ,Î´italic-Ïµğ›¿\epsilon,\deltaitalic_Ïµ , italic_Î´ be positive constants satisfying 1âˆ’Ïµâ‰¥1/|Imâ¢(Ï†)|+Î´1italic-Ïµ1Imğœ‘ğ›¿1-\epsilon\geq 1/|\textnormal{Im}(\varphi)|+\delta1 - italic_Ïµ â‰¥ 1 / | Im ( italic_Ï† ) | + italic_Î´. Then, 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,1âˆ’Ïµ,1/|Imâ¢(Ï†)|+Î´)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘1italic-Ïµ1Imğœ‘ğ›¿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , 1 - italic_Ïµ , 1 / | Im ( italic_Ï† ) | + italic_Î´ ) is NP-hard. The hardness result in Theorem 1.3 is tight for many, but perhaps surprisingly not all, templates. We call a template (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) cubic if for every hâˆˆImâ¢(Ï†)â„Imğœ‘h\in\textnormal{Im}(\varphi)italic_h âˆˆ Im ( italic_Ï† ) there is an element gâˆˆğ’¢2ğ‘”subscriptğ’¢2g\in\mathscr{G}_{2}italic_g âˆˆ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT satisfying g3=hsuperscriptğ‘”3â„g^{3}=hitalic_g start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT = italic_h. Theorem 1.3 is tight for cubic templates. Indeed, for these templates, the random assignment over Imâ¢(Ï†)Imğœ‘\textnormal{Im}(\varphi)Im ( italic_Ï† ) achieves a 1/|Imâ¢(Ï†)|1Imğœ‘1/|\textnormal{Im}(\varphi)|1 / | Im ( italic_Ï† ) | expected fraction of satisfied equations (and this can be derandomised, e.g., by the method of conditional expectations). Theorem 1.4. Let (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) be a cubic template and 0<sâ‰¤c<10ğ‘ ğ‘10<s\leq c<10 < italic_s â‰¤ italic_c < 1. Then, 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) is tractable if sâ‰¤1/|Imâ¢(Ï†)|ğ‘ 1Imğœ‘s\leq 1/|\textnormal{Im}(\varphi)|italic_s â‰¤ 1 / | Im ( italic_Ï† ) | and NP-hard otherwise. Let us now turn to non-cubic templates. An equation is unsatisfiable if it is of the form x3=hsuperscriptğ‘¥3â„x^{3}=hitalic_x start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT = italic_h or xâˆ’3=hsuperscriptğ‘¥3â„x^{-3}=hitalic_x start_POSTSUPERSCRIPT - 3 end_POSTSUPERSCRIPT = italic_h for some hâˆˆDomâ¢(Ï†)â„Domğœ‘h\in\textnormal{Dom}(\varphi)italic_h âˆˆ Dom ( italic_Ï† ) such that g3â‰ Ï†â¢(h)superscriptğ‘”3ğœ‘â„g^{3}\neq\varphi(h)italic_g start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT â‰  italic_Ï† ( italic_h ) for all gâˆˆğ’¢2ğ‘”subscriptğ’¢2g\in\mathscr{G}_{2}italic_g âˆˆ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Note that a template has unsatisfiable equations if and only if it is non-cubic. Note that the naive random assignment cannot achieve a positive approximation factor in systems of equations over non-cubic templates since the system could consist exclusively of unsatisfiable equations. However, there is a simple algorithm for 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,c/|Imâ¢(Ï†)|)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘Imğœ‘\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,c/|\textnormal{% Im}(\varphi)|)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_c / | Im ( italic_Ï† ) | ) that works even for non-cubic templates, which we describe next. Given a weighted system of equations over (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ), consider its set of unsatisfiable equations. Since Ï†ğœ‘\varphiitalic_Ï† extends to a full homomorphism, if the total weight of the set of unsatisfiable equations is more than 1âˆ’c1ğ‘1-c1 - italic_c, then the instance cannot be cğ‘citalic_c-satisfiable in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, hence, reject. Otherwise, the random assignment over Imâ¢(Ï†)Imğœ‘\textnormal{Im}(\varphi)Im ( italic_Ï† ) satisfies at least a 1/|Imâ¢(Ï†)|1Imğœ‘1/|\textnormal{Im}(\varphi)|1 / | Im ( italic_Ï† ) |-fraction of the satisfiable equations over ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, which is at least a c/|Imâ¢(Ï†)|ğ‘Imğœ‘c/|\textnormal{Im}(\varphi)|italic_c / | Im ( italic_Ï† ) |-fraction of the entire system. It is a simple corollary of Theorem 1.3 that this algorithm is optimal for non-cubic groups, leading to the following result. Details are deferred to Appendix A. Theorem 1.5. Let (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) be a non-cubic template and 0<sâ‰¤c<10ğ‘ ğ‘10<s\leq c<10 < italic_s â‰¤ italic_c < 1. Then, 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) is tractable if s/câ‰¤1/|Imâ¢(Ï†)|ğ‘ ğ‘1Imğœ‘s/c\leq 1/|\textnormal{Im}(\varphi)|italic_s / italic_c â‰¤ 1 / | Im ( italic_Ï† ) | and NP-hard otherwise. The structure of the paper is as follows. The rest of this section gives a sketch of the main proof: In Section 1.3 we present the reduction from Gap Label Cover to 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,1âˆ’Ïµ,1/|Imâ¢(Ï†)|+Î´)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘1italic-Ïµ1Imğœ‘ğ›¿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , 1 - italic_Ïµ , 1 / | Im ( italic_Ï† ) | + italic_Î´ ), and in Section 1.4 we give an overview of the techniques used in the analysis of this reduction and of the main challenges that arise in extending previous work to the promise setting. The rest of the paper then gives all technical details. In Section 2 we set the notation and present the necessary technical background on Fourier analysis over non-Abelian groups. Section 3 is dedicated to the proof of the main result, with the completeness analysis in Section 3.1 and the soundness analysis in Section 3.2. Finally, in Section 4 we relate our results to a recent theory of Barto et al. [BBK+24], who developed a systematic approach to study (in)approximability of promise CSPs, which includes approximability of promise linear equations, from the viewpoint of universal algebra. In particular, we show that the proof of Theorem 1.3 implies that the collection of symmetries444called the valued minion of plurimorphisms in [BBK+24]. of 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,1âˆ’Ïµ,1/|Imâ¢(Ï†)|+Î´)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘1italic-Ïµ1Imğœ‘ğ›¿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , 1 - italic_Ïµ , 1 / | Im ( italic_Ï† ) | + italic_Î´ ) can be mapped homomorphically to the collection of symmetries of Gap Label Cover, a condition that, based on the algebraic theory from [BBK+24], is known to guarantee NP-hardness of the former problem. 1.3 Reduction For the rest of the section we outline the proof of our main result, Theorem 1.3. From now on we fix a template (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ), and positive constants Î´,Ïµ>0ğ›¿italic-Ïµ0\delta,\epsilon>0italic_Î´ , italic_Ïµ > 0 with 1/|Imâ¢(Ï†)|+Î´â‰¤1âˆ’Ïµ1Imğœ‘ğ›¿1italic-Ïµ1/|\textnormal{Im}(\varphi)|+\delta\leq 1-\epsilon1 / | Im ( italic_Ï† ) | + italic_Î´ â‰¤ 1 - italic_Ïµ. We define â„‹1=Domâ¢(Ï†)â‰¤ğ’¢1subscriptâ„‹1Domğœ‘subscriptğ’¢1\mathscr{H}_{1}=\textnormal{Dom}(\varphi)\leq\mathscr{G}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = Dom ( italic_Ï† ) â‰¤ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and â„‹2=Imâ¢(Ï†)â‰¤ğ’¢2subscriptâ„‹2Imğœ‘subscriptğ’¢2\mathscr{H}_{2}=\textnormal{Im}(\varphi)\leq\mathscr{G}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = Im ( italic_Ï† ) â‰¤ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Our proof follows from a reduction from GLCD,Eâ¢(1,Î±)subscriptGLCğ·ğ¸1ğ›¼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_Î± ) where Î±=Î´2/(4â¢Îºâ¢|ğ’¢1|Îºâ¢|ğ’¢2|4)ğ›¼superscriptğ›¿24ğœ…superscriptsubscriptğ’¢1ğœ…superscriptsubscriptğ’¢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_Î± = italic_Î´ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_Îº | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_Îº end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ), Îº=âŒˆ(log2â¡Î´âˆ’2)/(log2â¡(1âˆ’Ïµ))âŒ‰ğœ…subscript2ğ›¿2subscript21italic-Ïµ\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon))\rceilitalic_Îº = âŒˆ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_Î´ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_Ïµ ) ) âŒ‰, and D,Eğ·ğ¸D,Eitalic_D , italic_E are chosen to be large enough so that GLCD,Eâ¢(1,Î±)subscriptGLCğ·ğ¸1ğ›¼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_Î± ) is NP-hard by the PCP theorem [ALM+98, AS98, Raz98] (cf. Theorem 1.1). This reduction constructs an instance Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT of 3âˆ’LIN(ğ’¢1,ğ’¢2,\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , Ï†,1âˆ’Ïµ,1/|â„‹2|+Î´)\varphi,1-\epsilon,1/|\mathscr{H}_{2}|+\delta)italic_Ï† , 1 - italic_Ïµ , 1 / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | + italic_Î´ ) for any given instance Î£Î£\Sigmaroman_Î£ of Gap Label Cover as described below. Let UâŠ”Vsquare-unionğ‘ˆğ‘‰U\sqcup Vitalic_U âŠ” italic_V be the underlying vertex set of Î£Î£\Sigmaroman_Î£, D,Eğ·ğ¸D,Eitalic_D , italic_E be the disjoint sets of labels, and Ï€uâ¢vsubscriptğœ‹ğ‘¢ğ‘£\pi_{uv}italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT be the labeling functions. We fix representatives from each right coset in â„‹1\ğ’¢1D\subscriptâ„‹1superscriptsubscriptğ’¢1ğ·\mathscr{H}_{1}\backslash\mathscr{G}_{1}^{D}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT \ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT and â„‹1\ğ’¢1E\subscriptâ„‹1superscriptsubscriptğ’¢1ğ¸\mathscr{H}_{1}\backslash\mathscr{G}_{1}^{E}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT \ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT. Given a tuple ğ±ğ±{\mathbf{x}}bold_x in either ğ’¢1Dsuperscriptsubscriptğ’¢1ğ·\mathscr{G}_{1}^{D}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT or ğ’¢1Esuperscriptsubscriptğ’¢1ğ¸\mathscr{G}_{1}^{E}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT we write ğ±â€ superscriptğ±â€ \mathbf{x}^{\dagger}bold_x start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT for the representative of the coset â„‹1â¢ğ±subscriptâ„‹1ğ±\mathscr{H}_{1}\mathbf{x}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT bold_x. Let X={uğ›|uâˆˆU,ğ›âˆˆğ’¢1D}âŠ”{vğš|vâˆˆV,ğšâˆˆğ’¢1E}ğ‘‹square-unionconditional-setsubscriptğ‘¢ğ›formulae-sequenceğ‘¢ğ‘ˆğ›superscriptsubscriptğ’¢1ğ·conditional-setsubscriptğ‘£ğšformulae-sequenceğ‘£ğ‘‰ğšsuperscriptsubscriptğ’¢1ğ¸X=\{u_{\mathbf{b}}\,|u\in U,{\mathbf{b}}\in\mathscr{G}_{1}^{D}\}\sqcup\{v_{% \mathbf{a}}\,|v\in V,{\mathbf{a}}\in\mathscr{G}_{1}^{E}\}italic_X = { italic_u start_POSTSUBSCRIPT bold_b end_POSTSUBSCRIPT | italic_u âˆˆ italic_U , bold_b âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT } âŠ” { italic_v start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT | italic_v âˆˆ italic_V , bold_a âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT }. Then Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT is the weighted system of equations over Xğ‘‹Xitalic_X that contains the equation vğšâ€ â¢uğ›s1s1â¢uğœs2s2=gğšsubscriptğ‘£superscriptğšâ€ superscriptsubscriptğ‘¢superscriptğ›subscriptğ‘ 1subscriptğ‘ 1superscriptsubscriptğ‘¢superscriptğœsubscriptğ‘ 2subscriptğ‘ 2subscriptğ‘”ğšv_{{\mathbf{a}}^{\dagger}}u_{{\mathbf{b}}^{s_{1}}}^{s_{1}}u_{{\mathbf{c}}^{s_{% 2}}}^{s_{2}}=g_{{\mathbf{a}}}italic_v start_POSTSUBSCRIPT bold_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT italic_u start_POSTSUBSCRIPT bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_u start_POSTSUBSCRIPT bold_c start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT (1) for each edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v } of Î£Î£\Sigmaroman_Î£, ğšâˆˆğ’¢1Eğšsuperscriptsubscriptğ’¢1ğ¸{\mathbf{a}}\in\mathscr{G}_{1}^{E}bold_a âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT, ğ›âˆˆğ’¢1Dğ›superscriptsubscriptğ’¢1ğ·{\mathbf{b}}\in\mathscr{G}_{1}^{D}bold_b âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT, s1,s2âˆˆ{âˆ’1,1}subscriptğ‘ 1subscriptğ‘ 211s_{1},s_{2}\in\{-1,1\}italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âˆˆ { - 1 , 1 }, where ğœğœ{\mathbf{c}}bold_c stands for ğ›âˆ’1â¢(ğšâˆ˜Ï€uâ¢v)âˆ’1â¢ğ‚superscriptğ›1superscriptğšsubscriptğœ‹ğ‘¢ğ‘£1ğ‚{\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu}bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ and ğ‚âˆˆğ’¢1Dğ‚superscriptsubscriptğ’¢1ğ·\bm{\nu}\in\mathscr{G}_{1}^{D}bold_italic_Î½ âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT is a small perturbation factor. The element gğšsubscriptğ‘”ğšg_{\mathbf{a}}italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT is chosen so that ğšâ€ =gğšâ¢ğšsuperscriptğšâ€ subscriptğ‘”ğšğš{\mathbf{a}}^{\dagger}=g_{\mathbf{a}}{\mathbf{a}}bold_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT bold_a. The weight of this equation in Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT is the joint probability of the independent events described in Figure 1. (1)The edge {u,v} is chosen uniformly at random among all edges of Î£.(2)The elements ğš and ğ› are chosen uniformly at random from ğ’¢1E and ğ’¢1D respectively.(3)The element ğ‚âˆˆğ’¢1D is chosen so that for each dâˆˆD, independently, ğ‚â¢(d)=1ğ’¢1 withprobability 1âˆ’Ïµ, and ğ‚â¢(d) is selected uniformly at random from ğ’¢1 with probability Ïµ.(4)The signs s1,s2 are chosen uniformly at random from {âˆ’1,1}.(1)The edge {u,v} is chosen uniformly at random among all edges of Î£.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(2)The elements ğš and ğ› are chosen uniformly at random from ğ’¢1E and ğ’¢1D respectively.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(3)The element ğ‚âˆˆğ’¢1D is chosen so that for each dâˆˆD, independently, ğ‚â¢(d)=1ğ’¢1 withmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionprobability 1âˆ’Ïµ, and ğ‚â¢(d) is selected uniformly at random from ğ’¢1 with probability Ïµ.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(4)The signs s1,s2 are chosen uniformly at random from {âˆ’1,1}.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression\displaystyle\boxed{\begin{array}[]{llllll}\mbox{($1$)}&\text{The edge $\{u,v\}$ is chosen uniformly at random among all edges of $\Sigma$.}\\[5% .0pt] \mbox{($2$)}&\text{The elements ${\mathbf{a}}$ and ${\mathbf{b}}$ are chosen % uniformly at random from $\mathscr{G}_{1}^{E}$ and $\mathscr{G}_{1}^{D}$ % respectively.}\\[5.0pt] \mbox{($3$)}&\text{The element $\bm{\nu}\in\mathscr{G}_{1}^{D}$ is chosen so % that for each $d\in D$, independently, $\bm{\nu}(d)=1_{\mathscr{G}_{1}}$ with}\\ &\text{probability $1-\epsilon$, and $\bm{\nu}(d)$ is selected uniformly at % random from $\mathscr{G}_{1}$ with probability $\epsilon$.}\\[5.0pt] \mbox{($4$)}&\text{The signs $s_{1},s_{2}$ are chosen uniformly at random from $\{-1,1\}$.}\end{array}}start_ARRAY start_ROW start_CELL ( 1 ) end_CELL start_CELL The edge { italic_u , italic_v } is chosen uniformly at random among all edges of roman_Î£ . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 2 ) end_CELL start_CELL The elements bold_a and bold_b are chosen uniformly at random from script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT and script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT respectively. end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 3 ) end_CELL start_CELL The element bold_italic_Î½ âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT is chosen so that for each italic_d âˆˆ italic_D , independently, bold_italic_Î½ ( italic_d ) = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT with end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL start_CELL probability 1 - italic_Ïµ , and bold_italic_Î½ ( italic_d ) is selected uniformly at random from script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT with probability italic_Ïµ . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 4 ) end_CELL start_CELL The signs italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are chosen uniformly at random from { - 1 , 1 } . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW end_ARRAY Figure 1: The sampling procedure for Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT. Let us describe assignments of Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT over ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT for i=1,2ğ‘–12i=1,2italic_i = 1 , 2. Formally, an assignment of Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT over ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is a map h:Xâ†’ğ’¢i:â„â†’ğ‘‹subscriptğ’¢ğ‘–h:X\rightarrow\mathscr{G}_{i}italic_h : italic_X â†’ script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT. Such an assignment can be described by two families of maps A=(Av)vâˆˆVğ´subscriptsubscriptğ´ğ‘£ğ‘£ğ‘‰A=(A_{v})_{v\in V}italic_A = ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_v âˆˆ italic_V end_POSTSUBSCRIPT from ğ’¢1Esubscriptsuperscriptğ’¢ğ¸1\mathscr{G}^{E}_{1}script_G start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and B=(Bu)uâˆˆUğµsubscriptsubscriptğµğ‘¢ğ‘¢ğ‘ˆB=(B_{u})_{u\in U}italic_B = ( italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_u âˆˆ italic_U end_POSTSUBSCRIPT from ğ’¢1Dsuperscriptsubscriptğ’¢1ğ·\mathscr{G}_{1}^{D}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT to ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT by letting Avâ¢(ğš)=hâ¢(vğš)subscriptğ´ğ‘£ğšâ„subscriptğ‘£ğšA_{v}({\mathbf{a}})=h(v_{{\mathbf{a}}})italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a ) = italic_h ( italic_v start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT ) for all vâˆˆV,ğšâˆˆğ’¢1Eformulae-sequenceğ‘£ğ‘‰ğšsuperscriptsubscriptğ’¢1ğ¸v\in V,{\mathbf{a}}\in\mathscr{G}_{1}^{E}italic_v âˆˆ italic_V , bold_a âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT, and Buâ¢(ğ›)=hâ¢(uğ›)=subscriptğµğ‘¢ğ›â„subscriptğ‘¢ğ›absentB_{u}({\mathbf{b}})=h(u_{{\mathbf{b}}})=italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b ) = italic_h ( italic_u start_POSTSUBSCRIPT bold_b end_POSTSUBSCRIPT ) = for all uâˆˆU,ğ›âˆˆğ’¢1Dformulae-sequenceğ‘¢ğ‘ˆğ›superscriptsubscriptğ’¢1ğ·u\in U,{\mathbf{b}}\in\mathscr{G}_{1}^{D}italic_u âˆˆ italic_U , bold_b âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT. It will be more convenient to talk about the pair (A,B)ğ´ğµ(A,B)( italic_A , italic_B ) rather than the map hâ„hitalic_h itself, so we will write Î¦Î£ğ’¢iâ¢(A,B)subscriptsuperscriptÎ¦subscriptğ’¢ğ‘–Î£ğ´ğµ\Phi^{\mathscr{G}_{i}}_{\Sigma}(A,B)roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) to refer to the proportion of equations satisfied by the assignment hâ„hitalic_h. Let us give a more useful expression for Î¦Î£ğ’¢iâ¢(A,B)subscriptsuperscriptÎ¦subscriptğ’¢ğ‘–Î£ğ´ğµ\Phi^{\mathscr{G}_{i}}_{\Sigma}(A,B)roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ). When i=1ğ‘–1i=1italic_i = 1, we can write Î¦Î£ğ’¢1(A,B)=ğ”¼uâ¢v,ğš,ğ›,ğ‚,s1,s2[âŸ¦Av(ğšâ€ )Bu(ğ›s1)s1Bu((ğ›âˆ’1(ğšâˆ˜Ï€uâ¢v)âˆ’1ğ‚)s2)s2=gğšâŸ§],\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket A_{v}({\mathbf{a}}^{% \dagger})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{% a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=g_{{\mathbf{a}}}\rrbracket% \right],roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_Î½ , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ âŸ¦ italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT âŸ§ ] , where the expectation is taken over the probabilities described in Figure 1, and we use uâ¢vğ‘¢ğ‘£uvitalic_u italic_v as a shorthand for an edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v }. Folding the assignments Avsubscriptğ´ğ‘£A_{v}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT over the identity on â„‹1subscriptâ„‹1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and using the fact that (Av)idâ„‹1â¢(ğš)=gğšâˆ’1â¢Avâ¢(ğšâ€ )subscriptsubscriptğ´ğ‘£subscriptidsubscriptâ„‹1ğšsuperscriptsubscriptğ‘”ğš1subscriptğ´ğ‘£superscriptğšâ€ (A_{v})_{\mathrm{id}_{\mathscr{H}_{1}}}({\mathbf{a}})=g_{{\mathbf{a}}}^{-1}A_{% v}({\mathbf{a}}^{\dagger})( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( bold_a ) = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT ), we obtain Î¦Î£ğ’¢1(A,B)=ğ”¼uâ¢v,ğš,ğ›,ğ‚,s1,s2[âŸ¦(Av)idâ„‹1(ğš)Bu(ğ›s1)s1Bu((ğ›âˆ’1(ğšâˆ˜Ï€uâ¢v)âˆ’1ğ‚)s2)s2=1ğ’¢1âŸ§].\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket(A_{v})_{\mathrm{id}_{% \mathscr{H}_{1}}}({\mathbf{a}})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({% \mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=1_{% \mathscr{G}_{1}}\rrbracket\right].roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_Î½ , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ âŸ¦ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT âŸ§ ] . (2) Analogously, when i=2ğ‘–2i=2italic_i = 2 and Av,Busubscriptğ´ğ‘£subscriptğµğ‘¢A_{v},B_{u}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT , italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are families of maps to ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, we obtain a similar expression for Î¦Î£ğ’¢2â¢(A,B)subscriptsuperscriptÎ¦subscriptğ’¢2Î£ğ´ğµ\Phi^{\mathscr{G}_{2}}_{\Sigma}(A,B)roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ): Î¦Î£ğ’¢2(A,B)=ğ”¼uâ¢v,ğš,ğ›,ğ‚,s1,s2[âŸ¦(Av)Ï†(ğš)Bu(ğ›s1)s1Bu((ğ›âˆ’1(ğšâˆ˜Ï€uâ¢v)âˆ’1ğ‚)s2)s2=1ğ’¢2âŸ§].\Phi^{\mathscr{G}_{2}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket(A_{v})_{\varphi}({\mathbf{% a}})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}% \circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=1_{\mathscr{G}_{2}}\rrbracket% \right].roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_Î½ , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ âŸ¦ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT âŸ§ ] . (3) That is, a pair of assignments (A,B)ğ´ğµ(A,B)( italic_A , italic_B ) satisfies an equation in Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT if and only if the corresponding pair of assignments obtained by folding Ağ´Aitalic_A (over idâ„‹1subscriptidsubscriptâ„‹1\mathrm{id}_{\mathscr{H}_{1}}roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT and Ï†ğœ‘\varphiitalic_Ï† respectively) maps the equation to the group identity (respectively, in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT). Thus, folding allows us to focus exclusively on the identity terms in these expectations, which will be useful in the analysis of the reduction. Theorem 1.3 follows from our completeness and soundness bounds for Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT, stated in the next results, using the fact that by Theorem 1.1, there are finite sets D,Eğ·ğ¸D,Eitalic_D , italic_E such that GLCD,Eâ¢(1,Î±)subscriptGLCğ·ğ¸1ğ›¼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_Î± ) is NP-hard for the value of Î±ğ›¼\alphaitalic_Î± chosen in Theorem 1.7 below. The proofs of the completeness and soundness bounds can be found in Section 3.1 and Section 3.2 respectively. Theorem 1.6 (Completeness). Let Î£Î£\Sigmaroman_Î£ be a Gap Label Cover instance and Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT be the system defined in (1). Suppose that Î£Î£\Sigmaroman_Î£ is 1111-satisfiable. Then Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT is (1âˆ’Ïµ)1italic-Ïµ(1-\epsilon)( 1 - italic_Ïµ )-satisfiable in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. Theorem 1.7 (Soundness). Let Î£Î£\Sigmaroman_Î£ be a Gap Label Cover instance and Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT be the system defined in (1). Suppose that Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT is (1/|â„‹2|+Î´)1subscriptâ„‹2ğ›¿(1/|\mathscr{H}_{2}|+\delta)( 1 / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | + italic_Î´ )-satisfiable in ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Then Î£Î£\Sigmaroman_Î£ is Î±ğ›¼\alphaitalic_Î±-satisfiable, where Î±=Î´2/(4â¢Îºâ¢|ğ’¢1|Îºâ¢|ğ’¢2|4)ğ›¼superscriptğ›¿24ğœ…superscriptsubscriptğ’¢1ğœ…superscriptsubscriptğ’¢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_Î± = italic_Î´ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_Îº | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_Îº end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) and Îº=âŒˆ(log2Î´âˆ’2)/(log2(1âˆ’Ïµ)âŒ‰\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon)\rceilitalic_Îº = âŒˆ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_Î´ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_Ïµ ) âŒ‰. 1.4 Proof Outline The main difficulty in proving the correctness of our reduction lies in showing the soundness bound (Theorem 1.7). The completeness result (Theorem 1.6) is relatively straightforward and follows as in [EHR04]. In summary, suppose the Gap Label Cover instance Î£Î£\Sigmaroman_Î£ is satisfied by a pair of assignments hD:Uâ†’D:subscriptâ„ğ·â†’ğ‘ˆğ·h_{D}:U\rightarrow Ditalic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT : italic_U â†’ italic_D, hE:Vâ†’E:subscriptâ„ğ¸â†’ğ‘‰ğ¸h_{E}:V\rightarrow Eitalic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT : italic_V â†’ italic_E. Then we find families A,Bğ´ğµA,Bitalic_A , italic_B such that Î¦Î£ğ’¢1â¢(A,B)â‰¥1âˆ’ÏµsubscriptsuperscriptÎ¦subscriptğ’¢1Î£ğ´ğµ1italic-Ïµ\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)\geq 1-\epsilonroman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) â‰¥ 1 - italic_Ïµ by letting Avsubscriptğ´ğ‘£A_{v}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT be the hEâ¢(v)subscriptâ„ğ¸ğ‘£h_{E}(v)italic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT ( italic_v )-th projection and Busubscriptğµğ‘¢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT be the hDâ¢(u)subscriptâ„ğ·ğ‘¢h_{D}(u)italic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_u )-th projection for each vâˆˆV,uâˆˆUformulae-sequenceğ‘£ğ‘‰ğ‘¢ğ‘ˆv\in V,u\in Uitalic_v âˆˆ italic_V , italic_u âˆˆ italic_U. As usual, the noise introduced by the perturbation factor ğ‚ğ‚\bm{\nu}bold_italic_Î½ is what forces us to give up perfect completeness. The idea behind our soundness analysis has appeared many times in the literature (e.g., [HÃ¥s01, EHR04, BK21]), but the approach taken in [EHR04] is the most similar to ours. Suppose that there are assignments A,Bğ´ğµA,Bitalic_A , italic_B, satisfying Î¦Î£ğ’¢2â¢(A,B)â‰¥1|â„‹2|+Î´.superscriptsubscriptÎ¦Î£subscriptğ’¢2ğ´ğµ1subscriptâ„‹2ğ›¿\Phi_{\Sigma}^{\mathscr{G}_{2}}(A,B)\geq\frac{1}{|\mathscr{H}_{2}|}+\delta.roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ( italic_A , italic_B ) â‰¥ divide start_ARG 1 end_ARG start_ARG | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | end_ARG + italic_Î´ . (4) In view of (3), this inequality can be understood as a lower bound for the the success probability of the following 3333-query dictatorship test: Sample all parameters according to the distribution shown in Figure 1, and then query the values (Av)Ï†â¢(ğš)subscriptsubscriptğ´ğ‘£ğœ‘ğš(A_{v})_{\varphi}({\mathbf{a}})( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_a ), Buâ¢(ğ›s1)s1subscriptğµğ‘¢superscriptsuperscriptğ›subscriptğ‘ 1subscriptğ‘ 1B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT, and Buâ¢((ğ›âˆ’1â¢(ğšâˆ˜Ï€uâ¢v)âˆ’1â¢ğ‚)s2)s2subscriptğµğ‘¢superscriptsuperscriptsuperscriptğ›1superscriptğšsubscriptğœ‹ğ‘¢ğ‘£1ğ‚subscriptğ‘ 2subscriptğ‘ 2B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_% {2}}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT. The test is passed if the product of the three values is the group identity, and failed otherwise. The soundness proof consists in showing that (4) implies that the functions (Av)Ï†:ğ’¢1Eâ†’ğ’¢2:subscriptsubscriptğ´ğ‘£ğœ‘â†’superscriptsubscriptğ’¢1ğ¸subscriptğ’¢2(A_{v})_{\varphi}:\mathscr{G}_{1}^{E}\rightarrow\mathscr{G}_{2}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and Bu:ğ’¢1Dâ†’ğ’¢2:subscriptğµğ‘¢â†’superscriptsubscriptğ’¢1ğ·subscriptğ’¢2B_{u}:\mathscr{G}_{1}^{D}\rightarrow\mathscr{G}_{2}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are â€œcloseâ€ to dictators (i.e., projections) for each vâˆˆVğ‘£ğ‘‰v\in Vitalic_v âˆˆ italic_V, uâˆˆUğ‘¢ğ‘ˆu\in Uitalic_u âˆˆ italic_U. Then, this fact allows us to find a good solution to the starting Gap Label Cover instance Î£Î£\Sigmaroman_Î£. Indeed, suppose that for each vâˆˆVğ‘£ğ‘‰v\in Vitalic_v âˆˆ italic_V the map (Av)Ï†subscriptsubscriptğ´ğ‘£ğœ‘(A_{v})_{\varphi}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT is the projection on the evsubscriptğ‘’ğ‘£e_{v}italic_e start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT-th coordinate, and for each uâˆˆUğ‘¢ğ‘ˆu\in Uitalic_u âˆˆ italic_U, the map Busubscriptğµğ‘¢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT is the projection on the dusubscriptğ‘‘ğ‘¢d_{u}italic_d start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT-th coordinate. Then the assignment mapping vğ‘£vitalic_v to evsubscriptğ‘’ğ‘£e_{v}italic_e start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT and uğ‘¢uitalic_u to dusubscriptğ‘‘ğ‘¢d_{u}italic_d start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT for each vâˆˆV,uâˆˆUformulae-sequenceğ‘£ğ‘‰ğ‘¢ğ‘ˆv\in V,u\in Uitalic_v âˆˆ italic_V , italic_u âˆˆ italic_U is a good solution for Î£Î£\Sigmaroman_Î£. However, it is not clear how to extend this simple idea to the case where the maps (Av)Ï†,Busubscriptsubscriptğ´ğ‘£ğœ‘subscriptğµğ‘¢(A_{v})_{\varphi},B_{u}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT , italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are not projections. In order to find a good solution for Î£Î£\Sigmaroman_Î£ in this general case, we first find suitable maps Î³1,Î³2:ğ’¢2â†’â„‚:subscriptğ›¾1subscriptğ›¾2â†’subscriptğ’¢2â„‚\gamma_{1},\gamma_{2}:\mathscr{G}_{2}\rightarrow\mathbb{C}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT â†’ blackboard_C and analyse Î³1âˆ˜(Av)Ï†subscriptğ›¾1subscriptsubscriptğ´ğ‘£ğœ‘\gamma_{1}\circ(A_{v})_{\varphi}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âˆ˜ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT, Î³2âˆ˜Busubscriptğ›¾2subscriptğµğ‘¢\gamma_{2}\circ B_{u}italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âˆ˜ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT. Now, using the fact that (Av)Ï†subscriptsubscriptğ´ğ‘£ğœ‘(A_{v})_{\varphi}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT and Busubscriptğµğ‘¢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are close to projections, we can prove that choosing the labels e,dğ‘’ğ‘‘e,ditalic_e , italic_d for the vertices v,uğ‘£ğ‘¢v,uitalic_v , italic_u according to the â€œlow-degree influenceâ€ of the eğ‘’eitalic_e-th coordinate in Î³1âˆ˜(Av)Ï†subscriptğ›¾1subscriptsubscriptğ´ğ‘£ğœ‘\gamma_{1}\circ(A_{v})_{\varphi}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âˆ˜ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT and the dğ‘‘ditalic_d-th coordinate in Î³2âˆ˜Busubscriptğ›¾2subscriptğµğ‘¢\gamma_{2}\circ B_{u}italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âˆ˜ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT yields a good randomised assignment of Î£Î£\Sigmaroman_Î£. This overview so far also applies to the soundness analysis of [EHR04]. Let us give more detail and highlight the main differences that sets our work apart. The first important difference has to do with the choice of Î³1,Î³2subscriptğ›¾1subscriptğ›¾2\gamma_{1},\gamma_{2}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. We define Î³1=Ï‰x,ysubscriptğ›¾1subscriptğœ”ğ‘¥ğ‘¦\gamma_{1}=\omega_{x,y}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_Ï‰ start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT, and Î³2=Ï‰y,zsubscriptğ›¾2subscriptğœ”ğ‘¦ğ‘§\gamma_{2}=\omega_{y,z}italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_Ï‰ start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT, where Ï‰ğœ”\omegaitalic_Ï‰ is some irreducible representation of ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, and x,y,zğ‘¥ğ‘¦ğ‘§x,y,zitalic_x , italic_y , italic_z are suitable indices in NÏ‰subscriptğ‘ğœ”N_{\omega}italic_N start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT. In [EHR04], the representation Ï‰ğœ”\omegaitalic_Ï‰ is a non-trivial representation chosen so that |ğ”¼â¢[Ï‡Ï‰â¢((Av)Ï†â¢(ğš)â¢Buâ¢(ğ›s1)s1â¢Buâ¢((ğ›âˆ’1â¢(ğšâˆ˜Ï€)âˆ’1â¢ğ‚)s2)s2)]|â‰¥dimÏ‰Î´.ğ”¼delimited-[]subscriptğœ’ğœ”subscriptsubscriptğ´ğ‘£ğœ‘ğšsubscriptğµğ‘¢superscriptsuperscriptğ›subscriptğ‘ 1subscriptğ‘ 1subscriptğµğ‘¢superscriptsuperscriptsuperscriptğ›1superscriptğšğœ‹1ğ‚subscriptğ‘ 2subscriptğ‘ 2subscriptdimensionğœ”ğ›¿\left|\mathbb{E}\left[\chi_{\omega}\left((A_{v})_{\varphi}({\mathbf{a}})B_{u}(% {\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi)^{-% 1}\bm{\nu})^{s_{2}})^{s_{2}}\right)\right]\right|\geq\dim_{\omega}\delta.| blackboard_E [ italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT ( ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) ] | â‰¥ roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ . Here the expectation is taken over the probability space described in Figure 1, and the dependence of Ï€ğœ‹\piitalic_Ï€ on the edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v } is left implicit. In our case, rather than using the Fourier characters for choosing Ï‰ğœ”\omegaitalic_Ï‰, we consider â€œpenalized charactersâ€ Ï‡Ï‰~~subscriptğœ’ğœ”\widetilde{\chi_{\omega}}over~ start_ARG italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT end_ARG. We define Ï‡Ï‰~:ğ’¢2â†’â„‚:~subscriptğœ’ğœ”â†’subscriptğ’¢2â„‚\widetilde{\chi_{\omega}}:\mathscr{G}_{2}\rightarrow\mathbb{C}over~ start_ARG italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT end_ARG : script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT â†’ blackboard_C as the map Ï‡Ï‰âˆ’Î·Ï‰subscriptğœ’ğœ”subscriptğœ‚ğœ”\chi_{\omega}-\eta_{\omega}italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT - italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT, where the penalty Î·Ï‰subscriptğœ‚ğœ”\eta_{\omega}italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT is the multiplicity of the trivial representation in the restriction Ï‰|â„‹2evaluated-atğœ”subscriptâ„‹2\omega|_{\mathscr{H}_{2}}italic_Ï‰ | start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT. This way, we pick Ï‰âˆˆğ’¢2^ğœ”^subscriptğ’¢2\omega\in\widehat{\mathscr{G}_{2}}italic_Ï‰ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG so that the previous inequality holds after replacing Ï‡Ï‰subscriptğœ’ğœ”\chi_{\omega}italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT with Ï‡Ï‰~~subscriptğœ’ğœ”\widetilde{\chi_{\omega}}over~ start_ARG italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT end_ARG. Equivalently, we find Ï‰ğœ”\omegaitalic_Ï‰ satisfying |ğ”¼â¢[Ï‡Ï‰â¢((Av)Ï†â¢(ğš)â¢Buâ¢(ğ›s1)s1â¢Buâ¢((ğ›âˆ’1â¢(ğšâˆ˜Ï€)âˆ’1â¢ğ‚)s2)s2)]|â‰¥dimÏ‰Î´+Î·Ï‰.ğ”¼delimited-[]subscriptğœ’ğœ”subscriptsubscriptğ´ğ‘£ğœ‘ğšsubscriptğµğ‘¢superscriptsuperscriptğ›subscriptğ‘ 1subscriptğ‘ 1subscriptğµğ‘¢superscriptsuperscriptsuperscriptğ›1superscriptğšğœ‹1ğ‚subscriptğ‘ 2subscriptğ‘ 2subscriptdimensionğœ”ğ›¿subscriptğœ‚ğœ”\left|\mathbb{E}\left[\chi_{\omega}\left((A_{v})_{\varphi}({\mathbf{a}})B_{u}(% {\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi)^{-% 1}\bm{\nu})^{s_{2}})^{s_{2}}\right)\right]\right|\geq\dim_{\omega}\delta+\eta_% {\omega}.| blackboard_E [ italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT ( ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) ] | â‰¥ roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ + italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT . (5) The fact that such Ï‰ğœ”\omegaitalic_Ï‰ exists is a consequence of (4) together with âˆ‘Ï‰âˆˆğ’¢2^dimÏ‰Î·Ï‰=|ğ’¢2|/|â„‹2|subscriptğœ”^subscriptğ’¢2subscriptdimensionğœ”subscriptğœ‚ğœ”subscriptğ’¢2subscriptâ„‹2\sum_{\omega\in\widehat{\mathscr{G}_{2}}}\dim_{\omega}\eta_{\omega}=|\mathscr{% G}_{2}|/|\mathscr{H}_{2}|âˆ‘ start_POSTSUBSCRIPT italic_Ï‰ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT = | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT |, which follows from the Frobenius Reciprocity Theorem, as shown in Lemma 2.11. This additional factor of Î·Ï‰subscriptğœ‚ğœ”\eta_{\omega}italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT is crucial to our soundness analysis, as we will see. Define the map ğ’œ=Ï‰âˆ˜(Av)Ï†ğ’œğœ”subscriptsubscriptğ´ğ‘£ğœ‘\mathcal{A}=\omega\circ(A_{v})_{\varphi}caligraphic_A = italic_Ï‰ âˆ˜ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT and the map â„¬:ğ’¢1Dâ†’ğ’¢2:â„¬â†’superscriptsubscriptğ’¢1ğ·subscriptğ’¢2\mathcal{B}:\mathscr{G}_{1}^{D}\rightarrow\mathscr{G}_{2}caligraphic_B : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT given by â„¬â¢(ğ›)=ğ”¼sâˆˆ{âˆ’1,1}â¢Ï‰âˆ˜Buâ¢(ğ›s)sâ„¬ğ›subscriptğ”¼ğ‘ 11ğœ”subscriptğµğ‘¢superscriptsuperscriptğ›ğ‘ ğ‘ \mathcal{B}({\mathbf{b}})=\mathbb{E}_{s\in\{-1,1\}}\omega\circ B_{u}({\mathbf{% b}}^{s})^{s}caligraphic_B ( bold_b ) = blackboard_E start_POSTSUBSCRIPT italic_s âˆˆ { - 1 , 1 } end_POSTSUBSCRIPT italic_Ï‰ âˆ˜ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT, where sâˆˆ{âˆ’1,1}ğ‘ 11s\in\{-1,1\}italic_s âˆˆ { - 1 , 1 } is distributed uniformly.555Observe that the maps ğ’œğ’œ\mathcal{A}caligraphic_A and â„¬â„¬\mathcal{B}caligraphic_B depend on the hidden parameters vğ‘£vitalic_v and uğ‘¢uitalic_u respectively. To show the soundness bound we consider the Fourier expansions of ğ’œğ’œ\mathcal{A}caligraphic_A and â„¬âˆ—â„¬â„¬â„¬\mathcal{B}*\mathcal{B}caligraphic_B âˆ— caligraphic_B in the expression |trâ¢ğ”¼â¢[ğ’œâ¢(ğš)â¢(â„¬âˆ—â„¬)â¢((ğšâˆ˜Ï€)âˆ’1â¢ğ‚)]|,trğ”¼delimited-[]ğ’œğšâ„¬â„¬superscriptğšğœ‹1ğ‚\left|\mathrm{tr}\,\mathbb{E}\left[\mathcal{A}({\mathbf{a}})(\mathcal{B}*% \mathcal{B})(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right]\right|,| roman_tr blackboard_E [ caligraphic_A ( bold_a ) ( caligraphic_B âˆ— caligraphic_B ) ( ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) ] | , which is just a rearrangement of the left-hand-side in the previous inequality. More precisely, we look at the equivalent expression |trâ¢ğ”¼â¢[(âˆ‘Ï„âˆˆğ’¢E^,s,tâˆˆNÏ„dimÏ„ğ’œ^â¢(Ï„s,t)â¢Ï„s,tâ¢(ğš))â¢(âˆ‘Ïâˆˆğ’¢D^,i,jâˆˆNÏdimÏ(â„¬âˆ—â„¬)^â¢(Ïi,j)â¢Ïi,jâ¢((ğšâˆ˜Ï€)âˆ’1â¢ğ‚))]|.trğ”¼delimited-[]subscriptformulae-sequenceğœ^superscriptğ’¢ğ¸ğ‘ ğ‘¡subscriptğ‘ğœsubscriptdimensionğœ^ğ’œsubscriptğœğ‘ ğ‘¡subscriptğœğ‘ ğ‘¡ğšsubscriptformulae-sequenceğœŒ^superscriptğ’¢ğ·ğ‘–ğ‘—subscriptğ‘ğœŒsubscriptdimensionğœŒ^â„¬â„¬subscriptğœŒğ‘–ğ‘—subscriptğœŒğ‘–ğ‘—superscriptğšğœ‹1ğ‚\left|\mathrm{tr}\,\mathbb{E}\left[\left(\sum_{\tau\in\widehat{\mathscr{G}^{E}% },s,t\in N_{\tau}}\dim_{\tau}\widehat{\mathcal{A}}(\tau_{s,t})\tau_{s,t}({% \mathbf{a}})\right)\left(\sum_{\rho\in\widehat{\mathscr{G}^{D}},i,j\in N_{\rho% }}\dim_{\rho}\widehat{(\mathcal{B}*\mathcal{B})}(\rho_{i,j})\rho_{i,j}(({% \mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right)\right]\right|.| roman_tr blackboard_E [ ( âˆ‘ start_POSTSUBSCRIPT italic_Ï„ âˆˆ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT over^ start_ARG caligraphic_A end_ARG ( italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ( bold_a ) ) ( âˆ‘ start_POSTSUBSCRIPT italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B âˆ— caligraphic_B ) end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) ) ] | . (6) Our goal is to find a bound Îºğœ…\kappaitalic_Îº, independent of |D|,|E|ğ·ğ¸|D|,|E|| italic_D | , | italic_E |, satisfying that the contribution to this expression of non-trivial representations Ï„,ÏğœğœŒ\tau,\rhoitalic_Ï„ , italic_Ï of degree less than Îºğœ…\kappaitalic_Îº is at least dimÏ‰Î´/2subscriptdimensionğœ”ğ›¿2\dim_{\omega}\delta/2roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ / 2. This is achieved by controlling the contribution of the trivial term and the contribution of high-degree terms, as indicated by Lemma 3.1 and Lemma 3.2 respectively. The second main difference of our soundness analysis compared to [EHR04] is our handling of the trivial term. In Lemma 3.1 we prove that |trâ¢ğ”¼â¢[ğ’œ^â¢(1)â¢(âˆ‘Ïâˆˆğ’¢D^,s,tâˆˆNÏdimÏ(â„¬âˆ—â„¬)^â¢(Ïi,j)â¢Ïi,jâ¢((ğšâˆ˜Ï€)âˆ’1â¢ğ‚))]|â‰¤Î·Ï‰.trğ”¼delimited-[]^ğ’œ1subscriptformulae-sequenceğœŒ^superscriptğ’¢ğ·ğ‘ ğ‘¡subscriptğ‘ğœŒsubscriptdimensionğœŒ^â„¬â„¬subscriptğœŒğ‘–ğ‘—subscriptğœŒğ‘–ğ‘—superscriptğšğœ‹1ğ‚subscriptğœ‚ğœ”\left|\mathrm{tr}\,\mathbb{E}\left[\widehat{\mathcal{A}}(1)\left(\sum_{\rho\in% \widehat{\mathscr{G}^{D}},s,t\in N_{\rho}}\dim_{\rho}\widehat{(\mathcal{B}*% \mathcal{B})}(\rho_{i,j})\rho_{i,j}(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right% )\right]\right|\leq\eta_{\omega}.| roman_tr blackboard_E [ over^ start_ARG caligraphic_A end_ARG ( 1 ) ( âˆ‘ start_POSTSUBSCRIPT italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B âˆ— caligraphic_B ) end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) ) ] | â‰¤ italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT . In the non-promise setting, this bound is not necessary. Roughly, under the stronger notion of folding used in [EHR04], it is possible to show that ğ’œ^â¢(1)^ğ’œ1\widehat{\mathcal{A}}(1)over^ start_ARG caligraphic_A end_ARG ( 1 ) vanishes. Our weaker notion of folding does not allow us to prove the same result, but we are still able to leverage folding to obtain the above bound. This mismatch with [EHR04] is the reason why the extra Î·Ï‰subscriptğœ‚ğœ”\eta_{\omega}italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT term was required in (5). The key insight in the proof of Lemma 3.1 is that if F:ğ’¢1Eâ†’ğ’¢2:ğ¹â†’superscriptsubscriptğ’¢1ğ¸subscriptğ’¢2F:\mathscr{G}_{1}^{E}\rightarrow\mathscr{G}_{2}italic_F : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is folded over Ï†ğœ‘\varphiitalic_Ï†, then the trace of (Ï‰âˆ˜F)^â¢(1)^ğœ”ğ¹1\widehat{(\omega\circ F)}(1)over^ start_ARG ( italic_Ï‰ âˆ˜ italic_F ) end_ARG ( 1 ) is at most Î·Ï‰subscriptğœ‚ğœ”\eta_{\omega}italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT in absolute value. Our analysis of high-degree terms is in the same spirit as previous works that show hardness of approximation in the imperfect completeness setting. In Lemma 3.2 we prove that |trğ”¼[(âˆ‘Ï„âˆˆğ’¢1E^,Ï„â‰ 1âˆ‘s,tâˆˆNÏ„dimÏ„ğ’œ^(Ï„s,t)Ï„s,t(ğš))Ã—\displaystyle\left|\mathrm{tr}\,\mathbb{E}\left[\left(\sum_{\tau\in\widehat{% \mathscr{G}_{1}^{E}},\tau\neq 1}\sum_{s,t\in N_{\tau}}\dim_{\tau}\widehat{% \mathcal{A}}(\tau_{s,t})\tau_{s,t}({\mathbf{a}})\right)\times\right.\right.| roman_tr blackboard_E [ ( âˆ‘ start_POSTSUBSCRIPT italic_Ï„ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_Ï„ â‰  1 end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT over^ start_ARG caligraphic_A end_ARG ( italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ( bold_a ) ) Ã— (âˆ‘Ïâˆˆğ’¢1D^,|Ï|â‰¥Îºâˆ‘i,jâˆˆNÏdimÏ(â„¬âˆ—â„¬)^(Ïi,j)Ïi,j((ğšâˆ˜Ï€)âˆ’1ğ‚))]|â‰¤(dimÏ‰Î´)/2\displaystyle\left.\left.\left(\sum_{\rho\in\widehat{\mathscr{G}_{1}^{D}},|% \rho|\geq\kappa}\sum_{i,j\in N_{\rho}}\dim_{\rho}\widehat{(\mathcal{B}*% \mathcal{B})}(\rho_{i,j})\rho_{i,j}(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right% )\right]\right|\leq(\dim_{\omega}\delta)/2( âˆ‘ start_POSTSUBSCRIPT italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , | italic_Ï | â‰¥ italic_Îº end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B âˆ— caligraphic_B ) end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) ) ] | â‰¤ ( roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ ) / 2 for all Îºâ‰¥(log2â¡Î´âˆ’2)/log2â¡(1âˆ’Ïµ)ğœ…subscript2ğ›¿2subscript21italic-Ïµ\kappa\geq(\log_{2}\delta-2)/\log_{2}(1-\epsilon)italic_Îº â‰¥ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_Î´ - 2 ) / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_Ïµ ). The essential idea is that the â€œnoise vectorâ€ ğ‚ğ‚\bm{\nu}bold_italic_Î½ has a smoothing effect that limits the contribution of high-degree terms in (6). Finally, having established that the contribution of non-trivial terms of degree less than Îºğœ…\kappaitalic_Îº in (6) is at least dimÏ‰Î´/2subscriptdimensionğœ”ğ›¿2\dim_{\omega}\delta/2roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ / 2, in Lemma 3.3 we give a good randomised strategy to solve Î£Î£\Sigmaroman_Î£. This strategy assigns the label eâˆˆEğ‘’ğ¸e\in Eitalic_e âˆˆ italic_E to vâˆˆVğ‘£ğ‘‰v\in Vitalic_v âˆˆ italic_V and the label dâˆˆDğ‘‘ğ·d\in Ditalic_d âˆˆ italic_D to uâˆˆUğ‘¢ğ‘ˆu\in Uitalic_u âˆˆ italic_U with probabilities Prâ¡(vâ†¦e)=âˆ‘Ï„âˆˆğ’¢1E^,Ï„eâ‰ 1âˆ‘s,tâˆˆNÏ„dimÏ„|ğ’œx,y^â¢(Ï„s,t)|2|Ï„|Prmaps-toğ‘£ğ‘’subscriptformulae-sequenceğœ^superscriptsubscriptğ’¢1ğ¸superscriptğœğ‘’1subscriptğ‘ ğ‘¡subscriptğ‘ğœsubscriptdimensionğœsuperscript^subscriptğ’œğ‘¥ğ‘¦subscriptğœğ‘ ğ‘¡2ğœ\Pr(v\mapsto e)\ =\sum_{\tau\in\widehat{\mathscr{G}_{1}^{E}},\tau^{e}\neq 1}% \sum_{s,t\in N_{\tau}}\dim_{\tau}\frac{\left|\widehat{\mathcal{A}_{x,y}}(\tau_% {s,t})\right|^{2}}{|\tau|}roman_Pr ( italic_v â†¦ italic_e ) = âˆ‘ start_POSTSUBSCRIPT italic_Ï„ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_Ï„ start_POSTSUPERSCRIPT italic_e end_POSTSUPERSCRIPT â‰  1 end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT divide start_ARG | over^ start_ARG caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT end_ARG ( italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_Ï„ | end_ARG and Prâ¡(uâ†¦d)=âˆ‘Ïâˆˆğ’¢1D^,Ïdâ‰ 1âˆ‘i,jâˆˆNÏdimÏ|â„¬y,z^â¢(Ïi,j)|2|Ï|,Prmaps-toğ‘¢ğ‘‘subscriptformulae-sequenceğœŒ^superscriptsubscriptğ’¢1ğ·superscriptğœŒğ‘‘1subscriptğ‘–ğ‘—subscriptğ‘ğœŒsubscriptdimensionğœŒsuperscript^subscriptâ„¬ğ‘¦ğ‘§subscriptğœŒğ‘–ğ‘—2ğœŒ\Pr(u\mapsto d)\ =\sum_{\rho\in\widehat{\mathscr{G}_{1}^{D}},\rho^{d}\neq 1}% \sum_{i,j\in N_{\rho}}\dim_{\rho}\frac{\left|\widehat{\mathcal{B}_{y,z}}(\rho_% {i,j})\right|^{2}}{|\rho|},roman_Pr ( italic_u â†¦ italic_d ) = âˆ‘ start_POSTSUBSCRIPT italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT â‰  1 end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT divide start_ARG | over^ start_ARG caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_Ï | end_ARG , where x,y,zâˆˆNÏ‰ğ‘¥ğ‘¦ğ‘§subscriptğ‘ğœ”x,y,z\in N_{\omega}italic_x , italic_y , italic_z âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT are suitable indices found in Lemma 3.3. These probabilities are supposed to capture the influence of the eğ‘’eitalic_e-th and dğ‘‘ditalic_d-th coordinates on ğ’œx,y=Ï‰x,yâˆ˜(Av)Ï†subscriptğ’œğ‘¥ğ‘¦subscriptğœ”ğ‘¥ğ‘¦subscriptsubscriptğ´ğ‘£ğœ‘\mathcal{A}_{x,y}=\omega_{x,y}\circ(A_{v})_{\varphi}caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT = italic_Ï‰ start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT âˆ˜ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT and â„¬y,z=Ï‰y,zâˆ˜ğ”¼sâ¢Buâ¢(â‹…s)ssubscriptâ„¬ğ‘¦ğ‘§subscriptğœ”ğ‘¦ğ‘§subscriptğ”¼ğ‘ subscriptğµğ‘¢superscriptsuperscriptâ‹…ğ‘ ğ‘ \mathcal{B}_{y,z}=\omega_{y,z}\circ\mathbb{E}_{s}B_{u}(\ \cdot^{s})^{s}caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT = italic_Ï‰ start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT âˆ˜ blackboard_E start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( â‹… start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT respectively (compare with the notion of influence in [BK21, AM09]). This turns out to be a good randomised assignment for Î£Î£\Sigmaroman_Î£. That is, ğ”¼uâ¢vâ¢[âˆ‘dâˆˆDPrâ¡(vâ†¦Ï€uâ¢vâ¢(d))â¢Prâ¡(uâ†¦d)]â‰¥Î±,subscriptğ”¼ğ‘¢ğ‘£delimited-[]subscriptğ‘‘ğ·Prmaps-toğ‘£subscriptğœ‹ğ‘¢ğ‘£ğ‘‘Prmaps-toğ‘¢ğ‘‘ğ›¼\mathbb{E}_{uv}\left[\sum_{d\in D}\Pr(v\mapsto\pi_{uv}(d))\Pr(u\mapsto d)% \right]\geq\alpha,blackboard_E start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT [ âˆ‘ start_POSTSUBSCRIPT italic_d âˆˆ italic_D end_POSTSUBSCRIPT roman_Pr ( italic_v â†¦ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_d ) ) roman_Pr ( italic_u â†¦ italic_d ) ] â‰¥ italic_Î± , (7) where the expectation is taken uniformly over the edges {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v } of Î£Î£\Sigmaroman_Î£, and Î±ğ›¼\alphaitalic_Î± is the soundness constant appearing in Theorem 1.7. We are being informal with the usage of the word â€œprobabilityâ€ here: the quantities Prâ¡(vâ†¦e)Prmaps-toğ‘£ğ‘’\Pr(v\mapsto e)roman_Pr ( italic_v â†¦ italic_e ) and Prâ¡(uâ†¦d)Prmaps-toğ‘¢ğ‘‘\Pr(u\mapsto d)roman_Pr ( italic_u â†¦ italic_d ) may add up to less than 1111, but this is easily fixed by normalising, or by letting our strategy default to the uniform assignment with some positive probability. Let us give some more detail. More precisely, Lemma 3.3 shows that truncating our assignment probabilities to terms of degree less than Îºğœ…\kappaitalic_Îº is enough to satisfy this last inequality. Let â„“â‰¥0â„“0\ell\geq 0roman_â„“ â‰¥ 0. The probabilities Pr<â„“â¡(vâ†¦e)superscriptPrabsentâ„“maps-toğ‘£ğ‘’\Pr^{<\ell}(v\mapsto e)roman_Pr start_POSTSUPERSCRIPT < roman_â„“ end_POSTSUPERSCRIPT ( italic_v â†¦ italic_e ), Pr<â„“â¡(uâ†¦d)superscriptPrabsentâ„“maps-toğ‘¢ğ‘‘\Pr^{<\ell}(u\mapsto d)roman_Pr start_POSTSUPERSCRIPT < roman_â„“ end_POSTSUPERSCRIPT ( italic_u â†¦ italic_d ) are defined the same way as Prâ¡(vâ†¦e)Prmaps-toğ‘£ğ‘’\Pr(v\mapsto e)roman_Pr ( italic_v â†¦ italic_e ) and Prâ¡(uâ†¦d)Prmaps-toğ‘¢ğ‘‘\Pr(u\mapsto d)roman_Pr ( italic_u â†¦ italic_d ) but considering only representations Ï„,ÏğœğœŒ\tau,\rhoitalic_Ï„ , italic_Ï of degree less than â„“â„“\ellroman_â„“. These modified probabilities can be understood as the â€œlow-degree influencesâ€ of each coordinate in ğ’œx,ysubscriptğ’œğ‘¥ğ‘¦\mathcal{A}_{x,y}caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT and â„¬y,zsubscriptâ„¬ğ‘¦ğ‘§\mathcal{B}_{y,z}caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT. With this notation, in Lemma 3.3 we prove that (7) holds after replacing each assignment probability PrPr\Prroman_Pr with its truncated variant Pr<ÎºsuperscriptPrabsentğœ…\Pr^{<\kappa}roman_Pr start_POSTSUPERSCRIPT < italic_Îº end_POSTSUPERSCRIPT. In other words, we prove that ğ”¼uâ¢vâ¢[âˆ‘dâˆˆDâˆ‘Ïâˆˆğ’¢1D^,Ïdâ‰ 1|Ï|<Îº,i,jâˆˆNÏâˆ‘Ï„âˆˆğ’¢1E^,Ï„Ï€uâ¢vâ¢(d)â‰ 1|Ï„|<Îº,s,tâˆˆNÏ„dimÏ„|ğ’œx,y^â¢(Ï„s,t)|2|Ï„|â¢dimÏ|â„¬y,z^â¢(Ïi,j)|2|Ï|]â‰¥Î±.subscriptğ”¼ğ‘¢ğ‘£delimited-[]subscriptğ‘‘ğ·subscriptformulae-sequenceğœŒ^superscriptsubscriptğ’¢1ğ·superscriptğœŒğ‘‘1formulae-sequenceğœŒğœ…ğ‘–ğ‘—subscriptğ‘ğœŒsubscriptformulae-sequenceğœ^superscriptsubscriptğ’¢1ğ¸superscriptğœsubscriptğœ‹ğ‘¢ğ‘£ğ‘‘1formulae-sequenceğœğœ…ğ‘ ğ‘¡subscriptğ‘ğœsubscriptdimensionğœsuperscript^subscriptğ’œğ‘¥ğ‘¦subscriptğœğ‘ ğ‘¡2ğœsubscriptdimensionğœŒsuperscript^subscriptâ„¬ğ‘¦ğ‘§subscriptğœŒğ‘–ğ‘—2ğœŒğ›¼\mathbb{E}_{uv}\left[\sum_{d\in D}\sum_{\begin{subarray}{c}\rho\in\widehat{% \mathscr{G}_{1}^{D}},\rho^{d}\neq 1\\ |\rho|<\kappa,\,i,j\in N_{\rho}\end{subarray}}\sum_{\begin{subarray}{c}\tau\in% \widehat{\mathscr{G}_{1}^{E}},\tau^{\pi_{uv}(d)}\neq 1\\ |\tau|<\kappa,\,s,t\in N_{\tau}\end{subarray}}\frac{\dim_{\tau}\left|\widehat{% \mathcal{A}_{x,y}}(\tau_{s,t})\right|^{2}}{|\tau|}\frac{\dim_{\rho}\left|% \widehat{\mathcal{B}_{y,z}}(\rho_{i,j})\right|^{2}}{|\rho|}\right]\geq\alpha.blackboard_E start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT [ âˆ‘ start_POSTSUBSCRIPT italic_d âˆˆ italic_D end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT â‰  1 end_CELL end_ROW start_ROW start_CELL | italic_Ï | < italic_Îº , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_Ï„ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_Ï„ start_POSTSUPERSCRIPT italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_d ) end_POSTSUPERSCRIPT â‰  1 end_CELL end_ROW start_ROW start_CELL | italic_Ï„ | < italic_Îº , italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT divide start_ARG roman_dim start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT | over^ start_ARG caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT end_ARG ( italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_Ï„ | end_ARG divide start_ARG roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT | over^ start_ARG caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_Ï | end_ARG ] â‰¥ italic_Î± . This shows that our proposed strategy produces a good randomised assignment for Î£Î£\Sigmaroman_Î£ and completes the soundness proof."
https://arxiv.org/html/2411.02148v1,Optimality of Frequency Moment Estimation,"Estimating the second frequency moment of a stream up to (1Â±Îµ)plus-or-minus1ğœ€(1\pm\varepsilon)( 1 Â± italic_Îµ ) multiplicative error requires at most Oâ¢(logâ¡n/Îµ2)ğ‘‚ğ‘›superscriptğœ€2O(\log n/\varepsilon^{2})italic_O ( roman_log italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) bits of space, due to a seminal result of Alon, Matias, and Szegedy. It is also known that at least Î©â¢(logâ¡n+1/Îµ2)Î©ğ‘›1superscriptğœ€2\Omega(\log n+1/\varepsilon^{2})roman_Î© ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) space is needed. We prove an optimal lower bound of Î©â¢(logâ¡(nâ¢Îµ2)/Îµ2)Î©ğ‘›superscriptğœ€2superscriptğœ€2\Omega\left(\log\left(n\varepsilon^{2}\right)/\varepsilon^{2}\right)roman_Î© ( roman_log ( italic_n italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) for all Îµ=Î©â¢(1/n)ğœ€Î©1ğ‘›\varepsilon=\Omega(1/\sqrt{n})italic_Îµ = roman_Î© ( 1 / square-root start_ARG italic_n end_ARG ). Note that when Îµ>nâˆ’1/2+cğœ€superscriptğ‘›12ğ‘\varepsilon>n^{-1/2+c}italic_Îµ > italic_n start_POSTSUPERSCRIPT - 1 / 2 + italic_c end_POSTSUPERSCRIPT, where c>0ğ‘0c>0italic_c > 0, our lower bound matches the classic upper bound of AMS. For smaller values of Îµğœ€\varepsilonitalic_Îµ we also introduce a revised algorithm that improves the classic AMS bound and matches our lower bound. Our lower bound holds also for the more general problem of pğ‘pitalic_p-th frequency moment estimation for the range of pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ], giving a tight bound in the only remaining range to settle the optimal space complexity of estimating frequency moments.","An extensive body of literature is devoted to the streaming model of computation, which is important for the analysis of massive datasets and in network traffic monitoring. A central problem in this model is the frequency moment estimation problem: Elements from a universe Uğ‘ˆUitalic_U are given to the algorithm one-by-one, defining a vector of frequencies â€” that is, fxâˆˆâ„•subscriptğ‘“ğ‘¥â„•f_{x}\in\mathbb{N}italic_f start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT âˆˆ blackboard_N is the number of times the element xâˆˆUğ‘¥ğ‘ˆx\in Uitalic_x âˆˆ italic_U appeared in the stream; Finally, the algorithm has to return, with good probability, a (1Â±Îµ)plus-or-minus1ğœ€(1\pm\varepsilon)( 1 Â± italic_Îµ )-estimation of Fp:=âˆ‘xâˆˆUfxpassignsubscriptğ¹ğ‘subscriptğ‘¥ğ‘ˆsuperscriptsubscriptğ‘“ğ‘¥ğ‘F_{p}:=\sum_{x\in U}f_{x}^{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT := âˆ‘ start_POSTSUBSCRIPT italic_x âˆˆ italic_U end_POSTSUBSCRIPT italic_f start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_p end_POSTSUPERSCRIPT â€” the pğ‘pitalic_p-th frequency moment of the stream. We generally denote the length of the stream by nğ‘›nitalic_n and assume that |U|=polyâ¢(n)ğ‘ˆpolyğ‘›|U|=\text{poly}(n)| italic_U | = poly ( italic_n ). The main complexity parameter studied in this model is how much space is needed for the algorithm to succeed. The study of both the streaming model and of frequency moment estimation in it was initiated in the seminal 1996 work of Alon, Matias, and Szegedy [AMS96]. The case of p=2ğ‘2p=2italic_p = 2, or second moment estimation, is of particular importance. It is often called the repeat rate or surprise index, and is used in various tasks such as database query optimization [AGMS99], network traffic anomaly detection [KSZC03], approximate histogram maintenance [GGI+02] and more. Other moments of particular interest are p=1ğ‘1p=1italic_p = 1, corresponding to the approximate counting problem [Mor78, NY22], and p=0ğ‘0p=0italic_p = 0, corresponding to the distinct elements problem [FM85, IW03, KNW10b]. Among these special cases, only the space complexity of the first remains not fully understood. The original algorithm for F2subscriptğ¹2F_{2}italic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-estimation given by Alon, Matias, and Szegedy uses Oâ¢(logâ¡n/Îµ2)ğ‘‚ğ‘›superscriptğœ€2O(\log n/\varepsilon^{2})italic_O ( roman_log italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) bits of space; while the highest known lower bound due to Woodruff in 2004 [Woo04] is Î©â¢(logâ¡n+1/Îµ2)Î©ğ‘›1superscriptğœ€2\Omega(\log n+1/\varepsilon^{2})roman_Î© ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) â€” leaving up to a quadratic gap between the upper and lower bounds for certain choices of Îµğœ€\varepsilonitalic_Îµ. While Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation for pâ‰¤2ğ‘2p\leq 2italic_p â‰¤ 2 uses amount of space that is only logarithmic in the length of the stream, it was shown that for p>2ğ‘2p>2italic_p > 2 at least Î©â¢(n1âˆ’2/p/polyâ¢(Îµ))Î©superscriptğ‘›12ğ‘polyğœ€\Omega(n^{1-2/p}/\text{poly}(\varepsilon))roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 - 2 / italic_p end_POSTSUPERSCRIPT / poly ( italic_Îµ ) ) space is needed [BYJKS04, CKS03b] â€” which is polynomial in the streamâ€™s length. A long list of works [IW05, BGKS06, MW10, AKO11, BO10, And17, Gan11b, WZ12, Gan11a, LW13] resulted in a nearly-tight bound of Î˜~â¢(n1âˆ’2/p/Îµ2)~Î˜superscriptğ‘›12ğ‘superscriptğœ€2\tilde{\Theta}\left(n^{1-2/p}/\varepsilon^{2}\right)over~ start_ARG roman_Î˜ end_ARG ( italic_n start_POSTSUPERSCRIPT 1 - 2 / italic_p end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) for Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation for every p>2ğ‘2p>2italic_p > 2 (not necessarily an integer) and Îµğœ€\varepsilonitalic_Îµ, for some ranges of parameters the bounds are tight â€” in others there is a gap between the bounds that is poly-logarithmic in the bound itself. For pâ‰¤2ğ‘2p\leq 2italic_p â‰¤ 2 the space complexity is not as well understood. Woodruff [Woo04] showed a lower bound of Î©â¢(logâ¡n+1/Îµ2)Î©ğ‘›1superscriptğœ€2\Omega(\log n+1/\varepsilon^{2})roman_Î© ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) for every pâ‰ 1ğ‘1p\neq 1italic_p â‰  1, this is optimal in terms of Îµğœ€\varepsilonitalic_Îµ alone and is also known to be optimal for the distinct elements problem (that is, p=0ğ‘0p=0italic_p = 0). For the special case of approximate counting (that is, p=1ğ‘1p=1italic_p = 1), a tight bound of Î˜â¢(logâ¡logâ¡n+logâ¡Îµâˆ’1)Î˜ğ‘›superscriptğœ€1\Theta(\log\log n+\log\varepsilon^{-1})roman_Î˜ ( roman_log roman_log italic_n + roman_log italic_Îµ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) is known [NY22]. For the range of pâˆˆ[0,1)ğ‘01p\in[0,1)italic_p âˆˆ [ 0 , 1 ), the upper bound of AMS was improved by Jayaram and Woodruff who presented a nearly-tight O~â¢(logâ¡n+1/Îµ2)~ğ‘‚ğ‘›1superscriptğœ€2\tilde{O}\left(\log n+1/\varepsilon^{2}\right)over~ start_ARG italic_O end_ARG ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) bound in that range [JW19]. This leaves pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ] as the last remaining range within no nearly-tight bounds are known. For certain generalizations more is known: When the stream is randomly shuffled and given in random order, then in the range pâˆˆ(1,2)ğ‘12p\in(1,2)italic_p âˆˆ ( 1 , 2 ) (excluding p=2ğ‘2p=2italic_p = 2) [BVWY18] showed an improved upper bound of O~â¢(logâ¡n+1/Îµ2)~ğ‘‚ğ‘›1superscriptğœ€2\tilde{O}\left(\log n+1/\varepsilon^{2}\right)over~ start_ARG italic_O end_ARG ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ). When updates are allowed in the stream, that is, elements can also be deleted and not only added to it, then [KNW10a] showed that Î˜â¢(logâ¡n/Îµ2)Î˜ğ‘›superscriptğœ€2\Theta(\log n/\varepsilon^{2})roman_Î˜ ( roman_log italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) is optimal for pâ‰¤2ğ‘2p\leq 2italic_p â‰¤ 2. In this work, we settle the space complexity of frequency moment estimation in the entire remaining range of pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ], including the special case of second frequency moment estimation. For p=2ğ‘2p=2italic_p = 2, we show that the AMS bound is essentially tight. Theorem. Let ğ’œğ’œ\mathcal{A}caligraphic_A be a streaming algorithm that gives an (1Â±Îµ)plus-or-minus1ğœ€\left(1\pm\varepsilon\right)( 1 Â± italic_Îµ ) multiplicative approximation to the F2subscriptğ¹2F_{2}italic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of its input stream and succeeds with probability â‰¥2/3absent23\geq 2/3â‰¥ 2 / 3, for some Îµ=Î©â¢(1/n)ğœ€Î©1ğ‘›\varepsilon=\Omega(1/\sqrt{n})italic_Îµ = roman_Î© ( 1 / square-root start_ARG italic_n end_ARG ). Then, the space used by ğ’œğ’œ\mathcal{A}caligraphic_A is Î©â¢(logâ¡(Îµ2â¢n)/Îµ2)Î©superscriptğœ€2ğ‘›superscriptğœ€2\Omega\left(\log\left(\varepsilon^{2}n\right)/\varepsilon^{2}\right)roman_Î© ( roman_log ( italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ). Note that the range Îµ<1/nğœ€1ğ‘›\varepsilon<1/\sqrt{n}italic_Îµ < 1 / square-root start_ARG italic_n end_ARG is less interesting as Oâ¢(minâ¡{nâ¢logâ¡n,|U|})ğ‘‚ğ‘›ğ‘›ğ‘ˆO\left(\min\{n\log n,|U|\}\right)italic_O ( roman_min { italic_n roman_log italic_n , | italic_U | } ) space suffices for exactly maintaining the vector of frequencies. We observe that in the range where Îµğœ€\varepsilonitalic_Îµ is very close to 1/n1ğ‘›1/\sqrt{n}1 / square-root start_ARG italic_n end_ARG our lower bound is (slightly) lower than the AMS upper bound, we show that this is inherent by introducing a modification of the AMS algorithm that matches our lower bound in this range. Theorem. For Îµ=Î©â¢(1/n)ğœ€Î©1ğ‘›\varepsilon=\Omega(1/\sqrt{n})italic_Îµ = roman_Î© ( 1 / square-root start_ARG italic_n end_ARG ), we can get a (1Â±Îµ)plus-or-minus1ğœ€(1\pm\varepsilon)( 1 Â± italic_Îµ )-approximation of the F2subscriptğ¹2F_{2}italic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of a stream of length nğ‘›nitalic_n using Oâ¢(logâ¡(Îµ2â¢n)/Îµ2)ğ‘‚superscriptğœ€2ğ‘›superscriptğœ€2O\left(\log\left(\varepsilon^{2}n\right)/\varepsilon^{2}\right)italic_O ( roman_log ( italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) space with success probability >2/3absent23>2/3> 2 / 3. 0â‰¤p<10ğ‘10\leq p<10 â‰¤ italic_p < 1 p=1ğ‘1p=1italic_p = 1 1<pâ‰¤21ğ‘21<p\leq 21 < italic_p â‰¤ 2 p>2ğ‘2p>2italic_p > 2 Î˜~â¢(logâ¡n+1/Îµ2)~Î˜ğ‘›1superscriptğœ€2\tilde{\Theta}(\log n+1/\varepsilon^{2})over~ start_ARG roman_Î˜ end_ARG ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) Î˜â¢(logâ¡logâ¡n+logâ¡Îµâˆ’1)Î˜ğ‘›superscriptğœ€1\Theta(\log\log n+\log\varepsilon^{-1})roman_Î˜ ( roman_log roman_log italic_n + roman_log italic_Îµ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) Î˜â¢(logâ¡n/Îµ2)Î˜ğ‘›superscriptğœ€2\Theta(\log n/\varepsilon^{2})roman_Î˜ ( roman_log italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) Î˜~â¢(n1âˆ’2/p/Îµ2)~Î˜superscriptğ‘›12ğ‘superscriptğœ€2\tilde{\Theta}(n^{1-2/p}/\varepsilon^{2})over~ start_ARG roman_Î˜ end_ARG ( italic_n start_POSTSUPERSCRIPT 1 - 2 / italic_p end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) Figure 1: Space complexity of Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation. We also extend our lower bound to the range pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ], which settles the space complexity of Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation for all values of pğ‘pitalic_p. See Figure 1 for a summary of the space complexity of Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation for all pâ‰¥0ğ‘0p\geq 0italic_p â‰¥ 0. Theorem. Fix pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ]. Let ğ’œğ’œ\mathcal{A}caligraphic_A be a streaming algorithm that gives an (1Â±Îµ)plus-or-minus1ğœ€\left(1\pm\varepsilon\right)( 1 Â± italic_Îµ ) approximation to the Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT of its input stream, for some Îµâˆˆ(Î©â¢(nâˆ’1/p),4âˆ’1/(pâˆ’1))ğœ€Î©superscriptğ‘›1ğ‘superscript41ğ‘1\varepsilon\in\left(\Omega\left(n^{-1/p}\right),{4^{-1/(p-1)}}\right)italic_Îµ âˆˆ ( roman_Î© ( italic_n start_POSTSUPERSCRIPT - 1 / italic_p end_POSTSUPERSCRIPT ) , 4 start_POSTSUPERSCRIPT - 1 / ( italic_p - 1 ) end_POSTSUPERSCRIPT ), and succeeds with probability â‰¥2/3absent23\geq 2/3â‰¥ 2 / 3. Then, the space used by ğ’œğ’œ\mathcal{A}caligraphic_A is Î©â¢(logâ¡(Îµ1/pâ¢n)/Îµ2)Î©superscriptğœ€1ğ‘ğ‘›superscriptğœ€2\Omega\left(\log\left(\varepsilon^{1/p}n\right)/\varepsilon^{2}\right)roman_Î© ( roman_log ( italic_Îµ start_POSTSUPERSCRIPT 1 / italic_p end_POSTSUPERSCRIPT italic_n ) / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ). Most of the lower bounds for streaming problems are based on reductions from communication complexity. In [JW19], a natural barrier to prove a better than Î©~â¢(1/Îµ2)~Î©1superscriptğœ€2\tilde{\Omega}(1/\varepsilon^{2})over~ start_ARG roman_Î© end_ARG ( 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) lower bound was shown: Even in a very strong model of communication, Oâ¢(1/Îµ2â‹…(logâ¡logâ¡n+logâ¡d+logâ¡Îµâˆ’1))ğ‘‚â‹…1superscriptğœ€2ğ‘›ğ‘‘superscriptğœ€1O\left(1/\varepsilon^{2}\cdot\left(\log\log n+\log d+\log\varepsilon^{-1}% \right)\right)italic_O ( 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‹… ( roman_log roman_log italic_n + roman_log italic_d + roman_log italic_Îµ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) ) bits of communication suffice for the players to correctly produce a Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT estimation, where dğ‘‘ditalic_d is the diameter of the communication graph. This means that problems who reduce to Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation have a too low communication complexity to improve the existing lower bounds. To overcome this natural barrier, we present a new type of a direct sum theorem that takes place at the level of the streaming algorithm rather than the level of the communication model â€” informally, we pack many instances of problems with communication complexity Î˜â¢(1/Îµ2)Î˜1superscriptğœ€2\Theta(1/\varepsilon^{2})roman_Î˜ ( 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) into a single stream, and then directly show that a successful streaming algorithm must solve them all. In Section 2 we give a detailed high-level overview of our proofs. The lower bound is presented in Section 4 and Section 5, and then extended from p=2ğ‘2p=2italic_p = 2 to pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ] in Section 5.3. The improved upper bound is presented in Section 6. We conclude and present remaining open problems in Section 7."
https://arxiv.org/html/2411.02087v2,"An Exponential Separation Between Quantum and Quantum-Inspired
Classical Algorithms for Machine Learning","Achieving a provable exponential quantum speedup for an important machine learning task has been a central research goal since the seminal HHL quantum algorithm for solving linear systems and the subsequent quantum recommender systems algorithm by Kerenidis and Prakash. These algorithms were initially believed to be strong candidates for exponential speedups, but a lower bound ruling out similar classical improvements remained absent. In breakthrough work by Tang, it was demonstrated that this lack of progress in classical lower bounds was for good reasons. Concretely, she gave a classical counterpart of the quantum recommender systems algorithm, reducing the quantum advantage to a mere polynomial. Her approach is quite general and was named quantum-inspired classical algorithms. Since then, almost all the initially exponential quantum machine learning speedups have been reduced to polynomial via new quantum-inspired classical algorithms. From the current state-of-affairs, it is unclear whether we can hope for exponential quantum speedups for any natural machine learning task.In this work, we present the first such provable exponential separation between quantum and quantum-inspired classical algorithms. We prove the separation for the basic problem of solving a linear system when the input matrix is well-conditioned and has sparse rows and columns.","Demonstrating an exponential quantum advantage for a relevant machine learning task has been an important research goal since the promising quantum algorithm by Harrow, Hassidim and Lloyd [12] for solving linear systems. Ignoring a few details, the HHL algorithm (and later improvements [4, 9]) generates a quantum state âˆ‘i=1nxiâ¢|iâŸ©superscriptsubscriptğ‘–1ğ‘›subscriptğ‘¥ğ‘–ketğ‘–\sum_{i=1}^{n}x_{i}|i\rangleâˆ‘ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT | italic_i âŸ© corresponding to the solution x=Mâˆ’1â¢yğ‘¥superscriptğ‘€1ğ‘¦x=M^{-1}yitalic_x = italic_M start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_y to an nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n linear system of equations Mâ¢x=yğ‘€ğ‘¥ğ‘¦Mx=yitalic_M italic_x = italic_y in just polyâ¡(lnâ¡n)polyğ‘›\operatorname{poly}(\ln n)roman_poly ( roman_ln italic_n ) time. At first sight, this seems exponentially faster than any classic algorithm, which probably has to read the entire input matrix Mğ‘€Mitalic_M to solve the same problem. However, as pointed out e.g. by Aaronson [1], the analysis of the HHL algorithm assumes the input matrix is given in a carefully chosen input format. Taking this state preparation into consideration, it was initially unclear how the performance could be compared to a classical algorithm and whether any quantum advantage remained. The shortcoming of the HHL algorithm regarding state preparation was later addressed in seminal work by Kerenedis and Prakash [14], who gave an end-to-end analysis (i.e. including state preparation) that can be directly compared to a classical algorithm. Concretely, their framework assumes that the input matrices and vectors to a linear algebraic machine learning problem are given as simple classical data structures, but with quantum access to the memory representations. At the time, their new quantum algorithm (for recommender systems) was exponentially faster than the best classical counterpart (which is given the same classical data structures as input). Their work sparked a fruitful line of research, yielding exponential speedups for a host of important machine learning tasks, including solving linear systems [6], linear regression [6], PCA [6], recommender systems [14], supervised clustering [15] and Hamiltonian simulation [10]. Despite the exponential speedups over classical algorithms, a lower bound for classical algorithms ruling out a similar improvement via new algorithmic ideas remained illusive. It turned out that this was for good reasons: In breakthrough work by Tang [20], it was demonstrated that on all inputs where the recommender systems algorithm by Kerenedis and Prakash yielded an exponential speedup, a similar speedup could be obtained via a classical algorithmic approach that she dubbed quantum-inspired classical (QIC) algorithms. Since then, almost all the initially exponential speedups from quantum algorithms have been reduced to mere polynomial speedups through the development of new efficient QIC algorithms, see e.g. [5, 7, 19]. The disheartening state-of-affairs is thus that only a few machine learning problems remain where there is still an exponential gap between quantum and QIC algorithms. Based on Tangâ€™s work, it remains entirely plausible that new QIC algorithms may close these gaps as well. Our Contribution. In this work, we present the first provable exponential separation between quantum and quantum-inspired classical algorithms for a central machine learning problem. Concretely, we prove a lower bound for any QIC algorithm for solving linear systems with sparse rows and columns. The lower bound is exponentially higher than known quantum upper bounds [6] when the matrix is well-conditioned, thus establishing the separation. 1.1 Quantum-Inspired Classical Algorithms In the following, we formally introduce QIC algorithms, the linear system problem, our lower bound statement and previous work on proving separations between quantum and QIC algorithms. As mentioned earlier, the work by Kerenidis and Prakash [14] gave a rigorous framework for directly comparing a quantum algorithm for a machine learning task with a classical counterpart. Taking state preparation into account, they define a natural input format for matrices and vectors in linear algebraic problems. At a high level, they assume the input is presented as a classical binary tree based data structure over the entries of the rows and columns of a matrix. They then built their quantum recommender system algorithm assuming quantum access to the memory representation of this classical data structure. Follow-up works have used essentially the same input representation or equivalent formulations. In many cases, for sufficiently well-conditioned matrices, the obtained quantum algorithms run in just polyâ¡(lnâ¡n)polyğ‘›\operatorname{poly}(\ln n)roman_poly ( roman_ln italic_n ) time. Now to prove a separation between quantum and classical algorithms, any fair comparison should use the same input representation. Given the simplicity of the data structure by Kerenidis and Prakash for representing the input, it seemed reasonable to conjecture that any classical algorithm for e.g. recommender systems would need polynomial time even when given this data structure. This intuition was however proven false by Tang [20]. Her key insight was that the classical data structure allows efficient classical (i.e. polyâ¡(lnâ¡n)polyğ‘›\operatorname{poly}(\ln n)roman_poly ( roman_ln italic_n ) time) â„“22superscriptsubscriptâ„“22\ell_{2}^{2}roman_â„“ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT sampling (formally defined below) from the rows and columns of the input, as well as efficient reading of individual entries. Exploiting this sampling access, she gave a classical algorithm for recommender systems that runs in just polyâ¡(lnâ¡n)polyğ‘›\operatorname{poly}(\ln n)roman_poly ( roman_ln italic_n ) time on all matrices where the quantum algorithm by Kerenidis and Prakash does. She referred to such classical algorithms with â„“22superscriptsubscriptâ„“22\ell_{2}^{2}roman_â„“ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT sampling access to input matrices and vectors as quantum-inspired classical algorithms. This sampling access has since then proved extremely useful in other machine learning tasks, see e.g. [5, 7, 19]. Tang [20] summarized the above discussion as follows: â€œwhen quantum machine learning algorithms are compared to classical machine learning algorithms in the context of finding speedups, any state preparation assumptions in the quantum machine learning model should be matched with â„“22superscriptsubscriptâ„“22\ell_{2}^{2}roman_â„“ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT-norm sampling assumptions in the classical machine learning modelâ€™â€™. Using the notation of Mande and Shao [17], QIC algorithms formally have the following access to the input: Definition 1 (Query Access). For a vector vâˆˆâ„nğ‘£superscriptâ„ğ‘›v\in\mathbb{R}^{n}italic_v âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, we have Qâ¢(v)ğ‘„ğ‘£Q(v)italic_Q ( italic_v ), query access to vğ‘£vitalic_v, if for all iğ‘–iitalic_i, we can query visubscriptğ‘£ğ‘–v_{i}italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT. Likewise for a matrix Mâˆˆâ„mÃ—nğ‘€superscriptâ„ğ‘šğ‘›M\in\mathbb{R}^{m\times n}italic_M âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_m Ã— italic_n end_POSTSUPERSCRIPT, we have query access to Mğ‘€Mitalic_M if for all (i,j)âˆˆ[m]Ã—[n]ğ‘–ğ‘—delimited-[]ğ‘šdelimited-[]ğ‘›(i,j)\in[m]\times[n]( italic_i , italic_j ) âˆˆ [ italic_m ] Ã— [ italic_n ], we can query Mi,jsubscriptğ‘€ğ‘–ğ‘—M_{i,j}italic_M start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT. Definition 2 (Sampling and Query Access to a Vector). For a vector vâˆˆâ„nğ‘£superscriptâ„ğ‘›v\in\mathbb{R}^{n}italic_v âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, we have Sâ¢Qâ¢(v)ğ‘†ğ‘„ğ‘£SQ(v)italic_S italic_Q ( italic_v ), sampling and query access to vğ‘£vitalic_v, if we can â€¢ Query for entries of vğ‘£vitalic_v as in Qâ¢(v)ğ‘„ğ‘£Q(v)italic_Q ( italic_v ). â€¢ Obtain independent samples of indices iâˆˆ[n]ğ‘–delimited-[]ğ‘›i\in[n]italic_i âˆˆ [ italic_n ], each distributed as â„™â¢[i]=vi2/â€–vâ€–2â„™delimited-[]ğ‘–superscriptsubscriptğ‘£ğ‘–2superscriptnormğ‘£2\mathbb{P}[i]=v_{i}^{2}/\|v\|^{2}blackboard_P [ italic_i ] = italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / âˆ¥ italic_v âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. â€¢ Query for â€–vâ€–normğ‘£\|v\|âˆ¥ italic_v âˆ¥. Definition 3 (Sampling and Query Access to a Matrix). For a matrix Mâˆˆâ„mÃ—nğ‘€superscriptâ„ğ‘šğ‘›M\in\mathbb{R}^{m\times n}italic_M âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_m Ã— italic_n end_POSTSUPERSCRIPT, we have Sâ¢Qâ¢(M)ğ‘†ğ‘„ğ‘€SQ(M)italic_S italic_Q ( italic_M ) if we have Sâ¢Qâ¢(Mi,â‹†)ğ‘†ğ‘„subscriptğ‘€ğ‘–â‹†SQ(M_{i,\star})italic_S italic_Q ( italic_M start_POSTSUBSCRIPT italic_i , â‹† end_POSTSUBSCRIPT ), Sâ¢Qâ¢(Mâ‹†,j)ğ‘†ğ‘„subscriptğ‘€â‹†ğ‘—SQ(M_{\star,j})italic_S italic_Q ( italic_M start_POSTSUBSCRIPT â‹† , italic_j end_POSTSUBSCRIPT ), Sâ¢Qâ¢(r)ğ‘†ğ‘„ğ‘ŸSQ(r)italic_S italic_Q ( italic_r ) and Sâ¢Qâ¢(c)ğ‘†ğ‘„ğ‘SQ(c)italic_S italic_Q ( italic_c ) for all iâˆˆmğ‘–ğ‘ši\in mitalic_i âˆˆ italic_m and jâˆˆnğ‘—ğ‘›j\in nitalic_j âˆˆ italic_n where râ¢(M)=(â€–M1,â‹†â€–,â€¦,â€–Mm,â‹†â€–)ğ‘Ÿğ‘€normsubscriptğ‘€1â‹†â€¦normsubscriptğ‘€ğ‘šâ‹†r(M)=(\|M_{1,\star}\|,\dots,\|M_{m,\star}\|)italic_r ( italic_M ) = ( âˆ¥ italic_M start_POSTSUBSCRIPT 1 , â‹† end_POSTSUBSCRIPT âˆ¥ , â€¦ , âˆ¥ italic_M start_POSTSUBSCRIPT italic_m , â‹† end_POSTSUBSCRIPT âˆ¥ ) and câ¢(M)=(â€–Mâ‹†,1â€–,â€¦,â€–Mâ‹†,nâ€–)ğ‘ğ‘€normsubscriptğ‘€â‹†1â€¦normsubscriptğ‘€â‹†ğ‘›c(M)=(\|M_{\star,1}\|,\dots,\|M_{\star,n}\|)italic_c ( italic_M ) = ( âˆ¥ italic_M start_POSTSUBSCRIPT â‹† , 1 end_POSTSUBSCRIPT âˆ¥ , â€¦ , âˆ¥ italic_M start_POSTSUBSCRIPT â‹† , italic_n end_POSTSUBSCRIPT âˆ¥ ). Here Mi,â‹†subscriptğ‘€ğ‘–â‹†M_{i,\star}italic_M start_POSTSUBSCRIPT italic_i , â‹† end_POSTSUBSCRIPT is the iğ‘–iitalic_iâ€™th row of Mğ‘€Mitalic_M, Mâ‹†,jsubscriptğ‘€â‹†ğ‘—M_{\star,j}italic_M start_POSTSUBSCRIPT â‹† , italic_j end_POSTSUBSCRIPT is the jğ‘—jitalic_jâ€™th column, râ¢(M)ğ‘Ÿğ‘€r(M)italic_r ( italic_M ) is the vector of row-norms and câ¢(M)ğ‘ğ‘€c(M)italic_c ( italic_M ) is the vector of column-norms of Mğ‘€Mitalic_M. With the input representation defined, we proceed to present the problem of solving a linear system via a QIC algorithm. Here one again needs to be careful for a fair comparison between quantum and QIC algorithms. Concretely, the known quantum algorithms for solving a linear system Mâ¢x=yğ‘€ğ‘¥ğ‘¦Mx=yitalic_M italic_x = italic_y do not output the full solution xğ‘¥xitalic_x (which would take linear time), but instead a quantum state âˆ‘ix~iâ¢|iâŸ©subscriptğ‘–subscript~ğ‘¥ğ‘–ketğ‘–\sum_{i}\tilde{x}_{i}|i\rangleâˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT over~ start_ARG italic_x end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT | italic_i âŸ© for a x~~ğ‘¥\tilde{x}over~ start_ARG italic_x end_ARG approximating the solution xğ‘¥xitalic_x. Taking measurements on such a state allows one to sample an index iğ‘–iitalic_i with probability x~i2/â€–x~â€–2superscriptsubscript~ğ‘¥ğ‘–2superscriptnorm~ğ‘¥2\tilde{x}_{i}^{2}/\|\tilde{x}\|^{2}over~ start_ARG italic_x end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / âˆ¥ over~ start_ARG italic_x end_ARG âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. With this in mind, the classical analog of solving a linear system is as follows. Problem 1 (Linear Systems). Given Sâ¢Qâ¢(M)ğ‘†ğ‘„ğ‘€SQ(M)italic_S italic_Q ( italic_M ) and Sâ¢Qâ¢(y)ğ‘†ğ‘„ğ‘¦SQ(y)italic_S italic_Q ( italic_y ) for a symmetric and real matrix Mâˆˆâ„nÃ—nğ‘€superscriptâ„ğ‘›ğ‘›M\in\mathbb{R}^{n\times n}italic_M âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_n end_POSTSUPERSCRIPT of full rank, a vector yâˆˆâ„nğ‘¦superscriptâ„ğ‘›y\in\mathbb{R}^{n}italic_y âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT and precision Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, the Linear Systems problem is to support sampling an index iğ‘–iitalic_i with probability x~i2/â€–x~â€–2superscriptsubscript~ğ‘¥ğ‘–2superscriptnorm~ğ‘¥2\tilde{x}_{i}^{2}/\|\tilde{x}\|^{2}over~ start_ARG italic_x end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / âˆ¥ over~ start_ARG italic_x end_ARG âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT from a vector x~~ğ‘¥\tilde{x}over~ start_ARG italic_x end_ARG satisfying that â€–x~âˆ’xâ€–â‰¤Îµâ¢â€–xâ€–norm~ğ‘¥ğ‘¥ğœ€normğ‘¥\|\tilde{x}-x\|\leq\varepsilon\|x\|âˆ¥ over~ start_ARG italic_x end_ARG - italic_x âˆ¥ â‰¤ italic_Îµ âˆ¥ italic_x âˆ¥ where x=Mâˆ’1â¢yğ‘¥superscriptğ‘€1ğ‘¦x=M^{-1}yitalic_x = italic_M start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_y is the solution to the linear system of equations Mâ¢x=yğ‘€ğ‘¥ğ‘¦Mx=yitalic_M italic_x = italic_y. The query complexity of a QIC algorithm for solving a linear system, is the number of queries to Sâ¢Qâ¢(M)ğ‘†ğ‘„ğ‘€SQ(M)italic_S italic_Q ( italic_M ) and Sâ¢Qâ¢(y)ğ‘†ğ‘„ğ‘¦SQ(y)italic_S italic_Q ( italic_y ) necessary to sample one index iğ‘–iitalic_i from x~~ğ‘¥\tilde{x}over~ start_ARG italic_x end_ARG. We remark that the known QIC algorithms furthermore output the value x~isubscript~ğ‘¥ğ‘–\tilde{x}_{i}over~ start_ARG italic_x end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT upon sampling iğ‘–iitalic_i. Since we aim to prove a lower bound, our results are only stronger if we prove it for merely sampling iğ‘–iitalic_i. Quantum Benchmark. To prove our exponential separation, we first present the state-of-the-art performance of quantum algorithms for linear systems. Here we focus on the case where the input matrix Mğ‘€Mitalic_M has sparse rows and columns, i.e. every row and column has at most sğ‘ sitalic_s non-zero entries. The running time of the best known quantum algorithm depends on the condition number of Mğ‘€Mitalic_M, defined as Îº=Ïƒmax/Ïƒmin.ğœ…subscriptğœsubscriptğœ\kappa=\sigma_{\max}/\sigma_{\min}.italic_Îº = italic_Ïƒ start_POSTSUBSCRIPT roman_max end_POSTSUBSCRIPT / italic_Ïƒ start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT . Here Ïƒmaxsubscriptğœ\sigma_{\max}italic_Ïƒ start_POSTSUBSCRIPT roman_max end_POSTSUBSCRIPT is the largest singular value of Mğ‘€Mitalic_M and Ïƒminsubscriptğœ\sigma_{\min}italic_Ïƒ start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT is the smallest singular value. Note that for real symmetric Mğ‘€Mitalic_M of full rank, all eigenvalues Î»1â‰¥â‹¯â‰¥Î»nsubscriptğœ†1â‹¯subscriptğœ†ğ‘›\lambda_{1}\geq\cdots\geq\lambda_{n}italic_Î» start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â‰¥ â‹¯ â‰¥ italic_Î» start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT of Mğ‘€Mitalic_M are real and non-zero, and the singular values Ïƒmax=Ïƒ1â‰¥â‹¯â‰¥Ïƒn=Ïƒmin>0subscriptğœsubscriptğœ1â‹¯subscriptğœğ‘›subscriptğœ0\sigma_{\max}=\sigma_{1}\geq\cdots\geq\sigma_{n}=\sigma_{\min}>0italic_Ïƒ start_POSTSUBSCRIPT roman_max end_POSTSUBSCRIPT = italic_Ïƒ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â‰¥ â‹¯ â‰¥ italic_Ïƒ start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT = italic_Ïƒ start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT > 0 are the absolute values of the eigenvalues {|Î»i|}i=1nsuperscriptsubscriptsubscriptğœ†ğ‘–ğ‘–1ğ‘›\{|\lambda_{i}|\}_{i=1}^{n}{ | italic_Î» start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT | } start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT in sorted order. Given a precision Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, matrix Mğ‘€Mitalic_M and vector yğ‘¦yitalic_y as input (in the classical data structure format), the quantum algorithm by Chakraborty, GilyÃ©n and Jeffery [6] runs in time polyâ¡(s,Îº,lnâ¡(1/Îµ),lnâ¡n)polyğ‘ ğœ…1ğœ€ğ‘›\displaystyle\operatorname{poly}(s,\kappa,\ln(1/\varepsilon),\ln n)roman_poly ( italic_s , italic_Îº , roman_ln ( 1 / italic_Îµ ) , roman_ln italic_n ) (1) to produce a quantum state âˆ‘ix~iâ¢|iâŸ©subscriptğ‘–subscript~ğ‘¥ğ‘–ketğ‘–\sum_{i}\tilde{x}_{i}|i\rangleâˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT over~ start_ARG italic_x end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT | italic_i âŸ© for a x~~ğ‘¥\tilde{x}over~ start_ARG italic_x end_ARG with â€–x~âˆ’xâ€–â‰¤Îµâ¢â€–xâ€–norm~ğ‘¥ğ‘¥ğœ€normğ‘¥\|\tilde{x}-x\|\leq\varepsilon\|x\|âˆ¥ over~ start_ARG italic_x end_ARG - italic_x âˆ¥ â‰¤ italic_Îµ âˆ¥ italic_x âˆ¥ with x=Mâˆ’1â¢yğ‘¥superscriptğ‘€1ğ‘¦x=M^{-1}yitalic_x = italic_M start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_y. We remark that to derive (1) from [6], one invokes their Lemma 11 (originating in [11]) to obtain a block-encoding of a sparse matrix and then invoke their Theorem 30. See also the recent work [16]. QIC Benchmark. The best QIC algorithm [19] for sparse linear systems instead has a query complexity (and running time) of polyâ¡(s,ÎºF,lnâ¡(1/Îµ),lnâ¡n),polyğ‘ subscriptğœ…ğ¹1ğœ€ğ‘›\displaystyle\operatorname{poly}(s,\kappa_{F},\ln(1/\varepsilon),\ln n),roman_poly ( italic_s , italic_Îº start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT , roman_ln ( 1 / italic_Îµ ) , roman_ln italic_n ) , (2) where ÎºF=â€–Mâ€–F/Ïƒmin=âˆ‘iÏƒi2Ïƒmin.subscriptğœ…ğ¹subscriptnormğ‘€ğ¹subscriptğœsubscriptğ‘–superscriptsubscriptğœğ‘–2subscriptğœ\kappa_{F}=\|M\|_{F}/\sigma_{\min}=\frac{\sqrt{\sum_{i}\sigma_{i}^{2}}}{\sigma% _{\min}}.italic_Îº start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT = âˆ¥ italic_M âˆ¥ start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT / italic_Ïƒ start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT = divide start_ARG square-root start_ARG âˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG end_ARG start_ARG italic_Ïƒ start_POSTSUBSCRIPT roman_min end_POSTSUBSCRIPT end_ARG . Since ÎºFsubscriptğœ…ğ¹\kappa_{F}italic_Îº start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT may be larger than Îºğœ…\kappaitalic_Îº by as much as a nğ‘›\sqrt{n}square-root start_ARG italic_n end_ARG factor, there are thus matrices with Îº,s=polyâ¡(lnâ¡n)ğœ…ğ‘ polyğ‘›\kappa,s=\operatorname{poly}(\ln n)italic_Îº , italic_s = roman_poly ( roman_ln italic_n ) where there is an exponential gap between (1) and (2). However, proving that a QIC algorithm with a performance matching (1) cannot be developed has so far remained out of reach. Our Result. We show the following strong lower bound for QIC algorithms Theorem 1. There is a constant c>0ğ‘0c>0italic_c > 0, such that for nâ‰¥cğ‘›ğ‘n\geq citalic_n â‰¥ italic_c and any precision Îµâ‰¤(câ¢ln2.5â¡n)âˆ’1ğœ€superscriptğ‘superscript2.5ğ‘›1\varepsilon\leq(c\ln^{2.5}n)^{-1}italic_Îµ â‰¤ ( italic_c roman_ln start_POSTSUPERSCRIPT 2.5 end_POSTSUPERSCRIPT italic_n ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT, it holds that for any QIC algorithm ğ’œğ’œ\mathcal{A}caligraphic_A for linear systems, there exists a full rank nÃ—nğ‘›ğ‘›n\times nitalic_n Ã— italic_n symmetric real matrix Mğ‘€Mitalic_M with condition number Îºâ‰¤câ¢ln2â¡nğœ…ğ‘superscript2ğ‘›\kappa\leq c\ln^{2}nitalic_Îº â‰¤ italic_c roman_ln start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n and 4444-sparse rows and columns, such that ğ’œğ’œ\mathcal{A}caligraphic_A must make Î©â¢(n1/12)Î©superscriptğ‘›112\Omega(n^{1/12})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / 12 end_POSTSUPERSCRIPT ) queries to Sâ¢Qâ¢(M)ğ‘†ğ‘„ğ‘€SQ(M)italic_S italic_Q ( italic_M ) on the linear system Mâ¢x=e1ğ‘€ğ‘¥subscriptğ‘’1Mx=e_{1}italic_M italic_x = italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. Observe that the complexity of the best quantum algorithm (1) for this setting of s,Îºğ‘ ğœ…s,\kappaitalic_s , italic_Îº and Îµğœ€\varepsilonitalic_Îµ is just polyâ¡(lnâ¡n)polyğ‘›\operatorname{poly}(\ln n)roman_poly ( roman_ln italic_n ), hence the claimed exponential separation. Furthermore, the matrix Mğ‘€Mitalic_M is extremely sparse, with only s=4ğ‘ 4s=4italic_s = 4 non-zeroes per row and column, and the vector yğ‘¦yitalic_y in the linear system Mâ¢x=yğ‘€ğ‘¥ğ‘¦Mx=yitalic_M italic_x = italic_y is simply the first standard unit vector e1subscriptğ‘’1e_{1}italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. Previous Separations. Finally, let us mention recent work by Mande and Shao [17] that also focuses on separating quantum and QIC algorithms. Using reductions from number-in-hand multiparty communication complexity [18], they prove a number of lower bounds for QIC algorithms for linear regression, supervised clustering, PCA, recommender systems and Hamiltonian simulation. Their lower bounds are of the form Î©~â¢(ÎºF2)~Î©superscriptsubscriptğœ…ğ¹2\tilde{\Omega}(\kappa_{F}^{2})over~ start_ARG roman_Î© end_ARG ( italic_Îº start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ), but only for problems where the best known quantum algorithms are no better than O~â¢(ÎºF)~ğ‘‚subscriptğœ…ğ¹\tilde{O}(\kappa_{F})over~ start_ARG italic_O end_ARG ( italic_Îº start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT ), thus establishing quadratic separations compared to our exponential separation. Let us also remark that our lower bound proof takes a completely different approach, instead reducing from a problem of random walks by Childs et al. [8]."
https://arxiv.org/html/2411.01992v1,"Ask, and it shall be given: Turing completeness of prompting","Since the success of GPT, large language models (LLMs) have been revolutionizing machine learning and have initiated the so-called LLM prompting paradigm. In the era of LLMs, people train a single general-purpose LLM and provide the LLM with different prompts to perform different tasks. However, such empirical success largely lacks theoretical understanding. Here, we present the first theoretical study on the LLM prompting paradigm to the best of our knowledge. In this work, we show that prompting is in fact Turing-complete: there exists a finite-size Transformer such that for any computable function, there exists a corresponding prompt following which the Transformer computes the function. Furthermore, we show that even though we use only a single finite-size Transformer, it can still achieve nearly the same complexity bounds as that of the class of all unbounded-size Transformers. Overall, our result reveals that prompting can enable a single finite-size Transformer to be efficiently universal, which establishes a theoretical underpinning for prompt engineering in practice.","The mainstream architecture of large language models (LLMs; e.g., OpenAI, 2024; Anthropic, 2024; Meta, 2024; Google, 2024) is Transformers (Vaswani et al., 2017). There has been a series of theoretical studies on Transformers under realistic abstractions (PÃ©rez et al., 2019; Bhattamishra et al., 2020; Hahn, 2020; PÃ©rez et al., 2021; Hao et al., 2022; Liu et al., 2023a; Chiang et al., 2023; Merrill & Sabharwal, 2023; Roberts, 2023; Merrill & Sabharwal, 2024a; b; Hou et al., 2024; Li et al., 2024). For example, PÃ©rez et al. (2021) have shown that the class of all Transformers with hardmaxhardmax\operatorname{hardmax}roman_hardmax attention is Turing-complete: for any computable function Ï†âˆˆğ–³ğ–¨ğ–¬ğ–¤1â¢(tâ¢(n))ğœ‘subscriptğ–³ğ–¨ğ–¬ğ–¤1ğ‘¡ğ‘›\varphi\in\mathsf{TIME}_{1}(t(n))italic_Ï† âˆˆ sansserif_TIME start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_t ( italic_n ) ), there exists a Transformer that computes Ï†ğœ‘\varphiitalic_Ï† using Oâ¢(tâ¢(n))Oğ‘¡ğ‘›\mathrm{O}(t(n))roman_O ( italic_t ( italic_n ) ) chain-of-thought (CoT; Wei et al., 2022b) steps and Oâ¢(logâ¡(n+tâ¢(n)))Oğ‘›ğ‘¡ğ‘›\mathrm{O}(\log(n+t(n)))roman_O ( roman_log ( italic_n + italic_t ( italic_n ) ) ) precision on length-nğ‘›nitalic_n inputs; Merrill & Sabharwal (2024a) have later improved the CoT complexity to Oâ¢(tâ¢(n))Oğ‘¡ğ‘›\mathrm{O}(t(n))roman_O ( italic_t ( italic_n ) ) for ğ–³ğ–¨ğ–¬ğ–¤â¢(tâ¢(n))ğ–³ğ–¨ğ–¬ğ–¤ğ‘¡ğ‘›\mathsf{TIME}(t(n))sansserif_TIME ( italic_t ( italic_n ) ) functions. These works have finely characterized the capacities and limits of Transformers under the classic one-model-one-task paradigm. Nevertheless, existing theoretical studies fail to align with the LLM prompting practice, i.e., the one-model-many-tasks paradigm. In the era of LLMs, people train a single general-purpose LLM and provide the LLM with different prompts to perform different tasks. Since the success of GPT (Brown et al., 2020), the LLM prompting paradigm has revolutionized machine learning (Liu et al., 2023b). For example, a bonus capability arising from prompting is zero-shot learning (Wei et al., 2022a): when provided with suitable prompts, LLMs can even perform novel tasks that are not present in their training corpora. Such empirical success calls for a theoretical understanding of the LLM prompting paradigm: Fundamentally, how powerful is the LLM prompting paradigm? We answer this call and present the first theory on the LLM prompting paradigm to the best of our knowledge. In this work, we show that prompting is in fact Turing-complete: there exists a finite-size Transformer such that for any computable function, there exists a corresponding prompt following which the Transformer computes the function. Furthermore, we show that prompting is not only universal but also efficiently universal: even though we only use a single finite-size Transformer, it can still achieve nearly the same complexity bounds as that of the class of all unbounded-size Transformers. Main contributions. Our main contributions are informally stated as follows: â€¢ Expressive power. We show that prompting is Turing-complete: there exists a finite-size Transformer Î“Î“\varGammaroman_Î“ such that for any computable function Ï†ğœ‘\varphiitalic_Ï†, there exists a finite prompt ğ…Ï†subscriptğ…ğœ‘\boldsymbol{\pi}_{\varphi}bold_italic_Ï€ start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT such that for any input ğ’™ğ’™\boldsymbol{x}bold_italic_x, the Transformer Î“Î“\varGammaroman_Î“ computes Ï†â¢(ğ’™)ğœ‘ğ’™\varphi(\boldsymbol{x})italic_Ï† ( bold_italic_x ) following the prompt ğ…Ï†subscriptğ…ğœ‘\boldsymbol{\pi}_{\varphi}bold_italic_Ï€ start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT. Importantly, our constructed Transformer Î“Î“\varGammaroman_Î“ is independent of the function Ï†ğœ‘\varphiitalic_Ï†, the prompt ğ…Ï†subscriptğ…ğœ‘\boldsymbol{\pi}_{\varphi}bold_italic_Ï€ start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT is independent of the input ğ’™ğ’™\boldsymbol{x}bold_italic_x, and the input ğ’™ğ’™\boldsymbol{x}bold_italic_x can be arbitrarily long. â€¢ CoT complexity. Our Î“Î“\varGammaroman_Î“ can compute any ğ–³ğ–¨ğ–¬ğ–¤2â¢(tâ¢(n))subscriptğ–³ğ–¨ğ–¬ğ–¤2ğ‘¡ğ‘›\mathsf{TIME}_{2}(t(n))sansserif_TIME start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_t ( italic_n ) ) function within Oâ¢(tâ¢(n))Oğ‘¡ğ‘›\mathrm{O}(t(n))roman_O ( italic_t ( italic_n ) ) CoT steps and can compute any ğ–³ğ–¨ğ–¬ğ–¤â¢(tâ¢(n))ğ–³ğ–¨ğ–¬ğ–¤ğ‘¡ğ‘›\mathsf{TIME}(t(n))sansserif_TIME ( italic_t ( italic_n ) ) function within Oâ¢(tâ¢(n)â¢logâ¡tâ¢(n))Oğ‘¡ğ‘›ğ‘¡ğ‘›\mathrm{O}(t(n)\log t(n))roman_O ( italic_t ( italic_n ) roman_log italic_t ( italic_n ) ) CoT steps for any length-nğ‘›nitalic_n input. Notably, our result shows that even a single Transformer can still achieve nearly the same CoT complexity as the class of all Transformers does. â€¢ Precision complexity. Our constructed Î“Î“\varGammaroman_Î“ can compute any ğ–³ğ–¨ğ–¬ğ–¤â¢(tâ¢(n))ğ–³ğ–¨ğ–¬ğ–¤ğ‘¡ğ‘›\mathsf{TIME}(t(n))sansserif_TIME ( italic_t ( italic_n ) ) function within Oâ¢(logâ¡(n+tâ¢(n)))Oğ‘›ğ‘¡ğ‘›\mathrm{O}(\log(n+t(n)))roman_O ( roman_log ( italic_n + italic_t ( italic_n ) ) ) bits of precision for any length-nğ‘›nitalic_n input. Notably, our result shows that even a single Transformer can still achieve the same precision complexity as the class of all Transformers does. In particular, Î“Î“\varGammaroman_Î“ can decide any ğ–¯ğ–¯\mathsf{P}sansserif_P language within log-precision. 1.1 Related work Existing theoretical studies on Transformers fall under the classic one-model-one-task paradigm: they need to construct different Transformers for different tasks. There are two lines of related work: (i) when at most Oâ¢(1)O1\mathrm{O}(1)roman_O ( 1 ) CoT steps are allowed, it has been shown that Transformers are capable but far from Turing-complete (Hahn, 2020; Hao et al., 2022; Liu et al., 2023a; Chiang et al., 2023; Merrill & Sabharwal, 2023; 2024b); (ii) when more CoT steps are allowed, it has been shown that the expressive power of Transformers increases with the number of CoT steps (PÃ©rez et al., 2019; Bhattamishra et al., 2020; PÃ©rez et al., 2021; Roberts, 2023; Merrill & Sabharwal, 2024a; Hou et al., 2024; Li et al., 2024). Besides that, there have recently been studies on the learnability (Malach, 2023; Grau-Moya et al., 2024) and the in-context learning capability (AkyÃ¼rek et al., 2022; von Oswald et al., 2023; Zhang et al., 2024; Ahn et al., 2024; Vladymyrov et al., 2024). Nevertheless, no existing work studies the LLM prompting paradigm (i.e., the one-model-many-tasks paradigm). Our work is the first to bridge this gap to the best of our knowledge. 1.2 Technical overview A core step of our proof is to construct a new model of computation (called 2222-PTMs) that can be easily encoded into a prompt using a finite alphabet. Furthermore, we show that 2222-PTMs are not only Turing-complete but also nearly as efficient as Turing machines. Theorem (informal version of Theorem 4.1). Any ğ–³ğ–¨ğ–¬ğ–¤â¢(tâ¢(n))ğ–³ğ–¨ğ–¬ğ–¤ğ‘¡ğ‘›\mathsf{TIME}(t(n))sansserif_TIME ( italic_t ( italic_n ) ) function can be computed by a 2222-PTM within Oâ¢(tâ¢(n)â¢logâ¡tâ¢(n))Oğ‘¡ğ‘›ğ‘¡ğ‘›\mathrm{O}(t(n)\log t(n))roman_O ( italic_t ( italic_n ) roman_log italic_t ( italic_n ) ) steps. âˆ Given any computable function Ï†ğœ‘\varphiitalic_Ï†, we encode its 2222-PTM into a prompt ğ…Ï†subscriptğ…ğœ‘\boldsymbol{\pi}_{\varphi}bold_italic_Ï€ start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT. Then, it remains to construct a Transformer Î“Î“\varGammaroman_Î“ that can execute 2222-PTMs. Since it is known that Transformers without CoTs are not universal (Hahn, 2020), the Transformer Î“Î“\varGammaroman_Î“ needs to use CoT steps to execute 2222-PTMs. Specifically, we use CoT steps to record the execution steps of the 2222-PTM so that the Transformer can restore the state of the 2222-PTM at any step. This establishes the CoT complexity of Î“Î“\varGammaroman_Î“. Corollary (informal version of Corollary 4.5). Our constructed Î“Î“\varGammaroman_Î“ can compute any ğ–³ğ–¨ğ–¬ğ–¤â¢(tâ¢(n))ğ–³ğ–¨ğ–¬ğ–¤ğ‘¡ğ‘›\mathsf{TIME}(t(n))sansserif_TIME ( italic_t ( italic_n ) ) function within Oâ¢(tâ¢(n)â¢logâ¡tâ¢(n))Oğ‘¡ğ‘›ğ‘¡ğ‘›\mathrm{O}(t(n)\log t(n))roman_O ( italic_t ( italic_n ) roman_log italic_t ( italic_n ) ) CoT steps. To incorporate input ğ’™ğ’™\boldsymbol{x}bold_italic_x into computation, we use Oâ¢(|ğ’™|)Oğ’™\mathrm{O}(|\boldsymbol{x}|)roman_O ( | bold_italic_x | ) CoT steps to emulate an imaginary process of writing the input ğ’™ğ’™\boldsymbol{x}bold_italic_x onto a tape of the 2222-PTM. This implies the precision complexity of Î“Î“\varGammaroman_Î“. Corollary (informal version of Corollary 4.7). Our constructed Î“Î“\varGammaroman_Î“ can compute any ğ–³ğ–¨ğ–¬ğ–¤â¢(tâ¢(n))ğ–³ğ–¨ğ–¬ğ–¤ğ‘¡ğ‘›\mathsf{TIME}(t(n))sansserif_TIME ( italic_t ( italic_n ) ) function within Oâ¢(logâ¡(n+tâ¢(n)))Oğ‘›ğ‘¡ğ‘›\mathrm{O}(\log(n+t(n)))roman_O ( roman_log ( italic_n + italic_t ( italic_n ) ) ) bits of precision. Finally, we construct a decoder-only Transformer that achieves the desiderata above by leveraging ReLU activation, layer normalization, and causal attention."
https://arxiv.org/html/2411.01718v1,Toward Separating QMA from QCMA with a Classical Oracle,"QMA is the class of languages that can be decided by an efficient quantum verifier given a quantum witness, whereas QCMA is the class of such languages where the efficient quantum verifier only is given a classical witness. A challenging fundamental goal in quantum query complexity is to find a classical oracle separation for these classes. In this work, we offer a new approach towards proving such a separation that is qualitatively different than prior work, and show that our approach is sound assuming a natural statistical conjecture which may have other applications to quantum query complexity lower bounds.","Do quantum witnesses offer more power than classical witnesses? Slightly more precisely, there are two natural ways to generalize ğ–­ğ–¯ğ–­ğ–¯{\sf NP}sansserif_NP from the classical setting to the quantum setting: ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA (for Quantum Merlin-Arthur) is the set of languages decidable by efficient quantum algorithms with quantum witnesses, whereas ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA (for Quantum Classical Merlin-Arthur) is the set of languages decidable by efficient quantum algorithms with classical witnesses. A long-standing fundamental question, first raised by [AN02], is whether or not these two generalizations of ğ–­ğ–¯ğ–­ğ–¯{\sf NP}sansserif_NP are the same. As an unconditional separation between ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA and ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA is out of reach given the state of complexity theory, the community has focused on proving oracle separations. The first such separation [AK07] gives a quantum oracle; that is, an oracle that implements a unitary operation and which can be queried on quantum states. A major open question has been whether there is a classical oracle separation; that is, an oracle that implements a classical function, but is accessible in superposition. Classical oracle separations are considered more standard in the community. An early candidate classical oracle separation was given by [Lut11], but no proof was given. More recently, there have been several results making progress towards this goal by proving separations under different restrictions on how the oracle is accessed. [FK18] show a separation assuming the classical oracle is an â€œin-place permutation oracleâ€, a non-standard modeling where the oracle irreversibly permutes the input state. [NN23] show a separation, assuming the witness is required to be independent of certain choices made in constructing the oracle. A very recent line of work has used quantum advantage relative to unstructured oracles [YZ22] to separate ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA from ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA: [Liu23, LLPY24] give a separation assuming the verifier can only make classical oracle queries, and more recently [BDK24] give a separation which allows the verifier quantum queries, but assumes the adaptivity of the queries is sub-logarithmic. A standard classical oracle separation that makes no constraints on how the oracle is accessed or how the witness is created still remains open. The central challenge in separating ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA from ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA relative to a classical oracle seems to be the following. Consider a language in ğ–°ğ–¬ğ– âˆ–ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QMA}\setminus{\sf QCMA}sansserif_QMA âˆ– sansserif_QCMA, and consider measuring the ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA witness in the computational basis. The resulting classical string must not be accepted by the ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA verifier, since otherwise we would then have a classical witness for the language, putting it in ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA. Therefore, in some sense, the ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA verifier needs to verify that the witness is in superposition. In order to allow for such verification using only a classical oracle, existing approaches require highly structured oracles. But then to actually prove the language is outside of ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA, we need a quantum query complexity lower-bound, and unfortunately the techniques we have are often not amenable to highly structured oracles. Additionally, any witness would naturally be treated as a form of oracle-dependent advice about the oracle, and most quantum query complexity techniques are not very good at distinguishing between quantum advice and classical advice. In other words, if a typical technique succeeded at proving a language is outside of ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA, then if it cannot distinguish quantum vs classical advice, it would likely also show that the language is outside ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA as well, thus failing to give a separation. Our Work. We give a new approach for separating ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA from ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA relative to a classical oracle. Like prior work, we are unable to prove our oracle separation unconditionally. However, our separation appears much less structured than the prior work (though this is an intuitive statement rather than a formal one), and appears much more amenable to existing quantum query complexity techniques. In particular, we prove under a natural conjecture about kğ‘˜kitalic_k-wise independent distributions that our separation indeed works. We believe our work adds to the evidence that ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA and ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA are indeed distinct relative to classical oracles, and may offer a new path toward a proof. 1.1 Our Separating Oracles Our basic idea is the following. An instance in our language will correspond to a subset SâŠ†[N]ğ‘†delimited-[]ğ‘S\subseteq[N]italic_S âŠ† [ italic_N ] where Nğ‘Nitalic_N is exponentially-sized. Sğ‘†Sitalic_S will be chosen to only contain a negligible fraction of [N]delimited-[]ğ‘[N][ italic_N ], but still be super-polynomial sized. We will provide a classical oracle (accessible in superposition) that decides membership in Sğ‘†Sitalic_S. We will often simply call this oracle Sğ‘†Sitalic_S. Next, we choose a random state |ÏˆâŸ©=âˆ‘yâˆˆSÎ±yâ¢|yâŸ©ketğœ“subscriptğ‘¦ğ‘†subscriptğ›¼ğ‘¦ketğ‘¦|\psi\rangle=\sum_{y\in S}\alpha_{y}|y\rangle| italic_Ïˆ âŸ© = âˆ‘ start_POSTSUBSCRIPT italic_y âˆˆ italic_S end_POSTSUBSCRIPT italic_Î± start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT | italic_y âŸ© with support on the set Sğ‘†Sitalic_S. The state |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© will be our witness state for the ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA instance. An incomplete verification for |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© proceeds by simply checking that |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© has support contained in Sğ‘†Sitalic_S. Essentially, |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© is acting as a ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA witness that Sğ‘†Sitalic_S is non-empty. But there is also a simple ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA witness for this fact: any classical value yâˆˆSğ‘¦ğ‘†y\in Sitalic_y âˆˆ italic_S. We will instead attempt to turn |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© into a witness that Sğ‘†Sitalic_S is super-polynomial sized. To do so, we will add a second oracle Uğ‘ˆUitalic_U which essentially attests to |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© being a superposition over super-polynomially-many points. Intuitively, we want to show that Uğ‘ˆUitalic_U can distinguish between |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© and any state whose support is only polynomial-sized. To construct Uğ‘ˆUitalic_U, let |Ïˆ^âŸ©ket^ğœ“|\hat{\psi}\rangle| over^ start_ARG italic_Ïˆ end_ARG âŸ© denote the quantum Fourier transform (QFT) of |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ©. We observe that if |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© has support on a single point yğ‘¦yitalic_y, then |Ïˆ^âŸ©ket^ğœ“|\hat{\psi}\rangle| over^ start_ARG italic_Ïˆ end_ARG âŸ© will have uniform amplitude on all points in [N]delimited-[]ğ‘[N][ italic_N ] (though with complex phases on these points). On the other hand, for random |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© with support on the large set Sğ‘†Sitalic_S, the amplitudes on different points will vary. Concretely, while the expected squared-amplitude on any point zâˆˆ[N]ğ‘§delimited-[]ğ‘z\in[N]italic_z âˆˆ [ italic_N ] is 1/N1ğ‘1/N1 / italic_N, there is a reasonable chance that it could be, say, smaller than 1/2â¢N12ğ‘1/2N1 / 2 italic_N or larger than 2/N2ğ‘2/N2 / italic_N. We will choose Uğ‘ˆUitalic_U to be a subset of [N]delimited-[]ğ‘[N][ italic_N ] consisting of points where |Ïˆ^âŸ©ket^ğœ“|\hat{\psi}\rangle| over^ start_ARG italic_Ïˆ end_ARG âŸ© has squared-amplitude somewhat larger than 1/N1ğ‘1/N1 / italic_N. We can then have, say, the total squared-amplitude of |Ïˆ^âŸ©ket^ğœ“|\hat{\psi}\rangle| over^ start_ARG italic_Ïˆ end_ARG âŸ© on points in Uğ‘ˆUitalic_U be roughly 3/4343/43 / 4 while |U|/Nğ‘ˆğ‘|U|/N| italic_U | / italic_N is only roughly 1/2121/21 / 2. In this case, the QFT of a classical string yğ‘¦yitalic_y will have squared-amplitude on Uğ‘ˆUitalic_U of only 1/2121/21 / 2. Thus, Uğ‘ˆUitalic_U enables distinguishing |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© from a classical input. We will therefore give out an oracle for deciding membership in Uğ‘ˆUitalic_U. The verifier will first confirm that |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© has support only on Sğ‘†Sitalic_S using the oracle for Sğ‘†Sitalic_S. Then it will compute |Ïˆ^âŸ©ket^ğœ“|\hat{\psi}\rangle| over^ start_ARG italic_Ïˆ end_ARG âŸ© via the QFT, and check that the support is in Uğ‘ˆUitalic_U. Overall the verifier accepts with probability 3/4343/43 / 4. Instances not in the language will consist of S,Uğ‘†ğ‘ˆS,Uitalic_S , italic_U pairs where Sğ‘†Sitalic_S is very small but non-empty. We show that, for a certain way of choosing Uğ‘ˆUitalic_U, that there is no ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA witness in the case of such small Sğ‘†Sitalic_S. Thus, our language is in ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA relative to the oracles for S,Uğ‘†ğ‘ˆS,Uitalic_S , italic_U. 1.2 ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA hardness We now need a way to argue that our language does not have ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA witnesses. While we showed that a classical string yâˆˆSğ‘¦ğ‘†y\in Sitalic_y âˆˆ italic_S cannot serve as a witness, this alone does not preclude some more clever way of attesting to Sğ‘†Sitalic_S being large. In particular, the witness wğ‘¤witalic_w could contain several points in Sğ‘†Sitalic_S. Worse, perhaps queries to Uğ‘ˆUitalic_U may reveal a significant amount of information about Sğ‘†Sitalic_S, which may help deciding if Sğ‘†Sitalic_S is large or small. We make progress toward showing ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA hardness of our oracle problem, as we now describe. Consider a hypothetical ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA verifier Vğ‘‰Vitalic_V which is given a classical witness wğ‘¤witalic_w and makes quantum queries to S,Uğ‘†ğ‘ˆS,Uitalic_S , italic_U, and accepts in the case Sğ‘†Sitalic_S is large. We want to show that we can replace Sğ‘†Sitalic_S with a small set Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, and Vğ‘‰Vitalic_V will still accept with too-high a probability, meaning it incorrectly claims that (Sâ€²,U)superscriptğ‘†â€²ğ‘ˆ(S^{\prime},U)( italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT , italic_U ) is in the language, despite Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT being small. Toward that end, we will choose Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT to be all points in Sğ‘†Sitalic_S that are also â€œheavyâ€ among the queries Vğ‘‰Vitalic_V makes to Sğ‘†Sitalic_S. That is, points yâˆˆSğ‘¦ğ‘†y\in Sitalic_y âˆˆ italic_S such that the query amplitude in Vğ‘‰Vitalic_Vâ€™s quantum queries to Sğ‘†Sitalic_S is above some inverse-polynomial threshold. As the total query amplitude of all points is just the number of queries of Vğ‘‰Vitalic_V and hence polynomial, the number of heavy yğ‘¦yitalic_y is polynomial. Hence, Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT is small. We can also construct Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT efficiently: for each heavy yğ‘¦yitalic_y, running Vğ‘‰Vitalic_V and measuring a random query will have an inverse polynomial chance of producing yğ‘¦yitalic_y. By repeating this process a polynomial number of times, we can collect all heavy queries. But why should Sğ‘†Sitalic_S and Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT be indistinguishable to Vğ‘‰Vitalic_V? By standard quantum query analysis, if Vğ‘‰Vitalic_V can distinguish Sğ‘†Sitalic_S from Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, then itâ€™s queries must place significant amplitude on Sâˆ–Sâ€²ğ‘†superscriptğ‘†â€²S\setminus S^{\prime}italic_S âˆ– italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. By measuring a random query, we therefore obtain with significant probability a yâˆˆSâˆ–Sâ€²ğ‘¦ğ‘†superscriptğ‘†â€²y\in S\setminus S^{\prime}italic_y âˆˆ italic_S âˆ– italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. But since yğ‘¦yitalic_y is not heavy, repeating this process many times will produce many different yğ‘¦yitalic_y. This means that if Vğ‘‰Vitalic_V can distinguish Sğ‘†Sitalic_S from Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, it must actually be able to generate essentially arbitrarily large (polynomial) numbers of yâˆˆSğ‘¦ğ‘†y\in Sitalic_y âˆˆ italic_S. Denote the number of yğ‘¦yitalic_y by Lğ¿Litalic_L. Vğ‘‰Vitalic_V that do not query Uğ‘ˆUitalic_U. Let us first assume that Vğ‘‰Vitalic_V makes no queries to Uğ‘ˆUitalic_U. In this case, we can argue that any distinguishing Vğ‘‰Vitalic_V actually violates known query complexity results for multiple Grover search. In particular, [HM23] show that an algorithm making polynomially-many queries to a random sparse Sğ‘†Sitalic_S cannot produce Lğ¿Litalic_L points in Sğ‘†Sitalic_S except with probability bounded by 2âˆ’Lsuperscript2ğ¿2^{-L}2 start_POSTSUPERSCRIPT - italic_L end_POSTSUPERSCRIPT (see Lemma 2.6 for precise statement). Now, this result assumes no advice is provided about Sğ‘†Sitalic_S, but the witness wğ‘¤witalic_w counts as advice. Fortunately, we can handle the advice using the strong exponential lower bound provided by [HM23]. Consider running the process above with a random wâ€²superscriptğ‘¤â€²w^{\prime}italic_w start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT instead of wğ‘¤witalic_w. In the event wâ€²=wsuperscriptğ‘¤â€²ğ‘¤w^{\prime}=witalic_w start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT = italic_w, the process will produce Lğ¿Litalic_L points in Sğ‘†Sitalic_S. Moreover, wâ€²=wsuperscriptğ‘¤â€²ğ‘¤w^{\prime}=witalic_w start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT = italic_w with probability 2âˆ’|w|superscript2ğ‘¤2^{-|w|}2 start_POSTSUPERSCRIPT - | italic_w | end_POSTSUPERSCRIPT. By setting Lâ‰«|w|much-greater-thanğ¿ğ‘¤L\gg|w|italic_L â‰« | italic_w | (recall that we can make Lğ¿Litalic_L an arbitrarily large polynomial), we therefore obtain an algorithm with no advice which produces Lğ¿Litalic_L points in Sğ‘†Sitalic_S with probability 2âˆ’|w|â‰«2âˆ’Lmuch-greater-thansuperscript2ğ‘¤superscript2ğ¿2^{-|w|}\gg 2^{-L}2 start_POSTSUPERSCRIPT - | italic_w | end_POSTSUPERSCRIPT â‰« 2 start_POSTSUPERSCRIPT - italic_L end_POSTSUPERSCRIPT, contradicting the hardness of multiple Grover search. Remark 1.1. The above strategy inherently uses the fact that wğ‘¤witalic_w is classical. If Vğ‘‰Vitalic_V had a quantum witness/advice, running it even once and measuring a random query to find a yâˆˆSğ‘¦ğ‘†y\in Sitalic_y âˆˆ italic_S would potentially destroy the witness, meaning further runs of Vğ‘‰Vitalic_V are not guaranteed to produce any points in Sğ‘†Sitalic_S. This is the key place in the proof where we distinguish between classical and quantum witnesses, hopefully indicating a promising route toward proving a separation between ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA and ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA. kğ‘˜kitalic_k-wise independent Uğ‘ˆUitalic_U. The above strategy does not work for handling queries to Uğ‘ˆUitalic_U. The problem is that Uğ‘ˆUitalic_U takes potentially Nğ‘Nitalic_N bits (which is exponential) to describe, meaning treating Uğ‘ˆUitalic_U as advice would require setting Lâ‰«Nmuch-greater-thanğ¿ğ‘L\gg Nitalic_L â‰« italic_N, at which point the bounds from [HM23] do not apply. We will for now assume that Uğ‘ˆUitalic_U is kğ‘˜kitalic_k-wise independent for a super-polynomial kğ‘˜kitalic_k, and return to justifying this assumption later. We will assume such kğ‘˜kitalic_k-wise independence holds even conditioned on Sğ‘†Sitalic_S (but not conditioned on |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ©, whose correlation with Uğ‘ˆUitalic_U is crucial for the correctness of our ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA verifier). A result of [Zha12] (formally described in Lemma 2.5) shows that a kğ‘˜kitalic_k-wise independent Uğ‘ˆUitalic_U is actually perfectly indistinguishable from a uniform Uğ‘ˆUitalic_U, for all quantum query algorithms making at most k/2ğ‘˜2k/2italic_k / 2 queries. Since kğ‘˜kitalic_k is super-polynomial, we thus obtain perfect indistinguishability against all polynomial-query algorithms, including our process above for generating points in Sğ‘†Sitalic_S. Consequently, the process above succeeds in generating Lğ¿Litalic_L points in Sğ‘†Sitalic_S even if Uğ‘ˆUitalic_U is replaced by a uniformly random Uğ‘ˆUitalic_U independent of Sğ‘†Sitalic_S. But such a uniform Uğ‘ˆUitalic_U can be simulated without knowledge of Sğ‘†Sitalic_S at all, and hence the lower-bound of [HM23] actually applies to algorithms making queries to uniform Uğ‘ˆUitalic_U. Thus under the assumption that Uğ‘ˆUitalic_U is kğ‘˜kitalic_k-wise independent, we can justify ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA hardness. Our Uğ‘ˆUitalic_U are â€œcloseâ€ to kğ‘˜kitalic_k-wise independent. We show that, by choosing Uğ‘ˆUitalic_U carefully in a probabilistic way, Uğ‘ˆUitalic_U is â€œcloseâ€ to kğ‘˜kitalic_k-wise independent, even conditioned on Sğ‘†Sitalic_S. By â€œcloseâ€, we concretely mean that for every subset TâŠ†[N]ğ‘‡delimited-[]ğ‘T\subseteq[N]italic_T âŠ† [ italic_N ] of size at most kğ‘˜kitalic_k, that 2âˆ’|T|â‰¤Prâ¡[Tâˆ©U=âˆ…]â‰¤(1+Ïµ)Ã—2âˆ’|T|superscript2ğ‘‡Prğ‘‡ğ‘ˆ1italic-Ïµsuperscript2ğ‘‡2^{-|T|}\leq\Pr[T\cap U=\emptyset]\leq(1+\epsilon)\times 2^{-|T|}2 start_POSTSUPERSCRIPT - | italic_T | end_POSTSUPERSCRIPT â‰¤ roman_Pr [ italic_T âˆ© italic_U = âˆ… ] â‰¤ ( 1 + italic_Ïµ ) Ã— 2 start_POSTSUPERSCRIPT - | italic_T | end_POSTSUPERSCRIPT, for some very small Ïµitalic-Ïµ\epsilonitalic_Ïµ which depends on k,|S|,Nğ‘˜ğ‘†ğ‘k,|S|,Nitalic_k , | italic_S | , italic_N. Note that true kğ‘˜kitalic_k-wise independence is equivalent to Prâ¡[Tâˆ©U=âˆ…]=2âˆ’|T|Prğ‘‡ğ‘ˆsuperscript2ğ‘‡\Pr[T\cap U=\emptyset]=2^{-|T|}roman_Pr [ italic_T âˆ© italic_U = âˆ… ] = 2 start_POSTSUPERSCRIPT - | italic_T | end_POSTSUPERSCRIPT for all Tğ‘‡Titalic_T of size at most kğ‘˜kitalic_k. Is this â€œcloseâ€ enough? Unfortunately, we do not know how to prove that Uğ‘ˆUitalic_U which are close to kğ‘˜kitalic_k-wise independent are sufficient to make our approach work. The issue is that [Zha12] only applies to perfect kğ‘˜kitalic_k-wise independence, and there are counterexamples that show that the result does not hold when replaced with some approximate notions of kğ‘˜kitalic_k-wise independence. The good news is that our notion of closeness is quite different from the usual notion of â€œbiasedâ€ or â€œalmostâ€ kğ‘˜kitalic_k-wise independence used in the literature. Specifically, those notions allow for an additive error in any of the marginal probabilities, whereas we impose a strong multiplicative error bound. This gives us hope that our distribution of Uğ‘ˆUitalic_U, despite not being truly kğ‘˜kitalic_k-wise independent, may still be close enough to get a separation. We make progress toward justifying this claim. We make a conjecture that any distribution over Uğ‘ˆUitalic_U which is â€œcloseâ€ to kğ‘˜kitalic_k-wise independent (in our sense) can be turned into a distribution Uâ€²superscriptğ‘ˆâ€²U^{\prime}italic_U start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT that is truly kğ‘˜kitalic_k-wise independent. Importantly, Uğ‘ˆUitalic_U and Uâ€²superscriptğ‘ˆâ€²U^{\prime}italic_U start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT will agree on almost all points. More precisely, for any zğ‘§zitalic_z, the probability that Uğ‘ˆUitalic_U and Uâ€²superscriptğ‘ˆâ€²U^{\prime}italic_U start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT differ on zğ‘§zitalic_z is negligible. See Conjecture 3.2 for the formal statement of this conjecture. Observe that this conjecture is simply a statement about distributions, and has nothing on the surface to do with quantum query complexity. Under this conjecture, we complete the full oracle separation between ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA and ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA. Instead of giving out the oracle Uğ‘ˆUitalic_U, we simply give out the oracle Uâ€²superscriptğ‘ˆâ€²U^{\prime}italic_U start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, and prove ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA hardness following the above approach. Our statistical conjecture is then used to show that replacing Uğ‘ˆUitalic_U with Uâ€²superscriptğ‘ˆâ€²U^{\prime}italic_U start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT does not break our ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA verifier. Concretely, by standard query complexity arguments, we show that if our verifier works on Uğ‘ˆUitalic_U, then it must also work (with negligibly larger error) on Uâ€²superscriptğ‘ˆâ€²U^{\prime}italic_U start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. Remark 1.2. Our statistical conjecture gives one way to prove an oracle separation between ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA and ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA following our approach. Our conjecture could of course turn out to be false. Even in this case, our oracles still seem likely to give a separation, and there may be many other paths toward proving it. Perhaps if the general conjecture is false, our particular Uğ‘ˆUitalic_U can still be converted into Uâ€²superscriptğ‘ˆâ€²U^{\prime}italic_U start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT as needed. Or maybe being â€œcloseâ€ to kğ‘˜kitalic_k-wise independent is directly sufficient for a separation and can be proven via quantum query complexity arguments. Possibly there is a different distribution over |ÏˆâŸ©ketğœ“|\psi\rangle| italic_Ïˆ âŸ© and associated Uğ‘ˆUitalic_U where Uğ‘ˆUitalic_U actually is perfectly kğ‘˜kitalic_k-wise independent. Thus, independent of our particular statistical conjecture, we believe our new approach at a separation gives a promising new approach toward separating ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– {\sf QMA}sansserif_QMA from ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– {\sf QCMA}sansserif_QCMA relative to classical oracles."
https://arxiv.org/html/2411.01663v1,Unlocking the Theory Behind Scaling 1-Bit Neural Networks,"Recently, 1-bit Large Language Models (LLMs) have emerged, showcasing an impressive combination of efficiency and performance that rivals traditional LLMs. Research by WMD+ [91], MWM+ [70] indicates that the performance of these 1-bit LLMs progressively improves as the number of parameters increases, hinting at the potential existence of a Scaling Law for 1-bit Neural Networks. In this paper, we present the first theoretical result that rigorously establishes this scaling law for 1-bit models. We prove that, despite the constraint of weights restricted to {âˆ’1,+1}11\{-1,+1\}{ - 1 , + 1 }, the dynamics of model training inevitably align with kernel behavior as the network width grows. This theoretical breakthrough guarantees convergence of the 1-bit model to an arbitrarily small loss as width increases. Furthermore, we introduce the concept of the generalization difference, defined as the gap between the outputs of 1-bit networks and their full-precision counterparts, and demonstrate that this difference maintains a negligible level as network width scales. Building on the work of KMH+ [51], we conclude by examining how the training loss scales as a power-law function of the model size, dataset size, and computational resources utilized for training. Our findings underscore the promising potential of scaling 1-bit neural networks, suggesting that int1 could become the standard in future neural network precision.","Large-scale neural networks, particularly Large Language Models (LLMs) [20, 106] and Large Multimodel Models (LMMs) [97, 87], are becoming increasingly relevant to our day-to-day lives, finding a huge variety of applications in both the workplace and at home [55, 98]. However, it is expensive to deploy and run these models due to their substantial computational requirements, large memory footprints, and energy consumption [86, 5, 103]. This is especially true for resource-constrained environments, such as mobile devices, edge computing, or companies with limited infrastructure [47, 69, 24]. To make these models more efficient and accessible, quantization techniques are used, which reduce the precision of the modelâ€™s parameters (such as weights and activations) from floating-point numbers to lower-bit representations (e.g., 8-bit or even lower) [72, 30, 33, 66, 2]. Quantization reduces the memory and computational costs of inference, enabling faster processing with less energy, while maintaining a comparable level of performance. This optimization allows language models to be more practical, scalable, and sustainable for widespread use across various platforms [21, 60, 35]. In particular, quantization techniques could be primarily divided into two methods: Post-Training Quantization (PTQ) [67, 94, 83] and Quantization-Aware Training (QAT) [62, 91, 70]. PTQ methods, including uniform and non-uniform quantization, conveniently convert pre-trained model weights and activations to lower-bit representations post-training. However, this leads to accuracy loss, especially in lower precision, as the model is not optimized for these quantized representations and significant shifts in weight distribution occur [73]. The alternative, Quantization-Aware Training (QAT), incorporates quantization during training, allowing the model to fine-tune and adapt its parameters to the quantized representation, compensating for quantization errors. Therefore, compared to PTQ, QAT maintains higher accuracy and robustness even in lower precision. Recent studies [61, 91, 70, 107] have shown that 1111-bit LLMs, most of which have matrix weights in the range of {âˆ’1,+1}11\{-1,+1\}{ - 1 , + 1 }, can be trained from scratch to deliver performance that rivals that of standard LLMs. These models exhibit remarkable efficiency, particularly in terms of scaling laws. Experimental results indicate that the performance of the 1111-bit model improves as the number of parameters increases, a principle that mirrors the training approach utilized in standard LLMs [51]. Despite the demonstrated efficiency of quantization methods, our understanding of the training mechanism for quantization remains limited. Specifically, it remains unclear how and why the 1111-bit QAT enhances learning capability as the number of neurons in the model is scaled up. In addition, we are also concerned about whether the quantization method damages the generalization ability compared to full precision networks. In this study, we initially apply the Neural Tangent Kernel (NTK) framework to delve into the optimization and generalization issues associated with a two-layer linear network operating in 1-bit (int1) precision, as detailed in Section 4. We introduce a 1-bit quantization method to the hidden-layer weights Wâˆˆâ„dÃ—mğ‘Šsuperscriptâ„ğ‘‘ğ‘šW\in\mathbb{R}^{d\times m}italic_W âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d Ã— italic_m end_POSTSUPERSCRIPT of the conventional NTK linear network, where dğ‘‘ditalic_d represents the input dimension and mğ‘šmitalic_m indicates the modelâ€™s width. Our analysis reveals that the training dynamics of the 1-bit model approximate kernel behavior as the model width mğ‘šmitalic_m expands. This key finding paves the way for an established relationship between the theoretically guaranteed loss and the model width, endowing the model with robust learning capabilities akin to kernel regression. Ultimately, the model achieves an insignificantly small training loss, contingent on setting a sufficiently large model width, selecting an appropriate learning rate, and allowing an adequate training duration. Moreover, Section 5 provides a theoretical confirmation that, within the scaling trend, the disparities in predictions of the 1-bit model from those of the original linear network on identical inputs maintain a negligible value. We assess the error between our 1-bit linear and standard linear networks on both the training and test datasets. Our theorem demonstrates that for any input from these datasets, the absolute error between the two network predictions can be denoted as Ïµquantâ‰¤Oâ¢(Îºâ¢dâ¢logâ¡(mâ¢d/Î´))subscriptitalic-Ïµquantğ‘‚ğœ…ğ‘‘ğ‘šğ‘‘ğ›¿\epsilon_{\rm quant}\leq O(\kappa d\log(md/\delta))italic_Ïµ start_POSTSUBSCRIPT roman_quant end_POSTSUBSCRIPT â‰¤ italic_O ( italic_Îº italic_d roman_log ( italic_m italic_d / italic_Î´ ) ) for scale coefficient Îºâ‰¤1ğœ…1\kappa\leq 1italic_Îº â‰¤ 1, model width mğ‘šmitalic_m, dimension dğ‘‘ditalic_d and failure probability Î´âˆˆ(0,0.1)ğ›¿00.1\delta\in(0,0.1)italic_Î´ âˆˆ ( 0 , 0.1 ). This indicates that the output behavior of the 1-bit linear model increasingly aligns with that of the standard linear model. The observed similarity on the test dataset validates the generalization similarity, suggesting the feasibility of approximating training neural networks with int1 precision equivalent to full precision. Finally, in Section 6, we verify our theoretical results by implementing training models to learn complicated functions to compare the difference between 1111-bit networks and full precision networks. Firstly, we choose a combination of difficult functions across the exponential function, trigonometric function, logarithmic function, the Lambert W function, the Gamma function, and their combination. Therefore, we sample random data points and split train and test datasets. We next compare how the training loss decreases as the model width mğ‘šmitalic_m scales up. Besides, as shown in Section 6.3, in the trend of a growing number of parameters, the error of predictions both on training and test input likewise converge as the power-law in 1111-bit networks optimization. In particular, we visualize some 1111-dimension function to see how the differences of outputs are. We demonstrate the results complying with our theoretical guarantee with a negligible error."
https://arxiv.org/html/2411.01452v1,Rapidly mixing loop representation quantum Monte Carlo for Heisenberg models on star-like bipartite graphs,"Quantum Monte Carlo (QMC) methods have proven invaluable in condensed matter physics, particularly for studying ground states and thermal equilibrium properties of quantum Hamiltonians without a sign problem. Over the past decade, significant progress has also been made on their rigorous convergence analysis. Heisenberg antiferromagnets (AFM) with bipartite interaction graphs are a popular target of computational QMC studies due to their physical importance, but despite the apparent empirical efficiency of these simulations it remains an open question whether efficient classical approximation of the ground energy is possible in general. In this work we introduce a ground state variant of the stochastic series expansion QMC method, and for the special class of AFM on interaction graphs with an Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 )-bipartite component (star-like), we prove rapid mixing of the associated QMC Markov chain (polynomial time in the number of qubits) by using Jerrum and Sinclairâ€™s method of canonical paths. This is the first Markov chain analysis of a practical class of QMC algorithms with the loop representation of Heisenberg models. Our findings contribute to the broader effort to resolve the computational complexity of Heisenberg AFM on general bipartite interaction graphs.","The Heisenberg Hamiltonian couples neighboring spin-1/2 degrees of freedom arranged on fixed spatial sites by the exchange interaction of the form Â±Ïƒâ†’iâ‹…Ïƒâ†’j=Â±(Xiâ¢Xj+Yiâ¢Yj+Ziâ¢Zj)plus-or-minusâ‹…subscriptâ†’ğœğ‘–subscriptâ†’ğœğ‘—plus-or-minussubscriptğ‘‹ğ‘–subscriptğ‘‹ğ‘—subscriptğ‘Œğ‘–subscriptğ‘Œğ‘—subscriptğ‘ğ‘–subscriptğ‘ğ‘—\pm\vec{\sigma}_{i}\cdot\vec{\sigma}_{j}=\pm(X_{i}X_{j}+Y_{i}Y_{j}+Z_{i}Z_{j})Â± overâ†’ start_ARG italic_Ïƒ end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‹… overâ†’ start_ARG italic_Ïƒ end_ARG start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT = Â± ( italic_X start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT + italic_Y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Y start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT + italic_Z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Z start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ), which models the effective energetic tendencies of neighboring electron spins in molecular orbitals within a solid (i,jğ‘–ğ‘—i,jitalic_i , italic_j refer to neighboring sites, and Ïƒâ†’=(X,Y,Z)â†’ğœğ‘‹ğ‘Œğ‘\vec{\sigma}=(X,Y,Z)overâ†’ start_ARG italic_Ïƒ end_ARG = ( italic_X , italic_Y , italic_Z ) is a vector of Pauli matrices). The coupling âˆ’Ïƒâ†’iâ‹…Ïƒâ†’jâ‹…subscriptâ†’ğœğ‘–subscriptâ†’ğœğ‘—-\vec{\sigma}_{i}\cdot\vec{\sigma}_{j}- overâ†’ start_ARG italic_Ïƒ end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‹… overâ†’ start_ARG italic_Ïƒ end_ARG start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT in a Hamiltonian is called ferromagnetic (FM) because it energetically favors alignment of spins, while the coupling +Ïƒâ†’iâ‹…Ïƒâ†’jâ‹…subscriptâ†’ğœğ‘–subscriptâ†’ğœğ‘—+\vec{\sigma}_{i}\cdot\vec{\sigma}_{j}+ overâ†’ start_ARG italic_Ïƒ end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‹… overâ†’ start_ARG italic_Ïƒ end_ARG start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT favors anti-alignment and is called antiferromanetic (AFM). Exact solutions for Heisenberg models are known only for a few cases [30, 4, 51, 33] so approximate or computational solutions are needed to study the model in more complicated geometries such as 2D lattices and beyond. Quantum Monte Carlo (QMC) methods seek computational solutions by reducing the approximation of equilibrium observables in certain quantum spin systems to the problem of sampling classical configurations from a weighted probability distribution. QMC methods use a Markov chain to sample from the target distribution, and Monte Carlo estimation to approximate observables of interest. An important condition for the efficient application of QMC is that the model should not have a sign problem [31, 34] , meaning that there should be some choice of local basis in which all of the off-diagonal Hamiltonian matrix elements are real and non-positive. In both Suzukiâ€™s original formulation of QMC [53, 52] and more modern QMC treatments for spin systems [45], this condition ensures that the paths contributing to the path integral for the ground state all have non-negative weights. More generally, the absence of a sign problem reduces the computational complexity of estimating equilibrium observables [13] and such models without a sign problem are now commonly called â€œstoquasticâ€ in the context of Hamiltonian complexity [10, 9, 7]. Ferromagnetic Heisenberg models are always stoquastic (the interaction âˆ’(Xiâ¢Xj+Yiâ¢Yj+Ziâ¢Zj)subscriptğ‘‹ğ‘–subscriptğ‘‹ğ‘—subscriptğ‘Œğ‘–subscriptğ‘Œğ‘—subscriptğ‘ğ‘–subscriptğ‘ğ‘—-(X_{i}X_{j}+Y_{i}Y_{j}+Z_{i}Z_{j})- ( italic_X start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT + italic_Y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Y start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT + italic_Z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Z start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ) has all real and non-positive matrix elements in the Zğ‘Zitalic_Z-basis). For the antiferromagnetic interaction (Xiâ¢Xj+Yiâ¢Yj+Ziâ¢Zj)subscriptğ‘‹ğ‘–subscriptğ‘‹ğ‘—subscriptğ‘Œğ‘–subscriptğ‘Œğ‘—subscriptğ‘ğ‘–subscriptğ‘ğ‘—(X_{i}X_{j}+Y_{i}Y_{j}+Z_{i}Z_{j})( italic_X start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT + italic_Y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Y start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT + italic_Z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Z start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ), the desired property of off-diagonal matrix elements in the Zğ‘Zitalic_Z-basis can be obtained by a local unitary transformation [34], (ZâŠ—I)â¢Ïƒâ†’iâ‹…Ïƒâ†’jâ¢(ZâŠ—I)=(Ziâ¢Zjâˆ’Xiâ¢Xjâˆ’Yiâ¢Yj)â‹…tensor-productğ‘ğ¼subscriptâ†’ğœğ‘–subscriptâ†’ğœğ‘—tensor-productğ‘ğ¼subscriptğ‘ğ‘–subscriptğ‘ğ‘—subscriptğ‘‹ğ‘–subscriptğ‘‹ğ‘—subscriptğ‘Œğ‘–subscriptğ‘Œğ‘—(Z\otimes I)\vec{\sigma}_{i}\cdot\vec{\sigma}_{j}(Z\otimes I)=(Z_{i}Z_{j}-X_{i% }X_{j}-Y_{i}Y_{j})( italic_Z âŠ— italic_I ) overâ†’ start_ARG italic_Ïƒ end_ARG start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‹… overâ†’ start_ARG italic_Ïƒ end_ARG start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( italic_Z âŠ— italic_I ) = ( italic_Z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Z start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT - italic_X start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT - italic_Y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Y start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ), but applying this transformation to successfully render the entire model stoquastic requires that the underlying interactions are bipartite in the graph-theoretic sense (i.e., vertices are two-colorable). Hamiltonian Complexity. Computing the ground state energy of an AFM Heisenberg model on general graphs up to an inverse polynomial precision is known to be QMA-complete, and is essentially regarded as the quantum analog of the classical MaxCut problem [17, 3], thus called QuantumMaxCut in the approximation algorithm community. In contrast, the same problem for bipartite graphs is contained in the more limited complexity class StoqMA [13] because it is stoquastic as described above. While classical MaxCut is trivial to solve on bipartite graphs, the complexity of QuantumMaxCut for bipartite graphs is unknown and is explicitly raised as an open problem in [16]. Currenlty, the only proven fact is the containment in StoqMA [38], so the possibility is wide open from containment in P to being StoqMA-complete. Classical ground state approximations to the QuantumMaxCut problem on general graphs have been obtained in special cases by semidefinite programming (SDP) heierarchies, generalizing the Goemans-Williamson algorithm for classical MaxCut [26, 57, 66, 27]. These SDP methods are not explicitly affected by the sign problem, but bipartite graphs (including the star-like graphs we consider) have been an important source of tractable examples for these algorithms. QMC and related methods have been used for proving polynomial-time simulability of a variety of stoquastic systems without NP-hardness obstructions, including 1D spin systems at constant temperature [11], ferromagnetic Ising models on general interaction graphs [6], high-temperature quantum Ising spin glasses on bounded-degree graphs [12], as well as a landmark result by Bravyi and Gosset establishing ground state and thermal state simulation for XY ferromagnets on arbitrary interaction graphs [8]. We note that this latter result includes Xâ¢Xğ‘‹ğ‘‹XXitalic_X italic_X and Yâ¢Yğ‘Œğ‘ŒYYitalic_Y italic_Y interactions as long as they are stoquastic (thus somewhat extending the notion of â€œferromagneticâ€) and also local Zğ‘Zitalic_Z fields, but not Zâ¢Zğ‘ğ‘ZZitalic_Z italic_Z interactions. Another related result is a deterministic quasipolynomial-time simulation of XXZ models with tunable Xâ¢X,Yâ¢Y,ğ‘‹ğ‘‹ğ‘Œğ‘ŒXX,YY,italic_X italic_X , italic_Y italic_Y , and Zâ¢Zğ‘ğ‘ZZitalic_Z italic_Z interactions as long as the Zâ¢Zğ‘ğ‘ZZitalic_Z italic_Z term dominates the other two in a ferromagnetic way [20]. Based on the empirical evidence provided by decades of computational studies [45], it is fairly plausible that QMC algorithms can approximate ground states of bipartite QuantumMaxCut models on a wide range of interaction graphs in classical polynomial time, but there has been no rigorous proof for efficient convergence of QMC for any bipartite AFM models to date. Our work thus provides a first step along a reasonable approach to putting bipartite cases of QuantumMaxCut in BPP. Markov chains and Mixing Times. To obtain a polynomial-time simulation by QMC, the mixing time of Markov chain that drives the QMC method must scale polynomially with the system size [28]. The mixing time of a Markov chain characterizes the number of classical updates which suffice to produce each approximate sample from the target distribution - a Markov chain which equilibrates in a time that scales logarithmically in the size of its state space (i.e. polynomially in the number of spins or particles for a quantum system) is called rapidly mixing. A general technique for analyzing the mixing time is to bound it in terms of reciprocal of the spectral gap of the Markov chain transition matrix. To bound the spectral gap of the QMC dynamics for Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 )-bipartite graphs, we use the method of canonical paths due to Jerrum and Sinclair [22, 50]. In this method the Markov chain state space is viewed as a combinatorial graph, with vertices representing states of the Markov chain and edges representing transitions between states. The task of showing rapid-mixing is then essentially to show that this combinatorial graph is an expander. The canonical path method does this by showing the existence of a routing of the probability flow through the state space graph that delivers the necessary stationary probability to every vertex without overloading any particular edges. We apply the method of canonical paths in a relatively straightforward way (inspired by the textbook example of â€œleft-to-right bit fixing pathsâ€) - most of our technical effort is devoted to developing the QMC representation that is simple enough to analyze yet close enough to the practical method, and proving geometric and topological facts about the state space so that these straightforward canonical paths suffice to show rapid mixing. The success of this approach highlights the opportunity to apply more sophisticated Markov chain analysis techniques to the interdisciplinary open problem of simulating bipartite AFM by rigorously efficient QMC. Figure 1: a) The â€œHeisenberg starâ€, or star graph with Nâˆ’1ğ‘1N-1italic_N - 1 qubits interacting antiferromagnetically with a single central qubit, is the archetypical example of the bipartite AFM we analyze. b) More generally we allow a constant number of qubits M=Oâ¢(1)ğ‘€ğ‘‚1M=O(1)italic_M = italic_O ( 1 ) to interact antiferromagnetically with Nâˆ’Mğ‘ğ‘€N-Mitalic_N - italic_M qubits. Our analysis also extends to include staggered local fields and ferromagnetic interactions within each bipartite component. Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 )-bipartite (star-like) Heisenberg Models. Throughout this work we consider Heisenberg Hamiltonians defined on a bipartite interaction graph ğ’œâˆªâ„¬ğ’œâ„¬\mathcal{A}\cup\mathcal{B}caligraphic_A âˆª caligraphic_B with N=|ğ’œ|+|â„¬|ğ‘ğ’œâ„¬N=|\mathcal{A}|+|\mathcal{B}|italic_N = | caligraphic_A | + | caligraphic_B | qubits, in which one component has a fixed size |ğ’œ|=Oâ¢(1)ğ’œğ‘‚1|\mathcal{A}|=O(1)| caligraphic_A | = italic_O ( 1 ) and the other component has size |â„¬|=Oâ¢(N)â„¬ğ‘‚ğ‘|\mathcal{B}|=O(N)| caligraphic_B | = italic_O ( italic_N ). For any pair of qubits define the 2-local projection operator hiâ¢j=(ğŸ™âˆ’Xiâ¢Xjâˆ’Yiâ¢Yjâˆ’Ziâ¢Zj)/4.subscriptâ„ğ‘–ğ‘—1subscriptğ‘‹ğ‘–subscriptğ‘‹ğ‘—subscriptğ‘Œğ‘–subscriptğ‘Œğ‘—subscriptğ‘ğ‘–subscriptğ‘ğ‘—4h_{ij}=(\mathbbm{1}-X_{i}X_{j}-Y_{i}Y_{j}-Z_{i}Z_{j})/4.italic_h start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT = ( blackboard_1 - italic_X start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_X start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT - italic_Y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Y start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT - italic_Z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_Z start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ) / 4 . (1) Then the Heisenberg AFM Hamiltonian with weights wiâ¢jâ‰¥0subscriptğ‘¤ğ‘–ğ‘—0w_{ij}\geq 0italic_w start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT â‰¥ 0 is HAFM=âˆ’âˆ‘iâˆˆğ’œ,jâˆˆâ„¬wiâ¢jâ¢hiâ¢j,subscriptğ»AFMsubscriptformulae-sequenceğ‘–ğ’œğ‘—â„¬subscriptğ‘¤ğ‘–ğ‘—subscriptâ„ğ‘–ğ‘—H_{\textrm{AFM}}=-\sum_{i\in\mathcal{A},j\in\mathcal{B}}w_{ij}h_{ij},italic_H start_POSTSUBSCRIPT AFM end_POSTSUBSCRIPT = - âˆ‘ start_POSTSUBSCRIPT italic_i âˆˆ caligraphic_A , italic_j âˆˆ caligraphic_B end_POSTSUBSCRIPT italic_w start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT italic_h start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT , (2) which we will explain in more detail in section 2. Although the AFM terms are the primary interest in this work, our analysis also extends (without much additional complication) to including ferromagnetic terms acting within ğ’œğ’œ\mathcal{A}caligraphic_A or within â„¬â„¬\mathcal{B}caligraphic_B, and 1-local Xğ‘‹Xitalic_X terms with their signs staggered to enhance the antiferromagnetic order. HFMsubscriptğ»FM\displaystyle H_{\textrm{FM}}italic_H start_POSTSUBSCRIPT FM end_POSTSUBSCRIPT =âˆ’âˆ‘(i,j)âˆˆğ’œâ¢ or â¢(i,j)âˆˆâ„¬Jiâ¢jâ¢(ğŸ™âˆ’hiâ¢j)absentsubscriptğ‘–ğ‘—ğ’œ or ğ‘–ğ‘—â„¬subscriptğ½ğ‘–ğ‘—1subscriptâ„ğ‘–ğ‘—\displaystyle=-\sum_{(i,j)\in\mathcal{A}\textrm{ or }(i,j)\in\mathcal{B}}J_{ij% }(\mathbbm{1}-h_{ij})= - âˆ‘ start_POSTSUBSCRIPT ( italic_i , italic_j ) âˆˆ caligraphic_A or ( italic_i , italic_j ) âˆˆ caligraphic_B end_POSTSUBSCRIPT italic_J start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT ( blackboard_1 - italic_h start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT ) (3) HXsubscriptğ»ğ‘‹\displaystyle H_{X}italic_H start_POSTSUBSCRIPT italic_X end_POSTSUBSCRIPT =12â¢âˆ‘iâˆˆAgiâ¢(ğŸ™âˆ’Xi)âˆ’12â¢âˆ‘jâˆˆBgjâ¢(ğŸ™âˆ’Xj)absent12subscriptğ‘–ğ´subscriptğ‘”ğ‘–1subscriptğ‘‹ğ‘–12subscriptğ‘—ğµsubscriptğ‘”ğ‘—1subscriptğ‘‹ğ‘—\displaystyle=\frac{1}{2}\sum_{i\in A}g_{i}(\mathbbm{1}-X_{i})-\frac{1}{2}\sum% _{j\in B}g_{j}(\mathbbm{1}-X_{j})= divide start_ARG 1 end_ARG start_ARG 2 end_ARG âˆ‘ start_POSTSUBSCRIPT italic_i âˆˆ italic_A end_POSTSUBSCRIPT italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( blackboard_1 - italic_X start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) - divide start_ARG 1 end_ARG start_ARG 2 end_ARG âˆ‘ start_POSTSUBSCRIPT italic_j âˆˆ italic_B end_POSTSUBSCRIPT italic_g start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( blackboard_1 - italic_X start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ) (4) where Jiâ¢j,gisubscriptğ½ğ‘–ğ‘—subscriptğ‘”ğ‘–J_{ij},g_{i}italic_J start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT , italic_g start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT are positive weights. The most general Hamiltonian we consider is H=HAFM+HFM+HXğ»subscriptğ»AFMsubscriptğ»FMsubscriptğ»XH=H_{\textrm{AFM}}+H_{\textrm{FM}}+H_{\textrm{X}}italic_H = italic_H start_POSTSUBSCRIPT AFM end_POSTSUBSCRIPT + italic_H start_POSTSUBSCRIPT FM end_POSTSUBSCRIPT + italic_H start_POSTSUBSCRIPT X end_POSTSUBSCRIPT (5) for Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 )-bipartite graphs, as indicated in Figure 1. Our main result is a proof of polyâ¢(N)polyğ‘\textrm{poly}(N)poly ( italic_N ) time rapid mixing for the QMC Markov chain dynamics of Section 3 applied to these models, which allows for approximating the expectation of local observables and approximately sampling from the ground state in the Zğ‘Zitalic_Z basis. Since our results pertain to a QMC method that estimates the ground state energy of (5), we emphasize that the ground state energy of these Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 )-bipartite models can always be found in polyâ¢(N)polyğ‘\textrm{poly}(N)poly ( italic_N ) time by the Lieb-Mattis theorem (see Appendix A). Our motivation here is not just to find some polynomial time algorithm for approximating these ground states, but to show that a popular and practical QMC algorithm also yields a rigorously efficient classical approximation algorithm for estimating ground state observables for these systems. The fact that the QMC algorithm is operated in a general way and does not make use of the Lieb-Mattis theorem to reduce the dimensionality brings hope for proving efficiency for more general cases in future work. Another perspective is that our main result lower bounds the spectral gap of the dynamical generator of a kinetic loop model that has not been previously analyzed. This loop model equilibrium distribution simulates the Heisenberg AFM ground state and thus yields an efficient algorithm for the problem of approximating the ground energy. Loop representation of QMC for Heisenberg models. Following the discussion of stoquastic complexity, a central goal of computational QMC studies is to design Markov chains for which the state space, stationary distribution, and update rules lead to rapid mixing. Despite progress in the rigorous analysis of QMC methods, bipartite Heisenberg models with AFM terms have resisted such analysis to date. A high-level reason for this is that the form of the Heisenberg interaction leads to QMC configurations with many combinatorial constraints when using the most basic type of QMC [53]. Such constraints not only brings difficulties for the rigorous analysis of the Markov chain mixing time, but also results in impractical long mixing times. To resolve this issue, modern QMC methods used in computational studies of Heisenberg models involve non-local cluster updates (analogous to Swendson-Wang updates [54] for classical Ising models, instead of single-site Glauber dynamics) achieving practically fast mixing time. Our approach is based on a state-of-the-art QMC used in computational condensed matter physics, called the stochastic series expansion (SSE) method [47]. This method is especially optimized for Heisenberg interactions, where it has been applied in thermal and ground state simulations with over 106superscript10610^{6}10 start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT qubits [58]. In the simplified version of this method which we introduce and analyze, the stationary distribution over configurations of clusters (which are conventionally called â€œloopsâ€ even when they can be open strings) takes a simplified purely geometric form, proportional to 2#â¢ of loopssuperscript2# of loops2^{\#\textrm{ of loops}}2 start_POSTSUPERSCRIPT # of loops end_POSTSUPERSCRIPT. Only by focusing on such practically fast QMC methods and appropriately simplifying them was it possible to rigorously prove rapid-mixing as we present here. Figure 2: An example configuration from the SPE Markov chain we analyze. The loop configuration (top) is an example of a configuration with 2â¢B=82ğµ82B=82 italic_B = 8 operators and 6 line segments (â€œloopsâ€) for a Heisenberg model on a 4-arm star graph (bottom). The QMC we analyze closely follows the standard SSE algorithm, except for one difference that is significant for the analysis: instead of using the Taylor series for trâ¢[eâˆ’Î²â¢H]trdelimited-[]superscriptğ‘’ğ›½ğ»\textrm{tr}[e^{-\beta H}]tr [ italic_e start_POSTSUPERSCRIPT - italic_Î² italic_H end_POSTSUPERSCRIPT ] as is done in standard SSE, we use a fixed large positive integer power of the Hamiltonian (âˆ’H)Lsuperscriptğ»ğ¿(-H)^{L}( - italic_H ) start_POSTSUPERSCRIPT italic_L end_POSTSUPERSCRIPT applied to the trial state |+NâŸ©ketsuperscriptğ‘|+^{N}\rangle| + start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT âŸ© to project onto the low energy subspace. As we discuss later on, although physical intuition may indicate that this is not much of a difference, this in fact turns out to be crucial for our proof to work because of topological reasons. The idea of applying (âˆ’H)Lsuperscriptğ»ğ¿(-H)^{L}( - italic_H ) start_POSTSUPERSCRIPT italic_L end_POSTSUPERSCRIPT to obtain the ground state has been done in many QMC methods [46], but in our QMC, we use the zğ‘§zitalic_z-basis unlike [46] and then switch to the loop representation. We term this modified version of SSE as Stochastic Power Expansion (SPE) QMC for convenience, as both the open boundary condition and the loop representation are essential for our analysis. Figure 2 illustrates a typical SPE (SSE) configuration for the Heisenberg AFM on the star graph. We briefly overview the method here; see Section 3 for a full derivation and explanation. â€¢ For a general bipartite AFM, the SSE representation augments the interaction graph ğ’¢ğ’¢\mathcal{G}caligraphic_G with an â€œimaginary time directionâ€ {1,â€¦,2â¢B}1â€¦2ğµ\{1,...,2B\}{ 1 , â€¦ , 2 italic_B } and considers configurations consisting of an assignment of a â€œbridgeâ€ (corresponding to an edge in ğ’¢ğ’¢\mathcal{G}caligraphic_G i.e. a local AFM term, dotted in the figure) to each â€œ(imaginary) time sliceâ€ jâˆˆ{1,â€¦,2â¢B}ğ‘—1â€¦2ğµj\in\{1,...,2B\}italic_j âˆˆ { 1 , â€¦ , 2 italic_B }. â€¢ One samples from this set of bridge configurations by a Markov chain that switches a randomly chosen bridge at each step. The Markov chain satisfies detailed balance and converges to the stationary distribution where probabilities are proportional to 2#â¢ of loopssuperscript2# of loops2^{\#\textrm{ of loops}}2 start_POSTSUPERSCRIPT # of loops end_POSTSUPERSCRIPT. The loops (which can be closed or open strings, shown in distinct colors for visual clarity in Figure 2) are defined via the bridge configuration. â€¢ The loop structure of a configuration will in general undergo non-local changes when a single bridge is changed, which complicates the analysis but is essential for the efficiency of the method in practice. This paper is structured as follows. In section 2, we introduce the notations as well as all possible forms of the Hamiltonians that we consider in this work. In section 3, we derive the configuration space and the probability distribution that our QMC method will be sampling from. This derivation shows how the seemingly nonquantum yet topological configurations that we sample are related to the Heisenberg model. Section 4 is devoted to introducing the canonical path method, the mathematical technique we use for proving rapid mixing. We also go through the basics of Markov Chain Monte Carlo methods in general, and also precisely define the QMC sampling algorithm based on the framework. We then move on to the main proof in section 5, where we cover all cases that we can prove rapid-mixing. Finally, in section 6, we discuss the implications of our result as well as relations with various concepts in condensed matter physics and also comment on open problems. We advice readers who are only interested in the core idea of the algorithm to see the simplest configuration space we consider in eq. 26 and the probability distribution over it that is explained thereafter. This should be enough to understand the QMC procedure explained in section 4.2, and also understand our proof in the simplest case which is explained in the first few subsections of section 5."
https://arxiv.org/html/2411.00976v1,Low-degree approximation of QAC0circuits,"QAC0 is the class of constant-depth quantum circuits with polynomially many ancillary qubits, where Toffoli gates on arbitrarily many qubits are allowed. In this work, we show that the parity function cannot be computed in QAC0, resolving a long-standing open problem in quantum circuit complexity more than twenty years old. As a result, this proves ğğ€ğ‚0â«‹ğğ€ğ‚wf0superscriptğğ€ğ‚0superscriptsubscriptğğ€ğ‚wf0{\bf QAC}^{0}\subsetneqq{\bf QAC}_{\rm wf}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT â«‹ bold_QAC start_POSTSUBSCRIPT roman_wf end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. We also show that any QAC circuit of depth dğ‘‘ditalic_d that approximately computes parity on nğ‘›nitalic_n bits requires 2Î©~â¢(n1/d)superscript2~Î©superscriptğ‘›1ğ‘‘2^{\widetilde{\Omega}(n^{1/d})}2 start_POSTSUPERSCRIPT over~ start_ARG roman_Î© end_ARG ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT ancillary qubits, which is close to tight. This implies a similar lower bound on approximately preparing cat states using QAC circuits. Finally, we prove a quantum analog of the Linial-Mansour-Nisan theorem for ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. This implies that, for any QAC0 circuit Uğ‘ˆUitalic_U with a=polyâ¢(n)ğ‘polyğ‘›a={\rm poly}(n)italic_a = roman_poly ( italic_n ) ancillary qubits, and for any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, the correlation between Qâ¢(x)ğ‘„ğ‘¥Q(x)italic_Q ( italic_x ) and the parity function is bounded by 1/2+2âˆ’Î©~â¢(n1/d)12superscript2~Î©superscriptğ‘›1ğ‘‘{1}/{2}+2^{-\widetilde{\Omega}(n^{1/d})}1 / 2 + 2 start_POSTSUPERSCRIPT - over~ start_ARG roman_Î© end_ARG ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT, where Qâ¢(x)ğ‘„ğ‘¥Q(x)italic_Q ( italic_x ) denotes the output of measuring the output qubit of Uâ¢|x,0aâŸ©ğ‘ˆketğ‘¥superscript0ğ‘U\ket{x,0^{a}}italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ©. All the above consequences rely on the following technical result. If Uğ‘ˆUitalic_U is a ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit with a=polyâ¢(n)ğ‘polyğ‘›a={\rm poly}(n)italic_a = roman_poly ( italic_n ) ancillary qubits, then there is a distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D of bounded polynomials of degree polylog(n)ğ‘›(n)( italic_n ) such that with high probability, a random polynomial from ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D approximates the function âŸ¨x,0a|â¢Uâ€ â¢Zn+1â¢Uâ¢|x,0aâŸ©brağ‘¥superscript0ğ‘superscriptğ‘ˆâ€ subscriptğ‘ğ‘›1ğ‘ˆketğ‘¥superscript0ğ‘\bra{x,0^{a}}U^{\dagger}Z_{n+1}U\ket{x,0^{a}}âŸ¨ start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG | italic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Z start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© for a large fraction of xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. This result is analogous to the Razborov-Smolensky result on the approximation of AC0 circuits by random low-degree polynomials.","Classically, ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits are circuits of constant depth and polynomial size, with unbounded fan-in AND, OR and NOT gates (the NOT gates only at the input layer). The complexity class ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT defined by these circuits is used in theoretical computer science to understand the computational power of circuits with limited depth. One of the main motivations for studying ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT is that it is a good â€œtoy modelâ€ for studying larger classes of circuits. It is known that if any NP problems cannot be solved by circuits of polynomial size [1], then NP â‰ \neqâ‰  P. Thus proving circuit lower bounds is a potential way for proving NP â‰ \neqâ‰  P. Solving this problem for general circuits is remarkably challenging. Hence, a natural way to make progress towards this goal is to first try to prove that NP problems cannot be solved by polynomial-size circuits chosen from a restricted family. The ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits are a particularly interesting and well-studied family. In some celebrated works [10, 3] it was shown that ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT cannot compute the parity function. Later, more precise characterisations of the relationship between parity and ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT were discovered, e.g., see [15, 19, 21, 13]. Analogously, in the quantum case, Moore in 1999 first introduced the concept of quantum ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit [16]. There are two versions of quantum ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. One is known as ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, which is the class of polynomial-size quantum circuits of constant depth made up of arbitrary single-qubit gates and arbitrary-width Toffoli gates. Another generalisation of ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT is called ğğ€ğ‚wf0subscriptsuperscriptğğ€ğ‚0wf{\bf QAC}^{0}_{\rm wf}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_wf end_POSTSUBSCRIPT, which further includes unbounded fanout gates. Here the subscript â€œwfâ€ means â€œwith fanoutâ€. It is straightforward to see that ğğ€ğ‚wf0subscriptsuperscriptğğ€ğ‚0wf{\bf QAC}^{0}_{\rm wf}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_wf end_POSTSUBSCRIPT includes ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, and was proved in [4] that ğğ€ğ‚wf0subscriptsuperscriptğğ€ğ‚0wf{\bf QAC}^{0}_{\rm wf}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_wf end_POSTSUBSCRIPT is much more powerful than ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. However, in sharp contrast, it is still unknown if ğ€ğ‚0âŠ‚ğğ€ğ‚0superscriptğ€ğ‚0superscriptğğ€ğ‚0{\bf AC}^{0}\subset{\bf QAC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT âŠ‚ bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT and if ğğ€ğ‚0=ğğ€ğ‚wf0superscriptğğ€ğ‚0subscriptsuperscriptğğ€ğ‚0wf{\bf QAC}^{0}={\bf QAC}^{0}_{\rm wf}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT = bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_wf end_POSTSUBSCRIPT, see [16, 4]. Note that arbitrary fan-out is allowed in the ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit. If ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT can also do fanout, then it can compute the parity function and so is a larger class than ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. In this case, ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT turns out to be a very powerful class, as it would be able to do many other things, like performing the MODq gates for all qğ‘qitalic_q, modular addition gates, and the quantum Fourier transform [16, 4, 11]. Conversely, if ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT cannot compute parity, then we would immediately obtain ğğ€ğ‚0â«‹ğğ€ğ‚wf0superscriptğğ€ğ‚0subscriptsuperscriptğğ€ğ‚0wf{\bf QAC}^{0}\subsetneqq{\bf QAC}^{0}_{\rm wf}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT â«‹ bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_wf end_POSTSUBSCRIPT. This would also show that fanout cannot be computed in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, highlighting an important difference between ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT and ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT.111Here we cannot claim that ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT does not include ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, unless we can find a decision problem (Boolean function) that is in ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, but not in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. â€œCompute fanoutâ€ is not a decision problem, so we do not seem to automatically obtain this consequence. The ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits also have a close connection to the cat (GHZ) state 12â¢(|0nâŸ©+|1nâŸ©)12ketsuperscript0ğ‘›ketsuperscript1ğ‘›\frac{1}{\sqrt{2}}(\ket{0^{n}}+\ket{1^{n}})divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG ( | start_ARG 0 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG âŸ© + | start_ARG 1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG âŸ© ), a quantum state which plays a fundamental role in the understanding of entanglement. In [16, 11], it was shown that the ability to form a cat state of nğ‘›nitalic_n qubits is equivalent to the ability to construct an nğ‘›nitalic_n-ary parity gate in constant depth. This result was extended to approximate constructions in [20], in which it was shown that approximating a cat state in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT is equivalent to approximating the parity function in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. It is easy to show via a lightcone argument [23] that cat states cannot be prepared by a fixed constant-depth quantum circuit using bounded fan-in gates, i.e., cat states cannot be created in ğğğ‚0superscriptğğğ‚0{\bf QNC}^{0}bold_QNC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT (although they can be prepared by interleaving low-depth quantum circuits with classical computations [7]). But until now, it has not been known if cat states can be prepared by ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits. As we can see, all the above open problems boil down to one particular open problem: is parity in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT? Although this is completely solved for the classical class ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, and special cases of the quantum problem have been solved, e.g., see [4, 20, 18, 8, 17, 2] (see Section 1.4), the main open problem has remained open for more than 20 years, and it is widely believed that the answer is â€œnoâ€. In this work, we resolve this open problem and show that parity is not in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. 1.1 ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuits and the parity problem A ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit is a quantum circuit consisting of arbitrary single-qubit gates and arbitrary-width Toffoli gates (also known as arbitrary-width CCNOT gates) acting as follows Toffolin:|x1,â€¦,xn,bâŸ©â†’|x1,â€¦,xn,bâŠ•â‹€i=1nxiâŸ©.{\rm Toffoli}_{n}:\leavevmode\nobreak\ \leavevmode\nobreak\ \ket{x_{1},\ldots,% x_{n},b}\rightarrow\ket{x_{1},\ldots,x_{n},b\oplus\bigwedge_{i=1}^{n}x_{i}}.roman_Toffoli start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT : | start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_b end_ARG âŸ© â†’ | start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_b âŠ• â‹€ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG âŸ© . (1.1) For any subset SâŠ†[n]ğ‘†delimited-[]ğ‘›S\subseteq[n]italic_S âŠ† [ italic_n ], the controlled-Z gate specified by Sğ‘†Sitalic_S is, denoted as CZSsubscriptCZğ‘†{\rm CZ}_{S}roman_CZ start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT, CZS:|x1,â€¦,xnâŸ©â†’(âˆ’1)âˆiâˆˆSxi|x1,â€¦,xnâŸ©.{\rm CZ}_{S}:\leavevmode\nobreak\ \leavevmode\nobreak\ \ket{x_{1},\ldots,x_{n}% }\rightarrow(-1)^{\prod_{i\in S}x_{i}}\ket{x_{1},\ldots,x_{n}}.roman_CZ start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT : | start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_ARG âŸ© â†’ ( - 1 ) start_POSTSUPERSCRIPT âˆ start_POSTSUBSCRIPT italic_i âˆˆ italic_S end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT | start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_ARG âŸ© . (1.2) In this work, when Sğ‘†Sitalic_S is not specified, we will simply call it the CC..CZ gate. The Toffoli gate ToffolinsubscriptToffoliğ‘›{\rm Toffoli}_{n}roman_Toffoli start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT is equivalent to the CZ[n+1]subscriptCZdelimited-[]ğ‘›1{\rm CZ}_{[n+1]}roman_CZ start_POSTSUBSCRIPT [ italic_n + 1 ] end_POSTSUBSCRIPT gate up to conjugation by Hadamard gate, namely Toffolin=(InâŠ—H)â¢CZ[n+1]â¢(InâŠ—H)subscriptToffoliğ‘›tensor-productsuperscriptğ¼ğ‘›ğ»subscriptCZdelimited-[]ğ‘›1tensor-productsuperscriptğ¼ğ‘›ğ»{\rm Toffoli}_{n}=(I^{n}\otimes H){\rm CZ}_{[n+1]}(I^{n}\otimes H)roman_Toffoli start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT = ( italic_I start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT âŠ— italic_H ) roman_CZ start_POSTSUBSCRIPT [ italic_n + 1 ] end_POSTSUBSCRIPT ( italic_I start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT âŠ— italic_H ). One advantage of CC..CZ gates over Toffoli gates in terms of simplicity is that there is no need to introduce an ancillary qubit to define them. So a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of depth dğ‘‘ditalic_d can be written as CZ(d)â¢Udâ¢â‹¯â¢CZ(1)â¢U1superscriptCZğ‘‘subscriptğ‘ˆğ‘‘â‹¯superscriptCZ1subscriptğ‘ˆ1{\rm CZ}^{(d)}U_{d}\cdots{\rm CZ}^{(1)}U_{1}roman_CZ start_POSTSUPERSCRIPT ( italic_d ) end_POSTSUPERSCRIPT italic_U start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT â‹¯ roman_CZ start_POSTSUPERSCRIPT ( 1 ) end_POSTSUPERSCRIPT italic_U start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, where U1,â€¦,Udsubscriptğ‘ˆ1â€¦subscriptğ‘ˆğ‘‘U_{1},\ldots,U_{d}italic_U start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_U start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT are tensor products of single qubit gates and CZ(1),â€¦,CZ(d)superscriptCZ1â€¦superscriptCZğ‘‘{\rm CZ}^{(1)},\ldots,{\rm CZ}^{(d)}roman_CZ start_POSTSUPERSCRIPT ( 1 ) end_POSTSUPERSCRIPT , â€¦ , roman_CZ start_POSTSUPERSCRIPT ( italic_d ) end_POSTSUPERSCRIPT are tensor products of CC..CZ gates. At each layer, all CC..CZ gates act on different qubits. The size of the circuit is the total number of CC..CZ gates; this would not change significantly if we also counted single-qubit gates. The complexity class ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT is the class of languages that are recognised by ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuits with depth Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 ), polynomial size, and using polynomially many ancillas. (Note that here, we define the family of â€œğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuitsâ€ to allow for arbitrary depth, an arbitrary number of ancillas, etc, as our results apply in a more general setting â€“ but when we use the term â€œğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuitâ€ we mean a circuit that corresponds to the complexity class ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT.) The parity function Parityn:{0,1}nâ†’{0,1}:subscriptParityğ‘›â†’superscript01ğ‘›01{\rm Parity}_{n}:\{0,1\}^{n}\rightarrow\{0,1\}roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT : { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ { 0 , 1 } is defined as Paritynâ¢(x1,â€¦,xn)=â¨i=1nxi.subscriptParityğ‘›subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›superscriptsubscriptdirect-sumğ‘–1ğ‘›subscriptğ‘¥ğ‘–{\rm Parity}_{n}(x_{1},\ldots,x_{n})=\bigoplus_{i=1}^{n}x_{i}.roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) = â¨ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT . (1.3) On a quantum circuit, it is implemented as UParityn:|x1,â€¦,xn,bâŸ©â†’|x1,â€¦,xn,bâŠ•â¨i=1nxiâŸ©U_{{\rm Parity}_{n}}:\leavevmode\nobreak\ \leavevmode\nobreak\ \ket{x_{1},% \ldots,x_{n},b}\rightarrow\ket{x_{1},\ldots,x_{n},b\oplus\bigoplus_{i=1}^{n}x_% {i}}italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT : | start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_b end_ARG âŸ© â†’ | start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_b âŠ• â¨ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG âŸ© (1.4) with the introduction of an ancillary qubit. To implement the parity function by a quantum circuit, we usually need to introduce some ancillary qubits. So for a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit, we will always use nğ‘›nitalic_n to denote the number of system qubits and ağ‘aitalic_a to denote the number of ancillary qubits. Definition 1.1 ((Îµ,Î·)ğœ€ğœ‚(\varepsilon,\eta)( italic_Îµ , italic_Î· ) approximation of parity function). Let Uğ‘ˆUitalic_U be a circuit on n+ağ‘›ğ‘n+aitalic_n + italic_a qubits. We say Uğ‘ˆUitalic_U (Îµ,Î·)ğœ€ğœ‚(\varepsilon,\eta)( italic_Îµ , italic_Î· ) approximates the parity function if for at least a (1âˆ’Îµ)1ğœ€(1-\varepsilon)( 1 - italic_Îµ ) fraction of xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, with probability at least 1âˆ’Î·1ğœ‚1-\eta1 - italic_Î·, the result of measuring a given output qubit (say, the (n+1)ğ‘›1(n+1)( italic_n + 1 )-th qubit) of Uâ¢|x,0aâŸ©ğ‘ˆketğ‘¥superscript0ğ‘U\ket{x,0^{a}}italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© is Paritynâ¢(x)subscriptParityğ‘›ğ‘¥{\rm Parity}_{n}(x)roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ). The main open problem proposed in [16, 8] can be described as follows. Problem 1.2 (Is parity in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT?). Let Îµâˆˆ[0,1),Î·âˆˆ[0,1/2]formulae-sequenceğœ€01ğœ‚012\varepsilon\in[0,1),\eta\in[0,1/2]italic_Îµ âˆˆ [ 0 , 1 ) , italic_Î· âˆˆ [ 0 , 1 / 2 ]. Is computing an (Îµ,Î·)ğœ€ğœ‚(\varepsilon,\eta)( italic_Îµ , italic_Î· ) approximation of the parity function in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT? The definition of Problem 1.2 here is weaker than the one proposed in [16]. In that case, Îµ=Î·=0ğœ€ğœ‚0\varepsilon=\eta=0italic_Îµ = italic_Î· = 0. That is, the parity function is computed cleanly. This is also the case studied in [8, 4, 18]. The problem here is also weaker than the statement given in [20], in which it is required that Îµ=0ğœ€0\varepsilon=0italic_Îµ = 0. Classically, if Câ¢(x)ğ¶ğ‘¥C(x)italic_C ( italic_x ) is the Boolean function computed by a polynomial-size ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit, then it was proved in several celebrated works [15, 19, 21] that Prxâˆˆ{0,1}nâ¡[Câ¢(x)=Paritynâ¢(x)]â‰¤12+onâ¢(1).subscriptPrğ‘¥superscript01ğ‘›ğ¶ğ‘¥subscriptParityğ‘›ğ‘¥12subscriptğ‘œğ‘›1\Pr_{x\in\{0,1\}^{n}}[C(x)={\rm Parity}_{n}(x)]\leq\frac{1}{2}+o_{n}(1).roman_Pr start_POSTSUBSCRIPT italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_C ( italic_x ) = roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) ] â‰¤ divide start_ARG 1 end_ARG start_ARG 2 end_ARG + italic_o start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( 1 ) . (1.5) The onâ¢(1)subscriptğ‘œğ‘›1o_{n}(1)italic_o start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( 1 ) is a function depending on nğ‘›nitalic_n, which is oâ¢(1/n)ğ‘œ1ğ‘›o(1/\sqrt{n})italic_o ( 1 / square-root start_ARG italic_n end_ARG ) in [19, 21] and is oâ¢(2âˆ’n1/d)ğ‘œsuperscript2superscriptğ‘›1ğ‘‘o(2^{-n^{1/d}})italic_o ( 2 start_POSTSUPERSCRIPT - italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ) in [15]. Equation (1.5) shows the average-case hardness of computing parity by ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. In the quantum case, we can study the following problem similarly. Problem 1.3 (Average case hardness). Let Uğ‘ˆUitalic_U be a ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit with a=polyâ¢(n)ğ‘polyğ‘›a={\rm poly}(n)italic_a = roman_poly ( italic_n ) ancillary qubits. For any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, let Qâ¢(x)ğ‘„ğ‘¥Q(x)italic_Q ( italic_x ) be the output of measuring the (n+1)ğ‘›1(n+1)( italic_n + 1 )-th qubit of Uâ¢|x,0aâŸ©ğ‘ˆketğ‘¥superscript0ğ‘U\ket{x,0^{a}}italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ©, then can we find an upper bound on the following probability Prâ¡[Qâ¢(x)=Paritynâ¢(x)]â¢?Prğ‘„ğ‘¥subscriptParityğ‘›ğ‘¥?\Pr[Q(x)={\rm Parity}_{n}(x)]?roman_Pr [ italic_Q ( italic_x ) = roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) ] ? (1.6) Here the probability is taken over all xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT and the randomness of Qâ¢(x)ğ‘„ğ‘¥Q(x)italic_Q ( italic_x ). In [20], the author proved that when the depth d=2ğ‘‘2d=2italic_d = 2, then no matter how large the number of ancilla qubits ağ‘aitalic_a is, the probability in Equation (1.6) is at most 12+oâ¢(2âˆ’n)12ğ‘œsuperscript2ğ‘›\frac{1}{2}+o(2^{-n})divide start_ARG 1 end_ARG start_ARG 2 end_ARG + italic_o ( 2 start_POSTSUPERSCRIPT - italic_n end_POSTSUPERSCRIPT ). In [17], the authors showed that for any dğ‘‘ditalic_d, if a<12â¢n1/dğ‘12superscriptğ‘›1ğ‘‘a<\frac{1}{2}n^{1/d}italic_a < divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT, then the probability in (1.6) is smaller than 12+oâ¢(2âˆ’n1/d)12ğ‘œsuperscript2superscriptğ‘›1ğ‘‘\frac{1}{2}+o(2^{-n^{1/d}})divide start_ARG 1 end_ARG start_ARG 2 end_ARG + italic_o ( 2 start_POSTSUPERSCRIPT - italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). Recently, in [2], the authors proved a similar result but only required a=O~â¢(n1+3âˆ’d)ğ‘~ğ‘‚superscriptğ‘›1superscript3ğ‘‘a=\widetilde{O}(n^{1+3^{-d}})italic_a = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1 + 3 start_POSTSUPERSCRIPT - italic_d end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). Thus, all these results leave open the possibility that the parity function can be computed with high probability by a ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit with, for example, Oâ¢(n1.1)ğ‘‚superscriptğ‘›1.1O(n^{1.1})italic_O ( italic_n start_POSTSUPERSCRIPT 1.1 end_POSTSUPERSCRIPT ) ancilla qubits. A closely relevant problem is the preparation of cat states by low depth quantum circuits. A cat state on nğ‘›nitalic_n qubits is a state of the form |CATnâŸ©:=12â¢(|0nâŸ©+|1nâŸ©)assignketsubscriptCATğ‘›12ketsuperscript0ğ‘›ketsuperscript1ğ‘›\ket{{\rm CAT}_{n}}:=\frac{1}{\sqrt{2}}(\ket{0^{n}}+\ket{1^{n}})| start_ARG roman_CAT start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_ARG âŸ© := divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG ( | start_ARG 0 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG âŸ© + | start_ARG 1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG âŸ© ). A more general family of states are called nğ‘›nitalic_n-nekomata states, defined as |Î½âŸ©:=12â¢(|0nâŸ©â¢|Ï•0âŸ©+|1nâŸ©â¢|Ï•1âŸ©)assignketğœˆ12ketsuperscript0ğ‘›ketsubscriptitalic-Ï•0ketsuperscript1ğ‘›ketsubscriptitalic-Ï•1\ket{\nu}:=\frac{1}{\sqrt{2}}(\ket{0^{n}}\ket{\phi_{0}}+\ket{1^{n}}\ket{\phi_{% 1}})| start_ARG italic_Î½ end_ARG âŸ© := divide start_ARG 1 end_ARG start_ARG square-root start_ARG 2 end_ARG end_ARG ( | start_ARG 0 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG âŸ© | start_ARG italic_Ï• start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT end_ARG âŸ© + | start_ARG 1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG âŸ© | start_ARG italic_Ï• start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_ARG âŸ© ), where |Ï•0âŸ©,|Ï•1âŸ©ketsubscriptitalic-Ï•0ketsubscriptitalic-Ï•1\ket{\phi_{0}},\ket{\phi_{1}}| start_ARG italic_Ï• start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT end_ARG âŸ© , | start_ARG italic_Ï• start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_ARG âŸ© can be arbitrary states on any number of qubits. In [20], the following problem was proposed. Problem 1.4 (Can nekomata states be constructed in ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT?). Let Î·âˆˆ[0,1)ğœ‚01\eta\in[0,1)italic_Î· âˆˆ [ 0 , 1 ) and let |Î½âŸ©ketğœˆ\ket{\nu}| start_ARG italic_Î½ end_ARG âŸ© be any nğ‘›nitalic_n-nekomata state. Is it possible to construct a ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit Uğ‘ˆUitalic_U such that the fidelity of Uâ¢|0n+aâŸ©ğ‘ˆketsuperscript0ğ‘›ğ‘U\ket{0^{n+a}}italic_U | start_ARG 0 start_POSTSUPERSCRIPT italic_n + italic_a end_POSTSUPERSCRIPT end_ARG âŸ© and |Î½âŸ©ketğœˆ\ket{\nu}| start_ARG italic_Î½ end_ARG âŸ© is at least 1âˆ’Î·1ğœ‚1-\eta1 - italic_Î·? It was also proved in [20, Theorem 3.1] that Problem 1.2 and Problem 1.4 are equivalent. In this work, we provide essentially complete answers to the above three problems. 1.2 Main results For Problem 1.2, our result is as follows. Theorem 1.5 (Parity is not in QAC0). Assume that Î·âˆˆ[0,1/2],Îµâˆˆ[0,1)formulae-sequenceğœ‚012ğœ€01\eta\in[0,1/2],\varepsilon\in[0,1)italic_Î· âˆˆ [ 0 , 1 / 2 ] , italic_Îµ âˆˆ [ 0 , 1 ) satisfying that (1âˆ’Î·)â¢(1âˆ’Îµ)>1/2+2âˆ’Î©â¢(n1/d/logâ¡n)1ğœ‚1ğœ€12superscript2Î©superscriptğ‘›1ğ‘‘ğ‘›(1-\eta)(1-\varepsilon)>{1}/{2}+2^{-\Omega({n^{1/d}}/{\log n})}( 1 - italic_Î· ) ( 1 - italic_Îµ ) > 1 / 2 + 2 start_POSTSUPERSCRIPT - roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT / roman_log italic_n ) end_POSTSUPERSCRIPT. Then any QAC0 circuit of depth dğ‘‘ditalic_d cannot (Îµ,Î·)ğœ€ğœ‚(\varepsilon,\eta)( italic_Îµ , italic_Î· )-approximate the parity function. As a direct application, we have the following result. Corollary 1.6. ğğ€ğ‚0â«‹ğğ€ğ‚wf0superscriptğğ€ğ‚0superscriptsubscriptğğ€ğ‚wf0{\bf QAC}^{0}\subsetneqq{\bf QAC}_{\rm wf}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT â«‹ bold_QAC start_POSTSUBSCRIPT roman_wf end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. We also have the following more concrete characterisation of the number of ancillary qubits to compute parity. Theorem 1.7 (Computing parity by QAC require exponentially many ancillas). Assume that Î·âˆˆ[0,1/2],Îµâˆˆ[0,1)formulae-sequenceğœ‚012ğœ€01\eta\in[0,1/2],\varepsilon\in[0,1)italic_Î· âˆˆ [ 0 , 1 / 2 ] , italic_Îµ âˆˆ [ 0 , 1 ) such that (1âˆ’Î·)â¢(1âˆ’Îµ)>1/21ğœ‚1ğœ€12(1-\eta)(1-\varepsilon)>1/2( 1 - italic_Î· ) ( 1 - italic_Îµ ) > 1 / 2. Then any ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of depth dğ‘‘ditalic_d that (Îµ,Î·)ğœ€ğœ‚(\varepsilon,\eta)( italic_Îµ , italic_Î· ) approximates the nğ‘›nitalic_n-bit parity function requires 2Î©â¢(n1/d/câ¢logâ¡n)superscript2Î©superscriptğ‘›1ğ‘‘ğ‘ğ‘›2^{\Omega(n^{1/d}/{c\log n})}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT / italic_c roman_log italic_n ) end_POSTSUPERSCRIPT ancillary qubits, where c=âˆ’logâ¡((1âˆ’Î·)â¢(1âˆ’Îµ)âˆ’1/2)ğ‘1ğœ‚1ğœ€12c=-\log((1-\eta)(1-\varepsilon)-1/2)italic_c = - roman_log ( ( 1 - italic_Î· ) ( 1 - italic_Îµ ) - 1 / 2 ). This is close to tight, as Rosenthal showed that there is a constant-depth ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit computing parity with high probability, using expâ¡(polyâ¢(n1/d)â¢logâ¡(n/Î·))polysuperscriptğ‘›1ğ‘‘ğ‘›ğœ‚\exp({\rm poly}(n^{1/d})\log(n/\eta))roman_exp ( roman_poly ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) roman_log ( italic_n / italic_Î· ) ) many ancillary qubits [20]. As a direct application of Theorem 1.7 and [20, Theorem 3.1], we have the following result towards Problem 1.4.222[20, Theorem 3.1] states that if there is a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of depth dğ‘‘ditalic_d, size sğ‘ sitalic_s using ağ‘aitalic_a ancillary qubits that prepares a nekomata state with fidelity 1âˆ’Î·1ğœ‚1-\eta1 - italic_Î·, then there is a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of depth 4â¢d+34ğ‘‘34d+34 italic_d + 3, size Oâ¢(n+s)ğ‘‚ğ‘›ğ‘ O(n+s)italic_O ( italic_n + italic_s ) using ağ‘aitalic_a ancillary qubits that (0,Oâ¢(Î·))0ğ‘‚ğœ‚(0,O(\eta))( 0 , italic_O ( italic_Î· ) ) approximates the parity function. From the proof of this theorem, Oâ¢(Î·)=72â¢Î·ğ‘‚ğœ‚72ğœ‚O(\eta)=72\etaitalic_O ( italic_Î· ) = 72 italic_Î·. So when using Theorem 1.7, cğ‘citalic_c becomes âˆ’logâ¡(1/2âˆ’72â¢Î·)1272ğœ‚-\log(1/2-72\eta)- roman_log ( 1 / 2 - 72 italic_Î· ) assuming Î·<1/144ğœ‚1144\eta<1/144italic_Î· < 1 / 144. Corollary 1.8 (Preparing nekomata states by ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuits requires exponentially many ancillas). Assume that Î·âˆˆ[0,1/144)ğœ‚01144\eta\in[0,1/144)italic_Î· âˆˆ [ 0 , 1 / 144 ). Then any ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of depth dğ‘‘ditalic_d that prepares a nğ‘›nitalic_n-nekomata state with fidelity at least 1âˆ’Î·1ğœ‚1-\eta1 - italic_Î· requires 2Î©â¢(n1/d/câ¢logâ¡n)superscript2Î©superscriptğ‘›1ğ‘‘ğ‘ğ‘›2^{\Omega(n^{1/d}/c\log n)}2 start_POSTSUPERSCRIPT roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT / italic_c roman_log italic_n ) end_POSTSUPERSCRIPT ancillary qubits, where c=âˆ’logâ¡(1/2âˆ’72â¢Î·)ğ‘1272ğœ‚c=-\log(1/2-72\eta)italic_c = - roman_log ( 1 / 2 - 72 italic_Î· ). For Problem 1.3, our main result is as follows. Theorem 1.9 (Average case hardness of computing parity by QAC). Let Uğ‘ˆUitalic_U be a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit with depth dğ‘‘ditalic_d, size sğ‘ sitalic_s and ağ‘aitalic_a ancillary qubits. For any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, let Qâ¢(x)ğ‘„ğ‘¥Q(x)italic_Q ( italic_x ) be the output of measuring the (n+1)ğ‘›1(n+1)( italic_n + 1 )-th qubit of Uâ¢|x,0aâŸ©ğ‘ˆketğ‘¥superscript0ğ‘U\ket{x,0^{a}}italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ©. Then Prâ¡[Qâ¢(x)=Paritynâ¢(x)]â‰¤12+sâ‹…2âˆ’Î©â¢(n~/logâ¡n~),Prğ‘„ğ‘¥subscriptParityğ‘›ğ‘¥12â‹…ğ‘ superscript2Î©~ğ‘›~ğ‘›\Pr\Big{[}Q(x)={\rm Parity}_{n}(x)\Big{]}\leq\frac{1}{2}+\sqrt{s}\cdot 2^{-% \Omega(\tilde{n}/\log\tilde{n})},roman_Pr [ italic_Q ( italic_x ) = roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) ] â‰¤ divide start_ARG 1 end_ARG start_ARG 2 end_ARG + square-root start_ARG italic_s end_ARG â‹… 2 start_POSTSUPERSCRIPT - roman_Î© ( over~ start_ARG italic_n end_ARG / roman_log over~ start_ARG italic_n end_ARG ) end_POSTSUPERSCRIPT , (1.7) where n~=n1/dlogâ¡(n+a)~ğ‘›superscriptğ‘›1ğ‘‘ğ‘›ğ‘\tilde{n}=\frac{n^{1/d}}{\log(n+a)}over~ start_ARG italic_n end_ARG = divide start_ARG italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT end_ARG start_ARG roman_log ( italic_n + italic_a ) end_ARG and the probability is taken over all xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT and the randomness of Qâ¢(x)ğ‘„ğ‘¥Q(x)italic_Q ( italic_x ). In particular, for ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits, we have Prâ¡[Qâ¢(x)=Paritynâ¢(x)]â‰¤12+2âˆ’Î©â¢(n1/d/logâ¡n).Prğ‘„ğ‘¥subscriptParityğ‘›ğ‘¥12superscript2Î©superscriptğ‘›1ğ‘‘ğ‘›\Pr\Big{[}Q(x)={\rm Parity}_{n}(x)\Big{]}\leq\frac{1}{2}+2^{-\Omega({n^{1/d}}/% {\log n})}.roman_Pr [ italic_Q ( italic_x ) = roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) ] â‰¤ divide start_ARG 1 end_ARG start_ARG 2 end_ARG + 2 start_POSTSUPERSCRIPT - roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT / roman_log italic_n ) end_POSTSUPERSCRIPT . (1.8) Theorem 1.9 follows from a quantum analog of the LMN theorem [15], which we now state. Theorem 1.10 (Fourier spectrum of ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuits). Let Uğ‘ˆUitalic_U be a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of depth dğ‘‘ditalic_d and size sğ‘ sitalic_s, acting on n+ağ‘›ğ‘n+aitalic_n + italic_a qubits. Let Î´âˆˆ(0,1]ğ›¿01\delta\in(0,1]italic_Î´ âˆˆ ( 0 , 1 ] and k=(Oâ¢((logâ¡(n+a))â¢(logâ¡s/Î´)â¢(logâ¡logâ¡s/Î´)))d.ğ‘˜superscriptğ‘‚ğ‘›ğ‘ğ‘ ğ›¿ğ‘ ğ›¿ğ‘‘k=\Big{(}O\big{(}(\log(n+a))(\log s/\delta)(\log\log s/\delta)\big{)}\Big{)}^{% d}.italic_k = ( italic_O ( ( roman_log ( italic_n + italic_a ) ) ( roman_log italic_s / italic_Î´ ) ( roman_log roman_log italic_s / italic_Î´ ) ) ) start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT . (1.9) Then for the function fâ¢(x):=âŸ¨x,0a|â¢Uâ€ â¢Zn+1â¢Uâ¢|x,0aâŸ©assignğ‘“ğ‘¥brağ‘¥superscript0ğ‘superscriptğ‘ˆâ€ subscriptğ‘ğ‘›1ğ‘ˆketğ‘¥superscript0ğ‘f(x):=\bra{x,0^{a}}U^{\dagger}Z_{n+1}U\ket{x,0^{a}}italic_f ( italic_x ) := âŸ¨ start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG | italic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Z start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© (1.10) from {0,1}nsuperscript01ğ‘›\{0,1\}^{n}{ 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT to [âˆ’1,1]11[-1,1][ - 1 , 1 ], we have âˆ‘|S|>kf^â¢(S)2â‰¤Î´.subscriptğ‘†ğ‘˜^ğ‘“superscriptğ‘†2ğ›¿\sum_{|S|>k}\widehat{f}(S)^{2}\leq\delta.âˆ‘ start_POSTSUBSCRIPT | italic_S | > italic_k end_POSTSUBSCRIPT over^ start_ARG italic_f end_ARG ( italic_S ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰¤ italic_Î´ . (1.11) In the above, f^â¢(S)^ğ‘“ğ‘†\widehat{f}(S)over^ start_ARG italic_f end_ARG ( italic_S ) are the Fourier coefficients of the real-valued Boolean function fâ¢(x)ğ‘“ğ‘¥f(x)italic_f ( italic_x ). For ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits, k=polyâ¢(logâ¡n)ğ‘˜polyğ‘›k={\rm poly}(\log n)italic_k = roman_poly ( roman_log italic_n ) in (1.9). So Theorem 1.10 shows that the Fourier coefficients of the real-valued Boolean function fâ¢(x)ğ‘“ğ‘¥f(x)italic_f ( italic_x ) defined by a ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit are concentrated on the low-degree parts. Consequently, the function fâ¢(x)ğ‘“ğ‘¥f(x)italic_f ( italic_x ) can be learned using quasipolynomially many samples, which coincides with the LMN theorem [15] for ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. 1.3 Technical overview Before starting the technical parts, we briefly recall some notation relating to Pauli matrices. In this work, Pauli matrices are denoted as I,X,Y,Zğ¼ğ‘‹ğ‘Œğ‘I,X,Y,Zitalic_I , italic_X , italic_Y , italic_Z. They are defined as I=(1001),X=(0110),Y=(0âˆ’ii0),Z=(100âˆ’1).formulae-sequenceğ¼matrix1001formulae-sequenceğ‘‹matrix0110formulae-sequenceğ‘Œmatrix0ğ‘–ğ‘–0ğ‘matrix1001I=\begin{pmatrix}1&0\\ 0&1\end{pmatrix},\quad X=\begin{pmatrix}0&1\\ 1&0\end{pmatrix},\quad Y=\begin{pmatrix}0&-i\\ i&0\end{pmatrix},\quad Z=\begin{pmatrix}1&0\\ 0&-1\end{pmatrix}.italic_I = ( start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW end_ARG ) , italic_X = ( start_ARG start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL end_ROW start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW end_ARG ) , italic_Y = ( start_ARG start_ROW start_CELL 0 end_CELL start_CELL - italic_i end_CELL end_ROW start_ROW start_CELL italic_i end_CELL start_CELL 0 end_CELL end_ROW end_ARG ) , italic_Z = ( start_ARG start_ROW start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL - 1 end_CELL end_ROW end_ARG ) . When a Pauli matrix, say Zğ‘Zitalic_Z, is acting on the iğ‘–iitalic_i-th qubit of nğ‘›nitalic_n qubits, then we sometimes simply write it as Zisubscriptğ‘ğ‘–Z_{i}italic_Z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, which represents ZiâŠ—I[n]\{i}tensor-productsubscriptğ‘ğ‘–subscriptğ¼\delimited-[]ğ‘›ğ‘–Z_{i}\otimes I_{[n]\backslash\{i\}}italic_Z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âŠ— italic_I start_POSTSUBSCRIPT [ italic_n ] \ { italic_i } end_POSTSUBSCRIPT. For any operator Ağ´Aitalic_A acting on nğ‘›nitalic_n qubits, it has a Pauli decomposition A=âˆ‘PÎ±Pâ¢ÏƒPğ´subscriptğ‘ƒsubscriptğ›¼ğ‘ƒsubscriptğœğ‘ƒA=\sum_{P}\alpha_{P}\sigma_{P}italic_A = âˆ‘ start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT italic_Î± start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT, where ÏƒPâˆˆ{I,X,Y,Z}âŠ—nsubscriptğœğ‘ƒsuperscriptğ¼ğ‘‹ğ‘Œğ‘tensor-productabsentğ‘›\sigma_{P}\in\{I,X,Y,Z\}^{\otimes n}italic_Ïƒ start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT âˆˆ { italic_I , italic_X , italic_Y , italic_Z } start_POSTSUPERSCRIPT âŠ— italic_n end_POSTSUPERSCRIPT, and the coefficients Î±Psubscriptğ›¼ğ‘ƒ\alpha_{P}italic_Î± start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT are computed via Î±P=âŸ¨A,ÏƒPâŸ©=12nâ¢Trâ¢(Aâ€ â¢ÏƒP).subscriptğ›¼ğ‘ƒğ´subscriptğœğ‘ƒ1superscript2ğ‘›Trsuperscriptğ´â€ subscriptğœğ‘ƒ\alpha_{P}=\langle A,\sigma_{P}\rangle=\frac{1}{2^{n}}{\rm Tr}(A^{\dagger}% \sigma_{P}).italic_Î± start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT = âŸ¨ italic_A , italic_Ïƒ start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT âŸ© = divide start_ARG 1 end_ARG start_ARG 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG roman_Tr ( italic_A start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT ) . Each ÏƒP=Ïƒ1âŠ—â‹¯âŠ—Ïƒnsubscriptğœğ‘ƒtensor-productsubscriptğœ1â‹¯subscriptğœğ‘›\sigma_{P}=\sigma_{1}\otimes\cdots\otimes\sigma_{n}italic_Ïƒ start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT = italic_Ïƒ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŠ— â‹¯ âŠ— italic_Ïƒ start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT defines a Pauli degree #â¢{iâˆˆ[n]:Ïƒiâ‰ I}#conditional-setğ‘–delimited-[]ğ‘›subscriptğœğ‘–ğ¼\#\{i\in[n]:\sigma_{i}\neq I\}# { italic_i âˆˆ [ italic_n ] : italic_Ïƒ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‰  italic_I }. The Pauli degree of Ağ´Aitalic_A is the largest Pauli degree of all ÏƒPsubscriptğœğ‘ƒ\sigma_{P}italic_Ïƒ start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT with Î±Pâ‰ 0subscriptğ›¼ğ‘ƒ0\alpha_{P}\neq 0italic_Î± start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT â‰  0. All our main results above are based on the following theorem. We actually proved a more general result that says ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits can be approximated by low Pauli degree operators in the Pauli decomposition, see Theorem 2.8 for more details. However, for the main results stated above, the following special case is enough. The degree in the following theorem refers to the degree of polynomials, not the Pauli degree of operators we just discussed, highlighting a key difference between the following theorem and Theorem 2.8. Theorem 1.11. Let Uğ‘ˆUitalic_U be a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of depth dğ‘‘ditalic_d and size sğ‘ sitalic_s, acting on n+ağ‘›ğ‘n+aitalic_n + italic_a qubits. Let Îµ,Î´âˆˆ(0,1)ğœ€ğ›¿01\varepsilon,\delta\in(0,1)italic_Îµ , italic_Î´ âˆˆ ( 0 , 1 ). Then there is a distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D on polynomials from {0,1}nâ†’[âˆ’1,1]â†’superscript01ğ‘›11\{0,1\}^{n}\rightarrow[-1,1]{ 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ [ - 1 , 1 ] of degree at most (Oâ¢((logâ¡(n+a))â¢(logâ¡1/Îµ)â¢(logâ¡logâ¡1/Îµ)))dsuperscriptğ‘‚ğ‘›ğ‘1ğœ€1ğœ€ğ‘‘\Big{(}O\big{(}(\log(n+a))(\log 1/\varepsilon)(\log\log 1/\varepsilon)\big{)}% \Big{)}^{d}( italic_O ( ( roman_log ( italic_n + italic_a ) ) ( roman_log 1 / italic_Îµ ) ( roman_log roman_log 1 / italic_Îµ ) ) ) start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT (1.12) such that for any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, Prgâˆ¼ğ’Ÿâ¡[|gâ¢(x)âˆ’âŸ¨x,0a|â¢Uâ€ â¢Zn+1â¢Uâ¢|x,0aâŸ©|â‰¤2â¢sâ¢Îµ]â‰¥(1âˆ’Îµ)s,subscriptPrsimilar-toğ‘”ğ’Ÿğ‘”ğ‘¥brağ‘¥superscript0ğ‘superscriptğ‘ˆâ€ subscriptğ‘ğ‘›1ğ‘ˆketğ‘¥superscript0ğ‘2ğ‘ ğœ€superscript1ğœ€ğ‘ \Pr_{g\sim\mathcal{D}}\left[\,\Big{|}g(x)-\bra{x,0^{a}}U^{\dagger}Z_{n+1}U\ket% {x,0^{a}}\Big{|}\leq 2s\varepsilon\,\right]\geq(1-\varepsilon)^{s},roman_Pr start_POSTSUBSCRIPT italic_g âˆ¼ caligraphic_D end_POSTSUBSCRIPT [ | italic_g ( italic_x ) - âŸ¨ start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG | italic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Z start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© | â‰¤ 2 italic_s italic_Îµ ] â‰¥ ( 1 - italic_Îµ ) start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT , (1.13) In particular, if 1/Îµ=Oâ¢(s/Î´)1ğœ€ğ‘‚ğ‘ ğ›¿1/\varepsilon=O(s/\delta)1 / italic_Îµ = italic_O ( italic_s / italic_Î´ ), then for any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, Prgâˆ¼ğ’Ÿâ¡[|gâ¢(x)âˆ’âŸ¨x,0a|â¢Uâ€ â¢Zn+1â¢Uâ¢|x,0aâŸ©|â‰¤Î´]â‰¥1âˆ’Î´.subscriptPrsimilar-toğ‘”ğ’Ÿğ‘”ğ‘¥brağ‘¥superscript0ğ‘superscriptğ‘ˆâ€ subscriptğ‘ğ‘›1ğ‘ˆketğ‘¥superscript0ğ‘ğ›¿1ğ›¿\Pr_{g\sim\mathcal{D}}\left[\,\Big{|}g(x)-\bra{x,0^{a}}U^{\dagger}Z_{n+1}U\ket% {x,0^{a}}\Big{|}\leq\delta\,\right]\geq 1-\delta.roman_Pr start_POSTSUBSCRIPT italic_g âˆ¼ caligraphic_D end_POSTSUBSCRIPT [ | italic_g ( italic_x ) - âŸ¨ start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG | italic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Z start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© | â‰¤ italic_Î´ ] â‰¥ 1 - italic_Î´ . (1.14) Theorem 1.11 can be viewed as a quantum analog of Razborov-Smolenskyâ€™s low-degree approximation for ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits, see [19, 21]. For an ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit of depth dğ‘‘ditalic_d and size sğ‘ sitalic_s, Razborov-Smolenskyâ€™s result shows that there is a distribution on real polynomials of degree Oâ¢((logâ¡s)2â¢d)ğ‘‚superscriptğ‘ 2ğ‘‘O((\log s)^{2d})italic_O ( ( roman_log italic_s ) start_POSTSUPERSCRIPT 2 italic_d end_POSTSUPERSCRIPT ) such that for any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, if we randomly choose a polynomial from the distribution, then with high probability it coincides with the output of the ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit. On the other hand, it was also proved that the parity function cannot be computed in the same sense by a low-degree polynomial. Thus, this proves that parity is not in ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT. Theorem 1.11 above is indeed inspired by Razborov-Smolenskyâ€™s result. However, we obtained more than Razborov-Smolenskyâ€™s proof. A surprising result is the quantum analog of the LMN theorem, stated in Theorem 1.10. In comparison, Razborov-Smolenskyâ€™s proof does not lead to a result on the Fourier spectrum of ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuits.333From our proofs, we feel Razborov-Smolenskyâ€™s proof should lead to a result similar to the LMN theorem, but this may not have been obvious previously. See Section 4. Once we have this result on low-degree approximation, together with some classical results on parity function, we can prove Theorem 1.5 and relevant results stated in the above section, see Section 3. To highlight the proof of Theorem 1.11, we first recall Razborov-Smolenskyâ€™s idea for low-degree approximation of the OR function. Note that the nğ‘›nitalic_n-bit OR function is ORnâ¢(x)=1âˆ’âˆi=1n(1âˆ’xi)subscriptORğ‘›ğ‘¥1superscriptsubscriptproductğ‘–1ğ‘›1subscriptğ‘¥ğ‘–{\rm OR}_{n}(x)=1-\prod_{i=1}^{n}(1-x_{i})roman_OR start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) = 1 - âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( 1 - italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ), to approximate it by a low-degree polynomial, we introduce m=logâ¡nğ‘šğ‘›m=\log nitalic_m = roman_log italic_n random linear polynomials piâ¢(x)=âˆ‘jâˆˆSixjsubscriptğ‘ğ‘–ğ‘¥subscriptğ‘—subscriptğ‘†ğ‘–subscriptğ‘¥ğ‘—p_{i}(x)=\sum_{j\in S_{i}}x_{j}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( italic_x ) = âˆ‘ start_POSTSUBSCRIPT italic_j âˆˆ italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT and construct câ¢(x)=1âˆ’âˆi=1m(1âˆ’piâ¢(x))ğ‘ğ‘¥1superscriptsubscriptproductğ‘–1ğ‘š1subscriptğ‘ğ‘–ğ‘¥c(x)=1-\prod_{i=1}^{m}(1-p_{i}(x))italic_c ( italic_x ) = 1 - âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT ( 1 - italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( italic_x ) ). Here jâˆˆ[n]ğ‘—delimited-[]ğ‘›j\in[n]italic_j âˆˆ [ italic_n ] is put into Sisubscriptğ‘†ğ‘–S_{i}italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT with probability 1/2i1superscript2ğ‘–1/2^{i}1 / 2 start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT. As we can see, there is a distribution in the construction of pisubscriptğ‘ğ‘–p_{i}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT. It can be proved that for any xğ‘¥xitalic_x, with a constant probability with respect to this distribution, câ¢(x)=ORnâ¢(x)ğ‘ğ‘¥subscriptORğ‘›ğ‘¥c(x)={\rm OR}_{n}(x)italic_c ( italic_x ) = roman_OR start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ). We can increase the success probability to 1âˆ’Îµ1ğœ€1-\varepsilon1 - italic_Îµ for any given xğ‘¥xitalic_x by generating â„“=Î©â¢(logâ¡1/Îµ)â„“Î©1ğœ€\ell=\Omega(\log 1/\varepsilon)roman_â„“ = roman_Î© ( roman_log 1 / italic_Îµ ) such polynomials c1â¢(x),â€¦,câ„“â¢(x)subscriptğ‘1ğ‘¥â€¦subscriptğ‘â„“ğ‘¥c_{1}(x),\ldots,c_{\ell}(x)italic_c start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_x ) , â€¦ , italic_c start_POSTSUBSCRIPT roman_â„“ end_POSTSUBSCRIPT ( italic_x ) and considering their average Câ¢(x)=1âˆ’âˆi=1â„“(1âˆ’ciâ¢(x))ğ¶ğ‘¥1superscriptsubscriptproductğ‘–1â„“1subscriptğ‘ğ‘–ğ‘¥C(x)=1-\prod_{i=1}^{\ell}(1-c_{i}(x))italic_C ( italic_x ) = 1 - âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT ( 1 - italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ( italic_x ) ). The degree of Câ¢(x)ğ¶ğ‘¥C(x)italic_C ( italic_x ) is only logâ¡(n)â¢logâ¡(1/Îµ)ğ‘›1ğœ€\log(n)\log(1/\varepsilon)roman_log ( italic_n ) roman_log ( 1 / italic_Îµ ). In the quantum case, the basic building blocks of ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuits are the CC..CZ gates. By definition, CZ[n]=Iâˆ’12nâˆ’1â¢âˆi=1n(Iâˆ’Zi).subscriptCZdelimited-[]ğ‘›ğ¼1superscript2ğ‘›1superscriptsubscriptproductğ‘–1ğ‘›ğ¼subscriptğ‘ğ‘–{\rm CZ}_{[n]}=I-\frac{1}{2^{n-1}}\prod_{i=1}^{n}(I-Z_{i}).roman_CZ start_POSTSUBSCRIPT [ italic_n ] end_POSTSUBSCRIPT = italic_I - divide start_ARG 1 end_ARG start_ARG 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT end_ARG âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_I - italic_Z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) . (1.15) So we also generate m=logâ¡nğ‘šğ‘›m=\log nitalic_m = roman_log italic_n random linear operators pi=âˆ‘jâˆˆSiZjsubscriptğ‘ğ‘–subscriptğ‘—subscriptğ‘†ğ‘–subscriptğ‘ğ‘—p_{i}=\sum_{j\in S_{i}}Z_{j}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = âˆ‘ start_POSTSUBSCRIPT italic_j âˆˆ italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT italic_Z start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT (here jâˆˆ[n]ğ‘—delimited-[]ğ‘›j\in[n]italic_j âˆˆ [ italic_n ] is put into Sisubscriptğ‘†ğ‘–S_{i}italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT also with probability 1/2i1superscript2ğ‘–1/2^{i}1 / 2 start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT) and consider q=Iâˆ’2M2â¢âˆi=1m(Iâˆ’pi)2ğ‘ğ¼2superscriptğ‘€2superscriptsubscriptproductğ‘–1ğ‘šsuperscriptğ¼subscriptğ‘ğ‘–2q=I-\frac{2}{M^{2}}\prod_{i=1}^{m}(I-p_{i})^{2}italic_q = italic_I - divide start_ARG 2 end_ARG start_ARG italic_M start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT ( italic_I - italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT (1.16) for some Mğ‘€Mitalic_M such that âŸ¨1n|â¢qâ¢|1nâŸ©=âˆ’1brasuperscript1ğ‘›ğ‘ketsuperscript1ğ‘›1\bra{1^{n}}q\ket{1^{n}}=-1âŸ¨ start_ARG 1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG | italic_q | start_ARG 1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG âŸ© = - 1, i.e., M=âˆi=1m(1+#â¢(Si))ğ‘€superscriptsubscriptproductğ‘–1ğ‘š1#subscriptğ‘†ğ‘–M=\prod_{i=1}^{m}(1+\#(S_{i}))italic_M = âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT ( 1 + # ( italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) ). In (1.16), the square is added to ensure that âŸ¨x|â¢qâ¢|xâŸ©âˆˆ[âˆ’1,1]brağ‘¥ğ‘ketğ‘¥11\bra{x}q\ket{x}\in[-1,1]âŸ¨ start_ARG italic_x end_ARG | italic_q | start_ARG italic_x end_ARG âŸ© âˆˆ [ - 1 , 1 ] for all xğ‘¥xitalic_x, i.e., â€–qâ€–â‰¤1normğ‘1\|q\|\leq 1âˆ¥ italic_q âˆ¥ â‰¤ 1.444This is a big difference between the standard classical construction and ours. Classically, câ¢(x)ğ‘ğ‘¥c(x)italic_c ( italic_x ) defined above is not a bounded polynomial as it can take values as large as polyâ¢(n)polyğ‘›{\rm poly}(n)roman_poly ( italic_n ) at some inputs. However, quantumly qğ‘qitalic_q is a bounded operator. In Lemma 2.1, we will prove that for any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT and xâ‰ 1nğ‘¥superscript1ğ‘›x\neq 1^{n}italic_x â‰  1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, with a constant probability, |âŸ¨x|â¢qâ¢|xâŸ©âˆ’1|â‰¤1/3brağ‘¥ğ‘ketğ‘¥113|\bra{x}q\ket{x}-1|\leq 1/3| âŸ¨ start_ARG italic_x end_ARG | italic_q | start_ARG italic_x end_ARG âŸ© - 1 | â‰¤ 1 / 3. Finally, we can increase the level of accuracy and the success probability by considering Q=Iâˆ’12â„“âˆ’1â¢âˆi=1â„“(Iâˆ’qi).ğ‘„ğ¼1superscript2â„“1superscriptsubscriptproductğ‘–1â„“ğ¼subscriptğ‘ğ‘–Q=I-\frac{1}{2^{\ell-1}}\prod_{i=1}^{\ell}(I-q_{i}).italic_Q = italic_I - divide start_ARG 1 end_ARG start_ARG 2 start_POSTSUPERSCRIPT roman_â„“ - 1 end_POSTSUPERSCRIPT end_ARG âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT ( italic_I - italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) . (1.17) Let ğ’Ÿq,ğ’ŸQsubscriptğ’Ÿğ‘subscriptğ’Ÿğ‘„\mathcal{D}_{q},\mathcal{D}_{Q}caligraphic_D start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT , caligraphic_D start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT denote the distributions on operators qğ‘qitalic_q and Qğ‘„Qitalic_Q, respectively. We will use these distributions throughout the paper. The connection between classical and quantum approximation can be understood by observing for any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, we have that âŸ¨x|â¢CZ[n]â¢|xâŸ©=(âˆ’1)ANDnâ¢(x)brağ‘¥subscriptCZdelimited-[]ğ‘›ketğ‘¥superscript1subscriptANDğ‘›ğ‘¥\bra{x}{\rm CZ}_{[n]}\ket{x}=(-1)^{{\rm AND}_{n}(x)}âŸ¨ start_ARG italic_x end_ARG | roman_CZ start_POSTSUBSCRIPT [ italic_n ] end_POSTSUBSCRIPT | start_ARG italic_x end_ARG âŸ© = ( - 1 ) start_POSTSUPERSCRIPT roman_AND start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) end_POSTSUPERSCRIPT. For function ANDnâ¢(x)=1âˆ’ORnâ¢(xÂ¯)subscriptANDğ‘›ğ‘¥1subscriptORğ‘›Â¯ğ‘¥{\rm AND}_{n}(x)=1-{\rm OR}_{n}(\bar{x})roman_AND start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) = 1 - roman_OR start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( overÂ¯ start_ARG italic_x end_ARG ), using (âˆ’1)x=1âˆ’2â¢xsuperscript1ğ‘¥12ğ‘¥(-1)^{x}=1-2x( - 1 ) start_POSTSUPERSCRIPT italic_x end_POSTSUPERSCRIPT = 1 - 2 italic_x for xâˆˆ{0,1}ğ‘¥01x\in\{0,1\}italic_x âˆˆ { 0 , 1 }, we have that ANDnâ¢(x)=12nâ¢âˆi=1n(1âˆ’(âˆ’1)xi).subscriptANDğ‘›ğ‘¥1superscript2ğ‘›superscriptsubscriptproductğ‘–1ğ‘›1superscript1subscriptğ‘¥ğ‘–{\rm AND}_{n}(x)=\frac{1}{2^{n}}\prod_{i=1}^{n}(1-(-1)^{x_{i}}).roman_AND start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) = divide start_ARG 1 end_ARG start_ARG 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( 1 - ( - 1 ) start_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) . (1.18) Namely, (âˆ’1)ANDnâ¢(x)=1âˆ’2â¢Aâ¢Nâ¢Dnâ¢(x)=1âˆ’12nâˆ’1â¢âˆi=1n(1âˆ’(âˆ’1)xi).superscript1subscriptANDğ‘›ğ‘¥12ANsubscriptDğ‘›ğ‘¥11superscript2ğ‘›1superscriptsubscriptproductğ‘–1ğ‘›1superscript1subscriptğ‘¥ğ‘–(-1)^{{\rm AND}_{n}(x)}=1-2{\rm AND}_{n}(x)=1-\frac{1}{2^{n-1}}\prod_{i=1}^{n}% (1-(-1)^{x_{i}}).( - 1 ) start_POSTSUPERSCRIPT roman_AND start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) end_POSTSUPERSCRIPT = 1 - 2 roman_A roman_N roman_D start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) = 1 - divide start_ARG 1 end_ARG start_ARG 2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT end_ARG âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( 1 - ( - 1 ) start_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) . (1.19) In (1.16), for any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, âŸ¨x|â¢qâ¢|xâŸ©=1âˆ’2M2â¢âˆi=1m(1âˆ’âˆ‘jâˆˆSi(âˆ’1)xj)2.brağ‘¥ğ‘ketğ‘¥12superscriptğ‘€2superscriptsubscriptproductğ‘–1ğ‘šsuperscript1subscriptğ‘—subscriptğ‘†ğ‘–superscript1subscriptğ‘¥ğ‘—2\bra{x}q\ket{x}=1-\frac{2}{M^{2}}\prod_{i=1}^{m}\left(1-\sum_{j\in S_{i}}(-1)^% {x_{j}}\right)^{2}.âŸ¨ start_ARG italic_x end_ARG | italic_q | start_ARG italic_x end_ARG âŸ© = 1 - divide start_ARG 2 end_ARG start_ARG italic_M start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG âˆ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT ( 1 - âˆ‘ start_POSTSUBSCRIPT italic_j âˆˆ italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( - 1 ) start_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . (1.20) Compared with (âˆ’1)ANDnâ¢(x)superscript1subscriptANDğ‘›ğ‘¥(-1)^{{\rm AND}_{n}(x)}( - 1 ) start_POSTSUPERSCRIPT roman_AND start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) end_POSTSUPERSCRIPT, it replaces each (âˆ’1)xisuperscript1subscriptğ‘¥ğ‘–(-1)^{x_{i}}( - 1 ) start_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT by the square of a random linear function. For a general ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit, to approximate it by a low-degree polynomial, we only need to replace each OR and AND function with a random low-degree polynomial. After dğ‘‘ditalic_d layers of composition, the degree of this low-degree approximate polynomial is (logâ¡(n)â¢logâ¡(1/Îµ))dsuperscriptğ‘›1ğœ€ğ‘‘(\log(n)\log(1/\varepsilon))^{d}( roman_log ( italic_n ) roman_log ( 1 / italic_Îµ ) ) start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT. If the size of the ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit is sğ‘ sitalic_s, then it suffices to set Îµ=1/Oâ¢(s)ğœ€1ğ‘‚ğ‘ \varepsilon=1/O(s)italic_Îµ = 1 / italic_O ( italic_s ) to ensure a high probability of approximation. In the end, the degree is bounded by (logâ¡s)2â¢dsuperscriptğ‘ 2ğ‘‘(\log s)^{2d}( roman_log italic_s ) start_POSTSUPERSCRIPT 2 italic_d end_POSTSUPERSCRIPT. However, in the quantum case, the proof of low-degree approximation of ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT is more involved. We work with the observable Uâ€ â¢Zn+1â¢Usuperscriptğ‘ˆâ€ subscriptğ‘ğ‘›1ğ‘ˆU^{\dagger}Z_{n+1}Uitalic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Z start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT italic_U corresponding to measurement of the (n+1)ğ‘›1(n+1)( italic_n + 1 )-th qubit following a QAC circuit Uğ‘ˆUitalic_U. In the circuit Uğ‘ˆUitalic_U, we can similarly replace each CC..CZ gate by a random low-degree operator defined above to obtain a new operator U~~ğ‘ˆ\widetilde{U}over~ start_ARG italic_U end_ARG. However, although each multi-qubit operator in U~~ğ‘ˆ\widetilde{U}over~ start_ARG italic_U end_ARG is low-degree, U~â€ â¢Zn+1â¢U~superscript~ğ‘ˆâ€ subscriptğ‘ğ‘›1~ğ‘ˆ\widetilde{U}^{\dagger}Z_{n+1}\widetilde{U}over~ start_ARG italic_U end_ARG start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Z start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT over~ start_ARG italic_U end_ARG can still be a high-degree operator. To obtain a truly low-degree approximation, we have to further modify the operator U~â€ â¢Zn+1â¢U~superscript~ğ‘ˆâ€ subscriptğ‘ğ‘›1~ğ‘ˆ\widetilde{U}^{\dagger}Z_{n+1}\widetilde{U}over~ start_ARG italic_U end_ARG start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Z start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT over~ start_ARG italic_U end_ARG and use a lightcone argument. Below, we use a simple example to explain our main idea; the detailed argument is given in Section 2. Assume that M=ÏƒAâŠ—IB+IAâŠ—ÏƒBğ‘€tensor-productsubscriptğœğ´subscriptğ¼ğµtensor-productsubscriptğ¼ğ´subscriptğœğµM=\sigma_{A}\otimes I_{B}+I_{A}\otimes\sigma_{B}italic_M = italic_Ïƒ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_I start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT + italic_I start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_Ïƒ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT is a low-degree operator. Let C=CZAâŠ—CZBğ¶tensor-productsubscriptCZğ´subscriptCZğµC={\rm CZ}_{A}\otimes{\rm CZ}_{B}italic_C = roman_CZ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— roman_CZ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT, which is a 1-layer QAC0 circuit. We can approximate CZAsubscriptCZğ´{\rm CZ}_{A}roman_CZ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT by QAsubscriptğ‘„ğ´Q_{A}italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT and approximate CZBsubscriptCZğµ{\rm CZ}_{B}roman_CZ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT by QBsubscriptğ‘„ğµQ_{B}italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT, where QA,QBsubscriptğ‘„ğ´subscriptğ‘„ğµQ_{A},Q_{B}italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT , italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT are low-degree operators defined via Equation (1.17). It is easy to check that M0:=Câ¢Mâ¢C=CZAâ¢ÏƒAâ¢CZAâŠ—IB+IAâŠ—CZBâ¢ÏƒBâ¢CZBassignsubscriptğ‘€0ğ¶ğ‘€ğ¶tensor-productsubscriptCZğ´subscriptğœğ´subscriptCZğ´subscriptğ¼ğµtensor-productsubscriptğ¼ğ´subscriptCZğµsubscriptğœğµsubscriptCZğµM_{0}:=CMC={\rm CZ}_{A}\sigma_{A}{\rm CZ}_{A}\otimes I_{B}+I_{A}\otimes{\rm CZ% }_{B}\sigma_{B}{\rm CZ}_{B}italic_M start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT := italic_C italic_M italic_C = roman_CZ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT roman_CZ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_I start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT + italic_I start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— roman_CZ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT roman_CZ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT. A natural way to approximate this is considering M1:=(QAâŠ—QB)â¢Mâ¢(QAâŠ—QB)assignsubscriptğ‘€1tensor-productsubscriptğ‘„ğ´subscriptğ‘„ğµğ‘€tensor-productsubscriptğ‘„ğ´subscriptğ‘„ğµM_{1}:=(Q_{A}\otimes Q_{B})M(Q_{A}\otimes Q_{B})italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT := ( italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT ) italic_M ( italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT ), which is QAâ¢ÏƒAâ¢QAâŠ—QB2+QA2âŠ—QBâ¢ÏƒBâ¢QBtensor-productsubscriptğ‘„ğ´subscriptğœğ´subscriptğ‘„ğ´superscriptsubscriptğ‘„ğµ2tensor-productsuperscriptsubscriptğ‘„ğ´2subscriptğ‘„ğµsubscriptğœğµsubscriptğ‘„ğµQ_{A}\sigma_{A}Q_{A}\otimes Q_{B}^{2}+Q_{A}^{2}\otimes Q_{B}\sigma_{B}Q_{B}italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT âŠ— italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT; so we see that the degree has increased. If there are many terms like QA2,QB2superscriptsubscriptğ‘„ğ´2superscriptsubscriptğ‘„ğµ2Q_{A}^{2},Q_{B}^{2}italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, the degree could increase significantly. As QAâ‰ˆCZA,QBâ‰ˆCZBformulae-sequencesubscriptğ‘„ğ´subscriptCZğ´subscriptğ‘„ğµsubscriptCZğµQ_{A}\approx{\rm CZ}_{A},Q_{B}\approx{\rm CZ}_{B}italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT â‰ˆ roman_CZ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT , italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT â‰ˆ roman_CZ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT, we have QA2â‰ˆIA,QB2â‰ˆIBformulae-sequencesuperscriptsubscriptğ‘„ğ´2subscriptğ¼ğ´superscriptsubscriptğ‘„ğµ2subscriptğ¼ğµQ_{A}^{2}\approx I_{A},Q_{B}^{2}\approx I_{B}italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰ˆ italic_I start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT , italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰ˆ italic_I start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT. Thus, we can consider a truly low-degree operator M2:=QAâ¢ÏƒAâ¢QAâŠ—IB+IAâŠ—QBâ¢ÏƒBâ¢QBassignsubscriptğ‘€2tensor-productsubscriptğ‘„ğ´subscriptğœğ´subscriptğ‘„ğ´subscriptğ¼ğµtensor-productsubscriptğ¼ğ´subscriptğ‘„ğµsubscriptğœğµsubscriptğ‘„ğµM_{2}:=Q_{A}\sigma_{A}Q_{A}\otimes I_{B}+I_{A}\otimes Q_{B}\sigma_{B}Q_{B}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT := italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_I start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT + italic_I start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT. The technical part is to prove M0â‰ˆM2subscriptğ‘€0subscriptğ‘€2M_{0}\approx M_{2}italic_M start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT â‰ˆ italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Although each term in M0,M2subscriptğ‘€0subscriptğ‘€2M_{0},M_{2}italic_M start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is close to each other, there may be exponentially many terms in Mğ‘€Mitalic_M in the general case. So we apparently cannot bound the error directly using the triangle inequality. Our key idea here is to encode QA,QBsubscriptğ‘„ğ´subscriptğ‘„ğµQ_{A},Q_{B}italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT , italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT into unitaries acting on a larger set of qubits and estimate the error in a global way. To be more exact, it is easy to prove M0,M1subscriptğ‘€0subscriptğ‘€1M_{0},M_{1}italic_M start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT are close to each other by noting that CZAâŠ—CZBâ‰ˆQAâŠ—QBtensor-productsubscriptCZğ´subscriptCZğµtensor-productsubscriptğ‘„ğ´subscriptğ‘„ğµ{\rm CZ}_{A}\otimes{\rm CZ}_{B}\approx Q_{A}\otimes Q_{B}roman_CZ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— roman_CZ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT â‰ˆ italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT because it is a tensor product form. If QA,QBsubscriptğ‘„ğ´subscriptğ‘„ğµQ_{A},Q_{B}italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT , italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT are unitary, then M1=M2subscriptğ‘€1subscriptğ‘€2M_{1}=M_{2}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Unfortunately, they are not in general. But we can encode them into unitaries, denoted as UA,UBsubscriptğ‘ˆğ´subscriptğ‘ˆğµU_{A},U_{B}italic_U start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT , italic_U start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT respectively, because â€–QAâ€–â‰¤1,â€–QBâ€–â‰¤1formulae-sequencenormsubscriptğ‘„ğ´1normsubscriptğ‘„ğµ1\|Q_{A}\|\leq 1,\|Q_{B}\|\leq 1âˆ¥ italic_Q start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âˆ¥ â‰¤ 1 , âˆ¥ italic_Q start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT âˆ¥ â‰¤ 1. We can also put them in the top left corner. For CZA,CZBsubscriptCZğ´subscriptCZğµ{\rm CZ}_{A},{\rm CZ}_{B}roman_CZ start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT , roman_CZ start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT, we can do a similar encoding and obtain two unitaries VA,VBsubscriptğ‘‰ğ´subscriptğ‘‰ğµV_{A},V_{B}italic_V start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT , italic_V start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT. For consistency, we carefully encode Mğ‘€Mitalic_M to obtain a new operator M~~ğ‘€\widetilde{M}over~ start_ARG italic_M end_ARG such that Mğ‘€Mitalic_M is in the top left corner. Finally, we prove that M0subscriptğ‘€0M_{0}italic_M start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT is a block of M~0:=(VAâŠ—VB)â€ â¢M~â¢(VAâŠ—VB)assignsubscript~ğ‘€0superscripttensor-productsubscriptğ‘‰ğ´subscriptğ‘‰ğµâ€ ~ğ‘€tensor-productsubscriptğ‘‰ğ´subscriptğ‘‰ğµ\widetilde{M}_{0}:=(V_{A}\otimes V_{B})^{\dagger}\widetilde{M}(V_{A}\otimes V_% {B})over~ start_ARG italic_M end_ARG start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT := ( italic_V start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_V start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT over~ start_ARG italic_M end_ARG ( italic_V start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_V start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT ) and M2subscriptğ‘€2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is a block of M~2:=(UAâŠ—UB)â€ â¢M~â¢(UAâŠ—UB)assignsubscript~ğ‘€2superscripttensor-productsubscriptğ‘ˆğ´subscriptğ‘ˆğµâ€ ~ğ‘€tensor-productsubscriptğ‘ˆğ´subscriptğ‘ˆğµ\widetilde{M}_{2}:=(U_{A}\otimes U_{B})^{\dagger}\widetilde{M}(U_{A}\otimes U_% {B})over~ start_ARG italic_M end_ARG start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT := ( italic_U start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_U start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT over~ start_ARG italic_M end_ARG ( italic_U start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT âŠ— italic_U start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT ). Now it is not hard to prove M~0â‰ˆM~2subscript~ğ‘€0subscript~ğ‘€2\widetilde{M}_{0}\approx\widetilde{M}_{2}over~ start_ARG italic_M end_ARG start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT â‰ˆ over~ start_ARG italic_M end_ARG start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT without considering the error caused by each term. As a result, M0â‰ˆM2subscriptğ‘€0subscriptğ‘€2M_{0}\approx M_{2}italic_M start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT â‰ˆ italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. The error depends on the operator norm of M~~ğ‘€\widetilde{M}over~ start_ARG italic_M end_ARG, which will be proved smaller than the operator norm of Mğ‘€Mitalic_M. In the end, we use Table 1 to compare the Razborov-Smolensky result [19, 21], the LMN theorem [15] for AC0 circuits and our results for QAC0 circuits. In the table, we omitted the big-O notation. ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT Boolean functions Real-valued Boolean functions f:{0,1}nâ†’{0,1}:ğ‘“â†’superscript01ğ‘›01f:\{0,1\}^{n}\rightarrow\{0,1\}italic_f : { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ { 0 , 1 } fâ¢(x)=âŸ¨x,0a|â¢Uâ€ â¢Zn+1â¢Uâ¢|x,0aâŸ©:{0,1}nâ†’[âˆ’1,1]:ğ‘“ğ‘¥brağ‘¥superscript0ğ‘superscriptğ‘ˆâ€ subscriptğ‘ğ‘›1ğ‘ˆketğ‘¥superscript0ğ‘â†’superscript01ğ‘›11f(x)=\bra{x,0^{a}}U^{\dagger}Z_{n+1}U\ket{x,0^{a}}:\{0,1\}^{n}\rightarrow[-1,1]italic_f ( italic_x ) = âŸ¨ start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG | italic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_Z start_POSTSUBSCRIPT italic_n + 1 end_POSTSUBSCRIPT italic_U | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© : { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ [ - 1 , 1 ] Degree of (logâ¡n)â¢(logâ¡1/Îµ)ğ‘›1ğœ€(\log n)(\log 1/\varepsilon)( roman_log italic_n ) ( roman_log 1 / italic_Îµ ) (logâ¡(n+a))â¢(logâ¡1/Îµ)â¢(logâ¡logâ¡1/Îµ)ğ‘›ğ‘1ğœ€1ğœ€(\log(n+a))(\log 1/\varepsilon)(\log\log 1/\varepsilon)( roman_log ( italic_n + italic_a ) ) ( roman_log 1 / italic_Îµ ) ( roman_log roman_log 1 / italic_Îµ ) Îµğœ€\varepsilonitalic_Îµ-approximation nğ‘›nitalic_n-bit OR function [RS] CC..CZ gate on n+ağ‘›ğ‘n+aitalic_n + italic_a qubits Choice of Îµğœ€\varepsilonitalic_Îµ â‰ˆÎ´/sabsentğ›¿ğ‘ \approx\delta/sâ‰ˆ italic_Î´ / italic_s [RS] â‰ˆÎ´/sabsentğ›¿ğ‘ \approx\delta/sâ‰ˆ italic_Î´ / italic_s Overall degree kğ‘˜kitalic_k k=((logâ¡n)â¢(logâ¡s/Î´))dğ‘˜superscriptğ‘›ğ‘ ğ›¿ğ‘‘k=((\log n)(\log s/\delta))^{d}italic_k = ( ( roman_log italic_n ) ( roman_log italic_s / italic_Î´ ) ) start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT [RS] k=(((log(n+a))(logs/Î´)(loglogs/Î´))dk=(((\log(n+a))(\log s/\delta)(\log\log s/\delta))^{d}italic_k = ( ( ( roman_log ( italic_n + italic_a ) ) ( roman_log italic_s / italic_Î´ ) ( roman_log roman_log italic_s / italic_Î´ ) ) start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT of approximation (logâ¡s/Î´)dâˆ’1â¢logâ¡(1/Î´)superscriptğ‘ ğ›¿ğ‘‘11ğ›¿(\log s/\delta)^{d-1}\log(1/\delta)( roman_log italic_s / italic_Î´ ) start_POSTSUPERSCRIPT italic_d - 1 end_POSTSUPERSCRIPT roman_log ( 1 / italic_Î´ ) [LMN] Correlation â‰¤1/2+oâ¢(1/n)absent12ğ‘œ1ğ‘›\leq 1/2+o(1/\sqrt{n})â‰¤ 1 / 2 + italic_o ( 1 / square-root start_ARG italic_n end_ARG ) [RS] â‰¤1/2+2âˆ’Î©â¢(n1/d/logâ¡n)absent12superscript2Î©superscriptğ‘›1ğ‘‘ğ‘›\leq 1/2+2^{-\Omega(n^{1/d}/\log n)}â‰¤ 1 / 2 + 2 start_POSTSUPERSCRIPT - roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT / roman_log italic_n ) end_POSTSUPERSCRIPT with parity â‰¤1/2+2âˆ’Î©â¢(n1/d)absent12superscript2Î©superscriptğ‘›1ğ‘‘\leq 1/2+2^{-\Omega(n^{1/d})}â‰¤ 1 / 2 + 2 start_POSTSUPERSCRIPT - roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT [LMN] Compute parity sâ‰¥2Î©â¢(n1/2â¢d)ğ‘ superscript2Î©superscriptğ‘›12ğ‘‘s\geq 2^{\Omega(n^{1/2d})}italic_s â‰¥ 2 start_POSTSUPERSCRIPT roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / 2 italic_d end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT [RS] aâ‰¥2Î©â¢(n1/d/logâ¡n)ğ‘superscript2Î©superscriptğ‘›1ğ‘‘ğ‘›a\geq 2^{\Omega(n^{1/d}/\log n)}italic_a â‰¥ 2 start_POSTSUPERSCRIPT roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT / roman_log italic_n ) end_POSTSUPERSCRIPT requires sâ‰¥2Î©â¢(n1/d)ğ‘ superscript2Î©superscriptğ‘›1ğ‘‘s\geq 2^{\Omega(n^{1/d})}italic_s â‰¥ 2 start_POSTSUPERSCRIPT roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT [LMN] Fourier spectrum âˆ‘|S|>kf^â¢(S)2â‰¤Î´subscriptğ‘†ğ‘˜^ğ‘“superscriptğ‘†2ğ›¿\sum_{|S|>k}\widehat{f}(S)^{2}\leq\deltaâˆ‘ start_POSTSUBSCRIPT | italic_S | > italic_k end_POSTSUBSCRIPT over^ start_ARG italic_f end_ARG ( italic_S ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰¤ italic_Î´ [LMN] âˆ‘|S|>kf^â¢(S)2â‰¤Î´subscriptğ‘†ğ‘˜^ğ‘“superscriptğ‘†2ğ›¿\sum_{|S|>k}\widehat{f}(S)^{2}\leq\deltaâˆ‘ start_POSTSUBSCRIPT | italic_S | > italic_k end_POSTSUBSCRIPT over^ start_ARG italic_f end_ARG ( italic_S ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰¤ italic_Î´ Table 1: Comparison between the Razborov-Smolensky result [19, 21], the LMN theorem [15] for AC0 and our results for QAC0. In the table, sğ‘ sitalic_s is the size, dğ‘‘ditalic_d is the depth, ağ‘aitalic_a is the number of ancillary qubits and nğ‘›nitalic_n is the number of inputs. [RS] refers to results of [19, 21], and [LMN] refers to results of [15]. From Table 1, the overall difference is small. Interestingly, our proof is inspired by Razborov-Smolenskyâ€™s approach, yet it yields stronger results akin to those in the LMN theorem [15]. The main reason for this is that in Razborov-Smolenskyâ€™s proof for ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, the function, which is not bounded (see footnote 4), agrees with the OR function with high probability, while for ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT, the operator, whose operator norm is bounded by 1, approximates the CC..CZ gate up to certain errors with high probability. As a result, the low-degree polynomial approximating the boolean function defined via ğ€ğ‚0superscriptğ€ğ‚0{\bf AC}^{0}bold_AC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT is not bounded, while the low-degree polynomial approximating the real function defined via ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT is bounded by 1. Thus in the quantum case, from the bounded low-degree approximating polynomial, we can obtain useful information about the Fourier coefficients of the original bounded real function. Notice that in the quantum case, we do not have a lower bound on the size sğ‘ sitalic_s. A reason for this is given after the proof of Theorem 1.7. 1.4 Relevant previous results In [8], Fang, Fenner, Green, Homer, and Zhang studied the computation of the parity function in a clean way by QAC0 circuits. In their paper, a QAC circuit Cğ¶Citalic_C acting on n+ağ‘›ğ‘n+aitalic_n + italic_a qubits cleanly computes parity if for any x,yâˆˆ{0,1}nğ‘¥ğ‘¦superscript01ğ‘›x,y\in\{0,1\}^{n}italic_x , italic_y âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT we have âŸ¨y,0a|â¢Câ¢|x,0aâŸ©=âŸ¨y,0a|â¢UParitynâŠ—Iâ¢|x,0aâŸ©.brağ‘¦superscript0ğ‘ğ¶ketğ‘¥superscript0ğ‘tensor-productbrağ‘¦superscript0ğ‘subscriptğ‘ˆsubscriptParityğ‘›ğ¼ketğ‘¥superscript0ğ‘\bra{y,0^{a}}C\ket{x,0^{a}}=\bra{y,0^{a}}U_{{\rm Parity}_{n}}\otimes I\ket{x,0% ^{a}}.âŸ¨ start_ARG italic_y , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG | italic_C | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© = âŸ¨ start_ARG italic_y , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG | italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT âŠ— italic_I | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© . Equivalently, Câ¢|x,0aâŸ©=UParitynâŠ—Iâ¢|x,0aâŸ©ğ¶ketğ‘¥superscript0ğ‘tensor-productsubscriptğ‘ˆsubscriptParityğ‘›ğ¼ketğ‘¥superscript0ğ‘C\ket{x,0^{a}}=U_{{\rm Parity}_{n}}\otimes I\ket{x,0^{a}}italic_C | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© = italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT âŠ— italic_I | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© for any xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. As a result, for any measurement operator Mğ‘€Mitalic_M on the target bit and bâˆˆ{0,1}ğ‘01b\in\{0,1\}italic_b âˆˆ { 0 , 1 }, we have âŸ¨x,b,0aâˆ’1|â¢Câ€ â¢Mâ¢Câ¢|x,b,0aâˆ’1âŸ©=âŸ¨x,b|â¢UParitynâ€ â¢Mâ¢UParitynâ¢|x,bâŸ©.brağ‘¥ğ‘superscript0ğ‘1superscriptğ¶â€ ğ‘€ğ¶ketğ‘¥ğ‘superscript0ğ‘1brağ‘¥ğ‘superscriptsubscriptğ‘ˆsubscriptParityğ‘›â€ ğ‘€subscriptğ‘ˆsubscriptParityğ‘›ketğ‘¥ğ‘\bra{x,b,0^{a-1}}C^{\dagger}MC\ket{x,b,0^{a-1}}=\bra{x,b}U_{{\rm Parity}_{n}}^% {\dagger}MU_{{\rm Parity}_{n}}\ket{x,b}.âŸ¨ start_ARG italic_x , italic_b , 0 start_POSTSUPERSCRIPT italic_a - 1 end_POSTSUPERSCRIPT end_ARG | italic_C start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_M italic_C | start_ARG italic_x , italic_b , 0 start_POSTSUPERSCRIPT italic_a - 1 end_POSTSUPERSCRIPT end_ARG âŸ© = âŸ¨ start_ARG italic_x , italic_b end_ARG | italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_M italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT | start_ARG italic_x , italic_b end_ARG âŸ© . In [8], it was proved that a QAC circuit of depth dğ‘‘ditalic_d and n+ağ‘›ğ‘n+aitalic_n + italic_a qubits that cleanly computes the parity function must have dâ‰¥2â¢logâ¡na+1ğ‘‘2ğ‘›ğ‘1d\geq 2\log\frac{n}{a+1}italic_d â‰¥ 2 roman_log divide start_ARG italic_n end_ARG start_ARG italic_a + 1 end_ARG. Later in [18, Theorem 4], PadÃ©, Fenner, Grier, and Thierauf showed that no depth-2 ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit cleanly computes parity for any nâ‰¥4ğ‘›4n\geq 4italic_n â‰¥ 4, regardless of the number of its ancillary qubits. In [20], Rosenthal made more interesting progress towards the computation of parity function with errors. Rosenthal considered the phase-dependent fidelity, which is defined as 1âˆ’â€–|ÏˆâŸ©âˆ’|Ï•âŸ©â€–21superscriptnormketğœ“ketitalic-Ï•21-\|\ket{\psi}-\ket{\phi}\|^{2}1 - âˆ¥ | start_ARG italic_Ïˆ end_ARG âŸ© - | start_ARG italic_Ï• end_ARG âŸ© âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT for any two states |ÏˆâŸ©ketğœ“\ket{\psi}| start_ARG italic_Ïˆ end_ARG âŸ© and |Ï•âŸ©ketitalic-Ï•\ket{\phi}| start_ARG italic_Ï• end_ARG âŸ©. A ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT circuit Cğ¶Citalic_C acting on n+ağ‘›ğ‘n+aitalic_n + italic_a qubits is said to (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximate clean parity if for any state nğ‘›nitalic_n-qubit state |Ï•âŸ©ketitalic-Ï•\ket{\phi}| start_ARG italic_Ï• end_ARG âŸ©, we have that the phase-dependent fidelity between Câ¢|Ï•,0aâŸ©ğ¶ketitalic-Ï•superscript0ğ‘C\ket{\phi,0^{a}}italic_C | start_ARG italic_Ï• , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© and (UParitynâŠ—I)â¢|Ï•,0aâŸ©tensor-productsubscriptğ‘ˆsubscriptParityğ‘›ğ¼ketitalic-Ï•superscript0ğ‘(U_{{\rm Parity}_{n}}\otimes I)\ket{\phi,0^{a}}( italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT âŠ— italic_I ) | start_ARG italic_Ï• , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© is at least 1âˆ’Î·1ğœ‚1-\eta1 - italic_Î·. It is said to (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximate dirty parity if â€–(âŸ¨Ï•|â¢UParitynâ€ âŠ—I)â¢Câ¢|Ï•,0aâŸ©â€–2â‰¥1âˆ’Î·.superscriptnormtensor-productbraitalic-Ï•superscriptsubscriptğ‘ˆsubscriptParityğ‘›â€ ğ¼ğ¶ketitalic-Ï•superscript0ğ‘21ğœ‚\|(\bra{\phi}U_{{\rm Parity}_{n}}^{\dagger}\otimes I)C\ket{\phi,0^{a}}\|^{2}% \geq 1-\eta.âˆ¥ ( âŸ¨ start_ARG italic_Ï• end_ARG | italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT âŠ— italic_I ) italic_C | start_ARG italic_Ï• , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰¥ 1 - italic_Î· . In other words, Cğ¶Citalic_C (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximates clean parity if Câ¢|Ï•,0aâŸ©=pâ¢UParitynâ¢|Ï•âŸ©âŠ—|0aâŸ©+Othersğ¶ketitalic-Ï•superscript0ğ‘tensor-productğ‘subscriptğ‘ˆsubscriptParityğ‘›ketitalic-Ï•ketsuperscript0ğ‘OthersC\ket{\phi,0^{a}}=pU_{{\rm Parity}_{n}}\ket{\phi}\otimes\ket{0^{a}}+\text{Others}italic_C | start_ARG italic_Ï• , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© = italic_p italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT | start_ARG italic_Ï• end_ARG âŸ© âŠ— | start_ARG 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© + Others with |pâˆ’1|2â‰¤Î·superscriptğ‘12ğœ‚|p-1|^{2}\leq\eta| italic_p - 1 | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰¤ italic_Î·; and Cğ¶Citalic_C (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximates dirty parity if Câ¢|Ï•,0aâŸ©=pâ¢UParitynâ¢|Ï•âŸ©âŠ—|Ï•â€²âŸ©+Othersğ¶ketitalic-Ï•superscript0ğ‘tensor-productğ‘subscriptğ‘ˆsubscriptParityğ‘›ketitalic-Ï•ketsuperscriptitalic-Ï•â€²OthersC\ket{\phi,0^{a}}=pU_{{\rm Parity}_{n}}\ket{\phi}\otimes\ket{\phi^{\prime}}+% \text{Others}italic_C | start_ARG italic_Ï• , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© = italic_p italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT | start_ARG italic_Ï• end_ARG âŸ© âŠ— | start_ARG italic_Ï• start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_ARG âŸ© + Others, where |p|2â‰¥1âˆ’Î·superscriptğ‘21ğœ‚|p|^{2}\geq 1-\eta| italic_p | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰¥ 1 - italic_Î·. As proved in [20], clean and dirty approximations are equivalent. For the clean appropriation, it is also equivalent to restricting to |Ï•âŸ©=|xâŸ©ketitalic-Ï•ketğ‘¥\ket{\phi}=\ket{x}| start_ARG italic_Ï• end_ARG âŸ© = | start_ARG italic_x end_ARG âŸ© for xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. So with probability at least (1âˆ’Î·)2superscript1ğœ‚2(1-\sqrt{\eta})^{2}( 1 - square-root start_ARG italic_Î· end_ARG ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, the output of measuring the (n+1)ğ‘›1(n+1)( italic_n + 1 )-th qubit of Câ¢|x,0aâŸ©ğ¶ketğ‘¥superscript0ğ‘C\ket{x,0^{a}}italic_C | start_ARG italic_x , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© is Paritynâ¢(x)subscriptParityğ‘›ğ‘¥{\rm Parity}_{n}(x)roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ). It was proved in [20, Corollary 1.1] that for all dâ‰¥7ğ‘‘7d\geq 7italic_d â‰¥ 7 and Î·>0ğœ‚0\eta>0italic_Î· > 0, there exist depth-dğ‘‘ditalic_d ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuits CâŠ•subscriptğ¶direct-sumC_{\oplus}italic_C start_POSTSUBSCRIPT âŠ• end_POSTSUBSCRIPT of size and number of ancillae expâ¡(polyâ¢(n1/d)â¢logâ¡(n/Î·))polysuperscriptğ‘›1ğ‘‘ğ‘›ğœ‚\exp({\rm poly}(n^{1/d})\log(n/\eta))roman_exp ( roman_poly ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) roman_log ( italic_n / italic_Î· ) ), where the polyâ¢(n1/d)polysuperscriptğ‘›1ğ‘‘{\rm poly}(n^{1/d})roman_poly ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) term is at most Oâ¢(n)ğ‘‚ğ‘›O(n)italic_O ( italic_n ), such that CâŠ•subscriptğ¶direct-sumC_{\oplus}italic_C start_POSTSUBSCRIPT âŠ• end_POSTSUBSCRIPT (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximates clean UParitynsubscriptğ‘ˆsubscriptParityğ‘›U_{{\rm Parity}_{n}}italic_U start_POSTSUBSCRIPT roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT. Rosenthal also studied the connection between parity approximation and cat state preparation (or more generally nekomata state preparation). A circuit Cğ¶Citalic_C is said to (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximate a clean cat state if the phase-dependent fidelity between Câ¢|0n+aâŸ©ğ¶ketsuperscript0ğ‘›ğ‘C\ket{0^{n+a}}italic_C | start_ARG 0 start_POSTSUPERSCRIPT italic_n + italic_a end_POSTSUPERSCRIPT end_ARG âŸ© and |CATn,0aâŸ©ketsubscriptCATğ‘›superscript0ğ‘\ket{{\rm CAT}_{n},0^{a}}| start_ARG roman_CAT start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , 0 start_POSTSUPERSCRIPT italic_a end_POSTSUPERSCRIPT end_ARG âŸ© is at least 1âˆ’Î·1ğœ‚1-\eta1 - italic_Î·. It is called a (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximation of a dirty cat state if â€–(âŸ¨CAT|nâŠ—I)â¢Câ¢|0n+aâŸ©â€–2â‰¥1âˆ’Î·.superscriptnormtensor-productsubscriptbraCATnICketsuperscript0na21ğœ‚\|(\bra{\rm CAT}_{n}\otimes I)C\ket{0^{n+a}}\|^{2}\geq 1-\eta.âˆ¥ ( âŸ¨ start_ARG roman_CAT end_ARG | start_POSTSUBSCRIPT roman_n end_POSTSUBSCRIPT âŠ— roman_I ) roman_C | start_ARG 0 start_POSTSUPERSCRIPT roman_n + roman_a end_POSTSUPERSCRIPT end_ARG âŸ© âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‰¥ 1 - italic_Î· . A circuit Cğ¶Citalic_C is said (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximates nğ‘›nitalic_n-nekomata if the fidelity of Câ¢|0n+aâŸ©ğ¶ketsuperscript0ğ‘›ğ‘C\ket{0^{n+a}}italic_C | start_ARG 0 start_POSTSUPERSCRIPT italic_n + italic_a end_POSTSUPERSCRIPT end_ARG âŸ© and |Î½âŸ©ketğœˆ\ket{\nu}| start_ARG italic_Î½ end_ARG âŸ© is at least 1âˆ’Î·1ğœ‚1-\eta1 - italic_Î·. In [20, Theorem 3.1], it was proved that for any Î·â‰¥0ğœ‚0\eta\geq 0italic_Î· â‰¥ 0, if there is a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of size sğ‘ sitalic_s, depth dğ‘‘ditalic_d, and number of ancillae ağ‘aitalic_a that (1âˆ’Î·)1ğœ‚(1-\eta)( 1 - italic_Î· )-approximates nğ‘›nitalic_n-nekomata state, then there is a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit of size Oâ¢(s+n)ğ‘‚ğ‘ ğ‘›O(s+n)italic_O ( italic_s + italic_n ), depth 4â¢d+34ğ‘‘34d+34 italic_d + 3, and number of ancillae ağ‘aitalic_a that (1âˆ’Oâ¢(Î·))1ğ‘‚ğœ‚(1-O(\eta))( 1 - italic_O ( italic_Î· ) )-approximates (n+1)ğ‘›1(n+1)( italic_n + 1 )-qubit clean parity problem. Consequently, if we cannot compute parity then we cannot prepare nğ‘›nitalic_n-nekomata state, and so cannot prepare the cat state. In 2023, the famous LMN theorem [15] was extended to the quantum case for ğğ€ğ‚0superscriptğğ€ğ‚0{\bf QAC}^{0}bold_QAC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT when a=Oâ¢(n1/d)ğ‘ğ‘‚superscriptğ‘›1ğ‘‘a=O(n^{1/d})italic_a = italic_O ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) by Nadimpalli, Parham, Vasconcelos, and Yuen [17]. They introduced a new notation of the Pauli spectrum for quantum channels using the Choi representation. Using this new notion, they obtained a quantum version of the LMN theorem, which states that any polynomial size, single-qubit-output QAC0 circuit that uses at most Oâ¢(n1/d)ğ‘‚superscriptğ‘›1ğ‘‘O(n^{1/d})italic_O ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) auxiliary qubits must have the Pauli spectrum that is concentrated on low-degree Pauli coefficients. This immediately yields average-case circuit lower bounds, see [17, Theorem 2]: Suppose that Uğ‘ˆUitalic_U is a ğğ€ğ‚ğğ€ğ‚{\bf QAC}bold_QAC circuit with depth d=Oâ¢(1)ğ‘‘ğ‘‚1d=O(1)italic_d = italic_O ( 1 ) and at most 12â¢n1/d12superscriptğ‘›1ğ‘‘\frac{1}{2}n^{1/d}divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT auxiliary qubits. Let Qâ¢(x)âˆˆ{0,1}ğ‘„ğ‘¥01Q(x)\in\{0,1\}italic_Q ( italic_x ) âˆˆ { 0 , 1 } denote the random measurement outcome in the computational basis of a single output qubit of Qğ‘„Qitalic_Q on input |xâŸ©ketğ‘¥\ket{x}| start_ARG italic_x end_ARG âŸ©. Then Prxâˆˆ{0,1}nâ¡[Qâ¢(x)=Paritynâ¢(x)]â‰¤12+2âˆ’Î©â¢(n1/d).subscriptPrğ‘¥superscript01ğ‘›ğ‘„ğ‘¥subscriptParityğ‘›ğ‘¥12superscript2Î©superscriptğ‘›1ğ‘‘\Pr_{x\in\{0,1\}^{n}}\Big{[}Q(x)={\rm Parity}_{n}(x)\Big{]}\leq\frac{1}{2}+2^{% -\Omega(n^{1/d})}.roman_Pr start_POSTSUBSCRIPT italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_Q ( italic_x ) = roman_Parity start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( italic_x ) ] â‰¤ divide start_ARG 1 end_ARG start_ARG 2 end_ARG + 2 start_POSTSUPERSCRIPT - roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 / italic_d end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT . This result is comparable to Theorem 1.9. As the Pauli spectrum is concentrated on the low-degree parts, a learning algorithm for QAC0 was obtained. Very recently in [2], Anshu, Dong, Ou, and Yao extended the results of [8, 18, 20, 17] and showed similar results when the number of ancillae is relaxed to a=O~â¢(n1+3âˆ’d)ğ‘~ğ‘‚superscriptğ‘›1superscript3ğ‘‘a=\widetilde{O}(n^{1+3^{-d}})italic_a = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1 + 3 start_POSTSUPERSCRIPT - italic_d end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). Their main result [2, Theorem 1.1] says that, for any operator Ağ´Aitalic_A acting on nğ‘›nitalic_n qubits with Pauli degree â„“â„“\ellroman_â„“, and any QAC0 circuit of depth dğ‘‘ditalic_d, the operator Uâ€ â¢Aâ¢Usuperscriptğ‘ˆâ€ ğ´ğ‘ˆU^{\dagger}AUitalic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_A italic_U is approximated by an operator of degree at most Oâ¢(n1âˆ’3âˆ’dâ¢â„“3âˆ’d)ğ‘‚superscriptğ‘›1superscript3ğ‘‘superscriptâ„“superscript3ğ‘‘O(n^{1-3^{-d}}\ell^{3^{-d}})italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 3 start_POSTSUPERSCRIPT - italic_d end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT roman_â„“ start_POSTSUPERSCRIPT 3 start_POSTSUPERSCRIPT - italic_d end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). The idea of [2] is a little similar to ours because they also approximate CC..CZ gates by low-degree operators. The difference is that the operator they constructed is deterministic and has degree roughly nğ‘›\sqrt{n}square-root start_ARG italic_n end_ARG when there are nğ‘›nitalic_n qubits involved, see [2, Corollary 3.3]. Then they replace some large CC..CZ gates carefully in the QAC0 circuit and obtain an approximation of Uâ€ â¢Aâ¢Usuperscriptğ‘ˆâ€ ğ´ğ‘ˆU^{\dagger}AUitalic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_A italic_U with degree Oâ¢(n1âˆ’3âˆ’dâ¢â„“3âˆ’d)ğ‘‚superscriptğ‘›1superscript3ğ‘‘superscriptâ„“superscript3ğ‘‘O(n^{1-3^{-d}}\ell^{3^{-d}})italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 3 start_POSTSUPERSCRIPT - italic_d end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT roman_â„“ start_POSTSUPERSCRIPT 3 start_POSTSUPERSCRIPT - italic_d end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ). In our case, we approximate CC..CZ gate by a random operator of degree polylog(n)ğ‘›(n)( italic_n ). We do not just replace all CC..CZ gates by these low-degree operators. We still need to make further modifications to obtain an approximation of Uâ€ â¢Aâ¢Usuperscriptğ‘ˆâ€ ğ´ğ‘ˆU^{\dagger}AUitalic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT italic_A italic_U with degree polylog(n)ğ‘›(n)( italic_n ). Finally, several separations are known between quantum and classical constant-depth circuits with bounded fan-in (the class ğğğ‚0superscriptğğğ‚0{\bf QNC}^{0}bold_QNC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT), e.g., the 2D Hidden Linear Function problem is in ğğğ‚0superscriptğğğ‚0{\bf QNC}^{0}bold_QNC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT but not in ğğ‚0superscriptğğ‚0{\bf NC}^{0}bold_NC start_POSTSUPERSCRIPT 0 end_POSTSUPERSCRIPT [5]."
https://arxiv.org/html/2411.00946v1,Classical versus quantum queries in quantum PCPswith classical proofs,"We generalize quantum-classical PCPs, first introduced by Weggemans, Folkertsma and Cade (TQC 2024), to allow for qğ‘qitalic_q quantum queries to a polynomially-sized classical proof (ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Q,c,sâ¢[q]subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„ğ‘ğ‘ delimited-[]ğ‘\mathsf{QCPCP}_{Q,c,s}[q]sansserif_QCPCP start_POSTSUBSCRIPT italic_Q , italic_c , italic_s end_POSTSUBSCRIPT [ italic_q ]). Exploiting a connection with the polynomial method, we prove that for any constant qğ‘qitalic_q, promise gap câˆ’s=Î©â¢(1/polyâ¢(n))ğ‘ğ‘ Î©1polyğ‘›c-s=\Omega(1/\mathrm{poly}(n))italic_c - italic_s = roman_Î© ( 1 / roman_poly ( italic_n ) ) and Î´>0ğ›¿0\delta>0italic_Î´ > 0, we have ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Q,c,sâ¢[q]âŠ†ğ–°ğ–¢ğ–¯ğ–¢ğ–¯1âˆ’Î´,1/2+Î´â¢[3]âŠ†ğ–¡ğ–°â‹…ğ–­ğ–¯subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„ğ‘ğ‘ delimited-[]ğ‘subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯1ğ›¿12ğ›¿delimited-[]3â‹…ğ–¡ğ–°ğ–­ğ–¯\mathsf{QCPCP}_{Q,c,s}[q]\subseteq\mathsf{QCPCP}_{1-\delta,1/2+\delta}[3]% \subseteq\mathsf{BQ}\cdot\mathsf{NP}sansserif_QCPCP start_POSTSUBSCRIPT italic_Q , italic_c , italic_s end_POSTSUBSCRIPT [ italic_q ] âŠ† sansserif_QCPCP start_POSTSUBSCRIPT 1 - italic_Î´ , 1 / 2 + italic_Î´ end_POSTSUBSCRIPT [ 3 ] âŠ† sansserif_BQ â‹… sansserif_NP, where ğ–¡ğ–°â‹…ğ–­ğ–¯â‹…ğ–¡ğ–°ğ–­ğ–¯\mathsf{BQ}\cdot\mathsf{NP}sansserif_BQ â‹… sansserif_NP is the class of promise problems with quantum reductions to an ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP-complete problem. Surprisingly, this shows that we can amplify the promise gap from inverse polynomial to constant for constant query quantum-classical PCPs, and that any quantum-classical PCP making any constant number of quantum queries can be simulated by one that makes only three classical queries. Nevertheless, even though we can achieve promise gap amplification, our result also gives strong evidence that there exists no constant query quantum-classical PCP for ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA, as it is unlikely that ğ–°ğ–¢ğ–¬ğ– âŠ†ğ–¡ğ–°â‹…ğ–­ğ–¯ğ–°ğ–¢ğ–¬ğ– â‹…ğ–¡ğ–°ğ–­ğ–¯\mathsf{QCMA}\subseteq\mathsf{BQ}\cdot\mathsf{NP}sansserif_QCMA âŠ† sansserif_BQ â‹… sansserif_NP, which we support by giving oracular evidence. In the (poly-)logarithmic query regime, we show for any positive integer cğ‘citalic_c, there exists an oracle relative to which ğ–°ğ–¢ğ–¯ğ–¢ğ–¯â¢[ğ’ªâ¢(logcâ¡n)]âŠŠğ–°ğ–¢ğ–¯ğ–¢ğ–¯Qâ¢[ğ’ªâ¢(logcâ¡n)]ğ–°ğ–¢ğ–¯ğ–¢ğ–¯delimited-[]ğ’ªsuperscriptğ‘ğ‘›subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„delimited-[]ğ’ªsuperscriptğ‘ğ‘›\mathsf{QCPCP}[\mathcal{O}(\log^{c}n)]\subsetneq\mathsf{QCPCP}_{Q}[\mathcal{O}% (\log^{c}n)]sansserif_QCPCP [ caligraphic_O ( roman_log start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT italic_n ) ] âŠŠ sansserif_QCPCP start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT [ caligraphic_O ( roman_log start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT italic_n ) ], contrasting the constant query case where the equivalence of both query models holds relative to any oracle. Finally, we connect our results to more general quantum-classical interactive proof systems.","A probabilistically checkable proof (PCP) system consists of a polynomial-time verifier that uses râ¢(n)ğ‘Ÿğ‘›r(n)italic_r ( italic_n ) random coins and has query access to some proof provided by a prover, to which it can make at most qâ¢(n)ğ‘ğ‘›q(n)italic_q ( italic_n ) queries. The celebrated PCP theorem states that the full power of ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP can be captured by a PCP that only has qâ¢(n)=ğ’ªâ¢(1)ğ‘ğ‘›ğ’ª1q(n)=\mathcal{O}(1)italic_q ( italic_n ) = caligraphic_O ( 1 ) and r=ğ’ªâ¢(logâ¡n)ğ‘Ÿğ’ªğ‘›r=\mathcal{O}(\log n)italic_r = caligraphic_O ( roman_log italic_n ) [ALM+98, AS98, Din07]. In quantum complexity theory, one of the biggest open questions is whether the de facto quantum generalization of ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP, i.e. ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA, can also be characterized in terms of a quantum probabilistically checkable proof system [AAV13]. This question is formalized as the quantum PCP conjecture, and is usually considered in terms of its local Hamiltonian formulation: this states that it is ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-hard to estimate the ground state energy of a local Hamiltonian up to constant additive error relative to the operator norm. Much less studied is its proof-checking formulation, which posits that any promise problem in ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA can be verified by a quantum polynomial-time verifier that only acts non-trivially on a subset of a polynomially-sized proof (effectively tracing out the rest). Both formulations are known to be equivalent under quantum reductions [AALV09, AAV13, BHW24]. Ref. [WFC24] proposed to study an intermediate version of a quantum probabilistically checkable proof system, where the verifier remains quantum but the proof is classical (ğ–°ğ–¢ğ–¯ğ–¢ğ–¯â¢[q]ğ–°ğ–¢ğ–¯ğ–¢ğ–¯delimited-[]ğ‘\mathsf{QCPCP}[q]sansserif_QCPCP [ italic_q ]). They showed that for a constant amount of classical queries, the corresponding class is contained in ğ–¡ğ–°ğ–¯ğ–­ğ–¯â¢[1]superscriptğ–¡ğ–°ğ–¯ğ–­ğ–¯delimited-[]1\mathsf{BQP}^{\mathsf{NP}[1]}sansserif_BQP start_POSTSUPERSCRIPT sansserif_NP [ 1 ] end_POSTSUPERSCRIPT, which is ğ–¡ğ–°ğ–¯ğ–¡ğ–°ğ–¯\mathsf{BQP}sansserif_BQP allowed to make a single query to an ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP oracle. Whilst the definition of ğ–°ğ–¢ğ–¯ğ–¢ğ–¯â¢[q]ğ–°ğ–¢ğ–¯ğ–¢ğ–¯delimited-[]ğ‘\mathsf{QCPCP}[q]sansserif_QCPCP [ italic_q ] preserves the locality aspect of PCPs, it does not capture the query aspect as usually considered in a quantum setting: one generally considers quantum queries instead of classical access to a string. This means that in a single query, the whole proof can be â€œaccessedâ€ in superposition, a model which is known to have an exponential advantage over classical queries for some computational tasks.111See https://quantumalgorithmzoo.org for a list of examples. Generally, query lower bounds in the randomized setting also hold in the quantum setting when only classical queries are allowed, provided the lower bound method works even when all intermediate computations (in between the queries) can be inefficient. This is because any quantum query algorithm in this model can be simulated with exponential overhead (in time and space) by a classical computation, but using the same number of queries. Hence, the following question arises: Can quantum-classical PCPs be made more powerful when they are allowed to make quantum queries to a classical proof? 1.1 Our results In this work, we generalize the class ğ–°ğ–¢ğ–¯ğ–¢ğ–¯c,sâ¢[q]subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘ğ‘ delimited-[]ğ‘\mathsf{QCPCP}_{c,s}[q]sansserif_QCPCP start_POSTSUBSCRIPT italic_c , italic_s end_POSTSUBSCRIPT [ italic_q ] to ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Q,c,sâ¢[q]subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„ğ‘ğ‘ delimited-[]ğ‘\mathsf{QCPCP}_{Q,c,s}[q]sansserif_QCPCP start_POSTSUBSCRIPT italic_Q , italic_c , italic_s end_POSTSUBSCRIPT [ italic_q ] such that it captures the standard quantum query model to an unknown bit string [BdW02]. A ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Q,c,sâ¢[q]subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„ğ‘ğ‘ delimited-[]ğ‘\mathsf{QCPCP}_{Q,c,s}[q]sansserif_QCPCP start_POSTSUBSCRIPT italic_Q , italic_c , italic_s end_POSTSUBSCRIPT [ italic_q ]-verifier consists of a uniform family of quantum circuits V={Vn:nâˆˆâ„•}ğ‘‰conditional-setsubscriptğ‘‰ğ‘›ğ‘›â„•V=\{V_{n}:n\in\mathbb{N}\}italic_V = { italic_V start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT : italic_n âˆˆ blackboard_N }, where the description of each Vnsubscriptğ‘‰ğ‘›V_{n}italic_V start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT is generated by a fixed polynomial-time Turing machine given 1nsuperscript1ğ‘›1^{n}1 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT as an input. We have that each circuit Vnsubscriptğ‘‰ğ‘›V_{n}italic_V start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT is allowed to make qğ‘qitalic_q queries to a classical proof yâˆˆ{0,1}polyâ¢(n)ğ‘¦superscript01polyğ‘›y\in\{0,1\}^{\mathrm{poly}(n)}italic_y âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT roman_poly ( italic_n ) end_POSTSUPERSCRIPT provided by an untrusted prover, via a unitary Uysubscriptğ‘ˆğ‘¦U_{y}italic_U start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT such that Uyâ¢|iâŸ©â¢|aâŸ©=|iâŸ©â¢|aâŠ•yiâŸ©subscriptğ‘ˆğ‘¦ketğ‘–ketğ‘ketğ‘–ketdirect-sumğ‘subscriptğ‘¦ğ‘–U_{y}\ket{i}\ket{a}=\ket{i}\ket{a\oplus y_{i}}italic_U start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT | start_ARG italic_i end_ARG âŸ© | start_ARG italic_a end_ARG âŸ© = | start_ARG italic_i end_ARG âŸ© | start_ARG italic_a âŠ• italic_y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG âŸ©.222One can also view this as having the proof stored in a quantum read-only memory (QROM), and the verifier is only allowed to access the memory qğ‘qitalic_q number of times. We then say that a promise problem A=(Ayes,Ano)ğ´subscriptğ´yessubscriptğ´noA=(A_{\text{\sc yes}},A_{\text{\sc no}})italic_A = ( italic_A start_POSTSUBSCRIPT yes end_POSTSUBSCRIPT , italic_A start_POSTSUBSCRIPT no end_POSTSUBSCRIPT ) is in ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Q,c,sâ¢[q]subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„ğ‘ğ‘ delimited-[]ğ‘\mathsf{QCPCP}_{Q,c,s}[q]sansserif_QCPCP start_POSTSUBSCRIPT italic_Q , italic_c , italic_s end_POSTSUBSCRIPT [ italic_q ] if for all inputs xâˆˆAyesğ‘¥subscriptğ´yesx\in A_{\text{\sc yes}}italic_x âˆˆ italic_A start_POSTSUBSCRIPT yes end_POSTSUBSCRIPT, there exists a proof yğ‘¦yitalic_y such that the ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Q,c,sâ¢[q]subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„ğ‘ğ‘ delimited-[]ğ‘\mathsf{QCPCP}_{Q,c,s}[q]sansserif_QCPCP start_POSTSUBSCRIPT italic_Q , italic_c , italic_s end_POSTSUBSCRIPT [ italic_q ]-verifier accepts with probability at least cğ‘citalic_c, and for all xâˆˆAnoğ‘¥subscriptğ´nox\in A_{\text{\sc no}}italic_x âˆˆ italic_A start_POSTSUBSCRIPT no end_POSTSUBSCRIPT, the verifier accepts all proofs yğ‘¦yitalic_y with probability at most sğ‘ sitalic_s (Definition 7 and 7a). We will study quantum-classical PCPs in both types of query models in the setting where the number of queries is constant or (poly)-logarithmic. Constant number of proof queries. We show that in the constant query regime the following result holds. Theorem 1 (From Corollary 2 and Proposition 4). For any positive integer qâˆˆâ„•ğ‘â„•q\in\mathbb{N}italic_q âˆˆ blackboard_N and for any computable functions c,sğ‘ğ‘ c,sitalic_c , italic_s such that câˆ’sâ‰¥1/polyâ¢(n)ğ‘ğ‘ 1polyğ‘›c-s\geq 1/\mathrm{poly}(n)italic_c - italic_s â‰¥ 1 / roman_poly ( italic_n ), we have ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Q,c,sâ¢[q]âŠ†ğ–°ğ–¢ğ–¯ğ–¢ğ–¯1âˆ’Î´,1/2+Î´â¢[3]âŠ†ğ–¡ğ–°â‹…ğ–­ğ–¯,subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„ğ‘ğ‘ delimited-[]ğ‘subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯1ğ›¿12ğ›¿delimited-[]3â‹…ğ–¡ğ–°ğ–­ğ–¯\displaystyle\mathsf{QCPCP}_{Q,c,s}[q]\subseteq\mathsf{QCPCP}_{1-\delta,1/2+% \delta}[3]\subseteq\mathsf{BQ}\cdot\mathsf{NP},sansserif_QCPCP start_POSTSUBSCRIPT italic_Q , italic_c , italic_s end_POSTSUBSCRIPT [ italic_q ] âŠ† sansserif_QCPCP start_POSTSUBSCRIPT 1 - italic_Î´ , 1 / 2 + italic_Î´ end_POSTSUBSCRIPT [ 3 ] âŠ† sansserif_BQ â‹… sansserif_NP , for any constant Î´>0ğ›¿0\delta>0italic_Î´ > 0 . Here â€˜ğ–¡ğ–°ğ–¡ğ–°\mathsf{BQ}sansserif_BQâ€™ is a quantum extension of SchÃ¶ningâ€™s ğ–¡ğ–¯ğ–¡ğ–¯\mathsf{BP}sansserif_BP-operator [Sch89],333Both are examples of what is known as dot operators [BS01]. such that ğ–¡ğ–°â‹…ğ’â‹…ğ–¡ğ–°ğ’\mathsf{BQ}\cdot\mathcal{C}sansserif_BQ â‹… caligraphic_C for a class ğ’ğ’\mathcal{C}caligraphic_C contains all promise problems that have a quantum reduction to a promise problem Ağ´Aitalic_A that is complete for ğ’ğ’\mathcal{C}caligraphic_C. Hence, when ğ’ğ’\mathcal{C}caligraphic_C is a classical complexity class, one can view the ğ–¡ğ–°ğ–¡ğ–°\mathsf{BQ}sansserif_BQ-operator as â€œpulling the quantumnessâ€ out of a problem. In Section 3, we prove that the ğ–¡ğ–°ğ–¡ğ–°\mathsf{BQ}sansserif_BQ-operator satisfies many of the similar properties as the ğ–¡ğ–¯ğ–¡ğ–¯\mathsf{BP}sansserif_BP-operator (Proposition 3) and also discuss its alternative formulation (for classes ğ’âŠ‡ğ–¯ğ–¯ğ’\mathcal{C}\supseteq\mathsf{P}caligraphic_C âŠ‡ sansserif_P) in terms of feeding random strings generated by measuring the output states of quantum algorithms as extra input to the class (Definition 6a). The following conclusions can be drawn from Theorem 1: (i) Any constant query quantum-classical PCP protocol can be simulated by a quantum-classical PCP making only 3333 classical queries which has a constant promise gap. Even more surprisingly, this even holds when the original completeness/soundness gap was inverse polynomial(!) instead of constant, showing that amplification in this regime can be done without increasing the query count.444If the original number of queries was at least 3333. (ii) It states that one can pull out the quantumness of quantum-classical PCPs, in terms of its interpretation in the context of the ğ–¡ğ–°ğ–¡ğ–°\mathsf{BQ}sansserif_BQ-operator, no matter if the access to the proof is quantum or classical. Since it seems very unlikely that ğ–°ğ–¢ğ–¬ğ– âŠ†ğ–¡ğ–°â‹…ğ–­ğ–¯ğ–°ğ–¢ğ–¬ğ– â‹…ğ–¡ğ–°ğ–­ğ–¯\mathsf{QCMA}\subseteq\mathsf{BQ}\cdot\mathsf{NP}sansserif_QCMA âŠ† sansserif_BQ â‹… sansserif_NPâ€”as it would imply that the â€œquantum partâ€ in the computation does not have to use the proofâ€”this provides very strong evidence that it is unlikely that there exists some notion of a â€œquantum PCPâ€ that uses a classical proof. We strengthen point (ii) by giving a classical oracle relative to which ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Qâ¢[ğ’ªâ¢(1)]subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„delimited-[]ğ’ª1\mathsf{QCPCP}_{Q}[\mathcal{O}(1)]sansserif_QCPCP start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT [ caligraphic_O ( 1 ) ] does not capture the power of ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA. Theorem 2. For any positive integer qâˆˆâ„•ğ‘â„•q\in\mathbb{N}italic_q âˆˆ blackboard_N, there exists an oracle ğ“ğ“\bm{\mathcal{O}}bold_caligraphic_O relative to which ğ–°ğ–¢ğ–¯ğ–¢ğ–¯â¢[q]ğ“âŠ†ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Qâ¢[q]ğ“âŠŠğ–°ğ–¢ğ–¬ğ– ğ“.ğ–°ğ–¢ğ–¯ğ–¢ğ–¯superscriptdelimited-[]ğ‘ğ“subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„superscriptdelimited-[]ğ‘ğ“superscriptğ–°ğ–¢ğ–¬ğ– ğ“\displaystyle\mathsf{QCPCP}[q]^{\bm{\mathcal{O}}}\subseteq\mathsf{QCPCP}_{Q}[q% ]^{\bm{\mathcal{O}}}\subsetneq\mathsf{QCMA}^{\bm{\mathcal{O}}}.sansserif_QCPCP [ italic_q ] start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT âŠ† sansserif_QCPCP start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT [ italic_q ] start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT âŠŠ sansserif_QCMA start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT . Unconditionally proving ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Qâ¢[ğ’ªâ¢(1)]â‰ ğ–°ğ–¢ğ–¬ğ– subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„delimited-[]ğ’ª1ğ–°ğ–¢ğ–¬ğ– \mathsf{QCPCP}_{Q}[\mathcal{O}(1)]\neq\mathsf{QCMA}sansserif_QCPCP start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT [ caligraphic_O ( 1 ) ] â‰  sansserif_QCMA would imply ğ–¯â‰ ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{P}\neq\mathsf{PSPACE}sansserif_P â‰  sansserif_PSPACE and therefore seems to be beyond the current techniques. We believe that Point (i) highlights the intuition that a classical proof in a quantum verification setting can be viewed as being â€œuncompiled.â€ In the fully quantum case, itâ€™s easy to show that there exists a polynomial pâ¢(n)ğ‘ğ‘›p(n)italic_p ( italic_n ) such that ğ–°ğ–¯ğ–¢ğ–¯c,sâ¢[2]=ğ–°ğ–¬ğ– subscriptğ–°ğ–¯ğ–¢ğ–¯ğ‘ğ‘ delimited-[]2ğ–°ğ–¬ğ– \mathsf{QPCP}_{c,s}[2]=\mathsf{QMA}sansserif_QPCP start_POSTSUBSCRIPT italic_c , italic_s end_POSTSUBSCRIPT [ 2 ] = sansserif_QMA when câˆ’s=1/pâ¢(n)ğ‘ğ‘ 1ğ‘ğ‘›c-s=1/p(n)italic_c - italic_s = 1 / italic_p ( italic_n ); roughly speaking, one picks a term of a ğ–°ğ–¬ğ– ğ–°ğ–¬ğ– \mathsf{QMA}sansserif_QMA-hard 2222-local Hamiltonian uniformly at random, and applies a 3333-qubit unitary operation which maps an ancillary qubit in |0âŸ©ket0\ket{0}| start_ARG 0 end_ARG âŸ© to |1âŸ©ket1\ket{1}| start_ARG 1 end_ARG âŸ© proportional to the energy of the 2222-local density matrix with respect the sampled local term.555See for example [KSV02] and [BHW24]. Similarly, in the fully classical case, one can sample a term of a ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP-hard 3333-local constraint satisfaction problem uniformly at random and detect unsatisfiability with a probability 1/m1ğ‘š1/m1 / italic_m, where mğ‘šmitalic_m is the total number of constraints. Therefore, the whole game of proving quantum PCP conjecture is to show that for some qâˆˆğ’ªâ¢(1)ğ‘ğ’ª1q\in\mathcal{O}(1)italic_q âˆˆ caligraphic_O ( 1 ), we have ğ–°ğ–¯ğ–¢ğ–¯c,sâ¢[2]=ğ–°ğ–¯ğ–¢ğ–¯câ€²,sâ€²â¢[q]subscriptğ–°ğ–¯ğ–¢ğ–¯ğ‘ğ‘ delimited-[]2subscriptğ–°ğ–¯ğ–¢ğ–¯superscriptğ‘â€²superscriptğ‘ â€²delimited-[]ğ‘\mathsf{QPCP}_{c,s}[2]=\mathsf{QPCP}_{c^{\prime},s^{\prime}}[q]sansserif_QPCP start_POSTSUBSCRIPT italic_c , italic_s end_POSTSUBSCRIPT [ 2 ] = sansserif_QPCP start_POSTSUBSCRIPT italic_c start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT , italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUBSCRIPT [ italic_q ] with câ€²âˆ’sâ€²=Î©â¢(1)superscriptğ‘â€²superscriptğ‘ â€²Î©1c^{\prime}-s^{\prime}=\Omega(1)italic_c start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT - italic_s start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT = roman_Î© ( 1 ). For quantum PCPs with classical proofs (independent of the access model), Theorem 1 shows that such an amplification step is indeed possible, however, we lose the property that â€œlocal informationâ€ about a proof is enough to verify any problem in ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA with an inverse polynomially small promise gap. In particular, variants of the local Hamiltonian which are ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA-complete use a classical proof to describe a quantum circuit which prepares a quantum state with low energy (or has a large overlap with such a state) [WJB03, WFC24], which can again only be â€œlocally verifiedâ€ after the quantum state is prepared, i.e., compiled. (Poly-)logarithmic number of queries. We show that when the number of queries to the proof becomes (poly-)logarithmic both query models can be separated relative to an oracle. Theorem 3. For any positive integer câˆˆâ„•ğ‘â„•c\in\mathbb{N}italic_c âˆˆ blackboard_N, there exists an oracle ğ“ğ“\bm{\mathcal{O}}bold_caligraphic_O such that ğ–°ğ–¢ğ–¯ğ–¢ğ–¯â¢[ğ’ªâ¢(logcâ¡n)]ğ“âŠŠğ–°ğ–¢ğ–¯ğ–¢ğ–¯Qâ¢[ğ’ªâ¢(logcâ¡n)]ğ“.ğ–°ğ–¢ğ–¯ğ–¢ğ–¯superscriptdelimited-[]ğ’ªsuperscriptğ‘ğ‘›ğ“subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„superscriptdelimited-[]ğ’ªsuperscriptğ‘ğ‘›ğ“\displaystyle\mathsf{QCPCP}[\mathcal{O}(\log^{c}n)]^{\bm{\mathcal{O}}}% \varsubsetneq\mathsf{QCPCP}_{Q}[\mathcal{O}(\log^{c}n)]^{\bm{\mathcal{O}}}.sansserif_QCPCP [ caligraphic_O ( roman_log start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT italic_n ) ] start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT âŠŠ sansserif_QCPCP start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT [ caligraphic_O ( roman_log start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT italic_n ) ] start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT . This contrasts the constant query case, where Theorem 1 holds even in the presence of oracles. 1.2 Proof ideas To prove Theorem 1, we exploit the connection between quantum-classical PCPs and the polynomial method of [BBC+01]. The polynomial method is a technique used to prove lower bounds on quantum query complexity, and utilizes the idea that the square of the amplitudes of every qğ‘qitalic_q-query quantum algorithm to a string yâˆˆ{0,1}Nğ‘¦superscript01ğ‘y\in\{0,1\}^{N}italic_y âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT can be expressed as a real-valued multi-linear polynomial Pâ¢(y)ğ‘ƒğ‘¦P(y)italic_P ( italic_y ) of degree 2â¢q2ğ‘2q2 italic_q on Nğ‘Nitalic_N bits. In our case, we will be interested in the case when N=|y|=polyâ¢(n)ğ‘ğ‘¦polyğ‘›N=|y|=\mathrm{poly}(n)italic_N = | italic_y | = roman_poly ( italic_n ) and qğ‘qitalic_q is constant, so Pğ‘ƒPitalic_P consists of at most (|y|2â¢q)=polyâ¢(n)binomialğ‘¦2ğ‘polyğ‘›\binom{|y|}{2q}=\mathrm{poly}(n)( FRACOP start_ARG | italic_y | end_ARG start_ARG 2 italic_q end_ARG ) = roman_poly ( italic_n ) number of monomials. We prove that for a fixed input xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, an approximation of Pğ‘ƒPitalic_P can be efficiently learned by sampling from the measurement outcome of the runs ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Qâ¢[q]subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„delimited-[]ğ‘\mathsf{QCPCP}_{Q}[q]sansserif_QCPCP start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT [ italic_q ]-verification circuit (Theorem 4). In these runs, it never queries the actual proof through Uysubscriptğ‘ˆğ‘¦U_{y}italic_U start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT, instead making queries to constructed UySsubscriptğ‘ˆsuperscriptğ‘¦ğ‘†U_{y^{S}}italic_U start_POSTSUBSCRIPT italic_y start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT end_POSTSUBSCRIPTâ€™s for some â€œfakeâ€ proofs ySsuperscriptğ‘¦ğ‘†y^{S}italic_y start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT, which can be efficiently implemented given a description of ySsuperscriptğ‘¦ğ‘†y^{S}italic_y start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT. Here SâŠ†[N]ğ‘†delimited-[]ğ‘S\subseteq[N]italic_S âŠ† [ italic_N ] indicates a subset of at most 2â¢q2ğ‘2q2 italic_q variables participating in a term. Combined with the promise on the acceptance probabilities of the quantum-classical PCP verifier in the yes- and no-cases, this yields a quantum reduction to a multi-linear polynomial threshold problem: here you are given classical descriptions of the coefficients Î²Ssubscriptğ›½ğ‘†{\beta_{S}}italic_Î² start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT up to a certain number of bits of precision of some constant degree multi-linear polynomial P:{0,1}pâ¢(n)â†’â„:ğ‘ƒâ†’superscript01ğ‘ğ‘›â„P:\{0,1\}^{p(n)}\rightarrow\mathbb{R}italic_P : { 0 , 1 } start_POSTSUPERSCRIPT italic_p ( italic_n ) end_POSTSUPERSCRIPT â†’ blackboard_R with pâ¢(n)=polyâ¢(n)ğ‘ğ‘›polyğ‘›p(n)=\mathrm{poly}(n)italic_p ( italic_n ) = roman_poly ( italic_n ), and an efficiently computable number aâˆˆ[0,1]ğ‘01a\in[0,1]italic_a âˆˆ [ 0 , 1 ], and the task is to decide whether there exists a yâˆˆ{0,1}pâ¢(n)ğ‘¦superscript01ğ‘ğ‘›y\in\{0,1\}^{p(n)}italic_y âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_p ( italic_n ) end_POSTSUPERSCRIPT such that Pâ¢(y)â‰¥ağ‘ƒğ‘¦ğ‘P(y)\geq aitalic_P ( italic_y ) â‰¥ italic_a or for all yğ‘¦yitalic_y it holds that Pâ¢(y)<ağ‘ƒğ‘¦ğ‘P(y)<aitalic_P ( italic_y ) < italic_a. The multi-linear polynomial threshold problem is clearly in ğ–­ğ–¯ğ–­ğ–¯\mathsf{NP}sansserif_NP, as the smallest possible function value of Pğ‘ƒPitalic_P above ağ‘aitalic_a can be discriminated from ağ‘aitalic_a using only a polynomial number of bits, which follows from the fact that each of the coefficients is specified up to a certain number of bits. Using a classical PCP construction, one then also has that the multi-linear polynomial threshold problem is in ğ–¯ğ–¢ğ–¯â¢[3,ğ’ªâ¢(logâ¡r)]ğ–¯ğ–¢ğ–¯3ğ’ªğ‘Ÿ\mathsf{PCP}[3,\mathcal{O}(\log r)]sansserif_PCP [ 3 , caligraphic_O ( roman_log italic_r ) ] [H0ÌŠ1]. Moreover, conditioning on the quantum reduction succeeding, the output of the reduction can be made deterministic, which means that the prover can fix the proof used by the classical PCP verification protocol in the yes-case. The above construction is somewhat similar in spirit to a recent work by Arad and Santha [AS24], in which a â€œquasi-quantum PCP theoremâ€ in terms of a local Hamiltonian problem over so-called quasi-quantum states is shown by using a classical PCP construction to achieve amplification. However, a key difference is that they want to reduce to a (quasi-)quantum problem from an amplified CSP, whilst we reduce from a quantum problem to a CSP, which can then be gap amplified. The proof of Theorem 2 relies on the OR âˆ˜\circâˆ˜ Forrelation oracle from [AIK22], which was used to demonstrate an oracle separation between ğ–­ğ–¯ğ–¡ğ–°ğ–¯superscriptğ–­ğ–¯ğ–¡ğ–°ğ–¯\mathsf{NP}^{\mathsf{BQP}}sansserif_NP start_POSTSUPERSCRIPT sansserif_BQP end_POSTSUPERSCRIPT and ğ–¡ğ–°ğ–¯ğ–­ğ–¯superscriptğ–¡ğ–°ğ–¯ğ–­ğ–¯\mathsf{BQP}^{\mathsf{NP}}sansserif_BQP start_POSTSUPERSCRIPT sansserif_NP end_POSTSUPERSCRIPT. We extend this result to show that the same oracle separation holds when ğ–­ğ–¯ğ–¡ğ–°ğ–¯superscriptğ–­ğ–¯ğ–¡ğ–°ğ–¯\mathsf{NP}^{\mathsf{BQP}}sansserif_NP start_POSTSUPERSCRIPT sansserif_BQP end_POSTSUPERSCRIPT is replaced by ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA. Additionally, we make use of the fact that the inclusion ğ–°ğ–¢ğ–¯ğ–¢ğ–¯Qâ¢[ğ’ªâ¢(1)]âŠ†ğ–¡ğ–°â‹…ğ–­ğ–¯subscriptğ–°ğ–¢ğ–¯ğ–¢ğ–¯ğ‘„delimited-[]ğ’ª1â‹…ğ–¡ğ–°ğ–­ğ–¯\mathsf{QCPCP}_{Q}[\mathcal{O}(1)]\subseteq\mathsf{BQ}\cdot\mathsf{NP}sansserif_QCPCP start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT [ caligraphic_O ( 1 ) ] âŠ† sansserif_BQ â‹… sansserif_NP from Theorem 1 holds even under relativization. The key insight in proving Theorem 3 is to consider the decision version of a search problem, specifically computing the OR-function over a string of poly-logarithmic length. Using quantum queries, the Bernstein-Vazirani algorithm [BV93] can decode ğ’ªâ¢(logâ¡n)ğ’ªğ‘›\mathcal{O}(\log n)caligraphic_O ( roman_log italic_n ) bits with just a single quantum query to a string of polynomial size. By concatenating ğ’ªâ¢(logcâ¡n)ğ’ªsuperscriptğ‘ğ‘›\mathcal{O}(\log^{c}n)caligraphic_O ( roman_log start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT italic_n ) of such strings into a proof, we can learn a total of ğ’ªâ¢(logc+1â¡n)ğ’ªsuperscriptğ‘1ğ‘›\mathcal{O}(\log^{c+1}n)caligraphic_O ( roman_log start_POSTSUPERSCRIPT italic_c + 1 end_POSTSUPERSCRIPT italic_n ) bits using only ğ’ªâ¢(logcâ¡n)ğ’ªsuperscriptğ‘ğ‘›\mathcal{O}(\log^{c}n)caligraphic_O ( roman_log start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT italic_n ) quantum queries, after which a single classical query is sufficient to solve the decision problem. To show that this is not achievable with classical access to a proof, we establish a quantum lower bound on computing the OR function for nğ‘›nitalic_n bits, even in cases where kğ‘˜kitalic_k bits (from a potentially larger proof) are observed to aid in finding the hidden string. Our lower bound generalizes a result from [BHW24, Appendix D]. Although their proof technique could also be applied to achieve the same result, we argue that our approach is simpler and more straightforward. 1.3 Implication to quantum-classical interactive proof systems As a final side result, our oracle separation between ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA and ğ–¡ğ–°â‹…ğ–­ğ–¯â‹…ğ–¡ğ–°ğ–­ğ–¯\mathsf{BQ}\cdot\mathsf{NP}sansserif_BQ â‹… sansserif_NP also leads to a corollary regarding quantum-classical interactive proof systems. We define a new class of quantum-classical interactive proof systems, denoted ğ–°ğ–¢ğ–¨ğ–¯â¢[k]ğ–°ğ–¢ğ–¨ğ–¯delimited-[]ğ‘˜\mathsf{QCIP}[k]sansserif_QCIP [ italic_k ], which, to the best of our knowledge, has not been explored in the literature. This class contains all promise problems that can be decided by a kğ‘˜kitalic_k-message interaction between a polynomial-time quantum verifier and a prover, where only classical strings are exchanged between them. Definition 1 (Quantum-classical interactive proofs). Let nâˆˆâ„•ğ‘›â„•n\in\mathbb{N}italic_n âˆˆ blackboard_N and pâ¢(n):â„•â†’â„•:ğ‘ğ‘›â†’â„•â„•p(n):\mathbb{N}\rightarrow\mathbb{N}italic_p ( italic_n ) : blackboard_N â†’ blackboard_N be a polynomial. A promise problem A=(Ayes,Ano)ğ´subscriptğ´yessubscriptğ´noA=(A_{\textup{\sc yes}},A_{\textup{\sc no}})italic_A = ( italic_A start_POSTSUBSCRIPT yes end_POSTSUBSCRIPT , italic_A start_POSTSUBSCRIPT no end_POSTSUBSCRIPT ) is in ğ–°ğ–¢ğ–¨ğ–¯c,sâ¢[k]subscriptğ–°ğ–¢ğ–¨ğ–¯ğ‘ğ‘ delimited-[]ğ‘˜\mathsf{QCIP}_{c,s}[k]sansserif_QCIP start_POSTSUBSCRIPT italic_c , italic_s end_POSTSUBSCRIPT [ italic_k ] if there exists a ğ–¯ğ–¯\mathsf{P}sansserif_P-uniform family of polynomial-time quantum verifier circuits {Vn:nâˆˆâ„•}conditional-setsubscriptğ‘‰ğ‘›ğ‘›â„•\{V_{n}:n\in\mathbb{N}\}{ italic_V start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT : italic_n âˆˆ blackboard_N }, where each verifier Vnsubscriptğ‘‰ğ‘›V_{n}italic_V start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT takes xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\in\{0,1\}^{n}italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT as an input and exchanges kğ‘˜kitalic_k classical messages of length at most pâ¢(n)ğ‘ğ‘›p(n)italic_p ( italic_n ) with a computationally unbounded prover P:{0,1}âˆ—â†’{0,1}âˆ—:ğ‘ƒâ†’superscript01superscript01P:\{0,1\}^{*}\rightarrow\{0,1\}^{*}italic_P : { 0 , 1 } start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT â†’ { 0 , 1 } start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT, such that the following conditions hold: â€¢ If xâˆˆAyesğ‘¥subscriptğ´yesx\in A_{\textup{\sc yes}}italic_x âˆˆ italic_A start_POSTSUBSCRIPT yes end_POSTSUBSCRIPT, there exists a prover Pğ‘ƒPitalic_P that causes Vnsubscriptğ‘‰ğ‘›V_{n}italic_V start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT to accept with probability at least cğ‘citalic_c. â€¢ If xâˆˆAnoğ‘¥subscriptğ´nox\in A_{\textup{\sc no}}italic_x âˆˆ italic_A start_POSTSUBSCRIPT no end_POSTSUBSCRIPT, then for every prover Pğ‘ƒPitalic_P, Vnsubscriptğ‘‰ğ‘›V_{n}italic_V start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT accepts with probability at most sğ‘ sitalic_s. We define ğ–°ğ–¢ğ–¨ğ–¯â¢[k]=ğ–°ğ–¢ğ–¨ğ–¯2/3,1/3â¢[k]ğ–°ğ–¢ğ–¨ğ–¯delimited-[]ğ‘˜subscriptğ–°ğ–¢ğ–¨ğ–¯2313delimited-[]ğ‘˜\mathsf{QCIP}[k]=\mathsf{QCIP}_{2/3,1/3}[k]sansserif_QCIP [ italic_k ] = sansserif_QCIP start_POSTSUBSCRIPT 2 / 3 , 1 / 3 end_POSTSUBSCRIPT [ italic_k ], ğ–°ğ–¢ğ–¨ğ–¯=â‹ƒÎ±â‰¥1ğ–°ğ–¢ğ–¨ğ–¯â¢[nÎ±]ğ–°ğ–¢ğ–¨ğ–¯subscriptğ›¼1ğ–°ğ–¢ğ–¨ğ–¯delimited-[]superscriptğ‘›ğ›¼\mathsf{QCIP}=\bigcup_{\alpha\geq 1}\mathsf{QCIP}[n^{\alpha}]sansserif_QCIP = â‹ƒ start_POSTSUBSCRIPT italic_Î± â‰¥ 1 end_POSTSUBSCRIPT sansserif_QCIP [ italic_n start_POSTSUPERSCRIPT italic_Î± end_POSTSUPERSCRIPT ], and ğ–°ğ–¢ğ–¬ğ– =ğ–°ğ–¢ğ–¨ğ–¯â¢[1]ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¨ğ–¯delimited-[]1\mathsf{QCMA}=\mathsf{QCIP}[1]sansserif_QCMA = sansserif_QCIP [ 1 ]. We have that ğ–°ğ–¢ğ–¨ğ–¯ğ–°ğ–¢ğ–¨ğ–¯\mathsf{QCIP}sansserif_QCIP in itself is not a particularly interesting class, as it is already known that ğ–°ğ–¨ğ–¯=ğ–¨ğ–¯=ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–°ğ–¨ğ–¯ğ–¨ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{QIP}=\mathsf{IP}=\mathsf{PSPACE}sansserif_QIP = sansserif_IP = sansserif_PSPACE. Therefore, since ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤=ğ–¨ğ–¯âŠ†ğ–°ğ–¢ğ–¨ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¨ğ–¯ğ–°ğ–¢ğ–¨ğ–¯\mathsf{PSPACE}=\mathsf{IP}\subseteq\mathsf{QCIP}sansserif_PSPACE = sansserif_IP âŠ† sansserif_QCIP [Sha92] and ğ–°ğ–¢ğ–¨ğ–¯âŠ†ğ–°ğ–¨ğ–¯=ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–°ğ–¢ğ–¨ğ–¯ğ–°ğ–¨ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{QCIP}\subseteq\mathsf{QIP}=\mathsf{PSPACE}sansserif_QCIP âŠ† sansserif_QIP = sansserif_PSPACE [JJUW11], we actually have ğ–°ğ–¢ğ–¨ğ–¯=ğ–°ğ–¨ğ–¯=ğ–¨ğ–¯=ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–°ğ–¢ğ–¨ğ–¯ğ–°ğ–¨ğ–¯ğ–¨ğ–¯ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{QCIP}=\mathsf{QIP}=\mathsf{IP}=\mathsf{PSPACE}sansserif_QCIP = sansserif_QIP = sansserif_IP = sansserif_PSPACE. This implies that, for interactive proof systems allowing a polynomial number of interaction rounds, the computational power is independent of whether the proofs are classical or quantum, or whether the verifier is quantum. However, it is well-known that ğ–°ğ–¨ğ–¯â¢[3]=ğ–°ğ–¨ğ–¯ğ–°ğ–¨ğ–¯delimited-[]3ğ–°ğ–¨ğ–¯\mathsf{QIP}[3]=\mathsf{QIP}sansserif_QIP [ 3 ] = sansserif_QIP [KW00], which demonstrates that quantum interactive proofs with a constant number of rounds (specifically, kâ‰¥3ğ‘˜3k\geq 3italic_k â‰¥ 3) are more powerful than classical ones, as ğ–¨ğ–¯â¢[k]=ğ– ğ–¬ğ–¨ğ–¯delimited-[]ğ‘˜ğ– ğ–¬\mathsf{IP}[k]=\mathsf{AM}sansserif_IP [ italic_k ] = sansserif_AM for all kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2. It seems unlikely that a similar result holds for quantum-classical interactive proofs, as the proof that ğ–°ğ–¨ğ–¯â¢[3]=ğ–°ğ–¨ğ–¯ğ–°ğ–¨ğ–¯delimited-[]3ğ–°ğ–¨ğ–¯\mathsf{QIP}[3]=\mathsf{QIP}sansserif_QIP [ 3 ] = sansserif_QIP heavily relies on the ability to exchange quantum registers, creating entanglement between the verifier and the proverâ€™s quantum states. Trivially, for any kâ‰¥1ğ‘˜1k\geq 1italic_k â‰¥ 1 and any oracle ğ“ğ“\bm{\mathcal{O}}bold_caligraphic_O, we have that ğ–°ğ–¢ğ–¬ğ– ğ“âŠ†ğ–°ğ–¢ğ–¨ğ–¯â¢[k]ğ“superscriptğ–°ğ–¢ğ–¬ğ– ğ“ğ–°ğ–¢ğ–¨ğ–¯superscriptdelimited-[]ğ‘˜ğ“\mathsf{QCMA}^{\bm{\mathcal{O}}}\subseteq\mathsf{QCIP}[k]^{\bm{\mathcal{O}}}sansserif_QCMA start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT âŠ† sansserif_QCIP [ italic_k ] start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT (the verifier does not have to make use of their ability to send a message to the prover, yielding the exact same class). Using the oracle ğ“ğ“\bm{\mathcal{O}}bold_caligraphic_O from Definition 2 and the result from Proposition 1, we have that (ğ–¡ğ–°â‹…ğ–­ğ–¯)ğ“âŠ†ğ–¡ğ–°ğ–¯ğ–­ğ–¯ğ“âŠ…ğ–°ğ–¢ğ–¬ğ– ğ“âŠ†ğ–°ğ–¢ğ–¨ğ–¯â¢[k]ğ“superscriptâ‹…ğ–¡ğ–°ğ–­ğ–¯ğ“superscriptğ–¡ğ–°ğ–¯superscriptğ–­ğ–¯ğ“not-superset-ofsuperscriptğ–°ğ–¢ğ–¬ğ– ğ“ğ–°ğ–¢ğ–¨ğ–¯superscriptdelimited-[]ğ‘˜ğ“\left(\mathsf{BQ}\cdot\mathsf{NP}\right)^{\bm{\mathcal{O}}}\subseteq\mathsf{% BQP}^{\mathsf{NP}^{\bm{\mathcal{O}}}}\not\supset\mathsf{QCMA}^{\bm{\mathcal{O}% }}\subseteq\mathsf{QCIP}[k]^{\bm{\mathcal{O}}}( sansserif_BQ â‹… sansserif_NP ) start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT âŠ† sansserif_BQP start_POSTSUPERSCRIPT sansserif_NP start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT âŠ… sansserif_QCMA start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT âŠ† sansserif_QCIP [ italic_k ] start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT, leading directly to the following corollary. Corollary 1. For any kâ‰¥1ğ‘˜1k\geq 1italic_k â‰¥ 1, there exists an oracle ğ“ğ“\bm{\mathcal{O}}bold_caligraphic_O relative to which ğ–°ğ–¢ğ–¨ğ–¯â¢[k]ğ“âŠ„(ğ–¡ğ–°â‹…ğ–­ğ–¯)ğ“.not-subset-ofğ–°ğ–¢ğ–¨ğ–¯superscriptdelimited-[]ğ‘˜ğ“superscriptâ‹…ğ–¡ğ–°ğ–­ğ–¯ğ“\displaystyle\mathsf{QCIP}[k]^{\bm{\mathcal{O}}}\not\subset\left(\mathsf{BQ}% \cdot\mathsf{NP}\right)^{\bm{\mathcal{O}}}.sansserif_QCIP [ italic_k ] start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT âŠ„ ( sansserif_BQ â‹… sansserif_NP ) start_POSTSUPERSCRIPT bold_caligraphic_O end_POSTSUPERSCRIPT . The same result holds by considering ğ–°ğ–¢ğ– ğ–¬â¢[k]ğ–°ğ–¢ğ– ğ–¬delimited-[]ğ‘˜\mathsf{QCAM}[k]sansserif_QCAM [ italic_k ] instead of ğ–°ğ–¢ğ–¨ğ–¯â¢[k]ğ–°ğ–¢ğ–¨ğ–¯delimited-[]ğ‘˜\mathsf{QCIP}[k]sansserif_QCIP [ italic_k ], where is ğ–°ğ–¢ğ– ğ–¬â¢[k]ğ–°ğ–¢ğ– ğ–¬delimited-[]ğ‘˜\mathsf{QCAM}[k]sansserif_QCAM [ italic_k ] the quantum generalization of ğ– ğ–¬â¢[k]ğ– ğ–¬delimited-[]ğ‘˜\mathsf{AM}[k]sansserif_AM [ italic_k ] (see, for example, [AGKR24, AH23]). This contrasts the classical result that ğ– ğ–¬â¢[k]âŠ†ğ–¨ğ–¯â¢[k]=ğ–¡ğ–¯â‹…ğ–­ğ–¯ğ– ğ–¬delimited-[]ğ‘˜ğ–¨ğ–¯delimited-[]ğ‘˜â‹…ğ–¡ğ–¯ğ–­ğ–¯\mathsf{AM}[k]\subseteq\mathsf{IP}[k]=\mathsf{BP}\cdot\mathsf{NP}sansserif_AM [ italic_k ] âŠ† sansserif_IP [ italic_k ] = sansserif_BP â‹… sansserif_NP for all kâˆˆâ„•â‰¥2ğ‘˜subscriptâ„•absent2k\in\mathbb{N}_{\geq 2}italic_k âˆˆ blackboard_N start_POSTSUBSCRIPT â‰¥ 2 end_POSTSUBSCRIPT, which holds relative to all oracles. Intuitively, we believe that our statements for quantum-classical PCPs hold because one can pull out the quantumness, while Corollary 1 for quantum-classical interactive proof systems holds because one cannot pull out the quantumness. 1.4 Discussion and open questions In this work, we have introduced a quantum version of the ğ–¡ğ–¯ğ–¡ğ–¯\mathsf{BP}sansserif_BP-operator and applied it to explore interactive proof systems with a quantum verifier and classical messages. For quantum-classical PCPs, many open questions appear to be resolved by this work, as achieving an unconditional separation from ğ–°ğ–¢ğ–¬ğ– ğ–°ğ–¢ğ–¬ğ– \mathsf{QCMA}sansserif_QCMA would require overcoming the ğ–¯ğ–¯\mathsf{P}sansserif_P versus ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤ğ–¯ğ–²ğ–¯ğ– ğ–¢ğ–¤\mathsf{PSPACE}sansserif_PSPACE barrier, which seems beyond current techniques. For future work, we would like to extend the direction of this work to general quantum- classical interactive proof systems, for which we believe that the concept of not being able to â€œpull out the quantumnessâ€ has many implications. We conjecture that, relative to an oracle, one can demonstrate that no round reduction exists for a constant number of rounds, and that ğ–°ğ–¢ğ– ğ–¬â¢[k]ğ–°ğ–¢ğ– ğ–¬delimited-[]ğ‘˜\mathsf{QCAM}[k]sansserif_QCAM [ italic_k ] does not contain ğ–°ğ–¢ğ–¨ğ–¯â¢[k]ğ–°ğ–¢ğ–¨ğ–¯delimited-[]ğ‘˜\mathsf{QCIP}[k]sansserif_QCIP [ italic_k ], highlighting the distinction between â€œquantumnessâ€ and randomness. Another direction worth exploring is whether, for some fixed kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2, ğ–°ğ–¢ğ–¨ğ–¯â¢[k]ğ–°ğ–¢ğ–¨ğ–¯delimited-[]ğ‘˜\mathsf{QCIP}[k]sansserif_QCIP [ italic_k ] admits perfect completeness, possibly with a constant overhead in the number of rounds. Additionally, what is the relationship between ğ–°ğ–¢ğ–¨ğ–¯â¢[k]ğ–°ğ–¢ğ–¨ğ–¯delimited-[]ğ‘˜\mathsf{QCIP}[k]sansserif_QCIP [ italic_k ] and ğ–°ğ–¨ğ–¯â¢[2]ğ–°ğ–¨ğ–¯delimited-[]2\mathsf{QIP}[2]sansserif_QIP [ 2 ] for larger values of kğ‘˜kitalic_k? For the ğ–¡ğ–°ğ–¡ğ–°\mathsf{BQ}sansserif_BQ-operator, it would be interesting to investigate whether it has broader applications. Specifically, are there other problems that allow a quantum reduction to a classical problem? Some examples in a non-quantum PCP context can be found in cryptography [Reg09, DART23], although the reduction in [Reg09] has also been shown to exist in a classical setting [Pei09]."
https://arxiv.org/html/2411.00082v1,Testing and learning structured quantum Hamiltonians,"We consider the problems of testing and learning an nğ‘›nitalic_n-qubit Hamiltonian H=âˆ‘xÎ»xâ¢Ïƒxğ»subscriptğ‘¥subscriptğœ†ğ‘¥subscriptğœğ‘¥H=\sum_{x}\lambda_{x}\sigma_{x}italic_H = âˆ‘ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT italic_Î» start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT expressed in its Pauli basis, from queries to its evolution operator U=eâˆ’iâ¢Hâ¢tğ‘ˆsuperscriptğ‘’ğ‘–ğ»ğ‘¡U=e^{-iHt}italic_U = italic_e start_POSTSUPERSCRIPT - italic_i italic_H italic_t end_POSTSUPERSCRIPT with respect the normalized Frobenius norm. To this end, we prove the following results (with and without quantum memory) for Hamiltonians whose Pauli spectrum involves only kğ‘˜kitalic_k-local terms or has sparsity at most sğ‘ sitalic_s:Local Hamiltonians: We give a tolerant testing protocol to decide if a Hamiltonian is Îµ1subscriptğœ€1\varepsilon_{1}italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-close to kğ‘˜kitalic_k-local or Îµ2subscriptğœ€2\varepsilon_{2}italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-far from kğ‘˜kitalic_k-local, with Oâ¢(1/(Îµ2âˆ’Îµ1)4)ğ‘‚1superscriptsubscriptğœ€2subscriptğœ€14O(1/(\varepsilon_{2}-\varepsilon_{1})^{4})italic_O ( 1 / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) queries, thereby solving two open questions posed in a recent work by Bluhm, Caro and Oufkir [5]. For learning a kğ‘˜kitalic_k-local Hamiltonian up to error Îµğœ€\varepsilonitalic_Îµ, we give a protocol with query complexity and total time evolution expâ¡(Oâ¢(k2+kâ¢logâ¡(1/Îµ)))ğ‘‚superscriptğ‘˜2ğ‘˜1ğœ€\exp(O(k^{2}+k\log(1/\varepsilon)))roman_exp ( italic_O ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + italic_k roman_log ( 1 / italic_Îµ ) ) ). Our algorithm leverages the non-commutative Bohnenblust-Hille inequality in order to get a complexity independent of nğ‘›nitalic_n.Sparse Hamiltonians: We give a protocol for testing whether a Hamiltonian is Îµ1subscriptğœ€1\varepsilon_{1}italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-close to being sğ‘ sitalic_s-sparse or Îµ2subscriptğœ€2\varepsilon_{2}italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-far from being sğ‘ sitalic_s-sparse, with Oâ¢(s6/(Îµ22âˆ’Îµ12)6)ğ‘‚superscriptğ‘ 6superscriptsuperscriptsubscriptğœ€22superscriptsubscriptğœ€126O(s^{6}/(\varepsilon_{2}^{2}-\varepsilon_{1}^{2})^{6})italic_O ( italic_s start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT ) queries. For learning up to error Îµğœ€\varepsilonitalic_Îµ, we show that Oâ¢(s4/Îµ8)ğ‘‚superscriptğ‘ 4superscriptğœ€8O(s^{4}/\varepsilon^{8})italic_O ( italic_s start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 8 end_POSTSUPERSCRIPT ) queries suffices.Learning without quantum memory: The learning results stated above have no dependence on the system size nğ‘›nitalic_n, but require nğ‘›nitalic_n-qubit quantum memory. We give subroutines that allow us to reproduce all the above learning results without quantum memory; increasing the query complexity by a (logâ¡n)ğ‘›(\log n)( roman_log italic_n )-factor in the local case and an nğ‘›nitalic_n-factor in the sparse case.Testing without quantum memory: We give a new subroutine called Pauli hashing, which allows one to tolerantly test sğ‘ sitalic_s-sparse Hamiltonians using O~â¢(s14/(Îµ22âˆ’Îµ12)18)~ğ‘‚superscriptğ‘ 14superscriptsuperscriptsubscriptğœ€22superscriptsubscriptğœ€1218\tilde{O}(s^{14}/(\varepsilon_{2}^{2}-\varepsilon_{1}^{2})^{18})over~ start_ARG italic_O end_ARG ( italic_s start_POSTSUPERSCRIPT 14 end_POSTSUPERSCRIPT / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT 18 end_POSTSUPERSCRIPT ) query complexity. A key ingredient is showing that sğ‘ sitalic_s-sparse Pauli channels can be tested in a tolerant fashion as being Îµ1subscriptğœ€1\varepsilon_{1}italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-close to being sğ‘ sitalic_s-sparse or Îµ2subscriptğœ€2\varepsilon_{2}italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-far under the diamond norm, using O~â¢(s2/(Îµ2âˆ’Îµ1)6)~ğ‘‚superscriptğ‘ 2superscriptsubscriptğœ€2subscriptğœ€16\tilde{O}(s^{2}/(\varepsilon_{2}-\varepsilon_{1})^{6})over~ start_ARG italic_O end_ARG ( italic_s start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT ) queries via Pauli hashing.In order to prove these results, we prove new structural theorems for local Hamiltonians, sparse Pauli channels and sparse Hamiltonians. We complement our learning algorithms with lower bounds that are polynomially weaker. Furthermore, our algorithms use short time evolutions and do not assume prior knowledge of the terms on which the Pauli spectrum is supported on, i.e., we do not require prior knowledge about the support of the Hamiltonian terms.","A fundamental and important challenge with building quantum devices is being able to characterize and calibrate its behavior. One approach to do so is Hamiltonian learning which seeks to learn the Hamiltonian governing the dynamics of a quantum system given finite classical and quantum resources. Beyond system characterization, it is also carried out during validation of physical systems and designing control strategies for implementing quantum gates [39]. However, learning an nğ‘›nitalic_n-qubit Hamiltonian is known to be difficult, requiring complexity that scales exponential in the number of qubits [12]. In practice, however, prior knowledge on the structure of Hamiltonians is available e.g., those of engineered quantum devices [53] where the underlying Hamiltonians primarily involve local interactions with few non-local interactions, and even naturally occurring physical quantum systems such as those with translationally invariant Hamiltonians. To highlight these structural properties, consider an nğ‘›nitalic_n-qubit Hamiltonian Hğ»Hitalic_H (which is a self-adjoint operator acting on (â„‚2)âŠ—nsuperscriptsuperscriptâ„‚2tensor-productabsentğ‘›(\mathbb{C}^{2})^{\otimes n}( blackboard_C start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT âŠ— italic_n end_POSTSUPERSCRIPT) expanded in terms of the nğ‘›nitalic_n-qubit Pauli operators: H=âˆ‘xâˆˆ{0,1}2â¢nÎ»xâ¢Ïƒx,ğ»subscriptğ‘¥superscript012ğ‘›subscriptğœ†ğ‘¥subscriptğœğ‘¥H=\sum_{x\in\{0,1\}^{2n}}\lambda_{x}\sigma_{x},italic_H = âˆ‘ start_POSTSUBSCRIPT italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT end_POSTSUBSCRIPT italic_Î» start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT , where Î»xsubscriptğœ†ğ‘¥\lambda_{x}italic_Î» start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT are real-valued coefficients (also called interaction strengths) of the Pauli operators Ïƒxsubscriptğœğ‘¥\sigma_{x}italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT denoted by the string x=(a,b)âˆˆğ”½2nğ‘¥ğ‘ğ‘superscriptsubscriptğ”½2ğ‘›x=(a,b)\in\mathbb{F}_{2}^{n}italic_x = ( italic_a , italic_b ) âˆˆ blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT with Ïƒ(a,b)=iaâ‹…bâŠ—i=1nXaiâ¢Zbisubscriptğœğ‘ğ‘superscriptsubscripttensor-productğ‘–1ğ‘›superscriptğ‘–â‹…ğ‘ğ‘superscriptğ‘‹subscriptğ‘ğ‘–superscriptğ‘subscriptğ‘ğ‘–\sigma_{(a,b)}=i^{a\cdot b}\otimes_{i=1}^{n}X^{a_{i}}Z^{b_{i}}italic_Ïƒ start_POSTSUBSCRIPT ( italic_a , italic_b ) end_POSTSUBSCRIPT = italic_i start_POSTSUPERSCRIPT italic_a â‹… italic_b end_POSTSUPERSCRIPT âŠ— start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_X start_POSTSUPERSCRIPT italic_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_Z start_POSTSUPERSCRIPT italic_b start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT. We call the set of Paulis with non-zero coefficients Î»xsubscriptğœ†ğ‘¥\lambda_{x}italic_Î» start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT as the Pauli spectrum of the Hamiltonian denoted by ğ’®={xâˆˆ{0,1}2â¢n:Î»xâ‰ 0}ğ’®conditional-setğ‘¥superscript012ğ‘›subscriptğœ†ğ‘¥0\mathcal{S}=\{x\in\{0,1\}^{2n}:\ \lambda_{x}\neq 0\}caligraphic_S = { italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT : italic_Î» start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT â‰  0 }. Of particular relevance are kğ‘˜kitalic_k-local Hamiltonians which involve Pauli operators that act non-trivially on all but at most kğ‘˜kitalic_k qubits and sğ‘ sitalic_s-sparse Hamiltonians whose Pauli expansion contains at most sğ‘ sitalic_s non-zero Pauli operators i.e., |ğ’®|â‰¤sğ’®ğ‘ |\mathcal{S}|\leq s| caligraphic_S | â‰¤ italic_s. There has thus been a growing suite of Hamiltonian learning results that have shown that when the underlying nğ‘›nitalic_n-qubit Hamiltonian Hğ»Hitalic_H satisfies these structural properties, learning can be performed with only polyâ¡(n)polyğ‘›\operatorname{poly}(n)roman_poly ( italic_n ) query complexity, either by making â€œqueriesâ€ to the unitary evolution operator Uâ¢(t)=expâ¡(âˆ’iâ¢Hâ¢t)ğ‘ˆğ‘¡ğ‘–ğ»ğ‘¡U(t)=\exp(-iHt)italic_U ( italic_t ) = roman_exp ( - italic_i italic_H italic_t ) [23, 34, 62, 36, 59, 21, 38, 40, 52, 28], or by assuming one has access to Gibbs state [1, 36, 51, 48, 8, 28]. Notably, [9] considered the problem of learning Hamiltonians that are both local and sparse, without prior knowledge of the support. Several of the learning algorithms mentioned above however require assumptions on the support of the Hamiltonian beyond locality or sparsity, such as [38] which considers geometrically-local Hamiltonians (a subset of local Hamiltonians) and [59] which requires assumptions on the support. Moreover, before learning, it might be desirable to uncover what is the structure of an unknown Hamiltonian in order to choose specialized learning algorithms. Even deciding if a Hamiltonian has a particular structure is a fundamental challenge and constitutes the problem of testing if an unknown Hamiltonian satisfies a certain structural property. As far as we know, this line of investigation is nascent with only a few works on Hamiltonian property testing [54, 2, 41] with Blum et al. [6] having considered the problem of testing local Hamiltonians and the problem of testing sparse Hamiltonians yet to be tackled. This leads us to the motivating question of our work: What is the query complexity of learning and testing structured Hamiltonians? 1.1 Problem statement Before we state our results answering the question above, we clearly mention our learning and testing problems first. If Hğ»Hitalic_H is the Hamiltonian describing the dynamics of a certain physical system, then the state of that system evolves according to the time evolution operator Uâ¢(t)=eâˆ’iâ¢Hâ¢tğ‘ˆğ‘¡superscriptğ‘’ğ‘–ğ»ğ‘¡U(t)=e^{-iHt}italic_U ( italic_t ) = italic_e start_POSTSUPERSCRIPT - italic_i italic_H italic_t end_POSTSUPERSCRIPT. This means that if Ïâ¢(0)ğœŒ0\rho(0)italic_Ï ( 0 ) is the state at time 00, at time tğ‘¡titalic_t the state would have evolved to Ïâ¢(t)=Uâ¢(t)â¢Ïâ¢(0)â¢Uâ€ â¢(t)ğœŒğ‘¡ğ‘ˆğ‘¡ğœŒ0superscriptğ‘ˆâ€ ğ‘¡\rho(t)=U(t)\rho(0)U^{\dagger}(t)italic_Ï ( italic_t ) = italic_U ( italic_t ) italic_Ï ( 0 ) italic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT ( italic_t ). Hence, to test and learn a Hamiltonian one can do the following: prepare a desired state, apply Uâ¢(t)ğ‘ˆğ‘¡U(t)italic_U ( italic_t ) or tensor products of Uâ¢(t)ğ‘ˆğ‘¡U(t)italic_U ( italic_t ) with identity to the state, and finally measure in a chosen basis. From here onwards, this is what we mean by querying the unitary Uâ¢(t)ğ‘ˆğ‘¡U(t)italic_U ( italic_t ). It is usual to impose the normalization condition âˆ¥Hâˆ¥âˆâ‰¤1subscriptdelimited-âˆ¥âˆ¥ğ»1\lVert H\rVert_{\infty}\leq 1âˆ¥ italic_H âˆ¥ start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT â‰¤ 1 (i.e., that the eigenvalues of Hğ»Hitalic_H are bounded in absolute value by 1111), as otherwise the complexities scale with the norm of the Hamiltonian. Throughout this paper, we will consider the normalized Frobenius norm as the distance between Hamiltonians, namely dâ¢(H,Hâ€²)=âˆ¥Hâˆ’Hâ€²âˆ¥2=Trâ¡[(Hâˆ’Hâ€²)2]2n,ğ‘‘ğ»superscriptğ»â€²subscriptdelimited-âˆ¥âˆ¥ğ»superscriptğ»â€²2Trsuperscriptğ»superscriptğ»â€²2superscript2ğ‘›d(H,H^{\prime})=\lVert H-H^{\prime}\rVert_{2}=\sqrt{\frac{\operatorname{Tr}[(H% -H^{\prime})^{2}]}{2^{n}}},italic_d ( italic_H , italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) = âˆ¥ italic_H - italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆ¥ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = square-root start_ARG divide start_ARG roman_Tr [ ( italic_H - italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ] end_ARG start_ARG 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG end_ARG , which equals the 2-norm of the Pauli spectrum, dâ¢(H,Hâ€²)=âˆ‘|Î»xâˆ’Î»xâ€²|2ğ‘‘ğ»superscriptğ»â€²superscriptsubscriptğœ†ğ‘¥subscriptsuperscriptğœ†â€²ğ‘¥2d(H,H^{\prime})=\sqrt{\sum|\lambda_{x}-\lambda^{\prime}_{x}|^{2}}italic_d ( italic_H , italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) = square-root start_ARG âˆ‘ | italic_Î» start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT - italic_Î» start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG. A property of a Hamiltonian, denoted â„‹â„‹\mathcal{H}caligraphic_H is a class of Hamiltonians that satisfy the property (here we will be interested in sparse and local properties). We say that Hğ»Hitalic_H is Îµğœ€\varepsilonitalic_Îµ-far from having a property â„‹â„‹\mathcal{H}caligraphic_H if dâ¢(H,Hâ€²)>Îµğ‘‘ğ»superscriptğ»â€²ğœ€d(H,H^{\prime})>\varepsilonitalic_d ( italic_H , italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) > italic_Îµ for every Hâ€²âˆˆâ„‹superscriptğ»â€²â„‹H^{\prime}\in\mathcal{H}italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ caligraphic_H, and otherwise is Îµğœ€\varepsilonitalic_Îµ-close. Now, we are ready to state the testing and learning problems. Let â„‹â„‹\mathcal{H}caligraphic_H be a property and let Hğ»Hitalic_H be an unknown Hamiltonian with âˆ¥Hâˆ¥âˆâ‰¤1subscriptdelimited-âˆ¥âˆ¥ğ»1\lVert H\rVert_{\infty}\leq 1âˆ¥ italic_H âˆ¥ start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT â‰¤ 1 and Trâ¡[H]=0Trğ»0\operatorname{Tr}[H]=0roman_Tr [ italic_H ] = 0. Problem 1.1 (Tolerant testing). Promised Hğ»Hitalic_H is either Îµ1subscriptğœ€1\varepsilon_{1}italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-close or Îµ2subscriptğœ€2\varepsilon_{2}italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-far from satisfying property â„‹â„‹\mathcal{H}caligraphic_H, decide which is the case by making queries to Uâ¢(t)ğ‘ˆğ‘¡U(t)italic_U ( italic_t ). Problem 1.2 (Hamiltonian learning). Promised Hâˆˆâ„‹ğ»â„‹H\in\mathcal{H}italic_H âˆˆ caligraphic_H, output a classical description of H~âˆˆâ„‹~ğ»â„‹\widetilde{H}\in\mathcal{H}over~ start_ARG italic_H end_ARG âˆˆ caligraphic_H such that â€–Hâˆ’H~â€–2â‰¤Îµsubscriptnormğ»~ğ»2ğœ€\|H-\widetilde{H}\|_{2}\leq\varepsilonâˆ¥ italic_H - over~ start_ARG italic_H end_ARG âˆ¥ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT â‰¤ italic_Îµ by making queries to Uâ¢(t)ğ‘ˆğ‘¡U(t)italic_U ( italic_t ). 1.2 Summary of results The main results of this submission are query-efficient algorithms for testing and learning Hamiltonians that are local and/or sparse. We can reproduce these results without using quantum memory by increasing the number of queries. We summarize our results in the table below (for simplicity we state our results for constant accuracy). Testing Learning with memory w/o memory with memory w/o memory sğ‘ sitalic_s-sparse polyâ¡(s)polyğ‘ \operatorname{poly}(s)roman_poly ( italic_s ) polyâ¡(s)polyğ‘ \operatorname{poly}(s)roman_poly ( italic_s ) polyâ¡(s)polyğ‘ \operatorname{poly}(s)roman_poly ( italic_s ) nâ‹…polyâ¡(s)â‹…ğ‘›polyğ‘ n\cdot\operatorname{poly}(s)italic_n â‹… roman_poly ( italic_s ) kğ‘˜kitalic_k-local Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 ) Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 ) [6] expâ¡(k2)superscriptğ‘˜2\exp(k^{2})roman_exp ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) (logâ¡n)â‹…expâ¡(k2)â‹…ğ‘›superscriptğ‘˜2(\log n)\cdot\exp(k^{2})( roman_log italic_n ) â‹… roman_exp ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) kğ‘˜kitalic_k-local & sğ‘ sitalic_s-sparse polyâ¡(s)polyğ‘ \operatorname{poly}(s)roman_poly ( italic_s ) polyâ¡(s)polyğ‘ \operatorname{poly}(s)roman_poly ( italic_s ) minâ¡{expâ¡(k2),polyâ¡(sâ¢k)}superscriptğ‘˜2polyğ‘ ğ‘˜\min\{\exp(k^{2}),\operatorname{poly}(sk)\}roman_min { roman_exp ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) , roman_poly ( italic_s italic_k ) } (logâ¡n)â‹…minâ¡{expâ¡(k2),polyâ¡(sâ¢k)}â‹…ğ‘›superscriptğ‘˜2polyğ‘ ğ‘˜(\log n)\cdot\min\{\exp(k^{2}),\operatorname{poly}(sk)\}( roman_log italic_n ) â‹… roman_min { roman_exp ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) , roman_poly ( italic_s italic_k ) } Table 1: Query complexity for learning and testing nğ‘›nitalic_n-qubit structured Hamiltonians. Dependence on nğ‘›nitalic_n and the structural property is shown for constant accuracy. Results are indicated with quantum memory (i.e., an nğ‘›nitalic_n-qubit ancillary system is available) and without quantum memory. Before we discuss our results in more detail, we make a few remarks about our main results. (i)ğ‘–(i)( italic_i ) As far as we know, this is the first work: (a)ğ‘(a)( italic_a ) with complexities that are independent of nğ‘›nitalic_n (with memory)111We remark that there are a few works that achieve nğ‘›nitalic_n-independent complexities for learning local Hamiltonians in the âˆ\inftyâˆ-norm of the Pauli coefficients, but when transformed into 2222-norm learners they yield complexities depending on nksuperscriptğ‘›ğ‘˜n^{k}italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT., and (b)ğ‘(b)( italic_b ) that does not assume knowledge of the support.222Soon after the third-authorâ€™s work [32], Bakshi et al. [9] presented a learning algorithm that does not require prior knowledge of the support, although their result achieve Heisenberg scaling in complexity using heavy machinery. (iâ¢v)ğ‘–ğ‘£(iv)( italic_i italic_v ) We give the first learning algorithm for Hamiltonians that are only promised to be sparse, and not necessarily local. Similarly, our local Hamiltonian learning problem doesnâ€™t assume geometric locality which was assumed in several prior works. (iâ¢iâ¢i)ğ‘–ğ‘–ğ‘–(iii)( italic_i italic_i italic_i ) Our testing algorithms are tolerant, i.e., they can handle the setting where Îµ1â‰ 0subscriptğœ€10\varepsilon_{1}\neq 0italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â‰  0. As far as we know, there are only a handful of polynomial-time tolerant testers for quantum objects. (iâ¢v)ğ‘–ğ‘£(iv)( italic_i italic_v ) We show that all our all the learning protocols with quantum memory can be translated to ones which require no quantum memory. In the case of learning structured Hamiltonians, we obtain a protocol with only a factor logâ¡nğ‘›\log nroman_log italic_n overhead for local Hamiltonians and a protocol with a factor nğ‘›nitalic_n overhead for sparse Hamiltonians. (v)ğ‘£(v)( italic_v ) We also give a tolerant testing algorithm for sğ‘ sitalic_s-sparse Hamiltonians that requires no quantum memory based on a new subroutine called Pauli hashing. The query complexity is Oâ¢(polyâ¡(s))ğ‘‚polyğ‘ O(\operatorname{poly}(s))italic_O ( roman_poly ( italic_s ) ) and is notably independent of dimension nğ‘›nitalic_n. We remark that most previous work on Hamiltonian learning (that we highlighted earlier) are done under the distance induced by the supremum norm of the Pauli spectrum and with extra constraints apart from locality [23, 34, 62, 36, 58, 59, 12, 21, 38, 40, 42, 52, 28]. When transformed into learning algorithms under the finer distance induced by the 2-norm of the Pauli spectrum, these proposals yield complexities that depend polynomially on nksuperscriptğ‘›ğ‘˜n^{k}italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT and only work for a restricted family of kğ‘˜kitalic_k-local Hamiltonians. The works that explicitly consider the problem of learning under the 2-norm have complexities depending on nğ‘›nitalic_n and assume a stronger access model [19, 9]. 1.3 Results Local Hamiltonians. Recently, Bluhm, Caro and Oufkir proposed a non-tolerant testing algorithm, meaning that it only works for the case Îµ1=0,subscriptğœ€10\varepsilon_{1}=0,italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = 0 , whose query complexity is Oâ¢(n2â¢k+2/(Îµ2âˆ’Îµ1)4)ğ‘‚superscriptğ‘›2ğ‘˜2superscriptsubscriptğœ€2subscriptğœ€14O(n^{2k+2}/(\varepsilon_{2}-\varepsilon_{1})^{4})italic_O ( italic_n start_POSTSUPERSCRIPT 2 italic_k + 2 end_POSTSUPERSCRIPT / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) and with total evolution time Oâ¢(nk+1/(Îµ2âˆ’Îµ1)3)ğ‘‚superscriptğ‘›ğ‘˜1superscriptsubscriptğœ€2subscriptğœ€13O(n^{k+1}/(\varepsilon_{2}-\varepsilon_{1})^{3})italic_O ( italic_n start_POSTSUPERSCRIPT italic_k + 1 end_POSTSUPERSCRIPT / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ). They posed as open questions whether the dependence on nğ‘›nitalic_n could be removed and whether an efficient tolerant-tester was possible [5, Section 1.5]. Our first result gives positive answer to both questions. Result 1.3. There is an algorithm that solves 1.1 for kğ‘˜kitalic_k-local Hamiltonians by making polyâ¡(1/(Îµ2âˆ’Îµ1))poly1subscriptğœ€2subscriptğœ€1\operatorname{poly}(1/(\varepsilon_{2}-\varepsilon_{1}))roman_poly ( 1 / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ) queries to the evolution operator and with polyâ¡(1/(Îµ2âˆ’Îµ1))poly1subscriptğœ€2subscriptğœ€1\operatorname{poly}(1/(\varepsilon_{2}-\varepsilon_{1}))roman_poly ( 1 / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ) total evolution time. See Theorem 4.1 for a formal statement of this result. Our algorithm to test for locality is simple. It consists of repeating the following process 1/(Îµ2âˆ’Îµ1)41superscriptsubscriptğœ€2subscriptğœ€141/(\varepsilon_{2}-\varepsilon_{1})^{4}1 / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT times: prepare nğ‘›nitalic_n EPR pairs, apply Uâ¢(Îµ2âˆ’Îµ1)âŠ—Id2ntensor-productğ‘ˆsubscriptğœ€2subscriptğœ€1subscriptIdsuperscript2ğ‘›U(\varepsilon_{2}-\varepsilon_{1})\otimes\mathop{\rm Id}\nolimits_{2^{n}}italic_U ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) âŠ— roman_Id start_POSTSUBSCRIPT 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUBSCRIPT to them and measure in the Bell basis. Each time that we repeat this process, we sample from the Pauli sprectrum of Uâ¢(Îµ2âˆ’Îµ1)ğ‘ˆsubscriptğœ€2subscriptğœ€1U(\varepsilon_{2}-\varepsilon_{1})italic_U ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ).333The Pauli spectrum of a unitary U=âˆ‘xU^xâ¢Ïƒxğ‘ˆsubscriptğ‘¥subscript^ğ‘ˆğ‘¥subscriptğœğ‘¥U=\sum_{x}\widehat{U}_{x}\sigma_{x}italic_U = âˆ‘ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT over^ start_ARG italic_U end_ARG start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT determines a probability distribution because âˆ‘x|U^x|2=1subscriptğ‘¥superscriptsubscript^ğ‘ˆğ‘¥21\sum_{x}|\widehat{U}_{x}|^{2}=1âˆ‘ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT | over^ start_ARG italic_U end_ARG start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = 1. As Îµ2âˆ’Îµ1subscriptğœ€2subscriptğœ€1\varepsilon_{2}-\varepsilon_{1}italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT is small, Taylor expansion ensures that Uâ¢(Îµ2âˆ’Îµ1)â‰ˆId2nâˆ’iâ¢(Îµ2âˆ’Îµ1)â¢Hğ‘ˆsubscriptğœ€2subscriptğœ€1subscriptIdsuperscript2ğ‘›ğ‘–subscriptğœ€2subscriptğœ€1ğ»U(\varepsilon_{2}-\varepsilon_{1})\approx\mathop{\rm Id}\nolimits_{2^{n}}-i(% \varepsilon_{2}-\varepsilon_{1})Hitalic_U ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) â‰ˆ roman_Id start_POSTSUBSCRIPT 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_POSTSUBSCRIPT - italic_i ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) italic_H, so sampling from the Pauli spectrum of Uâ¢(Îµ2âˆ’Îµ1)ğ‘ˆsubscriptğœ€2subscriptğœ€1U(\varepsilon_{2}-\varepsilon_{1})italic_U ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) allows us to estimate the weight of the non-local terms of Hğ»Hitalic_H. If that weight is big, we output that Hğ»Hitalic_H is far from kğ‘˜kitalic_k-local, and otherwise we conclude that Hğ»Hitalic_H is close to kğ‘˜kitalic_k-local. Our second result is a learning algorithm for kğ‘˜kitalic_k-local Hamiltonians. Result 1.4. There is an algorithm that solves 1.2 for kğ‘˜kitalic_k-local Hamiltonians by making expâ¡(k2+kâ¢logâ¡(1/Îµ))superscriptğ‘˜2ğ‘˜1ğœ€\exp(k^{2}+k\log(1/\varepsilon))roman_exp ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + italic_k roman_log ( 1 / italic_Îµ ) ) queries to the evolution operator with expâ¡(k2+kâ¢logâ¡(1/Îµ))superscriptğ‘˜2ğ‘˜1ğœ€\exp(k^{2}+k\log(1/\varepsilon))roman_exp ( italic_k start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + italic_k roman_log ( 1 / italic_Îµ ) ) total evolution time. See Theorem 4.3 for a formal statement of this result. The learning algorithm has two stages. In the first stage one samples from the Pauli distribution of Uâ¢(Îµ)ğ‘ˆğœ€U(\varepsilon)italic_U ( italic_Îµ ), as in the testing algorithm, and from that one can detect which are the big Pauli coefficients of Hğ»Hitalic_H. In the second stage we learn the big Pauli coefficients the swap test. One can ensure that the coefficients not detected as big in the first stage of the algorithm can be neglected. To argue this formally, we use the non-commutative Bohnenblust-Hille inequality, which has been used recently for various quantum learning algorithms [35, 56]. Sparse Hamiltonians. Despite the numerous papers in the classical literature studying the problems of testing and learning sparse Boolean functions [31, 46, 61, 24], there are not many results on learning Hamiltonians that are sparse (and not necessarily local) and the only testing result that we are aware of requires Oâ¢(sâ¢n)ğ‘‚ğ‘ ğ‘›O(sn)italic_O ( italic_s italic_n ) queries [6, Remark B.2]. Here, we present the first sparsity testing algorithm whose complexity does not depend on nğ‘›nitalic_n and the first learning algorithm for sparse Hamiltonians which does not make any assumptions regarding the support of the Hamiltonian beyond sparsity. Result 1.5. There is an algorithm that solves 1.1 for sğ‘ sitalic_s-sparse Hamiltonians by making polyâ¡(s/(Îµ2âˆ’Îµ1))polyğ‘ subscriptğœ€2subscriptğœ€1\operatorname{poly}(s/(\varepsilon_{2}-\varepsilon_{1}))roman_poly ( italic_s / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ) queries to the evolution operator and with polyâ¡(s/(Îµ2âˆ’Îµ1))polyğ‘ subscriptğœ€2subscriptğœ€1\operatorname{poly}(s/(\varepsilon_{2}-\varepsilon_{1}))roman_poly ( italic_s / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ) total evolution time. See Theorem 4.5 for a formal statement. This testing algorithm consists on performing Pauli sampling of Uâ¢((Îµ22âˆ’Îµ12)/s)ğ‘ˆsuperscriptsubscriptğœ€22superscriptsubscriptğœ€12ğ‘ U(\sqrt{(\varepsilon_{2}^{2}-\varepsilon_{1}^{2})/s})italic_U ( square-root start_ARG ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) / italic_s end_ARG ) a total of Oâ¢(s4/(Îµ22âˆ’Îµ12)4)ğ‘‚superscriptğ‘ 4superscriptsuperscriptsubscriptğœ€22superscriptsubscriptğœ€124O(s^{4}/(\varepsilon_{2}^{2}-\varepsilon_{1}^{2})^{4})italic_O ( italic_s start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) times. From these samples one can estimate the sum of the squares of the top sğ‘ sitalic_s Pauli coefficients of Uğ‘ˆUitalic_U. If this quantity is big enough, we output that the Hamiltonian is close to sğ‘ sitalic_s-sparse, and otherwise that is far. Although from this high-level description the algorithm seems similar to the locality testing one, the analysis is more involved and requires taking the second order Taylor expansion, which is the reason why the dependence on (Îµ2âˆ’Îµ1)subscriptğœ€2subscriptğœ€1(\varepsilon_{2}-\varepsilon_{1})( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) is worse in this case. Result 1.6. There is an algorithm that solves 1.2 for sğ‘ sitalic_s-sparse Hamiltonians by making polyâ¡(s/Îµ)polyğ‘ ğœ€\operatorname{poly}(s/\varepsilon)roman_poly ( italic_s / italic_Îµ ) queries to the evolution operator with polyâ¡(s/Îµ)polyğ‘ ğœ€\operatorname{poly}(s/\varepsilon)roman_poly ( italic_s / italic_Îµ ) total evolution time. See Theorem 4.6 for a formal statement. This learning algorithm begins by detecting which are the top sğ‘ sitalic_s Pauli coefficients, which can be done via Pauli sampling, and concludes by learning the top sğ‘ sitalic_s Pauli coefficients using a swap test, similarly to the locality learning algorithm. Learning and testing without quantum memory. Motivated by the limitations of current devices, there has been a series of recent works aiming to understand the power of quantum memory in testing and learning tasks, exhibiting exponential separations in some cases [14, 16, 17]. A natural question is, if the problems that we mentioned above become harder without quantum memory? Learning without memory. We surprisingly show that, the learning protocols that we mention above, can be implemented efficiently when one has no quantum memory. To this end, we provide two crucial subroutines for (i)ğ‘–(i)( italic_i ) estimating the Pauli spectrum of a unitary, (iâ¢i)ğ‘–ğ‘–(ii)( italic_i italic_i ) estimating a single Pauli coefficient to make our protocols work in the memory-less setting. Subroutine (iâ¢i)ğ‘–ğ‘–(ii)( italic_i italic_i ) incurs in no extra query-cost, and subroutine (i)ğ‘–(i)( italic_i ) only incurs in a factor-nğ‘›nitalic_n overhead in the case of learning sğ‘ sitalic_s-sparse Hamiltonians and a factor logâ¡(n)ğ‘›\log(n)roman_log ( italic_n ) in the case of learning kğ‘˜kitalic_k-local Hamiltonians. These subroutines can also be useful in other contexts. In particular, we propose tolerant tester to decide if an unknown unitary is a kğ‘˜kitalic_k-junta which uses Oâ¢(4k)ğ‘‚superscript4ğ‘˜O(4^{k})italic_O ( 4 start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ) queries (see Proposition 3.5), making progress on a question of Chen et al. [18, Section 1.3], and then we use subroutine (i)ğ‘–(i)( italic_i ) to turn it into a memory-less tester that only makes Oâ¢(4kâ¢n)ğ‘‚superscript4ğ‘˜ğ‘›O(4^{k}n)italic_O ( 4 start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT italic_n ) queries. Testing sparse Pauli channels via Pauli hashing. In order to test for sparsity of Hamiltonian without memory we reduce to the problem of testing sparsity of a Pauli channel Î¦:Ïâ†¦âˆ‘xpâ¢(x)â¢Ïƒxâ¢Ïâ¢Ïƒx:Î¦maps-toğœŒsubscriptğ‘¥ğ‘ğ‘¥subscriptğœğ‘¥ğœŒsubscriptğœğ‘¥\Phi:\rho\mapsto\sum_{x}p(x)\sigma_{x}\rho\sigma_{x}roman_Î¦ : italic_Ï â†¦ âˆ‘ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT italic_p ( italic_x ) italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT italic_Ï italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT, which is of independent interest. To do that, we introduce a new technique called Pauli Hashing which allows to construct random partitions of Pauli operators. The high-level idea is to bucket the error rates pâ¢(x)ğ‘ğ‘¥p(x)italic_p ( italic_x ) and thereby the corresponding Pauli operators: for this, we choose a random subgroup GğºGitalic_G of the nğ‘›nitalic_n-qubit Pauli group with dimension t=Oâ¢(logâ¡s)ğ‘¡ğ‘‚ğ‘ t=O(\log s)italic_t = italic_O ( roman_log italic_s ). Pauli hashing allows us to partition all the Pauli operators into cosets the centralizer of GğºGitalic_G which contains all the Paulis that commute with the Paulis in GğºGitalic_G. The buckets are then the Oâ¢(s)ğ‘‚ğ‘ O(s)italic_O ( italic_s ) cosets of the centralizer of GğºGitalic_G. The main work then goes into arguing that the sum of the weights of the top sğ‘ sitalic_s buckets is a good estimate of the top sğ‘ sitalic_s error rates, and then a structural lemma we prove shows this is a good proxy for indicating whether the Pauli channel is close to being sğ‘ sitalic_s-sparse or not. Putting everything together, with some careful analysis, we get an efficient tolerant tester for sğ‘ sitalic_s-sparse Pauli channels. Result 1.7. There is an algorithm requiring no quantum memory that tests if a Pauli channel Îµ1subscriptğœ€1\varepsilon_{1}italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-close to or Îµ1subscriptğœ€1\varepsilon_{1}italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-far-from being sğ‘ sitalic_s-sparse in diamond norm by making O~â¢(s2/(Îµ2âˆ’Îµ1)6)~ğ‘‚superscriptğ‘ 2superscriptsubscriptğœ€2subscriptğœ€16\widetilde{O}(s^{2}/(\varepsilon_{2}-\varepsilon_{1})^{6})over~ start_ARG italic_O end_ARG ( italic_s start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT ) queries to the channel. See Theorem 5.3 for a formal statement. We remark that Pauli Hashing only requires the preparation of Pauli eigenstates and Pauli measurements, making it suitable for the near-term. Testing sparse Hamiltonians without memory. We provide a memory-less testing algorithm for sğ‘ sitalic_s-sparse Hamiltonians that uses Pauli hashing, that is completely independent of our tester with memory and only requires polyâ¡(s/Îµ)polyğ‘ ğœ€\operatorname{poly}(s/\varepsilon)roman_poly ( italic_s / italic_Îµ ) queries and total evolution time, notably avoiding any dependence on nğ‘›nitalic_n. To do this, we reduce the problem of testing Hamiltonian sparsity to testing the sparsity of an associated Pauli channel. To be precise, given the time evolution channel â„‹t:Ïâ†’Uâ¢(t)â¢Ïâ¢Uâ€ â¢(t):subscriptâ„‹ğ‘¡â†’ğœŒğ‘ˆğ‘¡ğœŒsuperscriptğ‘ˆâ€ ğ‘¡\mathcal{H}_{t}:\rho\to U(t)\rho U^{\dagger}(t)caligraphic_H start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT : italic_Ï â†’ italic_U ( italic_t ) italic_Ï italic_U start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT ( italic_t ), we define its Pauli-twirled channel via â„‹tğ’¯â¢(Ï)=ğ”¼xâ¢[Ïƒxâ¢â„‹tâ¢(Ïƒxâ¢Ïâ¢Ïƒx)â¢Ïƒx],superscriptsubscriptâ„‹ğ‘¡ğ’¯ğœŒsubscriptğ”¼ğ‘¥delimited-[]subscriptğœğ‘¥subscriptâ„‹ğ‘¡subscriptğœğ‘¥ğœŒsubscriptğœğ‘¥subscriptğœğ‘¥\mathcal{H}_{t}^{\mathcal{T}}(\rho)=\mathbb{E}_{x}[\sigma_{x}\mathcal{H}_{t}(% \sigma_{x}\rho\sigma_{x})\sigma_{x}],caligraphic_H start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT start_POSTSUPERSCRIPT caligraphic_T end_POSTSUPERSCRIPT ( italic_Ï ) = blackboard_E start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT [ italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT caligraphic_H start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT italic_Ï italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT ) italic_Ïƒ start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT ] , and we prove that â„‹tsubscriptâ„‹ğ‘¡\mathcal{H}_{t}caligraphic_H start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT is sparse if and only if â„‹tğ’¯superscriptsubscriptâ„‹ğ‘¡ğ’¯\mathcal{H}_{t}^{\mathcal{T}}caligraphic_H start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT start_POSTSUPERSCRIPT caligraphic_T end_POSTSUPERSCRIPT is sparse. Our result is then as follows. See Theorem 5.7 for a formal statement. Result 1.8. There is an algorithm requiring no quantum memory that solves 1.2 for sğ‘ sitalic_s-sparse Hamiltonians by making polyâ¡(s/Îµ)polyğ‘ ğœ€\operatorname{poly}(s/\varepsilon)roman_poly ( italic_s / italic_Îµ ) queries to the evolution operator with polyâ¡(s/Îµ)polyğ‘ ğœ€\operatorname{poly}(s/\varepsilon)roman_poly ( italic_s / italic_Îµ ) total evolution time. Lower bounds. One drawback of our learning and testing algorithms is the exponent of the sparsity parameter sğ‘ sitalic_s, locality parameter kğ‘˜kitalic_k and the tolerance (Îµ2âˆ’Îµ1)subscriptğœ€2subscriptğœ€1(\varepsilon_{2}-\varepsilon_{1})( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ). Reducing to classical Boolean functions, we show lower bounds without memory that cerfity that the dependence on these parameters cannot be completely avoided, but an interesting and important future direction is to obtain the optimal results for these near-term relevant problems.444We remark that, Bakshi et al. [9] used highly non-trivial ideas to get Heisenberg scaling for their learning algorithm, and potentially similar ideas could be useful here. 1.4 Discussion and open questions Our work opens up several interesting directions which we state here and leave for future work. 1. Dependence on parameters Îµ1,Îµ2subscriptğœ€1subscriptğœ€2\varepsilon_{1},\varepsilon_{2}italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Our main objective in this work was to obtain query complexities for testing and learning with good dependence on the structural parameters. It is natural to ask if we could improve the dependence on the error parameters and perhaps achieve Heisenberg limited scaling as has been shown to be possible in some particular cases for Hamiltonian learning [38, 9]. 2. Robustness to SPAM noise. It would be desirable to make the protocols introduced in this work to be robust to SPAM noise. A potential approach is to adapt strategies in [26]. 3. Adaptivity. For learning structured Hamiltonians, adaptive strategies [29, 22] can improve query complexity by shedding constant factors over baseline learning algorithms, thereby improving performance in practice. Another direction is to then explore adaptive protocols for testing structured Hamiltonians and the performance gains they may bring. 4. Testing and learning with limited quantum memory. For estimating properties of quantum states, Chen et al. [14] showcased the utility of the resource of quantum memory or a kğ‘˜kitalic_k-qubit ancillary system (k<nğ‘˜ğ‘›k<nitalic_k < italic_n). Large separations in query complexity when learning with memory (even for kâ‰ªnmuch-less-thanğ‘˜ğ‘›k\ll nitalic_k â‰ª italic_n) and without memory have been reported for learning Pauli channels [20, 15] and shadow tomography [16]. We could thus imagine having access to only limited quantum memory during learning or testing structured Hamiltonians as well. However, it should be noted that given the separation between the query complexities (see Table 1) with access to nğ‘›nitalic_n-qubit quantum memory and without any, only marginal gains in complexity are expected from having access to limited quantum memory. 5. Testing and learning Hamiltonians from Gibbs states. Another natural learning model is that of having access to copies of the Gibbs state of a quantum Hamiltonian at a certain inverse temperature. There has been a suite of work investigating learning local Hamiltonians from Gibbs states [1, 8] but answering the question of testing structured Hamiltonians given access to copies of the Gibbs state remains wide open. Note added. After sharing Theorem 4.1 with Bluhm et al., they independently improved the analysis of their testing algorithm and showed that it only requires Oâ¢(1/(Îµ2âˆ’Îµ1)3â¢Îµ2)ğ‘‚1superscriptsubscriptğœ€2subscriptğœ€13subscriptğœ€2O(1/(\varepsilon_{2}-\varepsilon_{1})^{3}\varepsilon_{2})italic_O ( 1 / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) queries and Oâ¢(1/(Îµ2âˆ’Îµ1)2.5â¢Îµ20.5)ğ‘‚1superscriptsubscriptğœ€2subscriptğœ€12.5superscriptsubscriptğœ€20.5O(1/(\varepsilon_{2}-\varepsilon_{1})^{2.5}\varepsilon_{2}^{0.5})italic_O ( 1 / ( italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_Îµ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 2.5 end_POSTSUPERSCRIPT italic_Îµ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 0.5 end_POSTSUPERSCRIPT ) total evolution time, which is very similar to our Theorem 4.1 [6]. In addition, for a wide range of k=Oâ¢(n)ğ‘˜ğ‘‚ğ‘›k=O(n)italic_k = italic_O ( italic_n ), their algorithm does not require the use of auxiliary qubits. Acknowledgements. S.A. and A.D. thank the Institute for Pure and Applied Mathematics (IPAM) for its hospitality throughout the long program â€œMathematical and Computational Challenges in Quantum Computingâ€ in Fall 2023 during which part of this work was initiated. This work was done in part while S.A. was visiting the Simons Institute for the Theory of Computing, supported by DOE QSA grant #FP00010905. This research was supported by the Europea unionâ€™s Horizon 2020 research and innovation programme under the Marie SkÅ‚odowska-Curie grant agreement no. 945045, and by the NWO Gravitation project NETWORKS under grant no. 024.002.003. We thank Amira Abbas, Francesco Anna Mele, Andreas Bluhm, Jop BriÃ«t, Matthias Caro, Nunzia Cerrato, Aadil Oufkir, and Daniel Liang for useful comments and discussions. A.D. thanks Patrick Rall for multiple conversations on stabilizer subgroups and Pauli twirling. A.D. thanks Isaac Chuang for discussions on the problem of testing Hamiltonians. F.E.G. is funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germanyâ€™s Excellence Strategy â€“ EXC-2047/1 â€“ 390685813."
