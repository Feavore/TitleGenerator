URL,Title,Abstract,Introduction
https://arxiv.org/html/2411.03501v1,The Python LevelSet Toolbox (LevelSetPy),"This paper describes open-source scientific contributions in python surrounding the numerical solutions to hyperbolic Hamilton-Jacobi (HJ) partial differential equations viz., their implicit representation on co-dimension one surfaces; dynamics evolution with levelsets; spatial derivatives; total variation diminishing Runge-Kutta integration schemes; and their applications to the theory of reachable sets. They are increasingly finding applications in multiple research domains such as reinforcement learning, robotics, control engineering and automation. We describe the library components, illustrate usage with an example, and provide comparisons with existing implementations. This GPU-accelerated package allows for easy portability to many modern libraries for the numerical analyses of the HJ equations. We also provide a CPU implementation in python that is significantly faster than existing alternatives.","I Overview The reliability of the modern automation algorithms that we design has become paramount given the dangers that may evolve if nominally envisioned system performance falters. Even so, the need for scalable and faster numerical algorithms in software for verification and validation has become timely given the emergence of complexity of contemporary systems. The foremost open-source verification software for engineering applications based on Hamilton-Jacobi (HJ) equations [1, 2] and levelset methods [3, 4] is the CPU-based MATLABÂ®-implemented levelsets toolbox [5], developed before computing via graphical processing units (GPU) became pervasive. Since then, there has been significant improvements in computer hardware and architecture design, code parallelization algorithms, and compute-acceleration on modern GPUs. This paper describes a python-based GPU-accelerated scientific software package for numerically resolving generalized discontinuous solutions to Cauchy-type (or time-dependent) HJ hyperbolic partial differential equations (PDEs). HJ PDEs arise in many contexts including (multi-agent) reinforcement learning, robotics, control theory, differential games, flow, and transport phenomena. We focus on the numerical tools for safety assurance (ascertaining the freedom of a system from harm) in a verification sense in this paper. Accompanying the package are implicit calculus operations on dynamic codimension-one interfaces embedded within â„nsuperscriptâ„ğ‘›\mathbb{R}^{n}blackboard_R start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT surfaces, and spatial and temporal discretization schemes for HJ PDEs. Furthermore, we describe explicit integration schemes including the Lax-Friedrichs, Courant-Friedrichs-Lewy (CFL), and total variation diminishing Runge-Kutta (or TVD-RK) conditioning schemes for HJ Hamiltonians of the form ğ‘¯â¢(ğ’™,ğ’‘)ğ‘¯ğ’™ğ’‘\bm{H}(\bm{x},\bm{p})bold_italic_H ( bold_italic_x , bold_italic_p ), where ğ’™ğ’™\bm{x}bold_italic_x is the state and ğ’‘ğ’‘\bm{p}bold_italic_p is the co-state. Finally, extensions to reachability analyses for continuous and hybrid systems, formulated as optimal control or game theory problems using viscosity solutions to HJ PDEs are described. All data transfers to the GPU are based on CuPy [6] framework. In all, we closely follow the Python Enhancement Proposals (PEP) 8 style guide111Python PEP 8 style guide: peps.python.org/pep-0008/; however, in order not to break readability with respect to the original MATLABÂ®code, we err in consistency with the MATLABÂ®project layout. The Python package and installation instructions are available on the authorâ€™s github repository: levelsetpy. The CPU implementation (in Python) is on the cpu-numpy tree of the repository. Extensions to other python GPU programming language are straightforward (as detailed in the CuPy interoperability document). While our emphasis is on the resolution of safe sets in a reachability verification context, the applications of this package extend beyond control engineering."
https://arxiv.org/html/2411.00819v1,A Bellman-Ford algorithm for the path-length-weighted distance in graphs,"Consider a finite directed graph without cycles in which the arrows are weighted. We present an algorithm for the computation of a new distance, called path-length-weighted distance, which has proven useful for graph analysis in the context of fraud detection. The idea is that the new distance explicitly takes into account the size of the paths in the calculations. Thus, although our algorithm is based on arguments similar to those at work for the Bellman-Ford and Dijkstra methods, it is in fact essentially different. We lay out the appropriate framework for its computation, showing the constraints and requirements for its use, along with some illustrative examples.","Algorithms for calculating the (weighted) path-distance between vertices in a graph appeared in the middle of the 20th century, motivated by the growing interest of the time in the applications of mathematical analysis of graphs. The Bellman-Ford algorithm is the main reference of these early studies [2]. Dijkstraâ€™s algorithm for solving the same problem appeared at about the same time [11], and differs from the other, being more efficient depending on the particular problem. After these original works, the growing interest in the subject (due to the numerous applications that graph theory has found in many fields) has given rise to a great deal of research on graph analysis, which often includes the study of these structures when considered as metric spaces. The idea of considering a graph also as a metric space goes back to the beginnings of the theory of graphs. Metric notions begin to appear explicitly in mathematical works in the second half of the last century. The main metric that was considered (and in a sense the only one until the latter part of the century) was the so-called path distance ([12, 15, 18]): for undirected and connected graphs, this metric evaluated between two vertices (nodes) is defined as the length of the shortest path between them (see for example [4, Â§.2.2.2]). One of the first advances in the metric analysis of graphs was the introduction of weights in the definition of the path distance, assigning weights to the individual paths connecting two consecutive nodes and calculating the infimum of the sum of these weights. Some recent papers on the subject using weighted distances that have inspired this paper are [8, 14]. As in the case of other notions of fundamental graph theory, the relevant theoretical ideas appeared together with research topics from other scientific fields, such as sociology [1, 16, 22]. The definition of different metrics and algorithms to compute them increased greatly in the last decade of the last century, often proposed by problems from other disciplines such as chemistry or crystallography (see [18, 19] and references therein). In this sense, there is a particular case that deserves attention, that is the resistance distance [9, 23]. Coming from some ideas in theoretical chemistry [19] and social network analysis [22], this definition turned out to be a useful tool in the study of molecular configurations in chemistry, although it has also been used in network analysis and other fields [24, 5, 3]. In general, metrics could play a relevant role when studying properties such as robustness (see for example the survey [21]; see also [20]). The interested reader can find more information on applications of metric graphs in the books [6, 4, 13]. In the same direction, in this paper we provide an algorithm to compute a new distance that also appeared in an applied context, in connection with the automatic analysis of fraud in economic networks (see [7]). In this paper, we show that this metric allows to consider vertices that are far away when the distance is measured using the path-distance, becoming close with respect to this metric. It is especially useful in the economic analysis of fraud in networks of companies, since very often the strategy used to hide such fraud is to use the path-distance. Technically, it is defined as a weighted metric, but by dividing the sums of weights appearing in the infimum that provides the value of the metric by a new term that depends on the number of steps involved in the summation. We will show that this change in the weighting process forces to radically change the algorithm to calculate it, since in this new case, longer paths could give shorter distances. However, in the present work we consider the case of acyclic directed graphs, in order to avoid restrictions that make it impossible to define a weighted path metric, since continuous passage through a cycle could always give a null value to the metric (which would mean that it is not a metric). There are other ways to avoid this (see for example Proposition 4.1 in [7]), but in our case we decided to compute the distance between vertices by restricting the set of possible paths in the infimum that gives it. The way to do this is to avoid cycles, and to consider directed graphs. As a result, what we compute is not a metric on the whole graph, but only a distance between two vertices chosen in it. Let us give now some basic definitions about graphs and metric spaces. Let us explain some concepts related to the general definition of what a metric is, which will adapted later to the graph theoretic framework. Let â„+superscriptâ„\mathbb{R}^{+}blackboard_R start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT be the non-negative real numbers. An (extended) quasi-metric on a set Î©Î©\Omegaroman_Î© is a function d:Î©Ã—Î©â†’â„+âˆª{âˆ}:ğ‘‘â†’Î©Î©superscriptâ„d:\Omega\times\Omega\to\mathbb{R}^{+}\cup\{\infty\}italic_d : roman_Î© Ã— roman_Î© â†’ blackboard_R start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT âˆª { âˆ } such that for all a,b,câˆˆÎ©ğ‘ğ‘ğ‘Î©a,b,c\in\Omegaitalic_a , italic_b , italic_c âˆˆ roman_Î©, the axioms (1) dâ¢(a,b)=0=dâ¢(b,a)ğ‘‘ğ‘ğ‘0ğ‘‘ğ‘ğ‘d(a,b)=0=d(b,a)italic_d ( italic_a , italic_b ) = 0 = italic_d ( italic_b , italic_a ) if and only if a=b,ğ‘ğ‘a=b,italic_a = italic_b , and (2) dâ¢(a,b)â‰¤dâ¢(a,c)+dâ¢(c,b)ğ‘‘ğ‘ğ‘ğ‘‘ğ‘ğ‘ğ‘‘ğ‘ğ‘d(a,b)\leq d(a,c)+d(c,b)italic_d ( italic_a , italic_b ) â‰¤ italic_d ( italic_a , italic_c ) + italic_d ( italic_c , italic_b ) hold. The resulting quasi-metric structure (Î©,d)Î©ğ‘‘(\Omega,d)( roman_Î© , italic_d ) is called a quasi-metric space. For the specific framework of this paper, a useful summary of the notions of distance in graphs, with sufficient explanation and many examples, is given in Chapter 15 in [10]. In this paper we will deal with the so called path-length-weighted distance, that was introduced in [7, Â§.4]. It should be noted that the version defined there is given for non-directed graphs, and so the definition we will use is slightly different. However, we will define an extended quasi-metric also in this case by giving the value dâ¢(a,b)=âˆğ‘‘ğ‘ğ‘d(a,b)=\inftyitalic_d ( italic_a , italic_b ) = âˆ when there is no path for going from ağ‘aitalic_a to b,ğ‘b,italic_b , and considering only allowed paths between vertices. Since we are interested in how to compute the distance, and not in theoretical questions about its metric space structure, we will focus attention on the computational algorithm. All the notions on graph theory that are needed can be found in books on this subject, as for example [4]. We will introduce some of them in the next section."
