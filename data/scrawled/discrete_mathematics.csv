URL,Title,Abstract,Introduction
https://arxiv.org/html/2411.04479v1,On the number of partitions of the hypercube𝐙qnsuperscriptsubscript𝐙𝑞𝑛{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPTinto large subcubes,"We prove that the number of partitions of the hypercube 𝐙qnsuperscriptsubscript𝐙𝑞𝑛{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT into qmsuperscript𝑞𝑚q^{m}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT subcubes of dimension n−m𝑛𝑚n-mitalic_n - italic_m each for fixed q𝑞qitalic_q, m𝑚mitalic_m and growing n𝑛nitalic_n is asymptotically equal to n(qm−1)/(q−1)superscript𝑛superscript𝑞𝑚1𝑞1n^{(q^{m}-1)/(q-1)}italic_n start_POSTSUPERSCRIPT ( italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT - 1 ) / ( italic_q - 1 ) end_POSTSUPERSCRIPT.For the proof, we introduce the operation of the bang of a star matrix and demonstrate that any star matrix, except for a fractal, is expandable under some bang, whereas a fractal remains to be a fractal under any bang.","Let q,m,n𝑞𝑚𝑛q,m,nitalic_q , italic_m , italic_n be integers, q≥2𝑞2q\geq 2italic_q ≥ 2, n≥m≥0𝑛𝑚0n\geq m\geq 0italic_n ≥ italic_m ≥ 0. The (n−m𝑛𝑚n-mitalic_n - italic_m)-dimensional subcube in 𝐙qnsuperscriptsubscript𝐙𝑞𝑛{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is a subset of 𝐙qnsuperscriptsubscript𝐙𝑞𝑛{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT such that some m𝑚mitalic_m components are fixed, and each of the remaining n−m𝑛𝑚n-mitalic_n - italic_m components runs through all possible values from 𝐙qsubscript𝐙𝑞{\bf Z}_{q}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT. In partitioning into subcubes each vector of 𝐙qnsuperscriptsubscript𝐙𝑞𝑛{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT must fall into exactly one subcube. A partition into subcubes is called Agievich-primitive, or simply A-primitive222Agievich in [5] introduced the term ”primitive” for this concept (in more general case of partitioning into affine subspaces), but the use of this term is controversial, since it rather characterizes a certain non-degeneracy of the partition. In addition, such non-degeneracy of the partition can be defined in different ways, and the word ”primitive” is generally overloaded in mathematics. At the same time, giving another term also seems incorrect, therefore in [4] it was proposed to call such a partition Agievich-primitive or A-primitive. Note that in [2] the authors used the term ”tight” for the same concept, which also does not seem to us to be ”tight”., if each component is fixed in at least one of the subcubes of the partition. The most well-known problem is the partitioning problem into small-dimensional subcubes. Thus, if all subcubes of a partition of a Boolean cube have dimension 1111, then these subcubes are edges, and the partitions are called perfect matchings, and the problem of their number is well known. In [1], the problems of partitioning a Boolean cube into subcubes are considered, mainly of small dimensions, which can also be different within a single partition. Partitions into subcubes (not necessarily of the same dimension) with an additional irreducibility condition are studied in [2]. Partitions into one-dimensional subcubes in a not necessarily binary case are the subject of [3]. The main subject of study in [4] was partitions into affine subspaces, and for partitions into subcubes, which are a special case of partitions into affine subspaces, the following statements were proved, oriented towards partitions into subcubes of the same large dimension. Theorem 1. [4] Let q≥2𝑞2q\geq 2italic_q ≥ 2. For any natural m𝑚mitalic_m there exists the smallest natural N=Nqcoord⁢(m)𝑁subscriptsuperscript𝑁coord𝑞𝑚N=N^{\rm coord}_{q}(m)italic_N = italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) such that for n>N𝑛𝑁n>Nitalic_n > italic_N there are no A-primitive partitions of 𝐙qnsuperscriptsubscript𝐙𝑞𝑛{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT into qmsuperscript𝑞𝑚q^{m}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT subcubes of dimension n−m𝑛𝑚n-mitalic_n - italic_m. Theorem 2. [4] The following formula is valid cqcoord⁢(n,m)=∑h=mNqcoord⁢(m)(nh)⁢cqcoord⁣∗⁢(h,m),subscriptsuperscript𝑐coord𝑞𝑛𝑚superscriptsubscriptℎ𝑚subscriptsuperscript𝑁coord𝑞𝑚binomial𝑛ℎsubscriptsuperscript𝑐coord𝑞ℎ𝑚c^{\rm coord}_{q}(n,m)=\sum\limits_{h=m}^{N^{\rm coord}_{q}(m)}\binom{n}{h}c^{% \rm coord*}_{q}(h,m),italic_c start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_n , italic_m ) = ∑ start_POSTSUBSCRIPT italic_h = italic_m end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) end_POSTSUPERSCRIPT ( FRACOP start_ARG italic_n end_ARG start_ARG italic_h end_ARG ) italic_c start_POSTSUPERSCRIPT roman_coord ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_h , italic_m ) , (1) where cqcoord⁢(n,m)subscriptsuperscript𝑐coord𝑞𝑛𝑚c^{\rm coord}_{q}(n,m)italic_c start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_n , italic_m ) is the number of different unordered partitions of 𝐙qnsuperscriptsubscript𝐙𝑞𝑛{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT into qmsuperscript𝑞𝑚q^{m}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT subcubes of dimension n−m𝑛𝑚n-mitalic_n - italic_m; cqcoord⁣∗⁢(n,m)subscriptsuperscript𝑐coord𝑞𝑛𝑚c^{\rm coord*}_{q}(n,m)italic_c start_POSTSUPERSCRIPT roman_coord ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_n , italic_m ) is the number of different unordered A-primitive partitions of 𝐙qnsuperscriptsubscript𝐙𝑞𝑛{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT into qmsuperscript𝑞𝑚q^{m}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT subcubes of dimension n−m𝑛𝑚n-mitalic_n - italic_m; (nh)binomial𝑛ℎ\binom{n}{h}( FRACOP start_ARG italic_n end_ARG start_ARG italic_h end_ARG ) is the usual binomial coefficient. Theorem 3. [4] Let q𝑞qitalic_q and m𝑚mitalic_m be fixed, n→∞→𝑛n\to\inftyitalic_n → ∞. Then the following asymptotics holds cqcoord⁢(n,m)∼C′⁢nNqcoord⁢(m),similar-tosubscriptsuperscript𝑐coord𝑞𝑛𝑚superscript𝐶′superscript𝑛subscriptsuperscript𝑁coord𝑞𝑚c^{\rm coord}_{q}(n,m)\sim C^{\prime}n^{N^{\rm coord}_{q}(m)},italic_c start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_n , italic_m ) ∼ italic_C start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) end_POSTSUPERSCRIPT , where C′=cqcoord⁣∗⁢(Nqcoord⁢(m),m)Nqcoord⁢(m)!superscript𝐶′subscriptsuperscript𝑐coord𝑞subscriptsuperscript𝑁coord𝑞𝑚𝑚subscriptsuperscript𝑁coord𝑞𝑚C^{\prime}=\frac{c^{\rm coord*}_{q}(N^{\rm coord}_{q}(m),m)}{N^{\rm coord}_{q}% (m)!}italic_C start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT = divide start_ARG italic_c start_POSTSUPERSCRIPT roman_coord ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) , italic_m ) end_ARG start_ARG italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) ! end_ARG."
https://arxiv.org/html/2411.04204v1,Online Budgeted Matching with General Bids,"Online Budgeted Matching (OBM) is a classic problem with important applications in online advertising, online service matching, revenue management, and beyond. Traditional online algorithms typically assume a small bid setting, where the maximum bid-to-budget ratio (κ𝜅\kappaitalic_κ) is infinitesimally small. While recent algorithms have tried to address scenarios with non-small or general bids, they often rely on the Fractional Last Matching (FLM) assumption, which allows for accepting partial bids when the remaining budget is insufficient. This assumption, however, does not hold for many applications with indivisible bids. In this paper, we remove the FLM assumption and tackle the open problem of OBM with general bids. We first establish an upper bound of 1−κ1𝜅1-\kappa1 - italic_κ on the competitive ratio for any deterministic online algorithm. We then propose a novel meta algorithm, called MetaAd, which reduces to different algorithms with first known provable competitive ratios parameterized by the maximum bid-to-budget ratio κ∈[0,1]𝜅01\kappa\in[0,1]italic_κ ∈ [ 0 , 1 ]. As a by-product, we extend MetaAd to the FLM setting and get provable competitive algorithms. Finally, we apply our competitive analysis to the design learning-augmented algorithms.","Online Budgeted Matching (OBM) with general bids is a fundamental online optimization problem that generalizes to many important settings, such as online bipartite matching and Adwords with equal bids [23]. It has applications in various domains, including online advertising, online resource allocation, and revenue management among others [5, 16, 32]. OBM is defined on a bipartite graph with a set of offline nodes (bidders) and a set of online nodes (queries). The task is to select an available offline node to match with an online query in each round. When an offline node is matched to an online node, a bid value is subtracted from the budget of the offline node, and a reward equal to the consumed budget is obtained. If the remaining budget of an offline node is less than the bid value of an online query, the offline node cannot be matched to the online query. The goal is to maximize the total reward throughout the entire online matching process. OBM is challenging due to the nature of online discrete decisions. Previous works have studied this problem under one of the following two additional assumptions on bids or matching rules: • Small bids. The small-bid assumption is a special case of general bids corresponding to the maximum bid-budget ratio κ→0→𝜅0\kappa\to 0italic_κ → 0. That is, while the bid values can vary arbitrarily, the size of each individual bid is infinitely small compared to each offline node’s budget, and there is always enough budget for matching. Under this assumption, the first online algorithm was provided by [24], achieving an optimal competitive ratio of 1−1/e11𝑒1-1/e1 - 1 / italic_e [23]. This competitive ratio has also been attained by subsequent algorithms based on primal-dual techniques [4, 7]. However, the small-bid assumption significantly limits these algorithms for broader applications in practice. Take the application of matching Virtual Machines (VMs) to physical servers as an example. An online VM request typically takes up a non-negligible fraction of the total computing units in a server. • Fractional last match (FLM). Under FLM, if an offline node has an insufficient budget for an online query, the offline node can still be matched to the query, obtaining a partial reward equal to the remaining budget. Given the limitations of small bids, some recent studies [15, 29, 30] have studied competitive algorithms for OBM with general bids by making the additional assumption of FLM. For example, under FLM, the greedy algorithm (Greedy) achieves a competitive ratio of 1/2121/21 / 2, while other studies [4, 15, 29, 30] aim to achieve a competitive ratio greater than 1/2121/21 / 2 under various settings and/or using randomized algorithms. Although FLM allows fractional matching of a query to an offline node with insufficient budgets, it essentially assumes that any bids are potentially divisible. This assumption may not hold in many real applications, e.g., allocating fractional physical resources to a VM can result in significant performance issues that render the allocation unacceptable, and charging a fractional advertising fee may not be allowed in online advertising. Despite its practical relevance and theoretical importance, OBM with general bids has remained a challenging open problem in the absence of the small-bid and FLM assumptions. Specifically, an offline node may have insufficient budget and cannot be matched to a later query with a large value, potentially causing large sub-optimality in the worst case. This issue does not apply to small bids, as the small-bid setting implies that insufficient budgets will never occur. Additionally, this challenge is alleviated in the FLM setting, where fractional matching in cases of insufficient budgets can reduce sub-optimality. Indeed, removing the small-bid and FLM assumptions fundamentally changes and add significant challenges to the problem of OBM [30]. To further highlight the intrinsic difficulty of OBM with general bids, we formally prove in Proposition 4.1 an upper bound of the competitive ratio, i.e., 1−κ1𝜅1-\kappa1 - italic_κ, achieved by any deterministic online algorithm, where κ∈[0,1]𝜅01\kappa\in[0,1]italic_κ ∈ [ 0 , 1 ] is the maximum bid-budget ratio. Contributions: In this paper, we address OBM without the small-bid or FLM assumptions and design a meta algorithm called MetaAd, which adapts to different algorithms with provable competitive ratios. To our knowledge, MetaAd is the first provable competitive algorithm for general bids without the FLM assumption. Specifically, MetaAd generates a discounted score for each offline node by a general discounting function, which is then used to select the offline node. The discounting function evaluates the degree of budget insufficiency given a bid-budget ratio κ∈[0,1]𝜅01\kappa\in[0,1]italic_κ ∈ [ 0 , 1 ], addressing the challenge of infeasible matching due to insufficient budgets. Given different discounting functions, MetaAd yields concrete algorithms, and their competitive ratios are derived from Theorem 4.2, established through a novel proof technique. We show that with small bids (i.e., κ→0→𝜅0\kappa\rightarrow 0italic_κ → 0), MetaAd recovers the optimal competitive ratio of 1−1e11𝑒1-\frac{1}{e}1 - divide start_ARG 1 end_ARG start_ARG italic_e end_ARG. Furthermore, we show that MetaAd, with discounting functions from the exponential and polynomial function classes, achieves a positive competitive ratio for κ∈[0,1)𝜅01\kappa\in[0,1)italic_κ ∈ [ 0 , 1 ). As an extension, we adapt the design of MetaAd to the FLM setting, resulting in a meta-algorithm with provable competitive ratios for κ∈[0,1]𝜅01\kappa\in[0,1]italic_κ ∈ [ 0 , 1 ] (Theorem 4.3). The framework of MetaAd potentially opens an interesting direction for exploring concrete discounting function designs that yield high competitive ratios for settings both with and without FLM. Finally, we apply our competitive analysis to the design of LOBM, a learning-augmented algorithm for OBM, which enhances average performance while still guaranteeing a competitive ratio (Theorem 5.1). We validate the empirical benefits of MetaAd and LOBM through numerical experiments on the applications of an online movie matching an VM placement on physical servers."
https://arxiv.org/html/2411.03776v1,"Reconstruction of multiple strings of constant weight from prefix-suffix compositions††thanks:This paper was presented in part at the 2024 IEEE International Symposium on Information Theory (ISIT 2024)[1].
Y. Yang was with the School of Data Science, The Chinese University of Hong Kong, Shenzhen, China. (Email: yaoyuyang@link.cuhk.edu.cn) Z. Chen is with School of Science and Engineering, Future Networks of Intelligence Institute, The Chinese University of Hong Kong, Shenzhen, China. (Email: chenztan@cuhk.edu.cn)
This research was supported in part by the Basic Research Project of Hetao Shenzhen-Hong Kong Science and Technology Cooperation Zone under Project HZQB-KCZYZ-2021067,
the Guangdong Provincial Key Laboratory of Future Network of Intelligence under Project 2022B1212010001,
the National Natural Science Foundation of China under grants 62201487,
and the Shenzhen Science and Technology Stable Support Program.","Motivated by studies of data retrieval in polymer-based storage systems, we consider the problem of reconstructing a multiset of binary strings that have the same length and the same weight from the compositions of their prefixes and suffixes of every possible length. We provide necessary and sufficient conditions for which unique reconstruction up to reversal of the strings is possible. Additionally, we present two algorithms for reconstructing strings from the compositions of prefixes and suffixes of constant-length constant-weight strings.","The growing demand for archival data storage calls for innovative solutions to store information beyond traditional methods that rely on magnetic tapes or hard disk drives. Recent advancement in macromolecule synthesis and sequencing suggests that polymers such as DNA are promising media for future archival data storage, largely attributed to their high storage density and durability. Data retrieval in polymer-based storage systems depends on macromolecule sequencing technologies [2, 3] to read out the information stored in polymers. However, common sequencing technologies often only read random fragments of polymers. Thus, the task of data retrieval in these systems has to be based on the information provided by the fragments. Under proper assumptions, one may represent polymers by binary strings and turn the problem of data retrieval into the problem of string reconstruction from substring compositions, i.e., from the number of zeros and the number of ones in substrings of every possible length. In [4], the authors characterized the length for which strings can be uniquely reconstructed from their substring compositions up to reversal. Extending the work of [4], the authors of [5] and [6] studied the problem of string reconstruction from erroneous substring compositions. Specifically, [5] designed coding schemes capable of reconstructing strings in the presence of substitution errors and [6] further proposed codes that can deal with insertion and deletion errors. Observing that it may not be realistic to assume the compositions of all substrings are available, the authors of [7] initiated the study of string reconstruction based on the compositions of prefixes and suffixes of all possible lengths. In fact, [7] considered the more general problem of reconstructing multiple distinct strings of the same length simultaneously from the compositions of their prefixes and suffixes. The main result of [7] reveals that for reconstruction of no more than hℎhitalic_h distinct strings of the same length, there exists a code with rate approaching 1/h1ℎ1/h1 / italic_h asymptotically. Following [7], the authors of [8] studied in depth the problem of reconstructing a single string from the compositions of its prefixes and suffixes. In particular, their work completely characterized the strings that can be reconstructed from its prefixes and suffixes compositions uniquely up to reversal. Efficiency of data retrieval is a major concern for practical polymer-based storage systems, and thus low complexity algorithms for string reconstruction are of great interest. In the case of reconstruction from error-free substring compositions, [4] described a backtracking algorithm for binary strings of length n𝑛nitalic_n with worst-case time complexity exponential in n𝑛\sqrt{n}square-root start_ARG italic_n end_ARG. Moreover, [5] and [9] constructed sets of binary strings that can be uniquely reconstructed with time complexity polynomial in n𝑛nitalic_n. In the case of reconstruction from error-free compositions of prefixes and suffixes, [7] and [8] presented sets of binary strings that can be efficiently reconstructed. For reconstruction in the presence of substitution composition errors, [5] showed that when the number of errors is a constant independent of n𝑛nitalic_n, there exist coding schemes with decoding complexity polynomial in n𝑛nitalic_n. We note that string reconstruction is classic problem [10, 11, 12] and has been studied under various settings, including reconstruction from substrings [10, 13, 14] and from subsequences [11, 12, 15, 16, 17, 18] under either combinatorial or probabilistic assumptions. In this paper, we consider the problem of reconstructing hℎhitalic_h strings that are not necessarily distinct but have the same length n≥1𝑛1n\geq 1italic_n ≥ 1 and weight w¯≤n¯𝑤𝑛\bar{w}\leq nover¯ start_ARG italic_w end_ARG ≤ italic_n from their error-free compositions of prefixes and suffixes of all possible lengths. The problem of reconstructing multiple strings from prefix-suffix compositions becomes more amenable to analysis if the strings are of constant weight. This is because nice properties due to symmetry can be tethered to the prefix-suffix compositions. Our first result is a characterization of the properties of constant-weight strings that enable unique reconstruction up to reversal. Additionally, we present two algorithms that reconstruct constant-weight strings from prefix-suffix compositions. Given prefix-suffix compositions as input, one of the algorithms can efficiently output a multiset of strings whose prefix-suffix compositions are the same as the input, and the other is able to output all multisets of strings up to reversal that are allowed by the input. Our analysis relies on the running weight information of the strings that can be extracted from the prefix-suffix compositions and the inherent symmetry of constant-weight strings and their reversals. The rest of this paper is organized as follows. In Section II, we present the problem statement and introduce necessary notation and preliminaries that are helpful for later sections. In particular, we introduce the notion of cumulative weight functions that capture the running weight information of a multiset of strings, which is used throughout the paper. In Section III, we derive the necessary and sufficient conditions for unique reconstruction. Section IV is devoted to the reconstruction algorithms. We conclude this paper and mention a few open problems in Section V."
https://arxiv.org/html/2411.03407v1,Chorded Cycle Facets ofClique Partitioning Polytopes,"The q𝑞qitalic_q-chorded k𝑘kitalic_k-cycle inequalities are a class of valid inequalities for the clique partitioning polytope. It is known that for q=2𝑞2q=2italic_q = 2 or q=k−12𝑞𝑘12q=\tfrac{k-1}{2}italic_q = divide start_ARG italic_k - 1 end_ARG start_ARG 2 end_ARG, these inequalities induce facets of the clique partitioning polytope if and only if k𝑘kitalic_k is odd. We solve the open problem of characterizing such facets for arbitrary k𝑘kitalic_k and q𝑞qitalic_q. More specifically, we prove that the q𝑞qitalic_q-chorded k𝑘kitalic_k-cycle inequalities induce facets of the clique partitioning polytope if and only if two conditions are satisfied: k=1𝑘1k=1italic_k = 1 mod q𝑞qitalic_q, and if k=3⁢q+1𝑘3𝑞1k=3q+1italic_k = 3 italic_q + 1 then q=3𝑞3q=3italic_q = 3 or q𝑞qitalic_q is even. This establishes the existence of many facets induced by q𝑞qitalic_q-chorded k𝑘kitalic_k-cycle inequalities beyond those previously known.","Given a complete graph with edge values that can be both positive and negative real numbers, the clique partitioning problem consists in finding a partition of the graph into disjoint cliques that maximizes the value of the edges within the cliques. This problem has a wide range of applications, including the aggregation of binary relations [12], community detection in social networks [5], and group technology [16]. Its feasible solutions are encoded by binary vectors with one entry for each edge of the graph, where an entry is 1 if and only if the associated edge is contained in a clique. The convex hull of these vectors is called the clique partitioning polytope [14]. While a complete outer description of this polytope in terms of its facets is not known, many classes of valid and facet-inducing inequalities have been discovered and are described in the literature. One such class of valid inequalities is that of the 2222-chorded k𝑘kitalic_k-cycle inequalities introduced in [14] and shown to induce a facet if and only if the cycle has odd length k𝑘kitalic_k. This class is generalized in [15] to the q𝑞qitalic_q-chorded k𝑘kitalic_k-cycle inequalities, where q𝑞qitalic_q is any integer between 2222 and k2𝑘2\tfrac{k}{2}divide start_ARG italic_k end_ARG start_ARG 2 end_ARG. These inequalities are valid for the clique partitioning problem [15], but no claims have been made about facets induced by these inequalities. Recently, it was shown that for the special case of q=k−12𝑞𝑘12q=\tfrac{k-1}{2}italic_q = divide start_ARG italic_k - 1 end_ARG start_ARG 2 end_ARG, the q𝑞qitalic_q-chorded k𝑘kitalic_k-cycle inequalities induce facets of the clique partitioning polytope [1]. In this article, we establish for arbitrary k𝑘kitalic_k and q𝑞qitalic_q the exact condition under which the q𝑞qitalic_q-chorded k𝑘kitalic_k-cycle inequalities induce facets of the clique partitioning polytope (Theorem 2). For the special cases of q=2𝑞2q=2italic_q = 2 and q=k−12𝑞𝑘12q=\tfrac{k-1}{2}italic_q = divide start_ARG italic_k - 1 end_ARG start_ARG 2 end_ARG, this condition specializes to the properties previously known. In its general form, our result implies the existence of many facets induced by q𝑞qitalic_q-chorded k𝑘kitalic_k-cycle inequalities for 2<q<k−122𝑞𝑘122<q<\tfrac{k-1}{2}2 < italic_q < divide start_ARG italic_k - 1 end_ARG start_ARG 2 end_ARG previously unknown."
https://arxiv.org/html/2411.03813v1,On the satisfiability of random3333-SAT formulaswithk𝑘kitalic_k-wise independent clauses,"The problem of identifying the satisfiability threshold of random 3333-SAT formulas has received a lot of attention during the last decades and has inspired the study of other threshold phenomena in random combinatorial structures. The classical assumption in this line of research is that, for a given set of n𝑛nitalic_n Boolean variables, each clause is drawn uniformly at random among all sets of three literals from these variables, independently from other clauses. Here, we keep the uniform distribution of each clause, but deviate significantly from the independence assumption and consider richer families of probability distributions. For integer parameters n𝑛nitalic_n, m𝑚mitalic_m, and k𝑘kitalic_k, we denote by ℱk⁢(n,m)subscriptℱ𝑘𝑛𝑚\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) the family of probability distributions that produce formulas with m𝑚mitalic_m clauses, each selected uniformly at random from all sets of three literals from the n𝑛nitalic_n variables, so that the clauses are k𝑘kitalic_k-wise independent. Our aim is to make general statements about the satisfiability or unsatisfiability of formulas produced by distributions in ℱk⁢(n,m)subscriptℱ𝑘𝑛𝑚\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) for different values of the parameters n𝑛nitalic_n, m𝑚mitalic_m, and k𝑘kitalic_k.Our technical results are as follows: First, all probability distributions in ℱ2⁢(n,m)subscriptℱ2𝑛𝑚\mathcal{F}_{2}(n,m)caligraphic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_n , italic_m ) with m∈Ω⁢(n3)𝑚Ωsuperscript𝑛3m\in\Omega(n^{3})italic_m ∈ roman_Ω ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) return unsatisfiable formulas with high probability. This result is tight. We show that there exists a probability distribution 𝒟∈ℱ3⁢(n,m)𝒟subscriptℱ3𝑛𝑚\mathcal{D}\in\mathcal{F}_{3}(n,m)caligraphic_D ∈ caligraphic_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n , italic_m ) with m∈O⁢(n3)𝑚𝑂superscript𝑛3m\in O(n^{3})italic_m ∈ italic_O ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) so that a random formula drawn from 𝒟𝒟\mathcal{D}caligraphic_D is almost always satisfiable. In contrast, for m=Ω⁢(n2)𝑚Ωsuperscript𝑛2m=\Omega(n^{2})italic_m = roman_Ω ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ), any probability distribution 𝒟∈ℱ4⁢(n,m)𝒟subscriptℱ4𝑛𝑚\mathcal{D}\in\mathcal{F}_{4}(n,m)caligraphic_D ∈ caligraphic_F start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n , italic_m ) returns an unsatisfiable formula with high probability. This is our most surprising and technically involved result. Finally, for any integer k≥2𝑘2k\geq 2italic_k ≥ 2, any probability distribution 𝒟∈ℱk⁢(n,m)𝒟subscriptℱ𝑘𝑛𝑚\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D ∈ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) with m=O⁢(n1−1/k)𝑚𝑂superscript𝑛11𝑘m=O(n^{1-1/k})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) returns a satisfiable formula with high probability.","Satisfiability of propositional formulas (SAT) is one of the most renowned problems in theoretical computer science. It appeared in the first lists of NP-complete problems independently proposed by Cook and Levin, and is pivotal for many developments in modern complexity theory. Today, many lower bounds on the running time of algorithms rely on the Exponential Time Hypothesis for solving SAT [11, 18, 36, 37]. On the practical side, SAT solvers are frequently deployed in hardware circuit design, model checking, program verification, automated planning and scheduling, as well as in solving real-life instantiations of combinatorial optimization problems such as FCC spectrum auctions. Modern SAT solvers often find solutions to large industrial instances with thousands or even millions of variables despite the NP-hardness of the problem. However, there is still a large discrepancy between the performance of SAT solvers on those instances and theoretical average-case predictions, which have been studied in great depth under the line of research on random SAT. Random SAT. A j𝑗jitalic_j-CNF formula ϕitalic-ϕ\phiitalic_ϕ over n𝑛nitalic_n variables is composed of m𝑚mitalic_m OR-clauses, each containing exactly j𝑗jitalic_j literals of j𝑗jitalic_j different variables. In the most commonly studied random SAT model, a formula ϕitalic-ϕ\phiitalic_ϕ is generated uniformly at random from all possible j𝑗jitalic_j-CNF formulas over n𝑛nitalic_n variables and m𝑚mitalic_m clauses. The most prominent theoretical question related to random SAT is to identify the satisfiability threshold rjsubscript𝑟𝑗r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT such that limn→∞𝐏𝐫⁡[ϕ⁢ is satisfiable]subscript→𝑛𝐏𝐫italic-ϕ is satisfiable\lim_{n\to\infty}\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is % satisfiable}\right]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}% ]}{[\phi\text{ is satisfiable}]}roman_lim start_POSTSUBSCRIPT italic_n → ∞ end_POSTSUBSCRIPT bold_Pr [ italic_ϕ is satisfiable ] is equal to 00 when m/n>rj𝑚𝑛subscript𝑟𝑗m/n>r_{j}italic_m / italic_n > italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT, and equal to 1111 when m/n<rj𝑚𝑛subscript𝑟𝑗m/n<r_{j}italic_m / italic_n < italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT. It has been established [15] that 2222-SAT has r2=1subscript𝑟21r_{2}=1italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = 1, and its phase transition window [10] is m∈[n−Θ⁢(n1/3),n+Θ⁢(n1/3)]𝑚𝑛Θsuperscript𝑛13𝑛Θsuperscript𝑛13m\in[n-\Theta(n^{1/3}),n+\Theta(n^{1/3})]italic_m ∈ [ italic_n - roman_Θ ( italic_n start_POSTSUPERSCRIPT 1 / 3 end_POSTSUPERSCRIPT ) , italic_n + roman_Θ ( italic_n start_POSTSUPERSCRIPT 1 / 3 end_POSTSUPERSCRIPT ) ]. For j≥3𝑗3j\geq 3italic_j ≥ 3, the asymptotic j𝑗jitalic_j-SAT threshold was shown to be 2j⁢log⁡2−12⁢(1+log⁡2)±oj⁢(1)plus-or-minussuperscript2𝑗21212subscript𝑜𝑗12^{j}\log 2-\frac{1}{2}(1+\log 2)\pm o_{j}(1)2 start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT roman_log 2 - divide start_ARG 1 end_ARG start_ARG 2 end_ARG ( 1 + roman_log 2 ) ± italic_o start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( 1 ) as j→∞→𝑗j\to\inftyitalic_j → ∞ [17] (improving previous results from [3]), while for large enough j𝑗jitalic_j the exact value of rjsubscript𝑟𝑗r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT was determined in [20]. However, the question of identifying rjsubscript𝑟𝑗r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT for small values of j𝑗jitalic_j remains open. In particular, random 3333-SAT has attracted a lot of attention. For the lower bound part, it has been shown in a series of papers [15, 12, 32, 1, 35, 39] that r3≥3.52subscript𝑟33.52r_{3}\geq 3.52italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ≥ 3.52 (the currently best known bound is due to [35, 39]). The upper bound part is studied by [27, 38, 21, 19]; the currently best known bound is r3<4.49subscript𝑟34.49r_{3}<4.49italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT < 4.49 due to [19]. The estimate r3≈4.26subscript𝑟34.26r_{3}\approx 4.26italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ≈ 4.26 was derived from numerical experiments [40] (see also [14, 41]). A more recent line of work [29, 30, 31, 42] extends the standard model of random j𝑗jitalic_j-SAT to non-uniform distributions. Their motivation comes from the empirical observation that, in practice, CNF formulas often have rather different frequencies/probabilities for the n𝑛nitalic_n variables to appear in each clause (following a power-law distribution instead of a uniform one). Namely, Friedrich and Rothenberger [31] proposed a non-uniform random model, where the literals {xi,xi¯}i∈[n]subscriptsubscript𝑥𝑖¯subscript𝑥𝑖𝑖delimited-[]𝑛\{x_{i},\overline{x_{i}}\}_{i\in[n]}{ italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , over¯ start_ARG italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG } start_POSTSUBSCRIPT italic_i ∈ [ italic_n ] end_POSTSUBSCRIPT are selected independently at random in each clause c𝑐citalic_c of the random j𝑗jitalic_j-CNF with 𝐏𝐫⁡[xi∈c]=𝐏𝐫⁡[xi¯∈c]=pi𝐏𝐫subscript𝑥𝑖𝑐𝐏𝐫¯subscript𝑥𝑖𝑐subscript𝑝𝑖\operatorname{\mathbf{Pr}}\mathchoice{\left[x_{i}\in c\right]}{[x_{i}\in c]}{[% x_{i}\in c]}{[x_{i}\in c]}=\operatorname{\mathbf{Pr}}\mathchoice{\left[% \overline{x_{i}}\in c\right]}{[\overline{x_{i}}\in c]}{[\overline{x_{i}}\in c]% }{[\overline{x_{i}}\in c]}=p_{i}bold_Pr [ italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ∈ italic_c ] = bold_Pr [ over¯ start_ARG italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG ∈ italic_c ] = italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and where probabilities 𝐩=(pi)i∈[n]𝐩subscriptsubscript𝑝𝑖𝑖delimited-[]𝑛\mathbf{p}=(p_{i})_{i\in[n]}bold_p = ( italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_i ∈ [ italic_n ] end_POSTSUBSCRIPT may vary across different variables. They find satisfiability threshold r2⁢(𝐩)subscript𝑟2𝐩r_{2}(\mathbf{p})italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( bold_p ) of non-uniform random 2222-SAT for certain regimes depending on 𝐩𝐩\mathbf{p}bold_p. However, the non-uniform model of [31] does not capture the community biases/correlations (i.e., the fact that certain variables are more likely to appear together in a clause), which are often observed in practice [6]. This leads us to the question of whether it is possible to relax the strong independence assumption in the existing random SAT literature. Relaxation of independence. We first observe that it does not make much sense to study distributions of SAT formulas with arbitrary correlations over the clauses. Indeed, by allowing correlation between several clauses, one may enforce that the random formula ϕitalic-ϕ\phiitalic_ϕ contains large fixed sub-formulas corresponding to NP-hard SAT variants. This would be at odds with our goal of studying average-case complexity. Therefore, we must keep a certain degree of independence in the distribution of instances. We propose to consider the relaxation of mutual independence over m𝑚mitalic_m clauses in a random formula ϕitalic-ϕ\phiitalic_ϕ to k𝑘kitalic_k-wise independence for a small constant k𝑘kitalic_k. To keep the new model tractable, we focus on 3333-SAT and uniform distribution of literals within each clause. I.e., we assume that (i) every 3333-OR-clause c𝑐citalic_c of a random 3333-CNF formula ϕitalic-ϕ\phiitalic_ϕ has three literals of three distinct variables drawn uniformly at random among all such triplets of literals and that (ii) given this marginal distribution of each clause c∼Funi.similar-to𝑐subscript𝐹uni.c\sim F_{\text{uni.}}italic_c ∼ italic_F start_POSTSUBSCRIPT uni. end_POSTSUBSCRIPT, the distribution 𝒟𝒟\mathcal{D}caligraphic_D over the clause set C𝐶Citalic_C in ϕitalic-ϕ\phiitalic_ϕ is only k𝑘kitalic_k-wise independent instead of the mutually independent distribution 𝒟Ind.=(Funi.)⊗msubscript𝒟Ind.superscriptsubscript𝐹uni.tensor-productabsent𝑚\mathcal{D}_{\text{Ind.}}=\left(F_{\text{uni.}}\right)^{\otimes m}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT = ( italic_F start_POSTSUBSCRIPT uni. end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT ⊗ italic_m end_POSTSUPERSCRIPT in the standard model. This is a natural generalization that has been considered in a number of different settings but, to the best of our knowledge, not in the context of random SAT. Note that the smaller k𝑘kitalic_k is, the bigger the set of possible distributions 𝒟𝒟\mathcal{D}caligraphic_D. Furthermore, for small values of k𝑘kitalic_k, a k𝑘kitalic_k-wise independent distribution 𝒟𝒟\mathcal{D}caligraphic_D can still capture a large class of dependencies among clauses but at the same time does not allow correlation between any k𝑘kitalic_k-tuples of clauses. In mathematical terms, the family of discrete k𝑘kitalic_k-wise independent distributions naturally appears when we map the set of distributions to the set of their low-degree moments. Specifically, if a distribution 𝒟𝒟\mathcal{D}caligraphic_D is supported on the n𝑛nitalic_n-dimensional binary cube111Similar moment functions can be defined for any distribution with discrete marginals. supp⁢(D)={−1,1}nsupp𝐷superscript11𝑛\texttt{supp}(D)=\{-1,1\}^{n}supp ( italic_D ) = { - 1 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, then all its moments of degree up to k𝑘kitalic_k can be described as μ⁢(D)=(𝐄⁡[∏i∈Sxi])|S|≤k𝜇𝐷subscript𝐄subscriptproduct𝑖𝑆subscript𝑥𝑖𝑆𝑘\mu(D)=(\operatorname{\mathbf{E}}\mathchoice{\left[\prod_{i\in S}x_{i}\right]}% {[\prod_{i\in S}x_{i}]}{[\prod_{i\in S}x_{i}]}{[\prod_{i\in S}x_{i}]})_{|S|% \leq k}italic_μ ( italic_D ) = ( bold_E [ ∏ start_POSTSUBSCRIPT italic_i ∈ italic_S end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ] ) start_POSTSUBSCRIPT | italic_S | ≤ italic_k end_POSTSUBSCRIPT. As low-degree moments (basically, the image of μ𝜇\muitalic_μ) are extremely important in statistical analysis, it is equally important to study the kernel of the aforementioned mapping, which exactly corresponds to the family of k𝑘kitalic_k-wise independent distributions. Let us provide additional justifications of our framework by discussing some of the theoretical work on random 3333SAT and on other settings with similar k𝑘kitalic_k-wise independence relaxation. Pseudo-randomness. Historically, the k𝑘kitalic_k-wise relaxation of independence has been actively used in the literature on derandomization and pseudo-randomness, as it allows to significantly reduce the amount of random bits needed to generate random objects. For example, Alon and Nussboim [5] consider random Erdős-Rényi graphs and examine the minimal degree k𝑘kitalic_k of independence needed to achieve a variety of graph properties and statistics (such as connectivity, existence of perfect matchings, existence of Hamiltonian cycles, clique and chromatic numbers, etc.) that match those in the mutually independent case. Benjamini et al. [9] consider similar questions for monotone boolean functions. The motivation in [5] comes from the fact that there are efficient constructions of k𝑘kitalic_k-wise independent distributions with “low degree of independence” (say k=O⁢(log⁡n)𝑘𝑂𝑛k=O(\log n)italic_k = italic_O ( roman_log italic_n )) that utilize only polylog⁢(n)polylog𝑛\text{polylog}(n)polylog ( italic_n ) random bits, i.e., much fewer than the polynomial number of random bits required to generate mutually independent distributions. While some of this motivation can be applied to our setting of random 3333-SAT, it is a conceptually different story. Indeed, the perspective of pseudo-random generation is through the lenses of “probability theory”, where one controls the distributions and can simply choose one that satisfies necessary conditions such as, e.g., (log⁡n)𝑛(\log n)( roman_log italic_n )-wise independence. On the other hand, our motivation stems from “statistics”, as our ideal model should have a reasonable fit to empirical observations. So, we would like to use as minimal assumptions as possible and study small (constant) degrees of independence. Refutability of 3333-SAT. While the research on lower bounds for random 3333-SAT often comes up with certain simple heuristics that efficiently find a satisfying assignment (see, e.g., the surveys by Achlioptas [2] and Flaxman [26]), it is extremely hard to find an efficient refutation of a unsatisfiable 3333-SAT formula. Indeed, the common approach to refute a given SAT formula is proof in resolution. Chvatal and Szemeredi [16] first showed that a random 3333-CNF formula with m=Θ⁢(n)𝑚Θ𝑛m=\Theta(n)italic_m = roman_Θ ( italic_n ) clauses (which is almost surely unsatisfiable) almost surely admits only exponential size proof in resolution. Later, Ben-Sasson and Wigderson [8] derived similar result for much larger m=O⁢(n3/2−ε)𝑚𝑂superscript𝑛32𝜀m=O(n^{3/2-\varepsilon})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 - italic_ε end_POSTSUPERSCRIPT ). On the positive side, [28] gave the first polynomial time algorithm via spectral techniques that almost surely222Refutation in this case is an algorithm with one-sided error: it always refutes the formula correctly by producing certain certificates, or says that the formula might be correct. refutes a random 3333-SAT formula with m=n3/2+ε𝑚superscript𝑛32𝜀m=n^{3/2+\varepsilon}italic_m = italic_n start_POSTSUPERSCRIPT 3 / 2 + italic_ε end_POSTSUPERSCRIPT clauses. The best known bound on m𝑚mitalic_m is due to Feige and Ofek [25] who proved that, for a sufficiently large constant c𝑐citalic_c, random 3333-SAT formulas with m=c⋅n3/2𝑚⋅𝑐superscript𝑛32m=c\cdot n^{3/2}italic_m = italic_c ⋅ italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT clauses can be almost surely refuted in polynomial time using another spectral graph algorithm. We note that a similar situation (extremely high probability of unsatisfiability for a random formula and inability to efficiently confirm it) is unlikely to happen in our k𝑘kitalic_k-clause independent model for constant k𝑘kitalic_k. Indeed, the main proof approach for dealing with arbitrary k𝑘kitalic_k-wise independent distribution is to define a k𝑘kitalic_k-wise statistic, which differentiates any satisfiable formula from a typical unsatisfiable one. Testing k𝑘kitalic_k-wise independence. The property of k𝑘kitalic_k-wise independence of a distribution with n𝑛nitalic_n components can be tested using nO⁢(k)=p⁢o⁢l⁢y⁢(n)superscript𝑛𝑂𝑘𝑝𝑜𝑙𝑦𝑛n^{O(k)}=poly(n)italic_n start_POSTSUPERSCRIPT italic_O ( italic_k ) end_POSTSUPERSCRIPT = italic_p italic_o italic_l italic_y ( italic_n ) many samples in polynomial time, when k𝑘kitalic_k is a constant [4, 43]. This is a useful property to have, as it allows one to verify with only polynomially many instances of random 3333-SAT, whether these instances conform to k𝑘kitalic_k-wise independence or not. Robust mechanism design. A recent line of work in robust mechanism design also considers families of k𝑘kitalic_k-wise independent Bayesian priors in single and multi-unit auctions [13, 22, 33, 34]. Their motivation is similar to ours, as they also rely on the statistical point of view to justify the extension of the results for mutual independent priors typically assumed in Bayesian mechanism design to k𝑘kitalic_k-wise independent ones. 1.1 Problem formulation We consider random 3333-CNF formulas with n𝑛nitalic_n variables generated from a distribution 𝒟𝒟\mathcal{D}caligraphic_D over m𝑚mitalic_m clauses, where the mutual independence assumption over clauses is relaxed to k𝑘kitalic_k-wise independence. We use the term k𝑘kitalic_k-clause independence to refer to such distributions. We denote such families of distributions by ℱk⁢(n,m)subscriptℱ𝑘𝑛𝑚\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ), where each 𝒟∈ℱk⁢(n,m)𝒟subscriptℱ𝑘𝑛𝑚\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D ∈ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) has identical marginals uniformly distributed over all possible OR-clauses and those marginals are only assumed to be k𝑘kitalic_k-wise independent in 𝒟𝒟\mathcal{D}caligraphic_D. We would like to understand the following question for small values of k𝑘kitalic_k: How does the satisfiability threshold r3subscript𝑟3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT of random 3333-SAT formulas behave under any k𝑘kitalic_k-clause independent distribution 𝒟∈ℱk⁢(n,m)𝒟subscriptℱ𝑘𝑛𝑚\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D ∈ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m )? As the distribution 𝒟𝒟\mathcal{D}caligraphic_D is not unique, there might be a large gap between lower and upper estimates of r3subscript𝑟3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT. To this end, we formally define the lower satisfiability threshold LSTk⁢(n)subscriptLST𝑘𝑛\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) as an upper bound on m𝑚mitalic_m, such that a random formula ϕitalic-ϕ\phiitalic_ϕ drawn from a distribution in ℱk⁢(n,m)subscriptℱ𝑘𝑛𝑚\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) with m≤LSTk⁢(n)𝑚subscriptLST𝑘𝑛m\leq\texttt{LST}_{k}(n)italic_m ≤ LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) clauses has 𝐏𝐫⁡[ϕ⁢ is satisfiable]≥23𝐏𝐫italic-ϕ is satisfiable23\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\geq\frac{2}{3}bold_Pr [ italic_ϕ is satisfiable ] ≥ divide start_ARG 2 end_ARG start_ARG 3 end_ARG. Similarly, the upper satisfiability threshold USTk⁢(n)subscriptUST𝑘𝑛\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) is a lower bound on m𝑚mitalic_m, such that the random formula ϕitalic-ϕ\phiitalic_ϕ with m≥USTk⁢(n)𝑚subscriptUST𝑘𝑛m\geq\texttt{UST}_{k}(n)italic_m ≥ UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) clauses has 𝐏𝐫⁡[ϕ⁢ is satisfiable]≤13𝐏𝐫italic-ϕ is satisfiable13\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\leq\frac{1}{3}bold_Pr [ italic_ϕ is satisfiable ] ≤ divide start_ARG 1 end_ARG start_ARG 3 end_ARG. What kind of bounds on upper USTk⁢(n)subscriptUST𝑘𝑛\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) and lower LSTk⁢(n)subscriptLST𝑘𝑛\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) thresholds should we expect? Reasonable expectations. The condition 𝒟∈ℱk⁢(n,m)𝒟subscriptℱ𝑘𝑛𝑚\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D ∈ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) only says something about configurations of at most k𝑘kitalic_k clauses and does not put any other restrictions on the random formula ϕ∼𝒟similar-toitalic-ϕ𝒟\phi\sim\mathcal{D}italic_ϕ ∼ caligraphic_D. As the degree of independence k𝑘kitalic_k is a small constant, any argument that gives bounds on LSTksubscriptLST𝑘\texttt{LST}_{k}LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT or USTksubscriptUST𝑘\texttt{UST}_{k}UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT can only rely on statistics of at most a constant number of clauses. Hence, it is rather likely that bounds on LSTksubscriptLST𝑘\texttt{LST}_{k}LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT and USTksubscriptUST𝑘\texttt{UST}_{k}UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT come together with efficient procedures of, respectively, finding a satisfying assignment for a random formula ϕitalic-ϕ\phiitalic_ϕ, or certifying that ϕitalic-ϕ\phiitalic_ϕ is not satisfiable. Hence, given the prior work on random 3333-SAT for 𝒟Ind.∈ℱk⁢(n,m)subscript𝒟Ind.subscriptℱ𝑘𝑛𝑚\mathcal{D}_{\text{Ind.}}\in\mathcal{F}_{k}(n,m)caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT ∈ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ), we get the following picture: Upper satisfiability threshold. The best known result for refuting 3333-CNF formulas efficiently is due to Feige and Ofek [25], who show how to do it only for a fairly large number of clauses m=c⋅n3/2𝑚⋅𝑐superscript𝑛32m=c\cdot n^{3/2}italic_m = italic_c ⋅ italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT. Furthermore, for any smaller number of clauses m=O⁢(n3/2−ε)𝑚𝑂superscript𝑛32𝜀m=O(n^{3/2-\varepsilon})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 - italic_ε end_POSTSUPERSCRIPT ), a random 3333-CNF formula is likely to have only exponential in n𝑛nitalic_n proof size for any unsatisfiability proof in resolution [8]. Hence, it is out of reach to aim for a better bound on USTk⁢(n)subscriptUST𝑘𝑛\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) than O⁢(n3/2)𝑂superscript𝑛32O(n^{3/2})italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT ) while relying only on k𝑘kitalic_k-wise independence for some constant k𝑘kitalic_k. In fact, the best known positive result on efficiently computable proofs of unsatisfiability in resolution is due to Beame et al. [7], who show that an ordered DLL algorithm executed on a random 3333-SAT instance with m=Ω⁢(n2/log⁡n)𝑚Ωsuperscript𝑛2𝑛m=\Omega(n^{2}/\log n)italic_m = roman_Ω ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / roman_log italic_n ) clauses terminates in polynomial time. Lower satisfiability threshold. As the proofs for the lower bounds on r3subscript𝑟3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT often establish simple procedures that find satisfying assignments with high probability, it is still possible that LSTk⁢(n)subscriptLST𝑘𝑛\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) is of similar order Θ⁢(n)Θ𝑛\Theta(n)roman_Θ ( italic_n ) as the lower bounds on r3subscript𝑟3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT for 𝒟Ind.subscript𝒟Ind.\mathcal{D}_{\text{Ind.}}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT. Thus, the most ambitious result would be to show that LSTk⁢(n)≤ck⋅nsubscriptLST𝑘𝑛⋅subscript𝑐𝑘𝑛\texttt{LST}_{k}(n)\leq c_{k}\cdot nLST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) ≤ italic_c start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ⋅ italic_n for constant cksubscript𝑐𝑘c_{k}italic_c start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT that increases with k𝑘kitalic_k. A more modest goal is to aim for LSTk⁢(n)=o⁢(n)subscriptLST𝑘𝑛𝑜𝑛\texttt{LST}_{k}(n)=o(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_o ( italic_n ) for a constant k𝑘kitalic_k, where LSTk⁢(n)→Θ⁢(n)→subscriptLST𝑘𝑛Θ𝑛\texttt{LST}_{k}(n)\to\Theta(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) → roman_Θ ( italic_n ) as k→+∞→𝑘k\to+\inftyitalic_k → + ∞. 1.2 Our results We obtain the following bounds on the lower and upper satisfiability thresholds LSTk⁢(n)subscriptLST𝑘𝑛\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) and USTk⁢(n)subscriptUST𝑘𝑛\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) for various values of k𝑘kitalic_k. Lower satisfiability thresholds. We show (in Theorem 6.1) that LSTk⁢(n)≥Ω⁢(n1−1/k)subscriptLST𝑘𝑛Ωsuperscript𝑛11𝑘\texttt{LST}_{k}(n)\geq\Omega(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) ≥ roman_Ω ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) for any k≥2𝑘2k\geq 2italic_k ≥ 2. I.e., any k𝑘kitalic_k-clause independent random formula is satisfiable with high probability if it contains at most O⁢(n1−1/k)𝑂superscript𝑛11𝑘O(n^{1-1/k})italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) clauses. The argument is simple: for any k𝑘kitalic_k-clause independent distribution, we look at the 3333-uniform hypergraph that corresponds to the variables of a random formula ϕitalic-ϕ\phiitalic_ϕ produced according to this distribution, and argue that this graph does not have Berge-cycles, with high probability. We also provide an informal justification that this bound is asymptotically tight, i.e., that LSTk⁢(n)=O⁢(n1−1/k)subscriptLST𝑘𝑛𝑂superscript𝑛11𝑘\texttt{LST}_{k}(n)=O(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ). Specifically, we outline a plausible approach for constructing a k𝑘kitalic_k-clause independent distribution with m=O⁢(n1−1/k)𝑚𝑂superscript𝑛11𝑘m=O(n^{1-1/k})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) clauses such that most of its formulas are unsatisfiable. Our approach is built upon existing constructions of dense hyper-graphs with large girth. It is interesting to note that, in both the proof of the LSTk⁢(n)=Ω⁢(n1−1/k)subscriptLST𝑘𝑛Ωsuperscript𝑛11𝑘\texttt{LST}_{k}(n)=\Omega(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = roman_Ω ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) result and the approach for showing that LSTk⁢(n)=O⁢(n1−1/k)subscriptLST𝑘𝑛𝑂superscript𝑛11𝑘\texttt{LST}_{k}(n)=O(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ), we only need to consider variables and can completely ignore the distribution over the literals. Upper satisfiability thresholds. We first consider small degrees of independence, i.e., k∈{2,3}𝑘23k\in\{2,3\}italic_k ∈ { 2 , 3 }. In both cases, we show that USTk⁢(n)=Θ⁢(n3)subscriptUST𝑘𝑛Θsuperscript𝑛3\texttt{UST}_{k}(n)=\Theta(n^{3})UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = roman_Θ ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ), meaning that one needs almost all possible clauses in a 3333-clause (as well as 2222-clause) independent formula to ensure that it is unsatisfiable (see Theorem 3.1 and Theorem 4.1). The most nontrivial part is to construct the distribution 𝒟∈ℱ3⁢(n,m)𝒟subscriptℱ3𝑛𝑚\mathcal{D}\in\mathcal{F}_{3}(n,m)caligraphic_D ∈ caligraphic_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n , italic_m ) with m=Θ⁢(n3)𝑚Θsuperscript𝑛3m=\Theta(n^{3})italic_m = roman_Θ ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) and 𝐏𝐫⁡[ϕ⁢ is satisfiable]≥23𝐏𝐫italic-ϕ is satisfiable23\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\geq\frac{2}{3}bold_Pr [ italic_ϕ is satisfiable ] ≥ divide start_ARG 2 end_ARG start_ARG 3 end_ARG. Our construction is based on “3333-XOR formulas” (i.e., OR-clauses that have either one or three literals that are satisfied by a randomly planted truth assignment), which aligns well with the intuition developed in previous work [24, 25]. The main technical difficulty is to ensure k𝑘kitalic_k-clause independence by adding a small fraction of unsatisfiable instances and checking all 3333-wise statistics. Our most exciting and technically involved result (see Theorem 5.1) is our proof that UST4⁢(n)=O⁢(n2)subscriptUST4𝑛𝑂superscript𝑛2\texttt{UST}_{4}(n)=O(n^{2})UST start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ), i.e., a random formula ϕ∼𝒟similar-toitalic-ϕ𝒟\phi\sim\mathcal{D}italic_ϕ ∼ caligraphic_D with m=O⁢(n2)𝑚𝑂superscript𝑛2m=O(n^{2})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) clauses is unsatisfiable with large probability for any 4444-clause independent distribution 𝒟∈ℱ4⁢(n,m)𝒟subscriptℱ4𝑛𝑚\mathcal{D}\in\mathcal{F}_{4}(n,m)caligraphic_D ∈ caligraphic_F start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n , italic_m ). It is worth noting that such a bound is much harder to get under the 4444-wise independence assumption than in the case of a mutually independent distribution 𝒟Ind.subscript𝒟Ind.\mathcal{D}_{\text{Ind.}}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT. Indeed, Feige and Ofek [25] describe a very simple refutation algorithm for m=Θ⁢(n2)𝑚Θsuperscript𝑛2m=\Theta(n^{2})italic_m = roman_Θ ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) that fixes a variable x𝑥xitalic_x and considers all clauses containing x𝑥xitalic_x or x¯¯𝑥\overline{x}over¯ start_ARG italic_x end_ARG (there will be Θ⁢(n)Θ𝑛\Theta(n)roman_Θ ( italic_n ) such clauses in expectation). Then, after deleting x𝑥xitalic_x (or x¯¯𝑥\overline{x}over¯ start_ARG italic_x end_ARG), one can reduce the problem to the refutation of the respective random 2222-CNF sub-instance, which can be easily verified in polynomial time and has a low satisfiability threshold of r2=1subscript𝑟21r_{2}=1italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = 1. This simple approach obviously fails for 4444-clause independent distributions. We instead construct a bipartite multigraph G⁢(ϕ)𝐺italic-ϕG(\phi)italic_G ( italic_ϕ ) between pairs of distinct literals on one side and all singleton literals on the other, in which every OR-clause in ϕitalic-ϕ\phiitalic_ϕ corresponds to three different edges. We then carefully examine the statistic κ⁢(ϕ)𝜅italic-ϕ\kappa(\phi)italic_κ ( italic_ϕ ) that counts K2,2subscript𝐾22K_{2,2}italic_K start_POSTSUBSCRIPT 2 , 2 end_POSTSUBSCRIPT subgraphs in G⁢(ϕ)𝐺italic-ϕG(\phi)italic_G ( italic_ϕ ) for a random ϕ∼𝒟similar-toitalic-ϕ𝒟\phi\sim\mathcal{D}italic_ϕ ∼ caligraphic_D. We find that the expected value of κ⁢(ϕ)𝜅italic-ϕ\kappa(\phi)italic_κ ( italic_ϕ ) for random ϕitalic-ϕ\phiitalic_ϕ is only slightly larger than its absolute minimal value, while at the same time κ⁢(ϕ)𝜅italic-ϕ\kappa(\phi)italic_κ ( italic_ϕ ) is significantly larger than its expectation when ϕitalic-ϕ\phiitalic_ϕ is satisfiable. Our argument bears certain similarities with the argument in [25], which also looked at intersections of two literals between pairs of clauses but used the 3333-XOR principle and a differently constructed non-bipartite graph. 1.3 Roadmap The rest of the paper is structured as follows. We begin with preliminary definitions and notation in Section 2. Then, we warm up with our tight bounds on the upper satisfiability threshold UST2⁢(n)subscriptUST2𝑛\texttt{UST}_{2}(n)UST start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_n ) in Section 3. Our lower bound on UST3⁢(n)subscriptUST3𝑛\texttt{UST}_{3}(n)UST start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n ) is proved in Section 4 while our upper bound on UST4⁢(n)subscriptUST4𝑛\texttt{UST}_{4}(n)UST start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n ) follows in Section 5. Section 6 is devoted to the study of the lower satisfiability threshold."
https://arxiv.org/html/2411.03451v1,Redundancy Is All You Need,"The seminal work of Benczúr and Karger demonstrated cut sparsifiers of near-linear size, with several applications throughout theoretical computer science. Subsequent extensions have yielded sparsifiers for hypergraph cuts and more recently linear codes over Abelian groups. A decade ago, Kogan and Krauthgamer asked about the sparsifiability of arbitrary constraint satisfaction problems (CSPs). For this question, a trivial lower bound is the size of a non-redundant CSP instance, which admits, for each constraint, an assignment satisfying only that constraint (so that no constraint can be dropped by the sparsifier). For instance, for graph cuts, spanning trees are non-redundant instances.Our main result is that redundant clauses are sufficient for sparsification: for any CSP predicate R𝑅Ritalic_R, every unweighted instance of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) has a sparsifier of size at most its non-redundancy (up to polylog factors). For weighted instances, we similarly pin down the sparsifiability to the so-called chain length of the predicate. These results precisely determine the extent to which any CSP can be sparsified. A key technical ingredient in our work is a novel application of the entropy method from Gilmer’s recent breakthrough on the union-closed sets conjecture.As an immediate consequence of our main theorem, a number of results in the non-redundancy literature immediately extend to CSP sparsification. We also contribute new techniques for understanding the non-redundancy of CSP predicates. In particular, we give an explicit family of predicates whose non-redundancy roughly corresponds to the structure of matching vector families in coding theory. By adapting methods from the matching vector codes literature, we are able to construct an explicit predicate whose non-redundancy lies between Ω⁢(n1.5)Ωsuperscript𝑛1.5\Omega(n^{1.5})roman_Ω ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) and O~⁢(n1.6)~𝑂superscript𝑛1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ), the first example with a provably non-integral exponent.","The broad goal in sparsification is to replace an object by a more compact surrogate, typically a carefully chosen subsample, that preserves the behavior of the object under some metric of interest. For instance, for preserving cuts in undirected graphs, the influential works of Karger [Kar93] and Benczúr and Karger [BK96] showed that every graph has an edge-weighted subgraph with near-linear number of edges that preserves the value of all (edge) cuts up to a (1±ϵ)plus-or-minus1italic-ϵ(1\pm\epsilon)( 1 ± italic_ϵ ) multiplicative factor. These papers have had a substantial impact in shaping the last thirty years of work in areas such as spectral sparsifiers [ST11, BSS12, LS18], clustering [KVV04, SPR11], hypergraph sparsifiers [KK15, CKN20, KKTY21, KK23, KPS24c], linear solvers [ST04, Vis13, KMP14], convex optimization [LS14, AK16, Tod16], sketching/streaming algorithms [AG09, AGM12b, AGM12a, ACK+16, McG14, KLM+17, BHM+21], max-flow/min-cut algorithms [LR99, CKM+11, KLOS14, CKL+22], machine learning [LCY+21, CSZ22, ZSW+23, GBY+24], submodular functions [KK23, Sch24, Raf24, Qua24], differential privacy [BBDS12, AU19], PageRank [Chu14], and even theoretical physics [HKTH16, Van18, TN22], among many other works. Among the multiple exciting dimensions in which cut sparsification has been generalized, we now highlight two which form the backdrop for our work. Note that the graph cut problem can be modeled by the arity-two Boolean constraint x+y=1(mod2)𝑥𝑦annotated1pmod2x+y=1\pmod{2}italic_x + italic_y = 1 start_MODIFIER ( roman_mod start_ARG 2 end_ARG ) end_MODIFIER. One can thus generalize cut sparsification by allowing for arbitrary constraints (of any arity over some finite domain) as considered in the field of constraint satisfaction problems (CSPs), leading to CSP sparsification. This direction was proposed by Kogan and Krauthgamer [KK15] in their work on hypergraph cut sparsifiers, where the not-all-equal constraint captures hypergraph cut. As as special case, arbitrary binary CSPs (where each constraint has two variables) were studied in [FK17] for the Boolean domain and in [BŽ20] for general domains, leading to a dichotomy: either near-linear sized sparsifiers exist, or no improvement over quadratic is possible. In another direction, one can instead look toward more general structures to sparsify. For instance, a recent line of work by Khanna, Putterman, and Sudan turned toward sparsifying linear codes [KPS24a], or more generally subgroups of powers of Abelian groups [KPS24b]. Beyond being algorithmically efficient [KPS24b], these structural results have led to exciting new results in CSP sparsification by constructing optimal sparsifiers when the constraints can be embedded into linear/Abelian equations. In this work, we obtain sparsifiers encompassing both these generalizations via a unified approach to sparsification of non-linear codes. The resulting sparsifiers for CSPs have optimal asymptotic size up to polylogarithmic factors, for every choice of predicate defining the CSP. In other words, we pinpoint the optimal extent to which an arbitrary CSP can be sparsified.111In this work we focus on the existence of sparsifiers, which is already highly non-trivial (e.g., [KPS24a, BŽ20] are also non-algorithmic). Future directions (and barriers) for algorithmic aspects are briefly discussed in Sections 1.7 and 9. 1.1 Non-linear code sparsification We first state our result for codes as it is very general and crisply stated, and then turn to the consequences and further new results for CSPs. For a non-linear code C⊆{0,1}m𝐶superscript01𝑚C\subseteq\{0,1\}^{m}italic_C ⊆ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, an ε𝜀\varepsilonitalic_ε-sparsifier (for a parameter ε∈(0,1)𝜀01\varepsilon\in(0,1)italic_ε ∈ ( 0 , 1 )) is a weight function w:[m]→ℝ≥0:𝑤→delimited-[]𝑚subscriptℝabsent0w:[m]\to\mathbb{R}_{\geq 0}italic_w : [ italic_m ] → blackboard_R start_POSTSUBSCRIPT ≥ 0 end_POSTSUBSCRIPT such that for every codeword c𝑐citalic_c, adding up the weights of its nonzero positions, i.e., ∑iw⁢(i)⁢cisubscript𝑖𝑤𝑖subscript𝑐𝑖\sum_{i}w(i)c_{i}∑ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_w ( italic_i ) italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, is an accurate estimate of the Hamming weight of c𝑐citalic_c (i.e., ∑icisubscript𝑖subscript𝑐𝑖\sum_{i}c_{i}∑ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT) to within a (1±ε)plus-or-minus1𝜀(1\pm\varepsilon)( 1 ± italic_ε ) multiplicative factor (Definition 2.8). The goal is to minimize the support of w𝑤witalic_w (i.e., the number of nonzero entries w⁢(i)𝑤𝑖w(i)italic_w ( italic_i )), and the minimum value is called ε𝜀\varepsilonitalic_ε-sparsifiability of C𝐶Citalic_C and is denoted SPR⁡(C,ε)SPR𝐶𝜀\operatorname{SPR}(C,\varepsilon)roman_SPR ( italic_C , italic_ε ). One of our main results is an upper bound on the sparsifiability in terms of a natural combinatorial parameter of the code called its non-redundancy NRD⁡(C)NRD𝐶\operatorname{NRD}(C)roman_NRD ( italic_C ), defined as follows: NRD⁡(C)NRD𝐶\operatorname{NRD}(C)roman_NRD ( italic_C ) is the size of the largest subset of indices I⊆[m]𝐼delimited-[]𝑚I\subseteq[m]italic_I ⊆ [ italic_m ] such that for each i∈I𝑖𝐼i\in Iitalic_i ∈ italic_I, there is a codeword c∈C𝑐𝐶c\in Citalic_c ∈ italic_C with ci=1subscript𝑐𝑖1c_{i}=1italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = 1 and ci′=0subscript𝑐superscript𝑖′0c_{i^{\prime}}=0italic_c start_POSTSUBSCRIPT italic_i start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT end_POSTSUBSCRIPT = 0 for i′∈I∖{i}superscript𝑖′𝐼𝑖i^{\prime}\in I\setminus\{i\}italic_i start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT ∈ italic_I ∖ { italic_i }. In other words, if we imagine the code as a matrix whose rows are codewords, its non-redundancy is largest square submatrix which is a permutation matrix. Our result can then be stated compactly as follows. Theorem 1.1 (Main). For all C⊆{0,1}m𝐶superscript01𝑚C\subseteq\{0,1\}^{m}italic_C ⊆ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT and ε∈(0,1)𝜀01\varepsilon\in(0,1)italic_ε ∈ ( 0 , 1 ), SPR⁡(C,ε)=O⁢(NRD⁡(C)⁢(log⁡m)6/ε2).SPR𝐶𝜀𝑂NRD𝐶superscript𝑚6superscript𝜀2\operatorname{SPR}(C,\varepsilon)=O(\operatorname{NRD}(C)(\log m)^{6}/% \varepsilon^{2}).roman_SPR ( italic_C , italic_ε ) = italic_O ( roman_NRD ( italic_C ) ( roman_log italic_m ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_ε start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . To see how our theorem generalizes linear code sparsification [KPS24a, KPS24b], let 𝔽𝔽\mathbb{F}blackboard_F be a (finite) field and let V⊆𝔽m𝑉superscript𝔽𝑚V\subseteq\mathbb{F}^{m}italic_V ⊆ blackboard_F start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT be a subspace. Let C:={(𝟏⁢[v1=0],…,𝟏⁢[vm=0]):v∈V}assign𝐶conditional-set1delimited-[]subscript𝑣10…1delimited-[]subscript𝑣𝑚0𝑣𝑉C:=\{({\bf 1}[v_{1}=0],\ldots,{\bf 1}[v_{m}=0]):v\in V\}italic_C := { ( bold_1 [ italic_v start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = 0 ] , … , bold_1 [ italic_v start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT = 0 ] ) : italic_v ∈ italic_V } be the zero/non-zero pattern of V𝑉Vitalic_V. Then, any ε𝜀\varepsilonitalic_ε-sparsifier of C𝐶Citalic_C is an ε𝜀\varepsilonitalic_ε-sparsifier of V𝑉Vitalic_V and NRD⁡(C)=dimVNRD𝐶dimension𝑉\operatorname{NRD}(C)=\dim Vroman_NRD ( italic_C ) = roman_dim italic_V. In fact, for any finite group G𝐺Gitalic_G and subgroup H≤Gm𝐻superscript𝐺𝑚H\leq G^{m}italic_H ≤ italic_G start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, we can show for the corresponding C𝐶Citalic_C that NRD⁡(C)≤log2⁡|H|NRD𝐶subscript2𝐻\operatorname{NRD}(C)\leq\log_{2}|H|roman_NRD ( italic_C ) ≤ roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_H | (see Theorem 5.1), matching [KPS24b]’s result for Abelian groups (modulo their efficiency). If we view C⊆{0,1}m𝐶superscript01𝑚C\subseteq\{0,1\}^{m}italic_C ⊆ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT as a set family over the universe [m]delimited-[]𝑚[m][ italic_m ], the above result in effect says that the non-redundancy NRD⁡(C)NRD𝐶\operatorname{NRD}(C)roman_NRD ( italic_C ) plays the role of the VC dimension of C𝐶Citalic_C when the goal is to estimate the size of the set c∈C𝑐𝐶c\in Citalic_c ∈ italic_C rather than learn c𝑐citalic_c itself. In fact, it turns out that NRD⁡(C)NRD𝐶\operatorname{NRD}(C)roman_NRD ( italic_C ) is precisely the VC dimension of the union-closure of C𝐶Citalic_C. This connection to union-closed families plays a crucial role in the proof of Theorem 1.1. See the technical overview (Section 1.6) for more details, including discussion of a significantly simpler O~ε⁢(NRD⁡(C)⁢log⁡|C|)subscript~𝑂𝜀NRD𝐶𝐶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\log|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log | italic_C | )-sized sparsifier. 1.2 CSP sparsification We now turn to (unweighted222The weighted case is discussed in Section 1.4.) CSP sparsification. For a relation R⊆Dr𝑅superscript𝐷𝑟R\subseteq D^{r}italic_R ⊆ italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT of arity r𝑟ritalic_r over a finite domain D𝐷Ditalic_D, an instance ΨΨ\Psiroman_Ψ of the CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) problem consists a variable set X𝑋Xitalic_X and a constraint set Y⊆Xr𝑌superscript𝑋𝑟Y\subseteq X^{r}italic_Y ⊆ italic_X start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT. An assignment σ:X→D:𝜎→𝑋𝐷\sigma:X\to Ditalic_σ : italic_X → italic_D satisfies a constraint y=(x1,x2,…,xr)∈Y𝑦subscript𝑥1subscript𝑥2…subscript𝑥𝑟𝑌y=(x_{1},x_{2},\dots,x_{r})\in Yitalic_y = ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , … , italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ) ∈ italic_Y if (σ⁢(x1),σ⁢(x2),…,σ⁢(xr))∈R𝜎subscript𝑥1𝜎subscript𝑥2…𝜎subscript𝑥𝑟𝑅(\sigma(x_{1}),\sigma(x_{2}),\dots,\sigma(x_{r}))\in R( italic_σ ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) , italic_σ ( italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) , … , italic_σ ( italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ) ) ∈ italic_R. The value val⁡(Ψ,σ)valΨ𝜎\operatorname{val}(\Psi,\sigma)roman_val ( roman_Ψ , italic_σ ) of an assignment σ𝜎\sigmaitalic_σ is the number of constraints y∈Y𝑦𝑌y\in Yitalic_y ∈ italic_Y that it satisfies. Similarly, for a weight function w:Y→ℝ≥0:𝑤→𝑌subscriptℝabsent0w:Y\to\mathbb{R}_{\geq 0}italic_w : italic_Y → blackboard_R start_POSTSUBSCRIPT ≥ 0 end_POSTSUBSCRIPT, the weighted value val⁡(Ψ,w,σ)valΨ𝑤𝜎\operatorname{val}(\Psi,w,\sigma)roman_val ( roman_Ψ , italic_w , italic_σ ) is the sum of weights w⁢(y)𝑤𝑦w(y)italic_w ( italic_y ) of all constraints y∈Y𝑦𝑌y\in Yitalic_y ∈ italic_Y that σ𝜎\sigmaitalic_σ satisfies. The goal in CSP sparsification is to output a weight function w:Y→ℝ≥0:𝑤→𝑌subscriptℝabsent0w:Y\to\mathbb{R}_{\geq 0}italic_w : italic_Y → blackboard_R start_POSTSUBSCRIPT ≥ 0 end_POSTSUBSCRIPT of small support, such that for every assignment σ:X→D:𝜎→𝑋𝐷\sigma:X\to Ditalic_σ : italic_X → italic_D, (1−ε)⁢val⁡(Ψ,σ)≤val⁡(Ψ,w,σ)≤(1+ε)⁢val⁡(Ψ,σ),1𝜀valΨ𝜎valΨ𝑤𝜎1𝜀valΨ𝜎(1-\varepsilon)\operatorname{val}(\Psi,\sigma)\leq\operatorname{val}(\Psi,w,% \sigma)\leq(1+\varepsilon)\operatorname{val}(\Psi,\sigma)\ ,( 1 - italic_ε ) roman_val ( roman_Ψ , italic_σ ) ≤ roman_val ( roman_Ψ , italic_w , italic_σ ) ≤ ( 1 + italic_ε ) roman_val ( roman_Ψ , italic_σ ) , and minimum such support size is denoted SPR⁡(Ψ,ε)SPRΨ𝜀\operatorname{SPR}(\Psi,\varepsilon)roman_SPR ( roman_Ψ , italic_ε ). The ε𝜀\varepsilonitalic_ε-sparsifiability of the relation R⊆Dr𝑅superscript𝐷𝑟R\subseteq D^{r}italic_R ⊆ italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT, as a function of number of variables, is defined to the maximum (i.e., worst-case) value of SPR⁡(Ψ,ε)SPRΨ𝜀\operatorname{SPR}(\Psi,\varepsilon)roman_SPR ( roman_Ψ , italic_ε ) over all n𝑛nitalic_n-variables instances ΨΨ\Psiroman_Ψ of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ). We denote it by SPR⁡(R,n,ε)SPR𝑅𝑛𝜀\operatorname{SPR}(R,n,\varepsilon)roman_SPR ( italic_R , italic_n , italic_ε ) and it is the chief object of our study. Note that this is for the unweighted case, see Section 1.4 how this result can be (tightly) applied to the weighted case. Let us note an obvious obstruction to sparsification. Suppose we have an instance Ψ=(X,Y)Ψ𝑋𝑌\Psi=(X,Y)roman_Ψ = ( italic_X , italic_Y ) of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) such that for each of its constraints y∈Y𝑦𝑌y\in Yitalic_y ∈ italic_Y, there is an assignment σy:X→D:subscript𝜎𝑦→𝑋𝐷\sigma_{y}:X\to Ditalic_σ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT : italic_X → italic_D that satisfies only y𝑦yitalic_y and no other constraint. Then clearly ΨΨ\Psiroman_Ψ cannot be sparsified at all—dropping any constraint y𝑦yitalic_y would make the value of σysubscript𝜎𝑦\sigma_{y}italic_σ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT drop from 1111 to 00. We call such an instance a non-redundant instance of CSP⁡(R¯)CSP¯𝑅\operatorname{CSP}(\overline{R})roman_CSP ( over¯ start_ARG italic_R end_ARG ), where R¯=Dr∖R¯𝑅superscript𝐷𝑟𝑅\overline{R}=D^{r}\setminus Rover¯ start_ARG italic_R end_ARG = italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ∖ italic_R (cf., [BCH+13, BCK20]).333We use R¯¯𝑅\overline{R}over¯ start_ARG italic_R end_ARG rather than R𝑅Ritalic_R due to the conventions of each community. See Remark 2.6 for deeper technical reasons. As introduced by Bessiere, Carbonnel, and Katsirelos [BCK20], we denote the size of the largest such non-redundant instance of CSP⁡(R¯)CSP¯𝑅\operatorname{CSP}(\overline{R})roman_CSP ( over¯ start_ARG italic_R end_ARG ) on n𝑛nitalic_n-variables by NRD⁡(R¯,n)NRD¯𝑅𝑛\operatorname{NRD}(\overline{R},n)roman_NRD ( over¯ start_ARG italic_R end_ARG , italic_n ) and call it the non-redundancy of R¯¯𝑅\overline{R}over¯ start_ARG italic_R end_ARG. Thus a trivial lower bound on sparsifiability of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ), regardless of the choice of ε∈(0,1)𝜀01\varepsilon\in(0,1)italic_ε ∈ ( 0 , 1 ), is given by SPR⁡(R,n,ε)≥NRD⁡(R¯,n),SPR𝑅𝑛𝜀NRD¯𝑅𝑛\displaystyle\operatorname{SPR}(R,n,\varepsilon)\geq\operatorname{NRD}(% \overline{R},n)\ ,roman_SPR ( italic_R , italic_n , italic_ε ) ≥ roman_NRD ( over¯ start_ARG italic_R end_ARG , italic_n ) , (1) and this holds even if the goal is merely to preserve which assignments have nonzero value. Rather remarkably, this simplistic lower bound can be met and one can sparsify all the way down to NRD⁡(R¯,n)NRD¯𝑅𝑛\operatorname{NRD}(\overline{R},n)roman_NRD ( over¯ start_ARG italic_R end_ARG , italic_n ) times polylogarithmic factors! In fact, this turns out to be an easy corollary of Theorem 1.1. One can associate a canonical code CΨ⊆{0,1}Ysubscript𝐶Ψsuperscript01𝑌C_{\Psi}\subseteq\{0,1\}^{Y}italic_C start_POSTSUBSCRIPT roman_Ψ end_POSTSUBSCRIPT ⊆ { 0 , 1 } start_POSTSUPERSCRIPT italic_Y end_POSTSUPERSCRIPT with any CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) instance Ψ=(X,Y)Ψ𝑋𝑌\Psi=(X,Y)roman_Ψ = ( italic_X , italic_Y ) whose codewords cσsubscript𝑐𝜎c_{\sigma}italic_c start_POSTSUBSCRIPT italic_σ end_POSTSUBSCRIPT correspond to the assignments σ:X→D:𝜎→𝑋𝐷\sigma:X\to Ditalic_σ : italic_X → italic_D, and cσ,ysubscript𝑐𝜎𝑦c_{\sigma,y}italic_c start_POSTSUBSCRIPT italic_σ , italic_y end_POSTSUBSCRIPT is 1111 precisely when σ𝜎\sigmaitalic_σ satisfies y𝑦yitalic_y. It is easy to check that CSP sparsification of ΨΨ\Psiroman_Ψ reduces to code sparsification of CΨsubscript𝐶ΨC_{\Psi}italic_C start_POSTSUBSCRIPT roman_Ψ end_POSTSUBSCRIPT, and the non-redundancy of C𝐶Citalic_C equals the size of the largest non-redundant sub-instance of ΨΨ\Psiroman_Ψ (viewed as an instance of CSP⁡(R¯)CSP¯𝑅\operatorname{CSP}(\overline{R})roman_CSP ( over¯ start_ARG italic_R end_ARG )). Combining Theorem 1.1 and (1), we therefore have our main result pinning down the sparsifiability of every CSP up to polylogarithmic factors. Theorem 1.2. For every nonempty R⊊Dr𝑅superscript𝐷𝑟R\subsetneq D^{r}italic_R ⊊ italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT and ε∈(0,1)𝜀01\varepsilon\in(0,1)italic_ε ∈ ( 0 , 1 ), we have that NRD⁡(R¯,n)≤SPR⁡(R,n,ε)≤O⁢(NRD⁡(R¯,n)⁢(r⁢log⁡n)6/ε2).NRD¯𝑅𝑛SPR𝑅𝑛𝜀𝑂NRD¯𝑅𝑛superscript𝑟𝑛6superscript𝜀2\operatorname{NRD}(\overline{R},n)\leq\operatorname{SPR}(R,n,\varepsilon)\leq O% (\operatorname{NRD}(\overline{R},n)(r\log n)^{6}/\varepsilon^{2}).roman_NRD ( over¯ start_ARG italic_R end_ARG , italic_n ) ≤ roman_SPR ( italic_R , italic_n , italic_ε ) ≤ italic_O ( roman_NRD ( over¯ start_ARG italic_R end_ARG , italic_n ) ( italic_r roman_log italic_n ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_ε start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . 1.3 Non-redundancy of specific relations The non-redundancy of relations is readily computed in some simple cases. For example, for the relation ORr:=Dr∖{0r}assignsubscriptOR𝑟superscript𝐷𝑟superscript0𝑟\operatorname{OR}_{r}:=D^{r}\setminus\{0^{r}\}roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT := italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ∖ { 0 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT }, we have that NRD⁡(ORr,n)=Θ⁢(nr)NRDsubscriptOR𝑟𝑛Θsuperscript𝑛𝑟\operatorname{NRD}(\operatorname{OR}_{r},n)=\Theta(n^{r})roman_NRD ( roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT , italic_n ) = roman_Θ ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ). Indeed Y=(Xr)𝑌binomial𝑋𝑟Y=\binom{X}{r}italic_Y = ( FRACOP start_ARG italic_X end_ARG start_ARG italic_r end_ARG ) is a non-redundant instance because setting all but r𝑟ritalic_r variables to 1111 fails to satisfy exactly that r𝑟ritalic_r-tuple (see [FK17, Car22, KPS24b]). When R𝑅Ritalic_R is affine, NRD⁡(R,n)=Θ⁢(n)NRD𝑅𝑛Θ𝑛\operatorname{NRD}(R,n)=\Theta(n)roman_NRD ( italic_R , italic_n ) = roman_Θ ( italic_n ), and when R𝑅Ritalic_R is defined as the zero set of a degree k𝑘kitalic_k polynomial, NRD⁡(R,n)=O⁢(nk)NRD𝑅𝑛𝑂superscript𝑛𝑘\operatorname{NRD}(R,n)=O(n^{k})roman_NRD ( italic_R , italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ); these follow from simple rank arguments (e.g., [LW20]). Via Theorem 1.2, these special cases (plus simple gadget reductions) already capture all the previously known upper and lower bounds for CSP sparsification (see Section 1.5 for more details on the CSP sparsification literature). Furthermore, there are also some non-trivial upper bounds known on NRD in the literature, which we can now import to sparsifiability for free courtesy Theorem 1.2. For instance, the so-called Mal’tsev relations, which generalize affine predicates (i.e., cosets) over Abelian groups, have been shown to have OD⁢(n)subscript𝑂𝐷𝑛O_{D}(n)italic_O start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_n ) non-redundancy [LW20, BCK20], and therefore by Theorem 1.2 their complements have near-linear sparsifiability. Carbonnel [Car22] showed that if R𝑅Ritalic_R is an arity r𝑟ritalic_r relation that doesn’t contain444See Theorem 5.2 for a precise definition. any copy of ORrsubscriptOR𝑟\operatorname{OR}_{r}roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT, then NRD⁡(R,n)≤O⁢(nr−δr)NRD𝑅𝑛𝑂superscript𝑛𝑟subscript𝛿𝑟\operatorname{NRD}(R,n)\leq O(n^{r-\delta_{r}})roman_NRD ( italic_R , italic_n ) ≤ italic_O ( italic_n start_POSTSUPERSCRIPT italic_r - italic_δ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) for δr=21−rsubscript𝛿𝑟superscript21𝑟\delta_{r}=2^{1-r}italic_δ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT = 2 start_POSTSUPERSCRIPT 1 - italic_r end_POSTSUPERSCRIPT (the specific bound arises from a classic hypergraph Turán result [Erd64]). By Theorem 1.2 this immediately implies SPR⁡(R¯,n,ε)≤O~ε⁢(nr−δr)SPR¯𝑅𝑛𝜀subscript~𝑂𝜀superscript𝑛𝑟subscript𝛿𝑟\operatorname{SPR}(\overline{R},n,\varepsilon)\leq\widetilde{O}_{\varepsilon}(% n^{r-\delta_{r}})roman_SPR ( over¯ start_ARG italic_R end_ARG , italic_n , italic_ε ) ≤ over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r - italic_δ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ), where O~⁢(⋅)~𝑂⋅\widetilde{O}(\cdot)over~ start_ARG italic_O end_ARG ( ⋅ ) hides polylogarithmic factors in n𝑛nitalic_n, yielding an Ω⁢(nr)Ωsuperscript𝑛𝑟\Omega(n^{r})roman_Ω ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ) vs O~⁢(nr−δr)~𝑂superscript𝑛𝑟subscript𝛿𝑟\widetilde{O}(n^{r-\delta_{r}})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT italic_r - italic_δ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) dichotomy for sparsification of arity r𝑟ritalic_r CSPs. (This was known for the Boolean case [KPS24b]; see the related work subsection.) The non-redundancy of a relation can in general be difficult to estimate. Thus while in principle Theorem 1.2 pins down the sparisifiability of every CSP, for specific relations, it can still be non-trivial to actually determine the asymptotic behavior of its sparsifiability. Our next set of results makes progress in this direction via novel methods to bound non-redundancy. Given that the non-redundancy of linear predicates is easy to pin down, we consider a natural family of relations which are very close to being linear. Specifically, let 3⁢L⁢I⁢NG={(x,y,z)∣x+y+z=0}subscript3LIN𝐺conditional-set𝑥𝑦𝑧𝑥𝑦𝑧0\operatorname{3LIN}_{G}=\{(x,y,z)\mid x+y+z=0\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = { ( italic_x , italic_y , italic_z ) ∣ italic_x + italic_y + italic_z = 0 } over an Abelian group G𝐺Gitalic_G, and consider 3⁢L⁢I⁢NG∗=3⁢L⁢I⁢NG∖{(0,0,0)}subscriptsuperscript3LIN𝐺subscript3LIN𝐺000\operatorname{3LIN}^{*}_{G}=\operatorname{3LIN}_{G}\setminus\{(0,0,0)\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ∖ { ( 0 , 0 , 0 ) }. (We pick arity 3333 since the arity 2222 case is already fully resolved [FK17, BŽ20].) Being defined by a linear equation over an Abelian group, we already know that NRD⁡(3⁢L⁢I⁢NG,n)=ΘG⁢(n)NRDsubscript3LIN𝐺𝑛subscriptΘ𝐺𝑛\operatorname{NRD}(\operatorname{3LIN}_{G},n)=\Theta_{G}(n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) = roman_Θ start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n ). However the non-redundancy of 3⁢L⁢I⁢NG∗subscriptsuperscript3LIN𝐺\operatorname{3LIN}^{*}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT seems challenging to understand. Existing methods in the literature only yield NRD⁡(3⁢L⁢I⁢NG∗,n)∈[ΩG⁢(n),OG⁢(n2)]NRDsubscriptsuperscript3LIN𝐺𝑛subscriptΩ𝐺𝑛subscript𝑂𝐺superscript𝑛2\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)\in[\Omega_{G}(n),O_{G}(n^{2})]roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) ∈ [ roman_Ω start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n ) , italic_O start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) ]. We introduce a new method for bounding the non-redundancy of predicates like 3⁢L⁢I⁢NG∗subscriptsuperscript3LIN𝐺\operatorname{3LIN}^{*}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT by connecting them to the theory of matching vector (MV) families [Yek08, DGY11] that have been used in the construction of locally decodable codes. Exploiting this connection, we construct a non-redundant instance to establish that NRD⁡(3⁢L⁢I⁢NG,n)≥Ω⁢(n1.5)NRDsubscript3LIN𝐺𝑛Ωsuperscript𝑛1.5\operatorname{NRD}(\operatorname{3LIN}_{G},n)\geq\Omega(n^{1.5})roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) ≥ roman_Ω ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) for all Abelian groups of order ≥3absent3\geq 3≥ 3. Adapting ideas from the analysis of MV families together with some combinatorial ideas, we also prove an upper bound NRD⁡(3⁢L⁢I⁢Nℤ/p⁢ℤ,n)=O~p⁢(n2−εp)NRDsubscript3LINℤ𝑝ℤ𝑛subscript~𝑂𝑝superscript𝑛2subscript𝜀𝑝\operatorname{NRD}(\operatorname{3LIN}_{\mathbb{Z}/p\mathbb{Z}},n)=\widetilde{% O}_{p}(n^{2-\varepsilon_{p}})roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT blackboard_Z / italic_p blackboard_Z end_POSTSUBSCRIPT , italic_n ) = over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT 2 - italic_ε start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) for εp=22⁢p−1subscript𝜀𝑝22𝑝1\varepsilon_{p}=\tfrac{2}{2p-1}italic_ε start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT = divide start_ARG 2 end_ARG start_ARG 2 italic_p - 1 end_ARG and p𝑝pitalic_p prime. Specializing for p=3𝑝3p=3italic_p = 3, we have the following result, which also gives the first examples of relations whose non-redundancy and sparsifiability have a non-integral exponent. Theorem 1.3. We have NRD⁡(3⁢L⁢I⁢Nℤ/3⁢ℤ∗,n)NRDsubscriptsuperscript3LINℤ3ℤ𝑛\displaystyle\operatorname{NRD}(\operatorname{3LIN}^{*}_{\mathbb{Z}/3\mathbb{Z% }},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT , italic_n ) ∈[Ω⁢(n1.5),O~⁢(n1.6)], andabsentΩsuperscript𝑛1.5~𝑂superscript𝑛1.6 and\displaystyle\in[\Omega(n^{1.5}),\widetilde{O}(n^{1.6})],\ \ \ \text{ and }∈ [ roman_Ω ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) , over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) ] , and SPR⁡(3⁢L⁢I⁢Nℤ/3⁢ℤ∗¯,n,ε)SPR¯subscriptsuperscript3LINℤ3ℤ𝑛𝜀\displaystyle\operatorname{SPR}(\overline{\operatorname{3LIN}^{*}_{\mathbb{Z}/% 3\mathbb{Z}}},n,\varepsilon)roman_SPR ( over¯ start_ARG start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT end_ARG , italic_n , italic_ε ) ∈[Ω⁢(n1.5),O~⁢(n1.6/ε2)].absentΩsuperscript𝑛1.5~𝑂superscript𝑛1.6superscript𝜀2\displaystyle\in[\Omega(n^{1.5}),\widetilde{O}(n^{1.6}/\varepsilon^{2})].∈ [ roman_Ω ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) , over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT / italic_ε start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) ] . 1.4 Weighted CSP sparsification The discussion so far has focused on unweighted CSP instances, and we now shift our focus to the weighted case, where each constraint of Y𝑌Yitalic_Y comes with a weight. We also get a tight characterization of weighted CSP sparsifiablity, in terms of a parameter called the chain length, which was defined by Lagerkvist and Wahlström [LW17, LW20] in the context of CSP kernelization and later utilized by Bessiere, Carbonnel, and Katsirelos [BCK20] in the context of learning CSPs in a certain query model (see Section 1.5 for more details on these connections). As before, the result is obtained in the setting of weighted non-linear codes, with the consequence for weighted CSPs being an easy corollary. We just state the result for codes here (see Section 8 for the full treatment of weighted CSPs). For weighted sparsification of a code C⊆{0,1}m𝐶superscript01𝑚C\subseteq\{0,1\}^{m}italic_C ⊆ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, we might have an arbitrary input weighting ζ:[m]→ℝ≥0:𝜁→delimited-[]𝑚subscriptℝabsent0\zeta:[m]\to\mathbb{R}_{\geq 0}italic_ζ : [ italic_m ] → blackboard_R start_POSTSUBSCRIPT ≥ 0 end_POSTSUBSCRIPT of its coordinates, and we must find a sparsifier w~:[n]→ℝ≥0:~𝑤→delimited-[]𝑛subscriptℝabsent0\widetilde{w}:[n]\to\mathbb{R}_{\geq 0}over~ start_ARG italic_w end_ARG : [ italic_n ] → blackboard_R start_POSTSUBSCRIPT ≥ 0 end_POSTSUBSCRIPT of low support that sparsifies C𝐶Citalic_C with respect to the weighting ζ𝜁\zetaitalic_ζ, i.e., ⟨w~,c⟩∈(1±ε)⁢⟨ζ,c⟩~𝑤𝑐plus-or-minus1𝜀𝜁𝑐\langle\widetilde{w},c\rangle\in(1\pm\varepsilon)\langle\zeta,c\rangle⟨ over~ start_ARG italic_w end_ARG , italic_c ⟩ ∈ ( 1 ± italic_ε ) ⟨ italic_ζ , italic_c ⟩. The minimum possible support of sparsifiers over all weightings ζ𝜁\zetaitalic_ζ is called the weighted ε𝜀\varepsilonitalic_ε-sparsity wSPR⁡(C,ε)wSPR𝐶𝜀\operatorname{wSPR}(C,\varepsilon)roman_wSPR ( italic_C , italic_ε ). Now we define chain length. If we line up the codewords of C𝐶Citalic_C as rows of an |C|×m𝐶𝑚|C|\times m| italic_C | × italic_m matrix and allow arbitrary column permutations, the chain length of C𝐶Citalic_C, denoted CL⁡(C)CL𝐶\operatorname{CL}(C)roman_CL ( italic_C ), is the dimension of the largest upper triangular square submatrix with 1111’s on the diagonal.555In this view NRD⁡(C)NRD𝐶\operatorname{NRD}(C)roman_NRD ( italic_C ) is the dimension of the largest identity submatrix, so clearly NRD⁡(C)≤CL⁡(C)NRD𝐶CL𝐶\operatorname{NRD}(C)\leq\operatorname{CL}(C)roman_NRD ( italic_C ) ≤ roman_CL ( italic_C ). The quantity CL⁡(C)CL𝐶\operatorname{CL}(C)roman_CL ( italic_C ) was called visible rank in [AG21] and served as a field independent lower bound on the rank of C𝐶Citalic_C. In our main result for the weighted setting, we pin the sparsifiability of a weighted code to its chain length. Note that in the weighted case CL⁡(C)CL𝐶\operatorname{CL}(C)roman_CL ( italic_C ) is also a lower bound. Theorem 1.4. For all C⊆{0,1}m𝐶superscript01𝑚C\subseteq\{0,1\}^{m}italic_C ⊆ { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT and ε∈(0,1)𝜀01\varepsilon\in(0,1)italic_ε ∈ ( 0 , 1 ), we have CL⁡(C)≤wSPR⁡(C,ε)=O⁢(CL⁡(C)⁢(log⁡m)6/ε2).CL𝐶wSPR𝐶𝜀𝑂CL𝐶superscript𝑚6superscript𝜀2\operatorname{CL}(C)\leq\operatorname{wSPR}(C,\varepsilon)=O(\operatorname{CL}% (C)(\log m)^{6}/\varepsilon^{2}).roman_CL ( italic_C ) ≤ roman_wSPR ( italic_C , italic_ε ) = italic_O ( roman_CL ( italic_C ) ( roman_log italic_m ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_ε start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . The upper bound proceeds by using Theorem 1.1 as a black-box together with a geometric weight bucketing technique from [KPS24b]. The lower bound proceeds by applying an exponential sequence of weights to the indices i1,…,iCL⁡(C)∈[m]subscript𝑖1…subscript𝑖CL𝐶delimited-[]𝑚i_{1},\ldots,i_{\operatorname{CL}{(C)}}\in[m]italic_i start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_i start_POSTSUBSCRIPT roman_CL ( italic_C ) end_POSTSUBSCRIPT ∈ [ italic_m ] forming a maximal chain. Of note, if for a particular set of weights, the ratio between maximum and minimal weights is λ≪exp⁡(CL⁡(C)/NRD⁡(C))much-less-than𝜆CL𝐶NRD𝐶\lambda\ll\exp(\operatorname{CL}(C)/\operatorname{NRD}(C))italic_λ ≪ roman_exp ( roman_CL ( italic_C ) / roman_NRD ( italic_C ) ), we get a sharper upper bound of O~ε⁢(NRD⁡(C)⁢log⁡λ)subscript~𝑂𝜀NRD𝐶𝜆\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\log\lambda)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log italic_λ ) (see Corollary 8.18). We now transition to discussing the broader context of our work in the literature. 1.5 Related Work Our results and techniques have connections to many areas including computational complexity theory, extremal combinatorics, coding theory, and learning theory. We now give a general overview of these connections. CSP Sparsification. Since we already discussed the history of CSP sparsification, we give a comprehensive list of known results about CSP sparsification (up to polylog factors). • The case of binary CSPs (r=2𝑟2r=2italic_r = 2) is fully classified. In particular, for every finite domain D𝐷Ditalic_D and R⊆D2𝑅superscript𝐷2R\subseteq D^{2}italic_R ⊆ italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, we either have that SPR⁡(R,n,ε)=O⁢(n/ε2)SPR𝑅𝑛𝜀𝑂𝑛superscript𝜀2\operatorname{SPR}(R,n,\varepsilon)=O(n/\varepsilon^{2})roman_SPR ( italic_R , italic_n , italic_ε ) = italic_O ( italic_n / italic_ε start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) or SPR⁡(R,n,ε)=Ω⁢(n2)SPR𝑅𝑛𝜀Ωsuperscript𝑛2\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{2})roman_SPR ( italic_R , italic_n , italic_ε ) = roman_Ω ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) [BŽ20]. However, the sparsification routine is only efficient in the Boolean case [FK17]. Of note, SPR⁡(R,n,ε)=Ω⁢(n2)SPR𝑅𝑛𝜀Ωsuperscript𝑛2\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{2})roman_SPR ( italic_R , italic_n , italic_ε ) = roman_Ω ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) if and only if there exist D1,D2⊆Dsubscript𝐷1subscript𝐷2𝐷D_{1},D_{2}\subseteq Ditalic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ⊆ italic_D of size exactly 2222 such that |R∩(D1×D2)|=1𝑅subscript𝐷1subscript𝐷21|R\cap(D_{1}\times D_{2})|=1| italic_R ∩ ( italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) | = 1 (informally R𝑅Ritalic_R has an “induced copy” of AND2subscriptAND2\operatorname{AND}_{2}roman_AND start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT). • For r≥3𝑟3r\geq 3italic_r ≥ 3, much less is known. Kogan and Krauthgamer [KK15] contributed near-linear hypergraph cut sparsifiers (i.e., the predicate is NAEr:={0,1}r∖{0r,1r}assignsubscriptNAE𝑟superscript01𝑟superscript0𝑟superscript1𝑟\operatorname{NAE}_{r}:=\{0,1\}^{r}\setminus\{0^{r},1^{r}\}roman_NAE start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT := { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ∖ { 0 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT , 1 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT }). Since then, there have been multiple improvements in efficiently constructing hypergraph sparsifiers/sketches (e.g., [CKN20, KKTY21, KPS24c]). • The breakthroughs of Khanna, Putterman, and Sudan [KPS24a, KPS24b] construct non-linear sparsifiers for any predicate which can defined by a system of linear (in)equations (possibly over a higher domain). For example NAEr={x∈{0,1}r:x1+⋯+xr≢0modr}subscriptNAE𝑟conditional-set𝑥superscript01𝑟not-equivalent-tosubscript𝑥1⋯subscript𝑥𝑟modulo0𝑟\operatorname{NAE}_{r}=\{x\in\{0,1\}^{r}:x_{1}+\cdots+x_{r}\not\equiv 0\mod r\}roman_NAE start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT = { italic_x ∈ { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT : italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + ⋯ + italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ≢ 0 roman_mod italic_r }. Of note, their first paper [KPS24a] only proved the result over finite fields (and was nonalgorithmic), whereas their second paper [KPS24b] extended the result to all Abelian groups and was computationally efficient. • The framework of Khanna, Putterman, and Sudan [KPS24b] produced numerous corollaries. In particular, if a predicate can be expressed as the nonzero set of a degree k𝑘kitalic_k polynomial, then it has a sparsifier of size O~ε⁢(nk)subscript~𝑂𝜀superscript𝑛𝑘\widetilde{O}_{\varepsilon}(n^{k})over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). Furthermore, they show if a predicate R𝑅Ritalic_R can express666More specifically, we say that R⊆{0,1}r𝑅superscript01𝑟R\subseteq\{0,1\}^{r}italic_R ⊆ { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT can express ANDksubscriptAND𝑘\operatorname{AND}_{k}roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT if there exits a map z:[r]→{0,1,x1,…,xk,x1¯,…,xk¯}:𝑧→delimited-[]𝑟01subscript𝑥1…subscript𝑥𝑘¯subscript𝑥1…¯subscript𝑥𝑘z:[r]\to\{0,1,x_{1},\ldots,x_{k},\overline{x_{1}},\ldots,\overline{x_{k}}\}italic_z : [ italic_r ] → { 0 , 1 , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT , over¯ start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_ARG , … , over¯ start_ARG italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT end_ARG } such that R⁢(z⁢(1),…,z⁢(r))=ANDk⁡(x1,…,xk)𝑅𝑧1…𝑧𝑟subscriptAND𝑘subscript𝑥1…subscript𝑥𝑘R(z(1),\ldots,z(r))=\operatorname{AND}_{k}(x_{1},\ldots,x_{k})italic_R ( italic_z ( 1 ) , … , italic_z ( italic_r ) ) = roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ). We discuss a more general framework of gadget reductions in Section 5.4. ANDk:={1k}assignsubscriptAND𝑘superscript1𝑘\operatorname{AND}_{k}:=\{1^{k}\}roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT := { 1 start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT }, then SPR⁡(R,n,ε)=Ω⁢(nk)SPR𝑅𝑛𝜀Ωsuperscript𝑛𝑘\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{k})roman_SPR ( italic_R , italic_n , italic_ε ) = roman_Ω ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). As a consequence, they also classify all ternary Boolean predicates (r=3𝑟3r=3italic_r = 3) as well as which Boolean predicates of arity r𝑟ritalic_r cannot be sparsified below Ω⁢(nr)Ωsuperscript𝑛𝑟\Omega(n^{r})roman_Ω ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ) (just ANDrsubscriptAND𝑟\operatorname{AND}_{r}roman_AND start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT and its bit flips), while also constructing a sparsifier of size O~ε⁢(nr−1)subscript~𝑂𝜀superscript𝑛𝑟1\widetilde{O}_{\varepsilon}(n^{r-1})over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r - 1 end_POSTSUPERSCRIPT ) in the other cases. • It appears that lower bounds with a nontrivial dependence on ε𝜀\varepsilonitalic_ε are only known for cut sparsifiers (and thus hypergraph cut sparsifiers via a simple gadget reduction). See [ACK+16, CKST19] as well as Section 9 for further discussion. CSP Kernelization. Another question similar in spirit to CSP sparsification is that of CSP kernelization.777More commonly, CSP kernelization is referred to as CSP sparsification (e.g., [DvM14, LW20]). However, we refer to this line of work by the former name to reduce ambiguity. This similarity in name has been noted before in the literature (e.g., [BŽ20]), but we appear to be the first work to notice both variants of “CSP sparsification” can be analyzed with similar techniques. The basic question is to, given an instance ΨΨ\Psiroman_Ψ of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ), efficiently find as small of an instance Ψ′superscriptΨ′\Psi^{\prime}roman_Ψ start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) as possible (not necessarily a subinstance) such that ΨΨ\Psiroman_Ψ and Ψ′superscriptΨ′\Psi^{\prime}roman_Ψ start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT are either both satisfiable or both unsatisfiable. This particular question can be attributed to Dell and van Melkebeek [DvM14], who were particularly inspired Impagliazzo, Paturi, and Zane’s sparsification lemma [IPZ01] and Harnik and Naor’s compression framework [HN10]. See the literature review in [DvM14] for further motivations. At first, the problem seems rather unrelated to CSP sparsification. For example, if CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) is polynomial-time tractable, then there trivially exists a kernel of size O⁢(1)𝑂1O(1)italic_O ( 1 ). When CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) is NP-hard, however, the size of the smallest possible kernelization seems to much more closely track with the non-redundancy of R𝑅Ritalic_R. In particular, Dell and van Melkebeek [DvM14], proved that assuming 𝖼𝗈𝖭𝖯⊈𝖭𝖯/𝗉𝗈𝗅𝗒not-subset-of-nor-equals𝖼𝗈𝖭𝖯𝖭𝖯𝗉𝗈𝗅𝗒\mathsf{coNP}\nsubseteq\mathsf{NP/poly}sansserif_coNP ⊈ sansserif_NP / sansserif_poly, the problem k𝑘kitalic_k-SAT cannot be kernelized below Ω⁢(nk−ε)Ωsuperscript𝑛𝑘𝜀\Omega(n^{k-\varepsilon})roman_Ω ( italic_n start_POSTSUPERSCRIPT italic_k - italic_ε end_POSTSUPERSCRIPT ) for any constant ε>0𝜀0\varepsilon>0italic_ε > 0, which is close to k𝑘kitalic_k-SAT’s non-redundancy of Θ⁢(nk)Θsuperscript𝑛𝑘\Theta(n^{k})roman_Θ ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). Furthermore, most upper bounds on the kernelization of NP-hard predicates follow from upper bounds on non-redundancy (see [Car22]). For example the works of Chen, Jansen, and Pieterse [CJP20] as well as Lagerkvist and Wahlström [LW17, LW20] develop various kernelization methods that happen to just be “efficient” non-redundancy upper bounds. For example, these works show that if the predicate R𝑅Ritalic_R can be expressed as the zero set of a polynomial of degree k𝑘kitalic_k, then there exist a kernel of size O⁢(nk)𝑂superscript𝑛𝑘O(n^{k})italic_O ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). This kernel happens to preserve every solution to R𝑅Ritalic_R, so it is also a non-redundancy upper bound. Using techniques like these, they are able to prove a number of results similar to the state-of-the-art in CSP sparsification, such as a complete classification of ternary Boolean predicates and a O⁢(nr−1)𝑂superscript𝑛𝑟1O(n^{r-1})italic_O ( italic_n start_POSTSUPERSCRIPT italic_r - 1 end_POSTSUPERSCRIPT ) vs Ω⁢(nr−ε)Ωsuperscript𝑛𝑟𝜀\Omega(n^{r-\varepsilon})roman_Ω ( italic_n start_POSTSUPERSCRIPT italic_r - italic_ε end_POSTSUPERSCRIPT ) Boolean dichotomy [CJP20]. See [JP19, JW20, Jan20, Tak23, Beu21] and citations therein for related work. We seek to emphasize that any efficient CSP sparsification algorithm for CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) is by design a kernelization algorithm for CSP⁡(R¯)CSP¯𝑅\operatorname{CSP}(\overline{R})roman_CSP ( over¯ start_ARG italic_R end_ARG ) (since all codewords with weight 00 are preserved). As such, making Theorem 1.2 efficient would require explicitly proving that every CSP can be kernelized to (approximately) its non-redundancy, which is a significant open question in the CSP kernelization community (see [Car22]). See Section 1.7 and Section 9 for further discussion. The Union-closed Sets Conjecture. A family ℱℱ\mathcal{F}caligraphic_F of subsets of [n]delimited-[]𝑛[n][ italic_n ] is union-closed if A,B∈ℱ𝐴𝐵ℱA,B\in\mathcal{F}italic_A , italic_B ∈ caligraphic_F imply that A∪B∈ℱ𝐴𝐵ℱA\cup B\in\mathcal{F}italic_A ∪ italic_B ∈ caligraphic_F. In 1979, Frankl [Fra95] conjectured that there always exists i∈[n]𝑖delimited-[]𝑛i\in[n]italic_i ∈ [ italic_n ] which appears in at least half of the sets of ℱℱ\mathcal{F}caligraphic_F. For decades, progress on the conjecture was minimal, with the best general result being that some i∈[n]𝑖delimited-[]𝑛i\in[n]italic_i ∈ [ italic_n ] appears in Ω⁢(1/log2⁡|ℱ|)Ω1subscript2ℱ\Omega(1/\log_{2}|\mathcal{F}|)roman_Ω ( 1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | caligraphic_F | ) of the sets [Kni94, Wój99, Gil22]. However, in 2022, Gilmer [Gil22] shocked the combinatorics community by using an entropy-based approach to prove that some i∈[n]𝑖delimited-[]𝑛i\in[n]italic_i ∈ [ italic_n ] appears in 1/10011001/1001 / 100 of the sets. This immediately led to a large number of follow-up works refining Gilmer’s entropy method [AHS22, CL22, Peb22, Saw23, Yu23, Cam22]. In particular, we can now replace ‘1/10011001/1001 / 100’ with ‘0.382⁢…0.382…0.382\ldots0.382 …’, leaving Frankl’s conjecture (technically) still open. For our application to CSP sparsification, the entropy method used by Gilmer (and its subsequent refinements by many other reseachers) is the key idea needed to show that non-redundancy is essentially the optimal size for a CSP sparsifier. In particular, the improvement from 1/log2⁡|ℱ|1subscript2ℱ1/\log_{2}|\mathcal{F}|1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | caligraphic_F | to Ω⁢(1)Ω1\Omega(1)roman_Ω ( 1 ) is precisely the same “gain” we utilize to go from a very simple O~ε⁢(NRD⁡(C)⋅log2⁡|C|)subscript~𝑂𝜀⋅NRD𝐶subscript2𝐶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\cdot\log_{2}|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ⋅ roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C | ) sparsifier (see Section 3) to our O~ε⁢(NRD⁡(C))subscript~𝑂𝜀NRD𝐶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C))over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ) sparsifier. See the technical overview (Section 1.6) for more details. To the best of our knowledge, our work is the first application of Gilmer’s entropy method to sparsification.888Gilmer’s breakthough is cited in the literature review of [CDL+24], but the property-testing question they study on union-closed families has no technical connection to Gilmer’s entropy method. See also [Wak24] for applications of the entropy method to learning theory and statistical physics. Matching Vector Families and Locally Decodable Codes. In coding theory, locally decodable codes (LDCs) are a class of codes which allow for jthe reliable recovery of any message symbol based on a small sample of codeword symbols, even in the presence of a constant fraction of errors. A particularly interesting familiy of constructions of LDCs has arisen out of a theory of matching vector codes [Yek08] and follow-ups [Rag07, Gop09, Efr09, DGY11]. See [DGY11] for a literature survey. Simply stated, a matching vector (MV) family over a (finite) ring ℛℛ\mathcal{R}caligraphic_R is a pair of lists of vectors u1,…,uk,v1,…,vk∈ℛdsubscript𝑢1…subscript𝑢𝑘subscript𝑣1…subscript𝑣𝑘superscriptℛ𝑑u_{1},\ldots,u_{k},v_{1},\ldots,v_{k}\in\mathcal{R}^{d}italic_u start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_u start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_v start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ∈ caligraphic_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT such that the inner products ⟨ui,vj⟩subscript𝑢𝑖subscript𝑣𝑗\langle u_{i},v_{j}\rangle⟨ italic_u start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ⟩ are nonzero999Or, more generally the inner products lie in some restricted subset of ℛℛ\mathcal{R}caligraphic_R. if and only i≠j𝑖𝑗i\neq jitalic_i ≠ italic_j. Informally, the uisubscript𝑢𝑖u_{i}italic_u start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT’s play a role in the encoding of the i𝑖iitalic_i’th message symbol, with the matching vector visubscript𝑣𝑖v_{i}italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT helping with its local decoding. Given a choice of ℛℛ\mathcal{R}caligraphic_R and d𝑑ditalic_d, the primary question of interest is to find the maximal possible value of k𝑘kitalic_k. This “spin off” question about LDCs has become a topic of interest in its own right [DGY11, Yek12, GHSY12, BDL13]. In this work, we demonstrate a novel application of matching vector families to the study of non-redundancy and thus (by Theorem 1.2) sparsification. In particular, we construct an explicit family of predicates such that their non-redundant instances can be viewed as a generalized MV family. We then use techniques developed for MV families to given nontrivial bounds on the non-redundancy of the predicates. See Section 6 and the technical overview (Section 1.6) for more details. Extremal Combinatorics. Computing the non-redundancy of a predicate can be viewed as a problem in extremal combinatorics known as a hypergraph Turán problem. In particular, for an instance of a CSP to be non-redundant, every instance induced by a subset of the variables must also be non-redundant. In particular, if ℱℱ\mathcal{F}caligraphic_F is a family of hypergraphs which can never appear in non-redundant instances of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ), then NRD⁡(R,n)≤exr⁡(n,ℱ)NRD𝑅𝑛subscriptex𝑟𝑛ℱ\operatorname{NRD}(R,n)\leq\operatorname{ex}_{r}(n,\mathcal{F})roman_NRD ( italic_R , italic_n ) ≤ roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ), where the hypergraph Turán number exr⁡(n,ℱ)subscriptex𝑟𝑛ℱ\operatorname{ex}_{r}(n,\mathcal{F})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) is the size of the largest r𝑟ritalic_r-uniform hypergraph on n𝑛nitalic_n vertices without any F∈ℱ𝐹ℱF\in\mathcal{F}italic_F ∈ caligraphic_F as a subgraph. This observation was first made explicit by Carbonnel [Car22] although the technique was also used in earlier work [BCK20]. As far as we are aware, ours is the first work to observe that these insights can also benefit the study of CSP sparsification. The literature on hypergraph Turán numbers is quite rich. For instance, Keevash [Kee11] surveys the vast body of work on the “non-degenerate” case in which exr⁡(n,ℱ)=Ωr⁢(nr)subscriptex𝑟𝑛ℱsubscriptΩ𝑟superscript𝑛𝑟\operatorname{ex}_{r}(n,\mathcal{F})=\Omega_{r}(n^{r})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) = roman_Ω start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ). However, for our applications, we are mostly interested in the “denegerate” case in which exr⁡(n,ℱ)=O⁢(nc)subscriptex𝑟𝑛ℱ𝑂superscript𝑛𝑐\operatorname{ex}_{r}(n,\mathcal{F})=O(n^{c})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) = italic_O ( italic_n start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT ) for some c∈[1,r)𝑐1𝑟c\in[1,r)italic_c ∈ [ 1 , italic_r ). The works [BCK20, Car22] apply some of the most well-known works in this setting [Erd64, SEB73, RS78] to get some nontrivial results such as classifying precisely which predicates R𝑅Ritalic_R have NRD⁡(R,n)=Θ⁢(nr)NRD𝑅𝑛Θsuperscript𝑛𝑟\operatorname{NRD}(R,n)=\Theta(n^{r})roman_NRD ( italic_R , italic_n ) = roman_Θ ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ), extending Chen, Jansen, and Pieterse’s result for the Boolean case [CJP20]. See Sections 5.2, 7.1, and 8.4.2 for more details on specific applications. Query Complexity and Learning Theory. Rather surprisingly, the definition of non-redundancy appears to have come out of the artificial intelligence community [BCK20]. In particular, a rather broad and well-studied question (e.g., [FW02, PBS08, LLMV10, BK12, BCH+13, BCK20]) is that of constraint acquisition: how can an agent learn the constraints defining an instance of a constraint satisfaction problem? A model specifically relevant to our work is the partial membership queries model studied by Bessiere, Carbonnel, and Katsirelos [BCK20]. In this model, the domain D𝐷Ditalic_D, the constraint type R𝑅Ritalic_R (or types), and the set of variables X𝑋Xitalic_X are known but the constraints are hidden. For each query, the agent picks some subset of variables X′⊆Xsuperscript𝑋′𝑋X^{\prime}\subseteq Xitalic_X start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT ⊆ italic_X as well as a partial assignment σ:X′→D:𝜎→superscript𝑋′𝐷\sigma:X^{\prime}\to Ditalic_σ : italic_X start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT → italic_D. The response to the query is ‘YES’ if σ𝜎\sigmaitalic_σ satisfies every constraint induced by X′superscript𝑋′X^{\prime}italic_X start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT, and ‘NO’ otherwise. The goal is to construct an instance of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) with the same solution set as the hidden CSP. For every CSP predicate R𝑅Ritalic_R, they prove that the query complexity of an instance of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) on n𝑛nitalic_n variables is bounded between Ω⁢(NRD⁡(R,n))ΩNRD𝑅𝑛\Omega(\operatorname{NRD}(R,n))roman_Ω ( roman_NRD ( italic_R , italic_n ) ) and O⁢(CL⁡(R,n)⋅log⁡n)𝑂⋅CL𝑅𝑛𝑛O(\operatorname{CL}(R,n)\cdot\log n)italic_O ( roman_CL ( italic_R , italic_n ) ⋅ roman_log italic_n ). Notably, the lower bound is proved by showing that the VC dimension of the query complexity problem equals NRD⁡(R,n)NRD𝑅𝑛\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ).101010This observation is directly used in proving our main result, see Section 4.1. 1.6 Technical Overview We next describe the primary techniques we use to prove Theorem 1.1 and Theorem 1.3. A Simple Sparsifier. To begin, we discuss a warm-up version of Theorem 1.1 which proves a weaker upper bound of SPR⁡(C,ε)≤O~ε⁢(NRD⁡(C)⋅log⁡|C|)SPR𝐶𝜀subscript~𝑂𝜀⋅NRD𝐶𝐶\operatorname{SPR}(C,\varepsilon)\leq\widetilde{O}_{\varepsilon}(\operatorname% {NRD}(C)\cdot\log|C|)roman_SPR ( italic_C , italic_ε ) ≤ over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ⋅ roman_log | italic_C | ) (see Theorem 3.1), which for CSPs corresponds to an extra factor of the number of variables n𝑛nitalic_n. The key technical insight (Lemma 3.3) is that for all d∈[m]𝑑delimited-[]𝑚d\in[m]italic_d ∈ [ italic_m ], the set of codewords of C𝐶Citalic_C with Hamming weight at most d𝑑ditalic_d (denoted by C≤dsubscript𝐶absent𝑑C_{\leq d}italic_C start_POSTSUBSCRIPT ≤ italic_d end_POSTSUBSCRIPT) has total support size at most d⋅NRD⁡(C)⋅𝑑NRD𝐶d\cdot\operatorname{NRD}(C)italic_d ⋅ roman_NRD ( italic_C ). This can proved inductively by noticing that dropping a suitable non-redundant set of coordinates decreases the Hamming weight of every codeword of C𝐶Citalic_C by at least one. With this lemma, we can recursively construct a sparsifier as follows, similar to the divide-and-conquer framework in [KPS24a, KPS24b] for linear codes. Pick d≈Θ~ε⁢(log⁡|C|)𝑑subscript~Θ𝜀𝐶d\approx\widetilde{\Theta}_{\varepsilon}(\log|C|)italic_d ≈ over~ start_ARG roman_Θ end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_log | italic_C | ) and let I⊆[m]𝐼delimited-[]𝑚I\subseteq[m]italic_I ⊆ [ italic_m ] be the support of C≤dsubscript𝐶absent𝑑C_{\leq d}italic_C start_POSTSUBSCRIPT ≤ italic_d end_POSTSUBSCRIPT. Every i∈I𝑖𝐼i\in Iitalic_i ∈ italic_I is given weight 1111 in our sparsifier. For the rest of [m]delimited-[]𝑚[m][ italic_m ], let J⊆[m]∖I𝐽delimited-[]𝑚𝐼J\subseteq[m]\setminus Iitalic_J ⊆ [ italic_m ] ∖ italic_I be a subsample where each i∈[m]∖I𝑖delimited-[]𝑚𝐼i\in[m]\setminus Iitalic_i ∈ [ italic_m ] ∖ italic_I is kept independently with probability 1/3131/31 / 3. Using a standard Chernoff bound, we can show that with positive111111We only need positive probability since we are focused on existence. This can easily be amplified to 1−1/mΩ⁢(1)11superscript𝑚Ω11-1/m^{\Omega(1)}1 - 1 / italic_m start_POSTSUPERSCRIPT roman_Ω ( 1 ) end_POSTSUPERSCRIPT probability by making d𝑑ditalic_d a factor of log⁡m𝑚\log mroman_log italic_m bigger. In applications to CSPs, the main algorithmic bottleneck is (approximately) finding I𝐼Iitalic_I, which appears to be similar in difficulty to an open problem in CSP kernelization (see Section 1.7). probability the following holds for all c∈C𝑐𝐶c\in Citalic_c ∈ italic_C: 3⁢Ham⁡(c|J)+Ham⁡(c|I)∈[1−ε2⁢log2⁡m,1+ε2⁢log2⁡m]⋅Ham⁡(c).3Hamevaluated-at𝑐𝐽Hamevaluated-at𝑐𝐼⋅1𝜀2subscript2𝑚1𝜀2subscript2𝑚Ham𝑐3\operatorname{Ham}(c|_{J})+\operatorname{Ham}(c|_{I})\in\left[1-\frac{% \varepsilon}{2\log_{2}m},1+\frac{\varepsilon}{2\log_{2}m}\right]\cdot% \operatorname{Ham}(c).3 roman_Ham ( italic_c | start_POSTSUBSCRIPT italic_J end_POSTSUBSCRIPT ) + roman_Ham ( italic_c | start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT ) ∈ [ 1 - divide start_ARG italic_ε end_ARG start_ARG 2 roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m end_ARG , 1 + divide start_ARG italic_ε end_ARG start_ARG 2 roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m end_ARG ] ⋅ roman_Ham ( italic_c ) . By induction, we can find a O~ε′⁢(NRD⁡(C′)⋅log⁡|C′|)subscript~𝑂superscript𝜀′⋅NRDsuperscript𝐶′superscript𝐶′\widetilde{O}_{\varepsilon^{\prime}}(\operatorname{NRD}(C^{\prime})\cdot\log|C% ^{\prime}|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( roman_NRD ( italic_C start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT ) ⋅ roman_log | italic_C start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT | ) ε′superscript𝜀′\varepsilon^{\prime}italic_ε start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT-sparsifier for C′:=C|Jassignsuperscript𝐶′evaluated-at𝐶𝐽C^{\prime}:=C|_{J}italic_C start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT := italic_C | start_POSTSUBSCRIPT italic_J end_POSTSUBSCRIPT with ε′:=(1−1/log2⁡m)⁢εassignsuperscript𝜀′11subscript2𝑚𝜀\varepsilon^{\prime}:=(1-1/\log_{2}m)\varepsilonitalic_ε start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT := ( 1 - 1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m ) italic_ε. Scaling this sparsifier by 3333 and adding weights for I𝐼Iitalic_I gives us an ε𝜀\varepsilonitalic_ε-sparsifier of C𝐶Citalic_C. Entropy-based Sparsification. The key inefficiency of the O~ε⁢(NRD⁡(C)⋅log⁡|C|)subscript~𝑂𝜀⋅NRD𝐶𝐶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\cdot\log|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ⋅ roman_log | italic_C | ) bound is that the use of Lemma 3.3 is too conservative. For the purposes of this overview, assume that all codewords of C𝐶Citalic_C have the same Hamming weight d≈NRD⁡(C)𝑑NRD𝐶d\approx\operatorname{NRD}(C)italic_d ≈ roman_NRD ( italic_C ) as that is is the most representative case. Naively, Lemma 3.3 says we should set aside d2superscript𝑑2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT coordinates of [m]delimited-[]𝑚[m][ italic_m ] to “sparsify” all codewords of weight d𝑑ditalic_d. However, we can give a heuristic argument that far fewer than d2superscript𝑑2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT of these potential coordinates contain useful information for our sparsifier. Assume without loss of generality that the support of C𝐶Citalic_C lies in [d2]delimited-[]superscript𝑑2[d^{2}][ italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ]. For each i∈[d2]𝑖delimited-[]superscript𝑑2i\in[d^{2}]italic_i ∈ [ italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ], let pisubscript𝑝𝑖p_{i}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT be the probability that a codeword c∈C𝑐𝐶c\in Citalic_c ∈ italic_C selected uniformly at random has ci=1subscript𝑐𝑖1c_{i}=1italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = 1. Since each codeword of C𝐶Citalic_C has Hamming weight d𝑑ditalic_d, we have that p1+⋯+pd2=dsubscript𝑝1⋯subscript𝑝superscript𝑑2𝑑p_{1}+\cdots+p_{d^{2}}=ditalic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + ⋯ + italic_p start_POSTSUBSCRIPT italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUBSCRIPT = italic_d. Thus, the average value of pisubscript𝑝𝑖p_{i}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is 1/d1𝑑1/d1 / italic_d. Consider the case in which each pi=O⁢(1/d)subscript𝑝𝑖𝑂1𝑑p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ). In particular, no coordinate is distinguishing itself as a “must” to add to the sparsifier. A priori, the size of C𝐶Citalic_C may be exp⁡(Ω~⁢(d))~Ω𝑑\exp(\widetilde{\Omega}(d))roman_exp ( over~ start_ARG roman_Ω end_ARG ( italic_d ) ), so we cannot immediately use Chernoff bounds to analyze a random subsampling of the coordinates. To get around this issue, we need to prove a much stronger upper bound on the size of C𝐶Citalic_C, similar to Benczúr and Karger’s cut-counting bound [BK96] and its adaptation to linear codes [KPS24a, KPS24b]. However, we use an entirely new method for proving such bounds based on the entropy method Gilmer [Gil22] developed to prove the union-closed sets conjecture up to a constant factor. In our context, pick t=Θ~⁢(d)𝑡~Θ𝑑t=\widetilde{\Theta}(d)italic_t = over~ start_ARG roman_Θ end_ARG ( italic_d ) and sample uniformly and independently t𝑡titalic_t codewords c1,…,ct∈Csubscript𝑐1…subscript𝑐𝑡𝐶c_{1},\ldots,c_{t}\in Citalic_c start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_c start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ∈ italic_C. Let c𝑐citalic_c be the bitwise OR of these t𝑡titalic_t codewords, and let 𝒟𝒟\mathcal{D}caligraphic_D be the distribution of c𝑐citalic_c over {0,1}d2superscript01superscript𝑑2\{0,1\}^{d^{2}}{ 0 , 1 } start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT (recall that the weight d𝑑ditalic_d codewords are supported on d2superscript𝑑2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT coordinates). Since each pi=O⁢(1/d)subscript𝑝𝑖𝑂1𝑑p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ), by adapting Gilmer’s method (or more precisely, a refinement due to Sawin [Saw23]), we can show the entropy of 𝒟𝒟\mathcal{D}caligraphic_D is at least Θ~⁢(t)=Θ~⁢(d)~Θ𝑡~Θ𝑑\widetilde{\Theta}(t)=\widetilde{\Theta}(d)over~ start_ARG roman_Θ end_ARG ( italic_t ) = over~ start_ARG roman_Θ end_ARG ( italic_d ) times the entropy of the uniform distribution over C𝐶Citalic_C (i.e., log2⁡|C|subscript2𝐶\log_{2}|C|roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C |)–a similar inequality appears in [Wak24]. To apply this fact, observe that each sample of 𝒟𝒟\mathcal{D}caligraphic_D lies in the “OROR\operatorname{OR}roman_OR-closure” of C𝐶Citalic_C (denoted by spanOR⁡(C)subscriptspanOR𝐶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C )). As such, the entropy of 𝒟𝒟\mathcal{D}caligraphic_D is at most log⁡|spanOR⁡(C)|subscriptspanOR𝐶\log\lvert\operatorname{span}_{\operatorname{OR}}(C)\rvertroman_log | roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ) |, which by the Sauer-Shelah-Peres lemma is at most (up to log factors) the VC dimension of spanOR⁡(C)subscriptspanOR𝐶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ). It is easily seen that the VC dimension of spanOR⁡(C)subscriptspanOR𝐶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ) equals the non-redundancy of C𝐶Citalic_C [BCK20]. Therefore, we have proved that Θ~⁢(t)⋅log2⁡(C)≤O~⁢(NRD⁡(C))⋅~Θ𝑡subscript2𝐶~𝑂NRD𝐶\widetilde{\Theta}(t)\cdot\log_{2}(C)\leq\widetilde{O}(\operatorname{NRD}(C))over~ start_ARG roman_Θ end_ARG ( italic_t ) ⋅ roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_C ) ≤ over~ start_ARG italic_O end_ARG ( roman_NRD ( italic_C ) ). Since t≈d≈NRD⁡(C)𝑡𝑑NRD𝐶t\approx d\approx\operatorname{NRD}(C)italic_t ≈ italic_d ≈ roman_NRD ( italic_C ), C𝐶Citalic_C is actually at most quasipolynomial in size! Thus we can now use a Chernoff bound to prove that C𝐶Citalic_C can be subsampled to O~ε⁢(d)subscript~𝑂𝜀𝑑\widetilde{O}_{\varepsilon}(d)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( italic_d ) coordinates while approximately preserving all Hamming weights. Recall this discussion was purely about the “uniform” case pi=O⁢(1/d)subscript𝑝𝑖𝑂1𝑑p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ). In general, we apply minimax theorem to prove the following “skewed” versus “sparse” dichotomy (see Proposition 4.14): for every code C𝐶Citalic_C and parameter choice θ≥1𝜃1\theta\geq 1italic_θ ≥ 1 there is either a probability distribution 𝒫𝒫\mathcal{P}caligraphic_P over C𝐶Citalic_C for which each coordinate equals 1111 with probability at most 1/θ1𝜃1/\theta1 / italic_θ (i.e., 𝒫𝒫\mathcal{P}caligraphic_P is “θ𝜃\thetaitalic_θ-sparse”); or, there is a probability distribution 𝒬𝒬\mathcal{Q}caligraphic_Q over the coordinates of C𝐶Citalic_C such that for every (nonzero) c∈C𝑐𝐶c\in Citalic_c ∈ italic_C, we have that 𝒬𝒬\mathcal{Q}caligraphic_Q’s measure of supp⁡(c)supp𝑐\operatorname{supp}(c)roman_supp ( italic_c ) is at least 1/θ1𝜃1/\theta1 / italic_θ (i.e., 𝒬𝒬\mathcal{Q}caligraphic_Q is a “θ𝜃\thetaitalic_θ-cover.”) For a suitable choice of θ𝜃\thetaitalic_θ, we repeatedly apply Proposition 4.14 to recursively build the sparsifier: in the θ𝜃\thetaitalic_θ-sparse case, we use the entropy method to prove that a “small” number of codewords of C𝐶Citalic_C can be removed to put us in the θ𝜃\thetaitalic_θ-cover case (see Lemma 4.15); and in the θ𝜃\thetaitalic_θ-cover case, we sample from the θ𝜃\thetaitalic_θ-cover to get a coordinate to add to our sparsifier. This procedure culminates in showing that we can set aside O~ε⁢(NRD⁡(C))subscript~𝑂𝜀NRD𝐶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C))over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ) coordinates to have weight 1111 in our sparsifier with the remainder of the code being sufficiently sparse that subsampling can be used (Theorem 4.16). Note that the statement of Theorem 4.16 resembles the analogous decompositions for linear codes [KPS24a, KPS24b]. However, their method found all the coordinates to set aside in “one pass,” whereas we iteratively understand the dense and sparse structure of our non-linear code. With Theorem 4.16 in hand, we construct the sparsifier with a recursive argument similar to that of Theorem 3.1. As mentioned earlier, extended these ideas to weighted sparsification (Theorem 1.4) is relatively straightforward. We adapt a weight-binning argument of [KPS24b] by essentially computing an (unweighted) sparsifier for each group of coordinates that is similar in weight (within poly⁡(m)poly𝑚\operatorname{poly}(m)roman_poly ( italic_m )). We then analyze the aggregated size of these sparsifiers by comparing the sum of the non-redundancies of the groups of coordinates to the chain length of the code. Connections to Matching Vector Families. We now switch gears to briefly discussing the key ideas behind Theorem 1.3. Let G:=ℤ/3⁢ℤassign𝐺ℤ3ℤG:=\mathbb{Z}/3\mathbb{Z}italic_G := blackboard_Z / 3 blackboard_Z and recall that 3⁢L⁢I⁢NG={(x,y,z)∣x+y+z=0}subscript3LIN𝐺conditional-set𝑥𝑦𝑧𝑥𝑦𝑧0\operatorname{3LIN}_{G}=\{(x,y,z)\mid x+y+z=0\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = { ( italic_x , italic_y , italic_z ) ∣ italic_x + italic_y + italic_z = 0 } and 3⁢L⁢I⁢NG∗=3⁢L⁢I⁢NG∖{(0,0,0)}subscriptsuperscript3LIN𝐺subscript3LIN𝐺000\operatorname{3LIN}^{*}_{G}=\operatorname{3LIN}_{G}\setminus\{(0,0,0)\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ∖ { ( 0 , 0 , 0 ) }. It is well-known that since 3⁢L⁢I⁢NGsubscript3LIN𝐺\operatorname{3LIN}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT is an affine predicate, we have that NRD⁡(3⁢L⁢I⁢NG,n)=Θ⁢(n)NRDsubscript3LIN𝐺𝑛Θ𝑛\operatorname{NRD}(\operatorname{3LIN}_{G},n)=\Theta(n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) = roman_Θ ( italic_n ), which is much smaller than our bound on NRD⁡(3⁢L⁢I⁢NG∗,n)NRDsubscriptsuperscript3LIN𝐺𝑛\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ). As such, we prove that to understand the asymptotics of NRD⁡(3⁢L⁢I⁢NG∗,n)NRDsubscriptsuperscript3LIN𝐺𝑛\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) it suffices to look at specially-structured non-redundant instances. Recall that an instance Ψ:=(X,Y)assignΨ𝑋𝑌\Psi:=(X,Y)roman_Ψ := ( italic_X , italic_Y ) of CSP⁡(3⁢L⁢I⁢NG∗)CSPsubscriptsuperscript3LIN𝐺\operatorname{CSP}(\operatorname{3LIN}^{*}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) is non redundant if for every clause y∈Y𝑦𝑌y\in Yitalic_y ∈ italic_Y there is an assignment σysubscript𝜎𝑦\sigma_{y}italic_σ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT which satisfies every clause of ΨΨ\Psiroman_Ψ except y𝑦yitalic_y. We show that with at most an additive Θ⁢(n)Θ𝑛\Theta(n)roman_Θ ( italic_n ) change in size, we can assume that σysubscript𝜎𝑦\sigma_{y}italic_σ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT maps y𝑦yitalic_y to (0,0,0)000(0,0,0)( 0 , 0 , 0 ). In other words, each σysubscript𝜎𝑦\sigma_{y}italic_σ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT is a satisfying assignment to ΨΨ\Psiroman_Ψ when viewed as an instance of CSP⁡(3⁢L⁢I⁢NG)CSPsubscript3LIN𝐺\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) (see Proposition 6.3). This idea of “conditional” non-redundancy abstracts and generalizes an approach from [BCK20]. Since the set of solutions to an instance of CSP⁡(3⁢L⁢I⁢NG)CSPsubscript3LIN𝐺\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) form a vector space (of some dimension, say d𝑑ditalic_d) over 𝔽3subscript𝔽3\mathbb{F}_{3}blackboard_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT, we can think of each variable x∈X𝑥𝑋x\in Xitalic_x ∈ italic_X of ΨΨ\Psiroman_Ψ as a vector vx∈𝔽3dsubscript𝑣𝑥superscriptsubscript𝔽3𝑑v_{x}\in\mathbb{F}_{3}^{d}italic_v start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT ∈ blackboard_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT and the assignments as linear maps on the vectors. Because we are studying satisfying assignment to CSP⁡(3⁢L⁢I⁢NG)CSPsubscript3LIN𝐺\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ), these vectors are highly structured: for each y:=(x1,x2,x3)∈Yassign𝑦subscript𝑥1subscript𝑥2subscript𝑥3𝑌y:=(x_{1},x_{2},x_{3})\in Yitalic_y := ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ) ∈ italic_Y, we have that vx1+vx2+vx3=0subscript𝑣subscript𝑥1subscript𝑣subscript𝑥2subscript𝑣subscript𝑥30v_{x_{1}}+v_{x_{2}}+v_{x_{3}}=0italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT + italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT + italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = 0. Further, σysubscript𝜎𝑦\sigma_{y}italic_σ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT can be viewed as a linear map taking each of vx1,vx2,vx3subscript𝑣subscript𝑥1subscript𝑣subscript𝑥2subscript𝑣subscript𝑥3v_{x_{1}},v_{x_{2}},v_{x_{3}}italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_POSTSUBSCRIPT to 00, while mapping at least one vector in every other triple in Y𝑌Yitalic_Y to a nonzero value. We call this family of vectors together with these assignments a G𝐺Gitalic_G-ensemble (Definition 6.5), and note that it bears a strong resemblance to matching vector families. In particular, we adapt techniques used by Dvir, Gopalan, and Yekhanin [DGY11] for constraining the size of matching vector families to give nontrivial upper and lower bounds on the size of G𝐺Gitalic_G-ensembles. For the lower bound (Theorem 6.8), we directly construct a non-redundant instance with Ω⁢(n1.5)Ωsuperscript𝑛1.5\Omega(n^{1.5})roman_Ω ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) clauses. The proof is self-contained and elementary. The upper bound (Theorem 6.13) is slightly more technical. We break the proof into cases based on whether the embedding dimension d𝑑ditalic_d of the vectors is small (d=O~⁢(n0.4)𝑑~𝑂superscript𝑛0.4d=\widetilde{O}(n^{0.4})italic_d = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 0.4 end_POSTSUPERSCRIPT )) or large (d=Ω~⁢(n0.4)𝑑~Ωsuperscript𝑛0.4d=\widetilde{\Omega}(n^{0.4})italic_d = over~ start_ARG roman_Ω end_ARG ( italic_n start_POSTSUPERSCRIPT 0.4 end_POSTSUPERSCRIPT )). For small d𝑑ditalic_d, we adapt the polynomial method used in [DGY11] to prove there can be at most O⁢(d4)=O~⁢(n1.6)𝑂superscript𝑑4~𝑂superscript𝑛1.6O(d^{4})=\widetilde{O}(n^{1.6})italic_O ( italic_d start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) non-redundant clauses. On the other hand, when d𝑑ditalic_d is large, we ignore the assignments σysubscript𝜎𝑦\sigma_{y}italic_σ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT and use a careful induction (Lemma 6.11) to show that the geometry of the vectors imply that some x∈X𝑥𝑋x\in Xitalic_x ∈ italic_X is a member of at most O~⁢(n/d)=O~⁢(n0.6)~𝑂𝑛𝑑~𝑂superscript𝑛0.6\widetilde{O}(n/d)=\widetilde{O}(n^{0.6})over~ start_ARG italic_O end_ARG ( italic_n / italic_d ) = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 0.6 end_POSTSUPERSCRIPT ) clauses, thereby leading to a bound of at most O~⁢(n1.6)~𝑂superscript𝑛1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) clauses total. Closing the gap between Ω⁢(n1.5)Ωsuperscript𝑛1.5\Omega(n^{1.5})roman_Ω ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) and O~⁢(n1.6)~𝑂superscript𝑛1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) for NRD⁡(3⁢L⁢I⁢Nℤ/3⁢ℤ∗,n)NRDsuperscriptsubscript3LINℤ3ℤ𝑛\operatorname{NRD}(\operatorname{3LIN}_{\mathbb{Z}/3\mathbb{Z}}^{*},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT , italic_n ) is a tantalizing open question. 1.7 Open Questions We conclude the introduction with a few directions of further study. See Section 7 and Section 9 for a more thorough discussion of directions for future exploration. • Making Theorem 1.2 efficient. Note that the underlying construction for Theorem 1.1, if made algorithmic, runs in polynomial time with respect to the size of the code, yielding an exp⁡(O⁢(n))𝑂𝑛\exp(O(n))roman_exp ( italic_O ( italic_n ) )-time algorithm121212This is already nontrivial, as a naive guess-and-check algorithm would require exp⁡(O~⁢(NRD⁡(R¯,n)))~𝑂NRD¯𝑅𝑛\exp(\widetilde{O}(\operatorname{NRD}(\overline{R},n)))roman_exp ( over~ start_ARG italic_O end_ARG ( roman_NRD ( over¯ start_ARG italic_R end_ARG , italic_n ) ) ) time. for Theorem 1.2. The primary barrier in constructing our sparsifier in poly⁡(n)poly𝑛\operatorname{poly}(n)roman_poly ( italic_n ) time is the fact that an efficient sparsifier is also a kernelization algorithm, but kernelizing every CSP instance to its non-redundancy is a significant open question in the kernelization community [Car22]. • Computing NRD⁡(R,n)NRD𝑅𝑛\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ). For a general predicate R⊆Dr𝑅superscript𝐷𝑟R\subseteq D^{r}italic_R ⊆ italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT, there is no simple (even conjectured) expression for NRD⁡(R,n)NRD𝑅𝑛\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ). In fact, even determining when NRD⁡(R,n)=Θ⁢(n)NRD𝑅𝑛Θ𝑛\operatorname{NRD}(R,n)=\Theta(n)roman_NRD ( italic_R , italic_n ) = roman_Θ ( italic_n ) is an open question (e.g., [BCK20, Car22]). In Section 7, we explore a number of predicates from the various parts of the literature whose status is unresolved, including a predicate we categorize as the “simplest unresolved predicate.” • Non-redundancy versus Chain Length. Recall we show that unweighted sparsification is closely tied to non-redundancy while weighted sparsification is closely tied to chain length. For non-linear codes, NRDNRD\operatorname{NRD}roman_NRD and CLCL\operatorname{CL}roman_CL can be very different (e.g., Example 8.8), but the relationship for CSPs is unknown [BCK20, Car22]. In particular, it seems quite possible that there exists a CSP predicate R𝑅Ritalic_R for which wSPR⁡(R,n,ε)/SPR⁡(R,n,ε)=nΩ⁢(1).wSPR𝑅𝑛𝜀SPR𝑅𝑛𝜀superscript𝑛Ω1\operatorname{wSPR}(R,n,\varepsilon)/\operatorname{SPR}(R,n,\varepsilon)=n^{% \Omega(1)}.roman_wSPR ( italic_R , italic_n , italic_ε ) / roman_SPR ( italic_R , italic_n , italic_ε ) = italic_n start_POSTSUPERSCRIPT roman_Ω ( 1 ) end_POSTSUPERSCRIPT . • Average-case behavior. From Theorem 1.2, we know that every instance CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) has a sparsifier of size approximately its own non-redundancy, even if that value is much smaller than NRD⁡(R¯,n)NRD¯𝑅𝑛\operatorname{NRD}(\overline{R},n)roman_NRD ( over¯ start_ARG italic_R end_ARG , italic_n ). As such, it may be possible that ‘average’ instances of CSP⁡(R)CSP𝑅\operatorname{CSP}(R)roman_CSP ( italic_R ) admit sparsifiers much smaller than the worst case. 1.8 Organization In Section 2, we prove some basic facts about non-redundancy, sparsification and their relationship. In Section 3, we give a straightforward proof that SPR⁡(C,ε)=O~ε⁢(NRD⁡(C)⁢log2⁡|C|)SPR𝐶𝜀subscript~𝑂𝜀NRD𝐶subscript2𝐶\operatorname{SPR}(C,\varepsilon)=\widetilde{O}_{\varepsilon}(\operatorname{% NRD}(C)\log_{2}|C|)roman_SPR ( italic_C , italic_ε ) = over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_ε end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C | ). In Section 4, we prove Theorem 1.2 by connecting CSP sparsification to non-redundancy via Gilmer’s entropy method. In Section 5, we discuss the immediate applications of Theorem 1.2 based on what is known about non-redundancy in the literature. In Section 6, we bound the non-redundancy of a family of predicates via methods related to matching vector families. In Section 7, we give examples of CSP predicates in the literature whose non-redundancy is unresolved. In Section 8, we extend Theorem 1.2 to weighted instances. In Section 9, we wrap up with other directions of exploration. 1.9 Acknowledgments We thank Libor Barto, Dmitry Zhuk, Madhu Sudan, and Aaron Putterman for valuable conversations. This research was supported in part by a Simons Investigator award and NSF grant CCF-2211972."
https://arxiv.org/html/2411.03390v1,Six Candidates Suffice to Win a Voter Majority,"A cornerstone of social choice theory is Condorcet’s paradox which says that in an election where n𝑛nitalic_n voters rank m𝑚mitalic_m candidates it is possible that, no matter which candidate is declared the winner, a majority of voters would have preferred an alternative candidate. Instead, can we always choose a small committee of winning candidates that is preferred to any alternative candidate by a majority of voters?Elkind, Lang, and Saffidine raised this question and called such a committee a Condorcet winning set. They showed that winning sets of size 2222 may not exist, but sets of size logarithmic in the number of candidates always do. In this work, we show that Condorcet winning sets of size 6666 always exist, regardless of the number of candidates or the number of voters. More generally, we show that if α1−ln⁡α≥2k+1𝛼1𝛼2𝑘1\frac{\alpha}{1-\ln\alpha}\geq\frac{2}{k+1}divide start_ARG italic_α end_ARG start_ARG 1 - roman_ln italic_α end_ARG ≥ divide start_ARG 2 end_ARG start_ARG italic_k + 1 end_ARG, then there always exists a committee of size k𝑘kitalic_k such that less than an α𝛼\alphaitalic_α fraction of the voters prefer an alternate candidate. These are the first nontrivial positive results that apply for all k≥2𝑘2k\geq 2italic_k ≥ 2.Our proof uses the probabilistic method and the minimax theorem, inspired by recent work on approximately stable committee selection. We construct a distribution over committees that performs sufficiently well (when compared against any candidate on any small subset of the voters) so that this distribution must contain a committee with the desired property in its support.","Voting is a versatile model for the aggregation of individual preferences to reach a collective decision. Disparate situations, such as constituents choosing representatives, organizations hiring employees, judges choosing prize winners, and even friends choosing games to play, can all be understood as a group of voters choosing from a pool of candidates. Voting theory seeks to understand how winning candidates can be selected in a fair and representative manner. One of the longest known challenges with voting is Condorcet’s paradox, discovered by Nicolas de Condorcet around the French Revolution [dC85].111It is plausible that in early academic explorations of voting, 13th-century philosopher Ramon Llull had already discovered the possibility of this paradoxical situation [Llu83, HP00]. The paradox is that in an election where voters have ranked preferences over candidates, the preferences of the “majority” can be contradictory — no matter which candidate is declared the winner, a majority of the voters would have preferred another candidate. In fact, the contradiction can be even more dramatic, with “majority” replaced by a fraction arbitrarily close to 1. An illustrative example is when the voters have cyclic preferences as, for example, displayed in Table 1. v1subscript𝑣1v_{1}italic_v start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT v2subscript𝑣2v_{2}italic_v start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT v3subscript𝑣3v_{3}italic_v start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT v4subscript𝑣4v_{4}italic_v start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT v5subscript𝑣5v_{5}italic_v start_POSTSUBSCRIPT 5 end_POSTSUBSCRIPT v6subscript𝑣6v_{6}italic_v start_POSTSUBSCRIPT 6 end_POSTSUBSCRIPT 1 2 3 4 5 6 2 3 4 5 6 1 3 4 5 6 1 2 4 5 6 1 2 3 5 6 1 2 3 4 6 1 2 3 4 5 Table 1: An election where voters have cyclic preferences. The column headed with visubscript𝑣𝑖v_{i}italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT represents the i𝑖iitalic_ith voter’s ranking of the candidates (labeled 1,2,…,612…61,2,\dots,61 , 2 , … , 6 from top to bottom). For each candidate, another candidate is preferred by every voter except one. Though it is impossible to always find a single candidate that is always preferred over the others by a majority (called a Condorcet winner), one hope is that relaxations of this condition are still possible to achieve. A natural relaxation arises in the setting of committee selection, where rather than choosing a single winner, the goal is to choose a committee of k𝑘kitalic_k winners. For example, a political system may have districts with multiple representatives, organizations may make many hires at once, and friends might play more than one game in an evening. Another view is that committee selection can be used as an filtering step in a process with more than one round, like primaries or runoffs, choosing interviewees for a position, or nominations for a prize. In this context, Elkind, Lang, and Saffidine [ELS11, ELS15] asked: is it always possible to find a small committee of candidates such that no other candidate is preferred by a majority of voters over each member of the committee? They called this committee-analogue of a Condorcet winner a Condorcet winning set, and defined the Condorcet dimension of an election as the size of its smallest Condorcet winning set. For example, the election depicted in Table 1 has Condorcet dimension 2, since any pair of diametrically opposite candidates such as {3,6}36\{3,6\}{ 3 , 6 } would be a Condorcet winning set. More generally, [ELS15] raised the following question for an arbitrary threshold of α𝛼\alphaitalic_α in place of 1212\frac{1}{2}divide start_ARG 1 end_ARG start_ARG 2 end_ARG, and a target committee size k𝑘kitalic_k. Question 1 ([ELS15]). A committee S𝑆Sitalic_S is α𝛼\alphaitalic_α-undominated if for all candidates a∉S𝑎𝑆a\notin Sitalic_a ∉ italic_S, less than an α𝛼\alphaitalic_α fraction of voters prefer a𝑎aitalic_a over each member of S𝑆Sitalic_S. For what values of k∈ℤ+𝑘superscriptℤk\in\mathbb{Z}^{+}italic_k ∈ blackboard_Z start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT and α∈(0,1]𝛼01\alpha\in(0,1]italic_α ∈ ( 0 , 1 ] does every election have an α𝛼\alphaitalic_α-undominated committee of size k𝑘kitalic_k? In particular, we would like to know, for each k𝑘kitalic_k, what is the smallest α𝛼\alphaitalic_α for which α𝛼\alphaitalic_α-undominated committees of size k𝑘kitalic_k always exist (and, equivalently, for each α𝛼\alphaitalic_α, the smallest k𝑘kitalic_k such that these committees always exist). Condorcet’s paradox (or rather, its aformentioned generalization) shows that for k=1𝑘1k=1italic_k = 1 and any α𝛼\alphaitalic_α bounded away from 1, there are elections with no α𝛼\alphaitalic_α-undominated singleton candidates. For the threshold of α=12𝛼12\alpha=\frac{1}{2}italic_α = divide start_ARG 1 end_ARG start_ARG 2 end_ARG, [ELS15] constructed instances with Condorcet dimension 3 by taking the Kronecker product of two elections with cyclic preferences (see Table 3). This construction can be easily extended to give a lower bound of 2k+12𝑘1\frac{2}{k+1}divide start_ARG 2 end_ARG start_ARG italic_k + 1 end_ARG on the smallest α𝛼\alphaitalic_α such that there always exists an α𝛼\alphaitalic_α-undominated committee of size k𝑘kitalic_k (see Appendix B). They also showed that an election with m𝑚mitalic_m candidates has Condorcet dimension at most ⌈log2⁡m⌉subscript2𝑚\lceil\log_{2}m\rceil⌈ roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m ⌉; to see this, note that some candidate beats a majority of the other candidates, so we can iteratively add such a candidate to our committee and remove all the candidates that it beats. 1.1 Our Contributions We prove that every election has Condorcet dimension at most 6. This result is a corollary of our main theorem, which gives a nontrivial existence result for α𝛼\alphaitalic_α-undominated committees of size k≥2𝑘2k\geq 2italic_k ≥ 2. We note that the final result we prove (Theorem 5) is stronger, but we start with the approximation below as it is easier to get a handle on. (For a comparison, see Table 2.) Theorem 1. If α1−ln⁡α≥2k+1𝛼1𝛼2𝑘1\frac{\alpha}{1-\ln\alpha}\geq\frac{2}{k+1}divide start_ARG italic_α end_ARG start_ARG 1 - roman_ln italic_α end_ARG ≥ divide start_ARG 2 end_ARG start_ARG italic_k + 1 end_ARG, then in any election, there exists an α𝛼\alphaitalic_α-undominated committee of size k𝑘kitalic_k. For the specific threshold of α=12𝛼12\alpha=\frac{1}{2}italic_α = divide start_ARG 1 end_ARG start_ARG 2 end_ARG, Theorem 1 applies as long as k≥3+4⁢ln⁡2≈5.77𝑘3425.77k\geq 3+4\ln 2\approx 5.77italic_k ≥ 3 + 4 roman_ln 2 ≈ 5.77, and so any election has Condorcet dimension at most 6666 (which is not far from the lower bound of 3333). Taking k=2𝑘2k=2italic_k = 2, Theorem 1 implies that there always exists a pair of candidates such that no third candidate is preferred by more than roughly 80%percent8080\%80 % of the voters. Even replacing 80%percent8080\%80 % with 99%percent9999\%99 %, this was previously unknown. These results show that just by having a few winners instead of one, the most dramatic failures of Condorcet’s paradox are avoidable. We emphasize that these results hold for any election, regardless of the number of voters, the number of candidates, or the preferences that the voters have over candidates. Our starting point for proving Theorem 1 is the observation that 1 is closely linked to the problem of approximate stability in committee selection [JMW20]. The principle behind stability is that a subset of voters should have control over a subset of the committee of proportional size. That is, a committee of size k𝑘kitalic_k is stable (also referred to as in the core [Sca67, Fol70, FMS18]) if the fraction of voters that prefers any committee of size k′superscript𝑘′k^{\prime}italic_k start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT is less than k′ksuperscript𝑘′𝑘\frac{k^{\prime}}{k}divide start_ARG italic_k start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT end_ARG start_ARG italic_k end_ARG. We note that in this setting, voters have preferences over committees rather than candidates. This more expressive space of preferences gives it the power to model a wide variety of preference structures, such as approval voting and participatory budgeting. Unfortunately, in many settings, stable committees do not always exist. To remedy this, [JMW20] put forth the following approximate notion of stability, and showed the surprising result that for any monotone preference structure and any k𝑘kitalic_k, a 32323232-stable committee of size k𝑘kitalic_k exists. Definition 1 (Approximately stable committees [JMW20]). A committee S𝑆Sitalic_S of k𝑘kitalic_k candidates is c𝑐citalic_c-stable if for any committee S′superscript𝑆′S^{\prime}italic_S start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT of size k′superscript𝑘′k^{\prime}italic_k start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT, the fraction of voters that prefers S′superscript𝑆′S^{\prime}italic_S start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT over S𝑆Sitalic_S is less than c⋅k′k⋅𝑐superscript𝑘′𝑘c\cdot\frac{k^{\prime}}{k}italic_c ⋅ divide start_ARG italic_k start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT end_ARG start_ARG italic_k end_ARG. Consider the natural preference order over committees induced by rankings over candidates, where v𝑣vitalic_v prefers S′superscript𝑆′S^{\prime}italic_S start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT over S𝑆Sitalic_S if and only if she prefers her favorite candidate in S′superscript𝑆′S^{\prime}italic_S start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT over her favorite in S𝑆Sitalic_S. A simple observation (explained more fully in Appendix A) shows that a committee of size k𝑘kitalic_k is c𝑐citalic_c-stable if and only if it is ck𝑐𝑘\frac{c}{k}divide start_ARG italic_c end_ARG start_ARG italic_k end_ARG-undominated. For this ranked preference structure, the constant of 32323232 in the result of [JMW20] can be improved to 16161616 using the existence of stable lotteries for these preferences [CJMW20]. Then, as a black box, [JMW20] implies that 16k16𝑘\frac{16}{k}divide start_ARG 16 end_ARG start_ARG italic_k end_ARG-undominated committees of size k𝑘kitalic_k always exist, which in turn implies that we can always find Condorcet winning sets of size at most 32323232. Since this conclusion follows easily from [JMW20], we attribute the first constant upper bound on the size of Condorcet winning sets to their work. One can interpret the approximately stable committee problem as a version of 1 focused on the asymptotics of α𝛼\alphaitalic_α as the committee size k𝑘kitalic_k grows large. For this purpose, [JMW20] implies a result that is optimal up to a constant factor, but it says nothing nontrivial for committees of size at most 16161616. In contrast, Theorem 1 gives results even for k=2𝑘2k=2italic_k = 2, and outperforms the bound implied by [JMW20] for k≤1.75×104𝑘1.75superscript104k\leq 1.75\times 10^{4}italic_k ≤ 1.75 × 10 start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT, despite only implying the existence of O⁢(log⁡k)𝑂𝑘O(\log k)italic_O ( roman_log italic_k )-stable committees. Nonetheless, we show that our techniques can be applied to the asymptotic setting as well, giving an improvement over [JMW20]. Theorem 2. In any election, there exists a 9.8217k9.8217𝑘\frac{9.8217}{k}divide start_ARG 9.8217 end_ARG start_ARG italic_k end_ARG-undominated committee of size k𝑘kitalic_k. As a corollary, Theorem 2 implies the existence of 9.82179.82179.82179.8217-stable committees for preferences induced by rankings over candidates. We note that Theorem 2 improves Theorem 1 for k≥496𝑘496k\geq 496italic_k ≥ 496. 1.2 Technical Overview Our approach, building on [JMW20], is to first construct a particular distribution over committees of size k𝑘kitalic_k, and then to show that by sampling from this distribution, the resulting committee is α𝛼\alphaitalic_α-undominated in expectation. In fact, [ELS15]’s proof that the existence of O⁢(log⁡m)𝑂𝑚O(\log m)italic_O ( roman_log italic_m ) size Condorcet winning committees in elections with m𝑚mitalic_m candidates can also be viewed through this framework. There, we can consider the uniform distribution over candidates. To construct the committee, we sample from this distribution, remove the candidates that are beaten, and recurse on the remaining candidates. In expectation, half of the candidates are removed in each round, so the algorithm is likely to end with a committee of O⁢(log⁡m)𝑂𝑚O(\log m)italic_O ( roman_log italic_m ) candidates. The greedy algorithm of choosing the candidate that beats the most others in each round can be viewed as derandomization via conditional expectation. In this light, a natural approach to improving the O⁢(log⁡m)𝑂𝑚O(\log m)italic_O ( roman_log italic_m ) guarantee is to find a better distribution over committees. One of the insights in [JMW20] was to construct this distribution via the equilibrium of a zero-sum game. In the game, the defender chooses a committee S𝑆Sitalic_S of size k𝑘kitalic_k, and the attacker chooses a candidate a𝑎aitalic_a. After the choices are made, the defender pays the attacker a dollar for each voter that prefers a𝑎aitalic_a over all members of S𝑆Sitalic_S. The optimal strategy for the defender is to choose a committee randomly according to some distribution, which [JMW20] call the stable lottery. Then to create a committee of size k𝑘kitalic_k, [JMW20] take a recursive approach. First, they sample a committee S𝑆Sitalic_S of size k/2𝑘2k/2italic_k / 2, and show that ignoring the 25% of voters that least like S𝑆Sitalic_S, any candidate a𝑎aitalic_a is preferred over S𝑆Sitalic_S by less than a 8k8𝑘\frac{8}{k}divide start_ARG 8 end_ARG start_ARG italic_k end_ARG fraction of the voters (which are treated as an irrevocable loss). In the next step, they recurse on the ignored voters, sample a committee of size k/4𝑘4k/4italic_k / 4, and lose less than another 4k4𝑘\frac{4}{k}divide start_ARG 4 end_ARG start_ARG italic_k end_ARG fraction of the voters against any candidate a𝑎aitalic_a. The committee size and fraction of voters we lose continue to decrease exponentially, and in the end we have a committee of size k𝑘kitalic_k such that less than 16k16𝑘\frac{16}{k}divide start_ARG 16 end_ARG start_ARG italic_k end_ARG voters prefer any candidate a𝑎aitalic_a. To prove Theorem 1, we introduce three twists into this framework. Two are part of how we set up the zero-sum game in order to construct a distribution over committees that individual candidates perform poorly against (Lemma 1), and one is in how we show that in expectation, a random committee sampled from the distribution performs well (Lemma 2 and 4). Improving the game by confining the adversary. First, we modify the setup of the game so that the adversary must choose both a candidate a𝑎aitalic_a and a subset U𝑈Uitalic_U of an α𝛼\alphaitalic_α fraction of the voters. The adversary then only gets paid for the voters in U𝑈Uitalic_U that prefer a𝑎aitalic_a over the committee S𝑆Sitalic_S. By tying the hands of the adversary in this way, we can drive down the value of the game, which gives a more favorable guarantee for the distribution over committees. Once we fix the distribution over committees (referred to by ΔΔ\Deltaroman_Δ), we measure the quality of a candidate a𝑎aitalic_a or committee S𝑆Sitalic_S with respect to a voter v𝑣vitalic_v with a crucial notion that we call the rank, denoted rankv⁡(a)subscriptrank𝑣𝑎\operatorname{rank}_{v}(a)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_a ) or rankv⁡(S)subscriptrank𝑣𝑆\operatorname{rank}_{v}(S)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_S ) (see Definition 3). Roughly speaking, this is simply the probability when we sample from ΔΔ\Deltaroman_Δ that we get a committee that is worse than a𝑎aitalic_a or S𝑆Sitalic_S in v𝑣vitalic_v’s preference. The activation function. The second twist is what we call the activation function g𝑔gitalic_g, which allows us freedom in how we measure each voter’s preferences for candidates and committees. This function may seem somewhat enigmatic in the proof, but here we try to give some rough intuition for the idea behind it. The initial observation is that by using versions of the zero-sum game with different committee sizes, we can construct distributions over committees of size k𝑘kitalic_k in a variety of ways. The simplest would be to take the optimal mixed strategy for the defender in the original game with committee size k𝑘kitalic_k, but we could also take the optimal strategy for size k/2𝑘2k/2italic_k / 2, sample twice from it and take the union. These different ways of constructing the distributions can actually be interpreted as attaching different activation functions to the defender’s distribution in the payoffs of the original game. For example, sampling twice from the k/2𝑘2k/2italic_k / 2 distribution is equivalent to attaching the function g⁢(x)=x𝑔𝑥𝑥g(x)=\sqrt{x}italic_g ( italic_x ) = square-root start_ARG italic_x end_ARG, and the reason corresponds to the fact that sampling two uniform reals from [0,1]01[0,1][ 0 , 1 ] and taking the max is equivalent to sampling one uniform real from [0,1]01[0,1][ 0 , 1 ] and taking the square root. In the end, thanks to the generality of the minimax theorem, the proof works for any non-constant, non-decreasing function g:[0,1]→ℝ≥0:𝑔→01subscriptℝabsent0g\colon[0,1]\to\mathbb{R}_{\geq 0}italic_g : [ 0 , 1 ] → blackboard_R start_POSTSUBSCRIPT ≥ 0 end_POSTSUBSCRIPT such that g⁢(xk)𝑔superscript𝑥𝑘g(x^{k})italic_g ( italic_x start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ) is convex. These functions give a richer continuous space of options for modifying the game, some of which are not easily interpretable in terms of the intuition described above. Each choice of g𝑔gitalic_g gives a different bound for α𝛼\alphaitalic_α as a function of k𝑘kitalic_k, and so we can simply choose the function that gives the best guarantee. A one-shot approach with finer accounting of all voters. Third, we use a more precise approach for showing that some committee in the support of our distribution performs well, by diligently accounting for the contributions of each voter. In each step of [JMW20]’s recursion, when they sample committee S𝑆Sitalic_S, they consider for each voter v𝑣vitalic_v whether or not rankv⁡(S)subscriptrank𝑣𝑆\operatorname{rank}_{v}(S)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_S ) is above some threshold (called β𝛽\betaitalic_β, which is set to 1414\frac{1}{4}divide start_ARG 1 end_ARG start_ARG 4 end_ARG). The voters below the threshold are ignored, and then recursed on in the next iteration. There are two potential roadblocks in using this approach for small committee sizes. Intuitively, if we are aiming for a final committee size of around 6, the recursion cannot be very deep. Each iteration can only choose 2 or 3 candidates, for which the guarantee is insufficient. That is, the benefits of the recursion only kick in for sufficiently large committees, and for small committees, it is better to sample the whole committee in one shot (without recursion). Second, there is too much loss in evaluating each voter with a binary threshold, and without recursion, we need better accounting for voters with a low opinion of the committee. In Lemma 2 and 4, we give a smoother analysis, which allows us to more precisely account for the contributions of each voter. To give some rough intuition, what we would like to show is that there is some S𝑆Sitalic_S such that the total sum of rankv⁡(S)subscriptrank𝑣𝑆\operatorname{rank}_{v}(S)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_S ) is large for any subset of an α𝛼\alphaitalic_α fraction of the voters. If we fix S𝑆Sitalic_S and plot each rankv⁡(S)subscriptrank𝑣𝑆\operatorname{rank}_{v}(S)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_S ), ordered from smallest to largest, it suffices to bound the area under the bottom α𝛼\alphaitalic_α fraction. It turns out that the worst case for these ranks (that minimizes the area for all S𝑆Sitalic_S) is not a step function with a sharp threshold, but rather a linear function with slope 1111 (akin to the cyclic preferences depicted in Table 1). Finally, to prove Theorem 2, we use our modifications in tandem with the recursive approach. In the proof of this theorem, the idea above that does the heavy lifting is the use of the activation function g𝑔gitalic_g. 1.3 Related Work Proportionality in committee selection. In the context of committee selection, the principle of proportionality says that large voter coalitions should have their preferences fairly represented — an idea that dates back to at least the 19th century [Dro81]. Since its advent, a substantial body of research has been dedicated to studying the possibility and implications of proportionality. One of the most widely studied models is approval voting, where voters express their preferences by selecting a subset of candidates they approve of. We refer the reader to a survey by Lackner and Skowron [LS23] for a detailed discussion on the topic. A key appeal of this model is that there are a wide variety of proportionality axioms such as justified representation (JR) [ABC+17] and its variants (for example, [FEL+17, BP23]) that are satisfied by natural rules (such as Proportional Approval Voting (Thiele’s rule) [Thi95, Kil10, ABC+17, PS20], Phragmén’s rule [Phr94, PS20], and the Method of Equal Shares [PS20, PPS21]). These ideas have also been impactful in practice, with for example, the historical use of Thiele’s rule and Phragmén’s rule [Jan16], and the recent successful implementation of the Method of Equal Shares for participatory budgeting in several European cities [PS]. Additionally, this line of work is driven forward by intriguing conjectures that even stronger axioms, such as core stability [ABC+17, FMS18], might be universally satisfiable as well. In comparison, proportionality in committee selection with ranked preferences is relatively under-explored. As [LS23] suggest, part of the challenge is that notions of proportionality in the approval setting do not always generalize to the ranking setting. (Or, like with core stability, the analogous axioms are not always satisfiable [CJMW20].) One particularly well studied class of rank-based committee selection rules is that of committee scoring rules [EFSS17]. These voting rules, which generalize scoring rules in the single-winner setting, capture several natural committee selection rules, and have been axiomatically characterized [FSST19, SFS19]. We refer the reader to [FSST17] for a more in-depth discussion. Committee analogues of Condorcet winners. Grappling with Condorcet’s paradox has been a major driving force in social choice theory, and naturally, other attempts have been made to extend the notion of Condorcet winners to the multi-winner setting. Fishburn [Fis81b, Fis81a] introduced the idea of a majority committee, defined as a committee preferred by a majority of voters over any other committee of the same size. The Smith set [Goo71, Smi73] S𝑆Sitalic_S is defined as the minimal committee such that for any a∉S𝑎𝑆a\notin Sitalic_a ∉ italic_S and b∈S𝑏𝑆b\in Sitalic_b ∈ italic_S, a majority of voters prefers b𝑏bitalic_b over a𝑎aitalic_a. Uncovered sets [Fis77, Mil80], bipartisan sets [LLLB93] (the support of maximal lotteries [Fis84]), and other tournament solutions [BBH16] can also be viewed as multi-winner generalizations of Condorcet winners. However, these notions face the same challenge as Condorcet winners: they either do not always exist or sometimes coincide with the entire (potentially large) set of candidates. As in the single-winner case, the goal shifts to identifying Condorcet-consistent rules, which select a Condorcet winner (or the analogous multi-winner notion) when one exists [Coe05, BC08]. In this context, Theorem 1 highlights a distinct advantage of the approach by Elkind, Lang, and Saffidine [ELS15]: small Condorcet-undominated sets are guaranteed to exist. Other explorations of 1. Lastly, we mention a few other interesting explorations of Condorcet winning sets, and more generally α𝛼\alphaitalic_α-undominated sets. [Gei14] used SAT solving to determine the largest Condorcet dimension in elections with a small number of voters and candidates. Their search did not turn up any instances with dimension larger than 3, but they found an election with just 6 voters and candidates with dimension 3, and they showed that this is the smallest possible. (We include one such instance in Table 4.) [Blo18] also explored whether elections with Condorcet dimension 4 could be constructed by exploring dominating sets in tourament graphs, but that approach did not yield any such elections. On the positive side, [LVvS24] very recently showed that in elections where the voters and candidates are embedded in a 2-dimensional space, and their preferences are defined by their distance according to the ℓ1subscriptℓ1\ell_{1}roman_ℓ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT or ℓ∞subscriptℓ\ell_{\infty}roman_ℓ start_POSTSUBSCRIPT ∞ end_POSTSUBSCRIPT norm, the Condorcet dimension is at most 3. In a more informal setting, a question isomorphic to 1 has also been explored from a combinatorial perspective in a series of Math Overflow posts [Pál13, Spe13, Bra13]. These posts offer an intriguing window into different approaches to resolving the problem, including why some natural approaches fall short. In their formulation [Pál13], each candidate a𝑎aitalic_a is represented by a function fa:[n]→ℕ:subscript𝑓𝑎→delimited-[]𝑛ℕf_{a}\colon[n]\to\mathbb{N}italic_f start_POSTSUBSCRIPT italic_a end_POSTSUBSCRIPT : [ italic_n ] → blackboard_N, which can be thought of as a map from each voter v𝑣vitalic_v to the rank of a𝑎aitalic_a in v𝑣vitalic_v’s preference order. They ask 1, with a particular focus on the case where k=2𝑘2k=2italic_k = 2. The responses contain examples of elections with Condorcet dimension 3, including the general lower bound that α𝛼\alphaitalic_α-undominated committees of size k𝑘kitalic_k do not always exist when α<2k+1𝛼2𝑘1\alpha<\frac{2}{k+1}italic_α < divide start_ARG 2 end_ARG start_ARG italic_k + 1 end_ARG [Zba14]. One natural approach towards positive results, suggested by Speyer [Spe13], is to solve the following graph theory question. Question 2. For what choices of ℓ,k∈ℤ+ℓ𝑘superscriptℤ\ell,k\in\mathbb{Z}^{+}roman_ℓ , italic_k ∈ blackboard_Z start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT does there exist a directed graph with girth larger than ℓℓ\ellroman_ℓ such that every subset of k𝑘kitalic_k vertices has a common in-neighbor? If there does not exist such a graph for some choice of ℓℓ\ellroman_ℓ and k𝑘kitalic_k, then this implies that every election has a (1−1ℓ)11ℓ(1-\frac{1}{\ell})( 1 - divide start_ARG 1 end_ARG start_ARG roman_ℓ end_ARG )-undominated set of size k𝑘kitalic_k, by considering the graph on candidates where there is an edge (a,b)𝑎𝑏(a,b)( italic_a , italic_b ) whenever more than 1−1ℓ11ℓ1-\frac{1}{\ell}1 - divide start_ARG 1 end_ARG start_ARG roman_ℓ end_ARG fraction of the voters prefer a𝑎aitalic_a over b𝑏bitalic_b. In particular, if every triangle-free graph has a pair of vertices without a common in-neighbor (ℓ=3ℓ3\ell=3roman_ℓ = 3 and k=2𝑘2k=2italic_k = 2), then this would imply that 2323\frac{2}{3}divide start_ARG 2 end_ARG start_ARG 3 end_ARG-undominated sets of size 2222 always exist, which would resolve 1 for k=2𝑘2k=2italic_k = 2. Unfortunately, such graphs do exist. [AHL+15] gave a positive answer to 2 for every ℓ,k∈ℤ+ℓ𝑘superscriptℤ\ell,k\in\mathbb{Z}^{+}roman_ℓ , italic_k ∈ blackboard_Z start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT, using a construction based on additive combinatorics."
https://arxiv.org/html/2411.03331v1,"Hypergraphs as Weighted Directed Self-Looped Graphs:Spectral Properties, Clustering, Cheeger Inequality","Hypergraphs naturally arise when studying group relations and have been widely used in the field of machine learning. There has not been a unified formulation of hypergraphs, yet the recently proposed edge-dependent vertex weights (EDVW) modeling [7] is one of the most generalized modeling methods of hypergraphs, i.e., most existing hypergraphs can be formulated as EDVW hypergraphs without any information loss to the best of our knowledge. However, the relevant algorithmic developments on EDVW hypergraphs remain nascent: compared to spectral graph theories, the formulations are incomplete, the spectral clustering algorithms are not well-developed, and one result regarding hypergraph Cheeger Inequality is even incorrect. To this end, deriving a unified random walk-based formulation, we propose our definitions of hypergraph Rayleigh Quotient, NCut, boundary/cut, volume, and conductance, which are consistent with the corresponding definitions on graphs. Then, we prove that the normalized hypergraph Laplacian is associated with the NCut value, which inspires our HyperClus-G algorithm for spectral clustering on EDVW hypergraphs. Finally, we prove that HyperClus-G can always find an approximately linearly optimal partitioning in terms of Both NCut111The NCut of the returned partition 𝒩𝒩\mathcal{N}caligraphic_N and the optimal NCut of any partition 𝒩∗superscript𝒩\mathcal{N}^{*}caligraphic_N start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT satisfy 𝒩≤O⁢(𝒩∗)𝒩𝑂superscript𝒩\mathcal{N}\leq O(\mathcal{N}^{*})caligraphic_N ≤ italic_O ( caligraphic_N start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT ). and conductance 222The conductance of the returned partition ΦΦ\Phiroman_Φ and the optimal conductance Φ∗superscriptΦ\Phi^{*}roman_Φ start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT satisfy Φ≤O⁢(Φ∗)Φ𝑂superscriptΦ\Phi\leq O(\Phi^{*})roman_Φ ≤ italic_O ( roman_Φ start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT ). Additionally, we provide extensive experiments to validate our theoretical findings from an empirical perspective.","Higher-order relations are ubiquitous in nature, such as co-authorship [14, 48, 40], interactions between multiple proteins or chemicals [13, 47], items that are liked by the same person [49, 46], and interactions between multiple species in an ecosystem [20, 38]. Hypergraphs, extended from graphs, with the powerful capacity to model group interactions (i.e., higher-order relations), show extraordinary potential to be applied to many real-world tasks where the connections are beyond pair-wise. Therefore, hypergraphs have been used widely in recommendation systems [56, 36, 18], information retrieval [27, 53, 35] and link prediction [26, 12]. Hypergraphs modeled by edge-dependent vertex weights (EDVW) were necessitated in a recent work [7], with a motivating example that in citation networks, each scholar (i.e., vertex) may contribute differently to each co-authored publication (i.e., hyperedge). The authors show that hypergraphs with edge-independent vertex weights (EIVW) do not actually utilize the higher-order relations for the following two reasons. First, the hypergraph Laplacian matrix proposed by the seminal work [52], which serves as a basis of many follow-up algorithms, is equal to the Laplacian matrix of a closely related graph with only pair-wise relations. In this way, all the linear Laplacian operators utilize only pair-wise relationships between vertices [1]. Second, many hypergraph algorithms [37, 31, 4] are based on random walks [42, 9, 34], but it has been proved that for any EIVW hypergraph, there exists a weighted pair-wise graph on which a random walk is equivalent to that on the original hypergraph [7]. Table 1: Properties of graph models/formulations. EDVW hypergraphs generalized EIVW hypergraphs by allowing each hyperedge to distribute its vertex weights, bringing better formulation flexibility. Modeling/Formulation undirected graphs EIVW hypergraphs EDVW hypergraphs edge/hyperedge weights √square-root\surd√ √square-root\surd√ √square-root\surd√ vertex weights √square-root\surd√ √square-root\surd√ √square-root\surd√ hyperedges ×\times× √square-root\surd√ √square-root\surd√ edge-dependent vertex weights ×\times× ×\times× √square-root\surd√ Figure 1: Undirected graphs ⊂\subset⊂ EIVW hypergraphs ⊂\subset⊂ EDVW hypergraphs. Each undirected graph can be reformulated to EIVW hypergraph by regarding each pair-wise edge as a hyperedge; each EIVW hypergraph can be reformulated to EDVW hypergraph by setting each vertex’s weight to be the same across hyperedges, yet allowing different vertices to have different weights. In nature, ”EDVW hypergraph” is not a special case of hypergraphs, but a more generalized way to model hypergraphs (Figure 1). Any algorithm designed for EDVW hypergraphs, taking EDVW inputs, also works on typical (EIVW) hypergraphs by setting all the EDVW to 1 (i.e., independent w.r.t. edge). In other words, the properties and algorithms on EDVW-formulated hypergraphs can be applied to most hypergraphs. In this paper, we focus on further developing the incomplete yet fundamental spectral theories for EDVW hypergraphs, with a straightforward application on spectral clustering, a.k.a., k-way global partitioning, where typically k=2𝑘2k=2italic_k = 2. To be specific, k-way global partitioning aims to partition an entire graph into k𝑘kitalic_k clusters, where the vertices in one cluster are densely connected within this cluster while having sparser connections to vertices outside this cluster. On the one hand, although the spectral theories and spectral clustering on graphs have been well studied [10], converting the hypergraphs to graphs and applying those methods may ignore the higher-order relations and result in sub-optimal results [44]. On the other hand, despite the advantage of EDVW modeling in terms of utilizing high-order relations, directly developing a spectral clustering algorithm on EDVW hypergraphs is still an open question. To this end, for the first time, we propose a provably linearly optimal spectral clustering algorithm on EDVW hypergraphs, together with theoretical analysis concerning the Rayleigh Quotient, Normalized Cut (i.e., NCut), and conductance. In the context of EDVW hypergraphs, we bridge the eigensystem of Laplacian with the NCut value through our proposed Rayleigh Quotient. The proposed algorithm can also be applied to EIVW hypergraphs by setting all the vertex weights to 1, thus works generally for all hypergraphs. 1.1 Main Results In this paper, we further develop the spectral hypergraph theory for EDVW hypergraphs, and then study global partitioning on EDVW hypergraphs. Theorem 1. (algebraic connections between hypergraph NCut, Rayleigh Quotient and Laplacian) Given any hypergraph in the EDVW formatting ℋ=(𝒱,ℰ,ω,γ)ℋ𝒱ℰ𝜔𝛾\mathcal{H}=(\mathcal{V},\mathcal{E},\omega,\gamma)caligraphic_H = ( caligraphic_V , caligraphic_E , italic_ω , italic_γ ) with positive edge weights ω⁢(⋅)>0𝜔⋅0\omega(\cdot)>0italic_ω ( ⋅ ) > 0 and non-negative edge-dependent vertex weights γe⁢(⋅)subscript𝛾𝑒⋅\gamma_{e}(\cdot)italic_γ start_POSTSUBSCRIPT italic_e end_POSTSUBSCRIPT ( ⋅ ) for any e∈ℰ𝑒ℰe\in\mathcal{E}italic_e ∈ caligraphic_E, define Normalized Cut N⁢C⁢u⁢t⁢(⋅)𝑁𝐶𝑢𝑡⋅NCut(\cdot)italic_N italic_C italic_u italic_t ( ⋅ ), Volume of a vertex set v⁢o⁢l⁢(⋅)𝑣𝑜𝑙⋅vol(\cdot)italic_v italic_o italic_l ( ⋅ ), Rayleigh Quotient R⁢(⋅)𝑅⋅R(\cdot)italic_R ( ⋅ ), Laplacian L𝐿Litalic_L, and stationary distribution matrix ΠΠ\Piroman_Π as Definition 10, 8, 5, 13, and 4. For any vertex set 𝒮⊆𝒱𝒮𝒱\mathcal{S}\subseteq\mathcal{V}caligraphic_S ⊆ caligraphic_V, we define a |𝒱|𝒱|\mathcal{V}|| caligraphic_V |-dimensional vector x𝑥xitalic_x such that, x⁢(u)=v⁢o⁢l⁢(𝒮¯)v⁢o⁢l⁢(𝒮),∀u∈𝒮,x⁢(u¯)=−v⁢o⁢l⁢(𝒮)v⁢o⁢l⁢(𝒮¯),∀u¯∈𝒮¯.formulae-sequence𝑥𝑢𝑣𝑜𝑙¯𝒮𝑣𝑜𝑙𝒮formulae-sequencefor-all𝑢𝒮formulae-sequence𝑥¯𝑢𝑣𝑜𝑙𝒮𝑣𝑜𝑙¯𝒮for-all¯𝑢¯𝒮\begin{split}x(u)&=\sqrt{\frac{vol(\bar{\mathcal{S}})}{vol(\mathcal{S})}},% \leavevmode\nobreak\ \forall\,\,u\in\mathcal{S},\\ x(\bar{u})&=-\sqrt{\frac{vol(\mathcal{S})}{vol(\bar{\mathcal{S}})}},% \leavevmode\nobreak\ \forall\,\,\bar{u}\in\bar{\mathcal{S}}.\\ \end{split}start_ROW start_CELL italic_x ( italic_u ) end_CELL start_CELL = square-root start_ARG divide start_ARG italic_v italic_o italic_l ( over¯ start_ARG caligraphic_S end_ARG ) end_ARG start_ARG italic_v italic_o italic_l ( caligraphic_S ) end_ARG end_ARG , ∀ italic_u ∈ caligraphic_S , end_CELL end_ROW start_ROW start_CELL italic_x ( over¯ start_ARG italic_u end_ARG ) end_CELL start_CELL = - square-root start_ARG divide start_ARG italic_v italic_o italic_l ( caligraphic_S ) end_ARG start_ARG italic_v italic_o italic_l ( over¯ start_ARG caligraphic_S end_ARG ) end_ARG end_ARG , ∀ over¯ start_ARG italic_u end_ARG ∈ over¯ start_ARG caligraphic_S end_ARG . end_CELL end_ROW (1) then,⁢N⁢C⁢u⁢t⁢(𝒮,𝒮¯)=12⁢R⁢(x)=xT⁢L⁢xxT⁢Π⁢xthen,𝑁𝐶𝑢𝑡𝒮¯𝒮12𝑅𝑥superscript𝑥𝑇𝐿𝑥superscript𝑥𝑇Π𝑥\textit{then,}\,\,NCut(\mathcal{S},\bar{\mathcal{S}})=\frac{1}{2}R(x)=\frac{x^% {T}Lx}{x^{T}\Pi x}then, italic_N italic_C italic_u italic_t ( caligraphic_S , over¯ start_ARG caligraphic_S end_ARG ) = divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_R ( italic_x ) = divide start_ARG italic_x start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT italic_L italic_x end_ARG start_ARG italic_x start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT roman_Π italic_x end_ARG (2) This is the first work regarding the Rayleigh Quotient on hypergraphs. Inspired by this Theorem, we develop a spectral clustering algorithm HyperClus-G to optimize the NCut value by loosing the combinatorial optimization constraint. Theorem 2. (Hypergraph Spectral Clustering Algorithm) There exists a algorithm for hypergraph spectral clustering that can be applied to EDVW-formatted hypergraphs, and always returns approximately linearly optimal clustering in terms of Normalized Cut and conductance. In other words, approximately, the NCut of the returned partition 𝒩𝒩\mathcal{N}caligraphic_N and the optimal NCut of any partition 𝒩∗superscript𝒩\mathcal{N}^{*}caligraphic_N start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT satisfy 𝒩≤O⁢(𝒩∗)𝒩𝑂superscript𝒩\mathcal{N}\leq O(\mathcal{N}^{*})caligraphic_N ≤ italic_O ( caligraphic_N start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT ). We name this algorithm as HyperClus-G. The pseudo code of HyperClus-G is given in Algorithm 1. Moreover, to extend the hypergraph spectral theory, for the first time we give a complete proof regarding the hypergraph Cheeger Inequality. In the mean time, by proving Theorem 3, the previous result on hypergraph Cheeger Inequality (Theorem 5.1 in [7]) is incorrect as it refers to the eigenvector of unnormalized hypergraph Laplacian. Theorem 3. (Hypergraph Cheeger Inequality) Let ℋ=(𝒱,ℰ,ω,γ)ℋ𝒱ℰ𝜔𝛾\mathcal{H}=(\mathcal{V},\mathcal{E},\omega,\gamma)caligraphic_H = ( caligraphic_V , caligraphic_E , italic_ω , italic_γ ) be any hypergraph in the EDVW formatting with positive edge weights ω⁢(⋅)>0𝜔⋅0\omega(\cdot)>0italic_ω ( ⋅ ) > 0 and non-negative edge-dependent vertex weights γe⁢(⋅)subscript𝛾𝑒⋅\gamma_{e}(\cdot)italic_γ start_POSTSUBSCRIPT italic_e end_POSTSUBSCRIPT ( ⋅ ) for any e∈ℰ𝑒ℰe\in\mathcal{E}italic_e ∈ caligraphic_E. Define Φ⁢(ℋ)=min𝒮⊆𝒱Φ⁢(𝒮)Φℋsubscript𝒮𝒱Φ𝒮\Phi(\mathcal{H})=\mathop{\min}_{\mathcal{S}\subseteq\mathcal{V}}{\Phi(% \mathcal{S})}roman_Φ ( caligraphic_H ) = roman_min start_POSTSUBSCRIPT caligraphic_S ⊆ caligraphic_V end_POSTSUBSCRIPT roman_Φ ( caligraphic_S ). Then the second smallest eigenvector λ𝜆\lambdaitalic_λ of the normalized hypergraph Laplacian Π−12⁢L⁢Π−12superscriptΠ12𝐿superscriptΠ12\Pi^{-\frac{1}{2}}L\Pi^{-\frac{1}{2}}roman_Π start_POSTSUPERSCRIPT - divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_POSTSUPERSCRIPT italic_L roman_Π start_POSTSUPERSCRIPT - divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_POSTSUPERSCRIPT satisfies Φ⁢(ℋ)22≤λ≤2⁢Φ⁢(ℋ)Φsuperscriptℋ22𝜆2Φℋ\frac{\Phi(\mathcal{H})^{2}}{2}\leq\lambda\leq 2\Phi(\mathcal{H})divide start_ARG roman_Φ ( caligraphic_H ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG 2 end_ARG ≤ italic_λ ≤ 2 roman_Φ ( caligraphic_H ) (3) In fact, this theorem shows that our HyperClus-G is also approximately linearly optimal in terms of conductance. In other words, the conductance of the returned cluster ΦΦ\Phiroman_Φ and the optimal conductance Φ∗superscriptΦ\Phi^{*}roman_Φ start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT satisfy Φ≤O⁢(Φ∗)Φ𝑂superscriptΦ\Phi\leq O(\Phi^{*})roman_Φ ≤ italic_O ( roman_Φ start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT ). It is worth mentioning that the previous non-proved result in [7] regarding hypergraph Cheeger Inequality now can be proved by using normalized Laplacian instead of the conjecture of combinatorial Laplacian. Technical Overview. Given the EDVW modeling, the relevant algorithmic development still remains in a nascent stage, which hinders the application of hypergraphs in many real-world scenarios. To this end, we first re-analyze the random walks on EDVW hypergraphs, then propose the HyperClus-G for hypergraph partitioning. Finally, we prove the approximation of normalized cut, as well as the upper bound of NCut and conductance. The key insight from the previous work [7] is to model the hypergraphs similar to directed graphs through the equivalence of random walks. Unlike classical graph theory, such directed graphs are edge-weighted, node-weighted, and contain self-loops. In this work, inspired by the definitions of Rayleigh Quotient, NCut, boundary/cut, volume, and conductance in graphs, we develop these definitions in the context of EDVW hypergraphs. We show that Theorem 1 and Theorem 3, properties that hold for graphs, still hold for hypergraphs using our unified definitions. From Theorem 3, we can further prove that our proposed HyperClus-G is approximately linearly optimal in terms of both NCut and conductance. Our Appendix contains supplementary contents, such as trivial proofs and experimental details. Paper Organization. This paper is organized as follows. In Section 2, we introduce necessary notations and our definitions regarding hypergraphs. In Section 3, we introduce our definition of hypergraph Rayleigh Quotient and show its connection with the Laplacian and NCut. Then, we propose our HyperClus-G inspired from such connection. In section 4, we give complete proof regarding hypergraph Cheeger Inequality, then show the linear optimality of our HyperClus-G in terms of both NCut and conductance. In Section 5, we analyze the complexity of our algorithms. Finally, in Section 6, we prepare comprehensive experiments to validate our theoretical findings. 1.2 Other Related Works Early Hypergraphs [6] typically model graph structures and do not allow node or hyperedge weights. Later formulations [52] start to allow hyperedge weights. Among various choices of modeling hypergraphs [6, 52, 15, 33], EDVW modeling [7] shows great generalization because it allows both hyperedge weights and node weights. Many hypergraph-related techniques have been proposed [17, 3, 30], while very few of them involve EDVW hypergraphs. Inhomogeneous hypergraph partitioning was proposed in [32]. Later on, authors of [33] proposed submodular hypergraphs, a special group of weighted hypergraphs, and analyzed their spectral clustering. A recent work [23] demonstrates how random walks with EDVW are used to construct the EDVW hypergraph Laplacian. However, it stops at the construction of the Laplacian and only uses partial information encoded in the Laplacian for clustering. Some recent works [2, 43, 11] study partitioning edge-colored hypergraphs. There are several research works [57, 54, 55] targeting EDVW hypergraph global partitioning, but they do not actually directly work on EDVW hypergraphs, but are based on submodular hypergraphs; They propose to construct a submodular hypergraph from the given EDVW hypergraph [33], then apply learning-based approaches to optimize the global partitioning objective. Several works also study specific applications of hypergraph clustering [28, 5]."
https://arxiv.org/html/2411.03274v1,Generalized Word-Representable Graphs:A Formal Language Approach,"The literature on word-representable graphs is quite rich, and a number of variations of the original definition have been proposed over the years. In this paper, we are initiating a systematic study of such variations based on formal languages. In our framework, we can associate a graph class to each language over the binary alphabet {0,1}01\{0,1\}{ 0 , 1 }. All graph classes that are language-representable in this sense are hereditary and enjoy further common properties. Besides word-representable graphs and, more generally, 1ksuperscript1𝑘1^{k}1 start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT- or k𝑘kitalic_k-11-representable graphs, we can identify many more graph classes in our framework, like (co)bipartite graphs, (co)comparability graphs, to name a few.It was already known that any graph is 111111111111- or 2-11-representable. However, when such representations are considered for storing graphs (as in graph databases), 111111111111- or 2-11-representability bears the disadvantage of being significantly inferior to standard adjacency matrices or lists. We will prove that quite famous language like the palindrome language, the copy language or the language of Lyndon words, as well as their complements, can match the efficiency of standard graph representations in general.The perspective of language theory allows us to prove very general results that hold for all graph classes that can be defined in this framework. This includes certain closure properties (e.g., all language-definable graph classes are hereditary) as well as certain limitations (e.g., all language-representable graph classes contain graphs of arbitrarily large treewidth and graphs of arbitrarily large degeneracy, except a trivial case). As each language describes a graph class, we can also ask questions like: Given a language, say, by a context-free grammar, does the described graph class only contain graphs of treewidth at most 2? We show that this (and similar questions) are decidable.We also present a systematic study of graph classes that can be represented by binary languages in which each letter occurs at most twice. Here, we find graph classes like interval graphs, permutation graphs, circle graphs, bipartite chain graphs, convex graphs, and threshold graphs, to name the most prominent ones.","How to represent a graph? This question has come up and has been answered in many variations and has also led to the definition of many graph classes. For instance, geometric relations as intersection or containment are possible bases of definitions of interval, chordal or circle graphs, to give concrete examples. In the context of computer science, the study of implicit representations of graphs was initiated in [KanNaoRud92], but for instance the whole research on graph labeling (as testified by the ongoing survey of Gallian [Gal2023] with thousands of citations) can be interpreted in this way, as well as the already mentioned geometric representations. In this paper, we are generalizing the notion of word-representable graphs by linking it to formal language theory in a way that any language L𝐿Litalic_L over the binary alphabet {0,1}01\{0,1\}{ 0 , 1 } defines a graph class 𝒢Lsubscript𝒢𝐿\mathcal{G}_{L}caligraphic_G start_POSTSUBSCRIPT italic_L end_POSTSUBSCRIPT. Now classical word representability defines a graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) via a word w𝑤witalic_w over the alphabet of vertices V𝑉Vitalic_V, allowing an edge between two vertices u,v𝑢𝑣u,vitalic_u , italic_v if, in the scattered subword obtained from w𝑤witalic_w by omitting all letters but u,v𝑢𝑣u,vitalic_u , italic_v, never two subsequent letters are identical. This property can be expressed by the binary language (0∪1)∗⁢11⁢(0∪1)∗¯∩(0∪1)∗⁢00⁢(0∪1)∗¯¯superscript0111superscript01¯superscript0100superscript01\overline{(0\cup 1)^{*}11(0\cup 1)^{*}}\cap\overline{(0\cup 1)^{*}00(0\cup 1)^% {*}}over¯ start_ARG ( 0 ∪ 1 ) start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT 11 ( 0 ∪ 1 ) start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT end_ARG ∩ over¯ start_ARG ( 0 ∪ 1 ) start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT 00 ( 0 ∪ 1 ) start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT end_ARG in a natural way and our approach generalizes word representability exactly in this direction. Word-representable graphs have been introduced in [KitPya2008] as an analogue of a DAG model of words studied in [KitSei2008] in order to solve some complexity problems in the context of semigroup theory. This is remarkable due to the known links between automata and semigroup theory (via transition monoids) and as we are here presenting a completely different connection between formal languages and graphs. Many scientific works have been devoted to word representability. Instead of trying to list all of them, we only point to the monograph [KitLoz2015] and the survey papers [Kit2017, KitPya2018]. According to [CheKKKP2018], a graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) is k𝑘kitalic_k-11-represented by a word w∈V∗𝑤superscript𝑉w\in V^{*}italic_w ∈ italic_V start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT if, for all distinct vertices 𝚊,𝚋∈V𝚊𝚋𝑉\mathtt{a},\mathtt{b}\in Vtypewriter_a , typewriter_b ∈ italic_V, at most k𝑘kitalic_k times the pattern (factor) 𝚊𝚊𝚊𝚊\mathtt{a}\mathtt{a}typewriter_aa and at most k𝑘kitalic_k-times the pattern 𝚋𝚋𝚋𝚋\mathtt{b}\mathtt{b}typewriter_bb occurs in h{𝚊,𝚋}⁢(w)subscriptℎ𝚊𝚋𝑤h_{\{\mathtt{a},\mathtt{b}\}}(w)italic_h start_POSTSUBSCRIPT { typewriter_a , typewriter_b } end_POSTSUBSCRIPT ( italic_w ), obtained from w𝑤witalic_w by deleting all vertices (letters) but 𝚊,𝚋𝚊𝚋\mathtt{a},\mathtt{b}typewriter_a , typewriter_b. The 00-11-representable graphs are the classical word-representable graphs, while the 2-11-representable graphs are the class of all undirected graphs. These types of representability were further generalized in [GaeJi2020] towards avoiding arbitrary patterns, and in this paper, we are generalizing these approaches even more by allowing arbitrary languages (not only certain (local) regular languages) to prescribe how edges are defined by a word, so that each binary language describes a graph class. Yet another generalization of word representability was introduced in [KenMal2023]. The class of word-representable graphs also found some interest in the pure graph-theoretic literature, cf. [CheKitSun2016, ChoKimKim2019, EnrKit2019, GleKitPya2018, Gle2019, KitSai2020]. We finally mention that there are other ways to connect words to graphs and hence languages to graph classes. For instance, the notion of letter graphs introduced by Petkovšek in [Pet2002] gives rise to an infinite chain of graph classes where the languages are simply restricted by their alphabet size; in this context, this yields the graph parameter lettericity that obtained a certain popularity recently, see [AleAALZ2023] and related papers. Quite akin to our studies are pattern avoiding words in [JonKPR2015, Kit2017a]. In general, this u𝑢uitalic_u-representation of a graph depends on the labelling of its vertices and hence is different from our approach. Also, permutation representability as defined in [KitSei2008] is different, as this gives additional conditions on the words that can be used to represent graphs, not only on the patterns that define edges. Lozin [Loz2008a] discussed several representations of graphs with finite automata. Another completely different way to connect the theory of regular languages with basic notions of graph theory, e.g., with bounded treewidth, was recently proposed in [DieFerWol2022]. The paper is structured as follows. We start with a preliminary Section 2 that is already relatively lengthy, as we are using standard not(at)ion from different mathematical areas. In Section 3, we introduce the main (new) definitions of this paper, in particular, we discuss the notion of L𝐿Litalic_L-representable graphs, with L𝐿Litalic_L being any binary language. We also provide a number of examples and first observations regarding this notion. In Section 4, we discuss several language and graph operations and how they relate. For instance, complementary languages can be used to describe graph complements, and taking induced subgraphs corresponds to certain projective morphisms on the language side. Section 5 provides structural insights into language-representable graphs by showing that their edge sets can be decomposed by paying attention to the number of times a vertex (letter) occurs in the word describing a graph. This motivates to systematically study some finite languages in Section 6. But first, we discuss in Section 5 some limitations of our approach, finding a number of graph classes that cannot be represented by any language in our setting. Also, we provide counting arguments that show that no finite language can represent all graphs, neither all word-representable graphs (in the classical sense), etc. In Section 6, we characterize all graph classes that can be described by languages that contain only binary words with at most two occurrences of 0 and at most two occurrences of 1. In fact, quite a number of well-known graph classes can be described in this (simple) way, including interval graphs, permutation graphs, circle graphs, convex graphs, and bipartite chain graphs. In Section 7, we approach this phenomenon from another angle by looking at rather famous language classes, formed palindromes, copy-words, Lyndon-words and Dyck-words. This way, we get descriptions of all graphs, of all bipartite graphs, as well as of all comparability graphs. We also argue that these new representations of all graphs is more parsimonious than earlier findings in the area of graphs representable by languages and might be useful in practice. The study of graphs that have a short word-representation with respect to a given language is also connected to [GaeJi2020, SriHar2024] where short representations with respect to the classical notion of word representability was investigated. We conclude in Section 8 by discussing several open questions and research directions that are opened up within our framework. Many graph classes encountered in this paper are defined in Section 9."
https://arxiv.org/html/2411.03273v1,Graph-Based Semi-Supervised Segregated Lipschitz Learning,"This paper presents an approach to semi-supervised learning for the classification of data using the Lipschitz Learning on graphs. We develop a graph-based semi-supervised learning framework that leverages the properties of the infinity Laplacian to propagate labels in a dataset where only a few samples are labeled. By extending the theory of spatial segregation from the Laplace operator to the infinity Laplace operator, both in continuum and discrete settings, our approach provides a robust method for dealing with class imbalance, a common challenge in machine learning. Experimental validation on several benchmark datasets demonstrates that our method not only improves classification accuracy compared to existing methods but also ensures efficient label propagation in scenarios with limited labeled data.","In recent years, nonlinear Partial Differential Equations (PDEs) on graphs have attracted increasing interest due to their natural emergence in various applications in mathematics, physics, biology, economics, and data science. For example, they are relevant in fields such as Internet and road networks, social networks, population dynamics, image processing, and machine learning. Indeed, a large amount of complex and irregular data is generated daily from various sources, including the internet, images, point clouds, 3D meshes, and biological networks. These datasets can be directly represented or modeled as graphs or functions defined on graphs. Consequently, intensive research aims to develop new methods for processing and analyzing data defined on graphs and adapt classical signal and image processing methods and concepts to graphs. Recently, several works have focused on the study of PDEs on graphs and their local or non-local continuous limits in the Euclidean domain. Among the significant contributions, we can mention the works of teams such as those of A. Bertozzi [7, 46, 34], Y. VanGuennip [51, 50, 10], S. Osher [48, 35], and J. Mazon [43, 45, 44], who have proposed to adapt several types of continuous PDEs and variational models to graphs. Other research aims to transpose various continuous PDEs to graphs, such as p𝑝pitalic_p-Laplacian equations [24, 30, 36], infinity Laplacian [30], ”game” p𝑝pitalic_p-Laplacian [28], Hamilton-Jacobi equations with or without diffusion [33, 31, 14], related to certain stochastic games [26, 29], mean curvature flow equation, or p𝑝pitalic_p-biharmonic equation [33]. In this paper, utilizing the characteristic of Infinity Laplacian in propagating, we propose a novel graph-based semi-supervised learning method aimed at classifying large volumes of unlabeled data, particularly in scenarios involving imbalanced datasets and limited labeled samples. Our approach exploits the geometric and topological characteristics of the unlabeled data, integrating these properties to enhance the development and performance of various algorithms."
https://arxiv.org/html/2411.03006v1,Neural Networks and (Virtual) Extended Formulations,"Neural networks with piecewise linear activation functions, such as rectified linear units (ReLU) or maxout, are among the most fundamental models in modern machine learning. We make a step towards proving lower bounds on the size of such neural networks by linking their representative capabilities to the notion of the extension complexity xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ) of a polytope P𝑃Pitalic_P, a well-studied quantity in combinatorial optimization and polyhedral geometry. To this end, we propose the notion of virtual extension complexity vxc⁡(P)=min⁡{xc⁡(Q)+xc⁡(R)∣P+Q=R}vxc𝑃xc𝑄conditionalxc𝑅𝑃𝑄𝑅\operatorname{vxc}(P)=\min\{\operatorname{xc}(Q)+\operatorname{xc}(R)\mid P+Q=R\}roman_vxc ( italic_P ) = roman_min { roman_xc ( italic_Q ) + roman_xc ( italic_R ) ∣ italic_P + italic_Q = italic_R }. This generalizes xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ) and describes the number of inequalities needed to represent the linear optimization problem over P𝑃Pitalic_P as a difference of two linear programs. We prove that vxc⁡(P)vxc𝑃\operatorname{vxc}(P)roman_vxc ( italic_P ) is a lower bound on the size of a neural network that optimizes over P𝑃Pitalic_P. While it remains open to derive strong lower bounds on virtual extension complexity, we show that powerful results on the ordinary extension complexity can be converted into lower bounds for monotone neural networks, that is, neural networks with only nonnegative weights. Furthermore, we show that one can efficiently optimize over a polytope P𝑃Pitalic_P using a small virtual extended formulation. We therefore believe that virtual extension complexity deserves to be studied independently from neural networks, just like the ordinary extension complexity. As a first step in this direction, we derive an example showing that extension complexity can go down under Minkowski sum.","While machine learning is nowadays driven by rapid empirical progress, our work focuses on the theoretical understanding of the underlying models and methods. A crucial building block are feedforward neural networks. These are directed, acyclic graphs in which each vertex (neuron) defines a simple computation, usually a linear transformation composed with a scalar-valued, continuous and piecewise linear (CPWL) activation function. While a standard choice for the activation function is the rectified linear unit (ReLU) x↦max⁡{0,x}maps-to𝑥0𝑥x\mapsto\max\{0,x\}italic_x ↦ roman_max { 0 , italic_x }, in this paper we focus on the more general maxout networks. These allow to compute the maximum of constantly many linear functions at each neuron. As a result, the entire network computes a (potentially complex) CPWL function. One of the big challenges in the theoretical analysis of neural networks is to understand how many neurons one requires to exactly or approximately represent a given (CPWL) function. To the best of our knowledge, it is an open question whether there exists a family of CPWL functions, which we can evaluate in polynomial time, but which cannot be represented by polynomial-size neural networks. The piecewise linear nature of the studied networks suggests to tackle such questions by means of polyhedral geometry, see, e.g., the recent survey [25]. In fact, a similar problem to the question above used to be open for a long time in the context of linear programming, until Rothvoß [37] resolved it affirmatively: does there exist a polytope P𝑃Pitalic_P over which we can optimize in polynomial time, but any linear programming formulation must have exponential size? This question can be formalized with the notion of extension complexity xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ), which describes the minimal number of facets of any polytope Q𝑄Qitalic_Q that projects onto P𝑃Pitalic_P. In this case, we call Q𝑄Qitalic_Q an extended formulation of P𝑃Pitalic_P. Rothvoß [37] proved that the matching polytope has exponential extension complexity even though Edmonds’ algorithm [11] can be used to find the maximum weight matching or minimum weight perfect matching in polynomial time. Additionally, it was also proven that a couple of polytopes associated with NP-hard optimization problems like the travelling salesperson problem have exponential extension complexity [14]. There is a direct translation between polytopes (as feasible sets of linear programs) and CPWL functions (represented by neural networks) through the notion of the support function fP⁢(c)=maxx∈P⁡c⊤⁢xsubscript𝑓𝑃𝑐subscript𝑥𝑃superscript𝑐top𝑥f_{P}(c)=\max_{x\in P}c^{\top}xitalic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT ( italic_c ) = roman_max start_POSTSUBSCRIPT italic_x ∈ italic_P end_POSTSUBSCRIPT italic_c start_POSTSUPERSCRIPT ⊤ end_POSTSUPERSCRIPT italic_x of a polytope P𝑃Pitalic_P. This (convex) CPWL function, which has one linear region for each vertex of P𝑃Pitalic_P, uniquely determines P𝑃Pitalic_P via convex duality. Computing fP⁢(c)subscript𝑓𝑃𝑐f_{P}(c)italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT ( italic_c ) means determining the objective value when optimizing over P𝑃Pitalic_P in c𝑐citalic_c-direction. Each CPWL function fPsubscript𝑓𝑃f_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT can be represented by a neural network [1], though the required number of neurons can be large. To quantify this, we define the neural network complexity nnc⁡(P)nnc𝑃\operatorname{nnc}(P)roman_nnc ( italic_P ) as the minimum number of neurons to represent fPsubscript𝑓𝑃f_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT by a maxout neural network. 1.1 Our Contributions The aim of this paper is to connect the world of extended formulations with the study of neural networks. A “dream result” in this direction would be to bound xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ) polynomially in nnc⁡(P)nnc𝑃\operatorname{nnc}(P)roman_nnc ( italic_P ). Then the breakthrough results on extension complexity would directly imply strong lower bounds on the size of neural networks. It turns out, however, that there is one feature of neural networks that seems to make the “dream result” difficult to obtain: namely the ability to use subtraction. To remedy this, we propose the notion of virtual extension complexity vxc⁡(P)=min⁡{xc⁡(Q)+xc⁡(R)∣Q and R are polytopes with ⁢P+Q=R},vxc𝑃xc𝑄conditionalxc𝑅Q and R are polytopes with 𝑃𝑄𝑅\operatorname{vxc}(P)=\min\{\operatorname{xc}(Q)+\operatorname{xc}(R)\mid\text% {$Q$ and $R$ are polytopes with }P+Q=R\}\ ,roman_vxc ( italic_P ) = roman_min { roman_xc ( italic_Q ) + roman_xc ( italic_R ) ∣ italic_Q and italic_R are polytopes with italic_P + italic_Q = italic_R } , where P+Q={p+q∣p∈P,q∈Q}𝑃𝑄conditional-set𝑝𝑞formulae-sequence𝑝𝑃𝑞𝑄P+Q=\{p+q\mid p\in P,q\in Q\}italic_P + italic_Q = { italic_p + italic_q ∣ italic_p ∈ italic_P , italic_q ∈ italic_Q } is the Minkowski sum. In this definition, P𝑃Pitalic_P is a (formal) Minkowski difference of two polytopes Q𝑄Qitalic_Q and R𝑅Ritalic_R. Note that this is not the same as R+(−1)⋅Q𝑅⋅1𝑄R+(-1)\cdot Qitalic_R + ( - 1 ) ⋅ italic_Q but rather the inverse operation of Minkowski addition. The name virtual extension complexity is derived from virtual polytopes [33], a framework for the algebraic study of formal Minkowski differences of polytopes. Observe that vxc⁡(P)≤xc⁡(P)vxc𝑃xc𝑃\operatorname{vxc}(P)\leq\operatorname{xc}(P)roman_vxc ( italic_P ) ≤ roman_xc ( italic_P ) because we can always choose Q={0}𝑄0Q=\{0\}italic_Q = { 0 } with xc⁡({0})=0xc00\operatorname{xc}(\{0\})=0roman_xc ( { 0 } ) = 0. In that sense, virtual extension complexity is really a strengthening of the ordinary extension complexity. In Section 3, we deduce that vxc⁡(P)vxc𝑃\operatorname{vxc}(P)roman_vxc ( italic_P ) is indeed a lower bound for nnc⁡(P)nnc𝑃\operatorname{nnc}(P)roman_nnc ( italic_P ), up to a constant factor. This leaves the open question to find ways to lower-bound vxc⁡(P)vxc𝑃\operatorname{vxc}(P)roman_vxc ( italic_P ) in order to achieve the original goal to lower-bound nnc⁡(P)nnc𝑃\operatorname{nnc}(P)roman_nnc ( italic_P ). A consequence of the discussion above is that, if one removes the ability to subtract within neural networks, we do indeed obtain our “dream result”, namely lower bounds through xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ). The resulting model is the one of monotone neural networks, which are neural networks with only nonnegative weights. In analogy to nnc⁡(P)nnc𝑃\operatorname{nnc}(P)roman_nnc ( italic_P ), we define the monotone neural network complexity mnnc⁡(P)mnnc𝑃\operatorname{mnnc}(P)roman_mnnc ( italic_P ) as the minimum number of neurons to represent fPsubscript𝑓𝑃f_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT by a monotone maxout neural network. In Section 4, we show how lower bounds on xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ) imply lower bounds on exact and approximate representations of monotone neural networks. Studying monotone neural networks is justified both from a theoretical and a practical perspective. From the theoretical perspective, it is a natural approach in complexity theory to prove lower bounds first for monotone models of computation, to first circumvent some additional challenges of the general case; see, e.g., [42]. From the practical perspective, it is always a good idea to incorporate prior knowledge about a problem into a machine learning algorithm to solve that problem. If one knows that the target function should be a monotone function, then it might be a good idea to constrain each unit of the neural network to compute a monotone function—this exactly corresponds to nonnegative weights. See [29] and the references therein for recent studies of monotone neural networks in the machine learning community. Summarizing, in this paper, we discuss four ways to represent a polytope or its support function through (virtual) extended formulations and (monotone) neural networks. Figure 1 shows what we know about how the associated complexity measures xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ), vxc⁡(P)vxc𝑃\operatorname{vxc}(P)roman_vxc ( italic_P ), nnc⁡(P)nnc𝑃\operatorname{nnc}(P)roman_nnc ( italic_P ), and mnnc⁡(P)mnnc𝑃\operatorname{mnnc}(P)roman_mnnc ( italic_P ) relate to each other. xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P )mnnc⁡(P)mnnc𝑃\operatorname{mnnc}(P)roman_mnnc ( italic_P )vxc⁡(P)vxc𝑃\operatorname{vxc}(P)roman_vxc ( italic_P )nnc⁡(P)nnc𝑃\operatorname{nnc}(P)roman_nnc ( italic_P )?? Figure 1: Relations between complexity measures for a polytope P𝑃Pitalic_P. A directed arc means that the tail can be polynomially bounded by the head. It remains an open question whether xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ) and nnc⁡(P)nnc𝑃\operatorname{nnc}(P)roman_nnc ( italic_P ) can be related this way. We conclude with some insights for vxc⁡(P)vxc𝑃\operatorname{vxc}(P)roman_vxc ( italic_P ) and its relation to xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ). Observe that P+Q=R𝑃𝑄𝑅P+Q=Ritalic_P + italic_Q = italic_R is equivalent to fP=fR−fQsubscript𝑓𝑃subscript𝑓𝑅subscript𝑓𝑄f_{P}=f_{R}-f_{Q}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT = italic_f start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT - italic_f start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT pointwise. Therefore, intuitively, in order to optimize over P𝑃Pitalic_P, one only needs to optimize over R𝑅Ritalic_R and Q𝑄Qitalic_Q and subtract the results. We make this intuition formal in Section 5.1, implying that small extended formulations for Q𝑄Qitalic_Q and R𝑅Ritalic_R are sufficient to optimize efficiently over P𝑃Pitalic_P. Furthermore, in Section 5.2, we provide a class of examples with P+Q=R𝑃𝑄𝑅P+Q=Ritalic_P + italic_Q = italic_R demonstrating that xc⁡(R)xc𝑅\operatorname{xc}(R)roman_xc ( italic_R ) can be much smaller than xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ). This gives important insights on how extension complexity behaves under Minkowski sum and implies that we really need to look at both xc⁡(Q)xc𝑄\operatorname{xc}(Q)roman_xc ( italic_Q ) and xc⁡(R)xc𝑅\operatorname{xc}(R)roman_xc ( italic_R ) in order to lower-bound vxc⁡(P)vxc𝑃\operatorname{vxc}(P)roman_vxc ( italic_P ). 1.2 Further Related Work In this paper we aim to prove lower bounds on neural networks representing combinatorial optimization problems. Complementing upper bounds can be found in [22] for minimum spanning trees and maximum flows. Furthermore, in [23], similar upper bounds for the knapsack problem are given, even though they are different in flavor because some integrality assumptions are made. Concerning the general expressivity of (piecewise linear) neural networks, the celebrated universal approximation theorems state that a single layer of neurons is sufficient to approximate any continuous function on a bounded domain; see [10] for the original version for sigmoid activation functions and [27] for a version that encompasses ReLU. However, such shallow neural networks usually require a large number of neurons. A sequence of results demonstrates that deeper networks sometimes require exponentially fewer neurons to represent the same functions; see, e.g., [1, 12]. In terms of exact representation, it is known that a function can be represented if and only if it is CPWL [1], and it is still an open question whether constant depth is sufficient to do so [21, 20]. Interestingly, also for this question, monotone networks seem to be more amenable for proving lower bounds than their non-monotone counterparts [41]. Furthermore, the related question of how to efficiently write a non-convex CPWL function as a difference of two convex ones received quite some attention recently [5, 40]. We would like to emphasize that we view neural networks as a model of real-valued computation, as opposed to binary models of computation like Boolean circuits and Turing machines. In fact, if one restricts the inputs of a neural network to be binary, it is not too difficult to simulate AND-, OR-, and NOT-gates [32]. Thus, in such a binary model, every problem in P can be solved with polynomial-size neural networks. However, such networks would usually be very sensitive to single bits in the input and therefore cannot naturally be transformed into exact or approximate neural networks in the real-valued model. See also the discussion in [22] for more details. The more useful connection to circuit complexity is through arithmetic [38], and in particular tropical circuits [26], which are also real-valued models of computation. Again we refer to [22] for a more detailed discussion of how these models relate to neural networks. In fact, the extension complexity has been related before to Boolean and arithmetic circuits, see [13, 24]. This is also related to Goemans’ proof that the permutahedron has extension complexity 𝒪⁢(n⁢log⁡n)𝒪𝑛𝑛\mathcal{O}(n\log n)caligraphic_O ( italic_n roman_log italic_n ) [16], as this goes via sorting networks, which can be seen as a very specific version of a piecewise-linear arithmetic circuit."
https://arxiv.org/html/2411.03003v1,Fractional Chromatic Numbersfrom Exact Decision Diagrams,"Recently, Van Hoeve proposed an algorithm for graph coloring based on an integer flow formulation on decision diagrams for stable sets [10]. We prove that the solution to the linear flow relaxation on exact decision diagrams determines the fractional chromatic number of a graph. This settles the question whether the decision diagram formulation or the fractional chromatic number establishes a stronger lower bound. It also establishes that the integrality gap of the linear programming relaxation is 𝒪⁢(log⁡n)𝒪𝑛\mathcal{O}(\log n)caligraphic_O ( roman_log italic_n ), where n𝑛nitalic_n represents the number of vertices in the graph.We also conduct experiments using exact decision diagrams and could determine the chromatic number of r1000.1c from the DIMACS benchmark set. It was previously unknown and is one of the few newly solved DIMACS instances in the last 10 years.","A (vertex) coloring of a graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) assigns a color to each vertex such that adjacent vertices have different colors. Thus, each set of vertices with the same color is a stable set (also called independent set) in G𝐺Gitalic_G. The (vertex) coloring problem is to compute a coloring with the minimum possible number of colors. This number is denoted by χ⁢(G)𝜒𝐺\chi(G)italic_χ ( italic_G ) and also called the chromatic number of G𝐺Gitalic_G. Let 𝒮𝒮\mathcal{S}caligraphic_S denote the set of all stable sets in G𝐺Gitalic_G. Then, solving the following integer programming model yields the chromatic number [9]: χ⁢(G)=𝜒𝐺absent\displaystyle\chi(G)=italic_χ ( italic_G ) = min⁢∑S∈𝒮zSminsubscript𝑆𝒮subscript𝑧𝑆\displaystyle\text{min}\sum_{S\in\mathcal{S}}z_{S}min ∑ start_POSTSUBSCRIPT italic_S ∈ caligraphic_S end_POSTSUBSCRIPT italic_z start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT (VCIP) s.t.⁢∑S∈𝒮:j∈Szi≥1∀j∈Vformulae-sequences.t.subscript:𝑆𝒮𝑗𝑆subscript𝑧𝑖1for-all𝑗𝑉\displaystyle\text{s.t.}\;\;\sum_{S\in\mathcal{S}:j\in S}z_{i}\geq 1\quad% \forall j\in Vs.t. ∑ start_POSTSUBSCRIPT italic_S ∈ caligraphic_S : italic_j ∈ italic_S end_POSTSUBSCRIPT italic_z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ≥ 1 ∀ italic_j ∈ italic_V zS∈{0,1}∀S∈𝒮formulae-sequencesubscript𝑧𝑆01for-all𝑆𝒮\displaystyle z_{S}\in\{0,1\}\quad\forall S\in\mathcal{S}italic_z start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT ∈ { 0 , 1 } ∀ italic_S ∈ caligraphic_S It is a special case of the set cover problem, where the vertex set V𝑉Vitalic_V has to be covered with a minimum number of stable sets. The linear relaxation results in the fractional chromatic number χf⁢(G)subscript𝜒𝑓𝐺\chi_{f}(G)italic_χ start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT ( italic_G ). χf⁢(G):=assignsubscript𝜒𝑓𝐺absent\displaystyle\chi_{f}(G):=italic_χ start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT ( italic_G ) := min⁢∑S∈𝒮zIminsubscript𝑆𝒮subscript𝑧𝐼\displaystyle\text{min}\sum_{S\in\mathcal{S}}z_{I}min ∑ start_POSTSUBSCRIPT italic_S ∈ caligraphic_S end_POSTSUBSCRIPT italic_z start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT (VCLP) s.t.⁢∑S∈𝒮:j∈SzS≥1∀j∈Vformulae-sequences.t.subscript:𝑆𝒮𝑗𝑆subscript𝑧𝑆1for-all𝑗𝑉\displaystyle\text{s.t.}\;\;\sum_{S\in\mathcal{S}:j\in S}z_{S}\geq 1\quad% \forall j\in Vs.t. ∑ start_POSTSUBSCRIPT italic_S ∈ caligraphic_S : italic_j ∈ italic_S end_POSTSUBSCRIPT italic_z start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT ≥ 1 ∀ italic_j ∈ italic_V 0≤zS≤1∀S∈𝒮.formulae-sequence0subscript𝑧𝑆1for-all𝑆𝒮\displaystyle 0\leq z_{S}\leq 1\quad\forall S\in\mathcal{S}.0 ≤ italic_z start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT ≤ 1 ∀ italic_S ∈ caligraphic_S . Lovász showed that χ⁢(G)≤𝒪⁢(log⁡n)⋅χf⁢(G)𝜒𝐺⋅𝒪𝑛subscript𝜒𝑓𝐺\chi(G)\leq\mathcal{O}(\log n)\cdot\chi_{f}(G)italic_χ ( italic_G ) ≤ caligraphic_O ( roman_log italic_n ) ⋅ italic_χ start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT ( italic_G ) [7]. However for any ϵ>0italic-ϵ0\epsilon>0italic_ϵ > 0, approximating either χf⁢(G)subscript𝜒𝑓𝐺\chi_{f}(G)italic_χ start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT ( italic_G ) or χ⁢(G)𝜒𝐺\chi(G)italic_χ ( italic_G ) within a factor n1−ϵsuperscript𝑛1italic-ϵn^{1-\epsilon}italic_n start_POSTSUPERSCRIPT 1 - italic_ϵ end_POSTSUPERSCRIPT is NP-hard [12]. The IP formulation (VCIP) is the basis for several branch-&-price algorithms for vertex coloring [9, 8, 5]. Recently, Van Hoeve [10] proposed to tackle the graph coloring problem with decision diagrams. A (binary) decision diagram consists of an acyclic digraph with arc labels. It can represent the set of feasible solutions to an optimization problem P𝑃Pitalic_P, e.g. the stable sets of a graph. They are called exact if they represent all solutions, e.g. all stable sets. Van Hoeve showed how to compute a graph coloring using a constrained network flow in the decision diagram. 1.1 Contributions We show that the linear relaxation of the integral network flow in an exact decision diagram describes the fractional chromatic number, i.e. the linear relaxations arising from (VCLP) and from exact decision diagrams lead to the same lower bound. Thus, fractional flows in relaxed decision diagrams provide fast lower bounds for the (fractional) chromatic number. Finally, we show that the exact decision diagrams are computationally efficient on dense instances. For the first time, we are able to compute the chromatic number of r1000.1c [6]. To provide a provably correct solution, we employ exact arithmetic using SCIP-exact [4]. In unsafe floating point arithmetic, we could also improve the best known lower bound of the instance DJSC500.9. The paper is organized as follows. In Section 2, we shortly describe decision diagrams for the stable set problem and how a graph coloring integer program based on such a decision diagram can be formulated (Section 2.2) as proposed by [10]. Then, in Section 3 we prove that the solution to the linear relaxation of the integer program determines the fractional chromatic number. Section 4 contains experimental results with exact arithmetic on the instances of the DIMACS benchmark set, followed by Conclusions."
https://arxiv.org/html/2411.02686v1,On thed𝑑ditalic_d-independence number in 1-planar graphs,"The d𝑑ditalic_d-independence number of a graph G𝐺Gitalic_G is the largest possible size of an independent set I𝐼Iitalic_I in G𝐺Gitalic_G where each vertex of I𝐼Iitalic_I has degree at least d𝑑ditalic_d in G𝐺Gitalic_G. Upper bounds for the d𝑑ditalic_d-independence number in planar graphs are well-known for d=3,4,5𝑑345d=3,4,5italic_d = 3 , 4 , 5, and can in fact be matched with constructions that actually have minimum degree d𝑑ditalic_d. In this paper, we explore the same questions for 1-planar graphs, i.e., graphs that can be drawn in the plane with at most one crossing per edge. We give upper bounds for the d𝑑ditalic_d-independence number for all d𝑑ditalic_d. Then we give constructions that match the upper bound, and (for small d𝑑ditalic_d) also have minimum degree d𝑑ditalic_d.Keywords: 1-planar graph, independent set, minimum degree","An independent set in a graph contains vertices that are not adjacent to each other. A maximum independent set is an independent set of largest possible size for a given graph, and its cardinality is known as the independence number of G𝐺Gitalic_G and denoted by α⁢(G)𝛼𝐺\alpha(G)italic_α ( italic_G ). The celebrated 4-color theorem [3, 36] immediately implies that α⁢(G)≥n/4𝛼𝐺𝑛4\alpha(G)\geq n/4italic_α ( italic_G ) ≥ italic_n / 4 for every planar graph G𝐺Gitalic_G, where n𝑛nitalic_n is the number of vertices in the graph. Interestingly, this bound represents the maximum attainable, as there exist planar graphs without larger independent sets; for instance, consider disjoint copies of complete graphs with 4444 vertices. Some weaker lower bounds are also established [1, 20] that circumvent the complexity of the 4-color theorem (as suggested by Erdős [5]) via charging and discharging argument. From an algorithmic standpoint, determining the maximum independent set in planar graphs is \NP-hard, even when restricted to planar graphs of maximum degree 3, see [27, 35] or planar triangle-free graphs, see [33]. Consequently, efforts have shifted towards finding large independent sets through methods like approximation algorithms [2, 4, 14, 18, 24, 33], parallel algorithms [19, 22, 28], fixed-parameter tractable algorithms [26, 31, 25, 21] or within certain minor-free planar graphs [24, 32, 34]. The size α⁢(G)𝛼𝐺\alpha(G)italic_α ( italic_G ) serves as a crucial parameter in graph theory and holds significance in algorithmic contexts. For instance, Kirkpatrick [30] and Dobkin and Kirkpatrick [23] employed the repeated removal of independent sets from triangulations to devise data structures for efficient point location and distance computation between convex polytopes, respectively. For this technique, it is important that the vertices in the independent set have bounded degrees. Biedl and Wilkinson [6] further explored the size of bounded degree independent sets in triangulations. In addition, Bose, Dujmović and Wood [13] studied how to obtain graphs with large independent sets of bounded degrees in graphs of bounded treewidth. In the above context, ‘bounded degree independent set’ meant that every vertex of the independent set should have degree at most d𝑑ditalic_d, for some specified constant d𝑑ditalic_d. In contrast to this, we study here independent sets where every vertex of the independent set should have degree at least d𝑑ditalic_d. We call this a d𝑑ditalic_d-independent set111The term ‘d𝑑ditalic_d-independent set’ is heavily overloaded in the literature; for example, it has also been used for an independent set of cardinality d𝑑ditalic_d [11] or for an independent set that induces a graph of maximum degree d𝑑ditalic_d [16]. Unfortunately, more descriptive notations such as ‘(deg≥d)degree𝑑(\deg\geq d)( roman_deg ≥ italic_d )-independent set’ are rather difficult to parse. and the maximum size of a d𝑑ditalic_d-independent set in G𝐺Gitalic_G is called the d𝑑ditalic_d-independence number of G𝐺Gitalic_G and denoted αd⁢(G)subscript𝛼𝑑𝐺\alpha_{d}(G)italic_α start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ). We also speak of the independence number of a graph class 𝒢𝒢\mathcal{G}caligraphic_G (such as ‘the 1-planar graphs’), which is a function that depends on n𝑛nitalic_n and denotes the maximum of αd⁢(G)subscript𝛼𝑑𝐺\alpha_{d}(G)italic_α start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ) over all graphs G𝐺Gitalic_G with n𝑛nitalic_n vertices in 𝒢𝒢\mathcal{G}caligraphic_G. The d𝑑ditalic_d-independence number for planar graphs was first studied by Caro and Roditty in [15] (they actually studied graphs of minimum degree d𝑑ditalic_d, which means that any independent set is a d𝑑ditalic_d-independent set). They showed that any independent set in a simple planar graph G𝐺Gitalic_G with minimum degree d𝑑ditalic_d has size at most 2⁢n−4d2𝑛4𝑑\tfrac{2n-4}{d}divide start_ARG 2 italic_n - 4 end_ARG start_ARG italic_d end_ARG. They also showed that these bounds are tight for 2≤d≤52𝑑52\leq d\leq 52 ≤ italic_d ≤ 5 by constructing infinite families of simpler planar graphs with minimum degree d𝑑ditalic_d and an independent set of size 2⁢n−4d2𝑛4𝑑\tfrac{2n-4}{d}divide start_ARG 2 italic_n - 4 end_ARG start_ARG italic_d end_ARG. There are various generalizations of planar graphs, for example, a 1111-planar graph is a graph that can be drawn in the Euclidean plane with at most one crossing per edge. In this paper, we study the independence number of 1111-planar graphs. Borodin [12] establishes that every 1111-planar graph G𝐺Gitalic_G has chromatic number at most 6666, therefore α⁢(G)≥n/6𝛼𝐺𝑛6\alpha(G)\geq n/6italic_α ( italic_G ) ≥ italic_n / 6. This is tight; for example, a graph consisting of disjoint copies of K6subscript𝐾6K_{6}italic_K start_POSTSUBSCRIPT 6 end_POSTSUBSCRIPT is 1111-planar and has chromatic number 6666. Unlike planar graphs, to the best of our knowledge, there are no prior results222Preliminary version appeared in [8]. on the upper bound for the d𝑑ditalic_d-independence number of 1111-planar graphs. Motivated by the work by Caro and Roditty, we ask the following: Problem 1. What is the d𝑑ditalic_d-independence number of 1-planar graphs? And does it change if we additionally require the graphs to have minimum degree d𝑑ditalic_d? In this paper, we address Problem 1 by giving upper bounds for the d𝑑ditalic_d-independence number of 1-planar graphs for d≥3𝑑3d\geq 3italic_d ≥ 3. (No smaller values of d𝑑ditalic_d are worth studying, since K2,nsubscript𝐾2𝑛K_{2,n}italic_K start_POSTSUBSCRIPT 2 , italic_n end_POSTSUBSCRIPT has a 2-independent set of size n−2𝑛2n-2italic_n - 2, and so only trivial bounds of n−O⁢(1)𝑛𝑂1n-O(1)italic_n - italic_O ( 1 ) can be shown.) Specifically, we show that αd⁢(n)≤4d+⌈d/3⌉⁢(n−2)subscript𝛼𝑑𝑛4𝑑𝑑3𝑛2\alpha_{d}(n)\leq\tfrac{4}{d+\lceil d/3\rceil}(n-2)italic_α start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_n ) ≤ divide start_ARG 4 end_ARG start_ARG italic_d + ⌈ italic_d / 3 ⌉ end_ARG ( italic_n - 2 ) for d≥3𝑑3d\geq 3italic_d ≥ 3, and this bound holds not only for simple graphs but also in the presence of parallel edges as long as (in some 1-planar drawing) there are no bigons. For simple graphs we can prove the stronger bound α3⁢(n)≤67⁢(n−2)subscript𝛼3𝑛67𝑛2\alpha_{3}(n)\leq\tfrac{6}{7}(n-2)italic_α start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n ) ≤ divide start_ARG 6 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ). Then we construct classes of 1-planar graphs that match these bounds (at least if we permit parallel edges); for small values of d𝑑ditalic_d, we can construct the graphs such that they are simple and have minimum degree d𝑑ditalic_d. A concise summary of our results is in Table 1. d𝑑ditalic_d 3333 4444 5555 6666 7777 8888 9999 10101010 11111111 12121212 13131313 14141414 15151515 16161616 17171717 18181818 ≥19absent19{\geq}19≥ 19 αd⁢(G)/n≤subscript𝛼𝑑𝐺𝑛absent\alpha_{d}(G)/n\leqitalic_α start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ) / italic_n ≤ ≈67absent67{\scriptstyle{\approx}}\tfrac{6}{7}≈ divide start_ARG 6 end_ARG start_ARG 7 end_ARG ≈23absent23{\scriptstyle{\approx}}\tfrac{2}{3}≈ divide start_ARG 2 end_ARG start_ARG 3 end_ARG ≈47absent47{\scriptstyle{\approx}}\tfrac{4}{7}≈ divide start_ARG 4 end_ARG start_ARG 7 end_ARG ≈12absent12{\scriptstyle{\approx}}\tfrac{1}{2}≈ divide start_ARG 1 end_ARG start_ARG 2 end_ARG ≈25absent25{\scriptstyle{\approx}}\tfrac{2}{5}≈ divide start_ARG 2 end_ARG start_ARG 5 end_ARG ≈411absent411{\scriptstyle{\approx}}\tfrac{4}{11}≈ divide start_ARG 4 end_ARG start_ARG 11 end_ARG ≈13absent13{\scriptstyle{\approx}}\tfrac{1}{3}≈ divide start_ARG 1 end_ARG start_ARG 3 end_ARG ≈27absent27{\scriptstyle{\approx}}\tfrac{2}{7}≈ divide start_ARG 2 end_ARG start_ARG 7 end_ARG ≈415absent415{\scriptstyle{\approx}}\tfrac{4}{15}≈ divide start_ARG 4 end_ARG start_ARG 15 end_ARG ≈14absent14{\scriptstyle{\approx}}\tfrac{1}{4}≈ divide start_ARG 1 end_ARG start_ARG 4 end_ARG ≈29absent29{\scriptstyle{\approx}}\tfrac{2}{9}≈ divide start_ARG 2 end_ARG start_ARG 9 end_ARG ≈419absent419{\scriptstyle{\approx}}\tfrac{4}{19}≈ divide start_ARG 4 end_ARG start_ARG 19 end_ARG ≈15absent15{\scriptstyle{\approx}}\tfrac{1}{5}≈ divide start_ARG 1 end_ARG start_ARG 5 end_ARG ≈211absent211{\scriptstyle{\approx}}\tfrac{2}{11}≈ divide start_ARG 2 end_ARG start_ARG 11 end_ARG ≈423absent423{\scriptstyle{\approx}}\tfrac{4}{23}≈ divide start_ARG 4 end_ARG start_ARG 23 end_ARG ≈16absent16{\scriptstyle{\approx}}\tfrac{1}{6}≈ divide start_ARG 1 end_ARG start_ARG 6 end_ARG ≈4d+⌈d/3⌉absent4𝑑𝑑3{\scriptstyle{\approx}}\tfrac{4}{d+\lceil d/3\rceil}≈ divide start_ARG 4 end_ARG start_ARG italic_d + ⌈ italic_d / 3 ⌉ end_ARG (G𝐺Gitalic_G is bigon-free) (G𝐺Gitalic_G simple) ∃G:αd⁢(G)/n≥:𝐺subscript𝛼𝑑𝐺𝑛absent\,\exists G:\alpha_{d}(G)/n\geq∃ italic_G : italic_α start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ) / italic_n ≥ ≈67absent67{\scriptstyle{\approx}}\tfrac{6}{7}≈ divide start_ARG 6 end_ARG start_ARG 7 end_ARG ≈23absent23{\scriptstyle{\approx}}\tfrac{2}{3}≈ divide start_ARG 2 end_ARG start_ARG 3 end_ARG ≈47absent47{\scriptstyle{\approx}}\tfrac{4}{7}≈ divide start_ARG 4 end_ARG start_ARG 7 end_ARG ≈12absent12{\scriptstyle{\approx}}\tfrac{1}{2}≈ divide start_ARG 1 end_ARG start_ARG 2 end_ARG ≈25absent25{\scriptstyle{\approx}}\tfrac{2}{5}≈ divide start_ARG 2 end_ARG start_ARG 5 end_ARG ≈13absent13{\scriptstyle{\approx}}\tfrac{1}{3}≈ divide start_ARG 1 end_ARG start_ARG 3 end_ARG ≈27absent27{\scriptstyle{\approx}}\tfrac{2}{7}≈ divide start_ARG 2 end_ARG start_ARG 7 end_ARG ≈14absent14{\scriptstyle{\approx}}\tfrac{1}{4}≈ divide start_ARG 1 end_ARG start_ARG 4 end_ARG ≈313absent313{\scriptstyle{\approx}}\tfrac{3}{13}≈ divide start_ARG 3 end_ARG start_ARG 13 end_ARG ≈314absent314{\scriptstyle{\approx}}\tfrac{3}{14}≈ divide start_ARG 3 end_ARG start_ARG 14 end_ARG ≈15absent15{\scriptstyle{\approx}}\tfrac{1}{5}≈ divide start_ARG 1 end_ARG start_ARG 5 end_ARG ≈211absent211{\scriptstyle{\approx}}\tfrac{2}{11}≈ divide start_ARG 2 end_ARG start_ARG 11 end_ARG ≈16absent16{\scriptstyle{\approx}}\tfrac{1}{6}≈ divide start_ARG 1 end_ARG start_ARG 6 end_ARG ≈319absent319{\scriptstyle{\approx}}\tfrac{3}{19}≈ divide start_ARG 3 end_ARG start_ARG 19 end_ARG ≈320absent320{\scriptstyle{\approx}}\tfrac{3}{20}≈ divide start_ARG 3 end_ARG start_ARG 20 end_ARG ≈17absent17{\scriptstyle{\approx}}\tfrac{1}{7}≈ divide start_ARG 1 end_ARG start_ARG 7 end_ARG ≈2d−4absent2𝑑4{\scriptstyle{\approx}}\tfrac{2}{d-4}≈ divide start_ARG 2 end_ARG start_ARG italic_d - 4 end_ARG (G𝐺Gitalic_G is simple) ∃G:αd⁢(G)/n≥:𝐺subscript𝛼𝑑𝐺𝑛absent\,\exists G:\alpha_{d}(G)/n\geq∃ italic_G : italic_α start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ) / italic_n ≥ ≈1absent1{\scriptstyle{\approx}}1≈ 1 ≈23absent23{\scriptstyle{\approx}}\tfrac{2}{3}≈ divide start_ARG 2 end_ARG start_ARG 3 end_ARG ≈47absent47{\scriptstyle{\approx}}\tfrac{4}{7}≈ divide start_ARG 4 end_ARG start_ARG 7 end_ARG ≈12absent12{\scriptstyle{\approx}}\tfrac{1}{2}≈ divide start_ARG 1 end_ARG start_ARG 2 end_ARG ≈25absent25{\scriptstyle{\approx}}\tfrac{2}{5}≈ divide start_ARG 2 end_ARG start_ARG 5 end_ARG ≈411absent411{\scriptstyle{\approx}}\tfrac{4}{11}≈ divide start_ARG 4 end_ARG start_ARG 11 end_ARG ≈13absent13{\scriptstyle{\approx}}\tfrac{1}{3}≈ divide start_ARG 1 end_ARG start_ARG 3 end_ARG ≈27absent27{\scriptstyle{\approx}}\tfrac{2}{7}≈ divide start_ARG 2 end_ARG start_ARG 7 end_ARG ≈415absent415{\scriptstyle{\approx}}\tfrac{4}{15}≈ divide start_ARG 4 end_ARG start_ARG 15 end_ARG ≈14absent14{\scriptstyle{\approx}}\tfrac{1}{4}≈ divide start_ARG 1 end_ARG start_ARG 4 end_ARG ≈29absent29{\scriptstyle{\approx}}\tfrac{2}{9}≈ divide start_ARG 2 end_ARG start_ARG 9 end_ARG ≈419absent419{\scriptstyle{\approx}}\tfrac{4}{19}≈ divide start_ARG 4 end_ARG start_ARG 19 end_ARG ≈15absent15{\scriptstyle{\approx}}\tfrac{1}{5}≈ divide start_ARG 1 end_ARG start_ARG 5 end_ARG ≈211absent211{\scriptstyle{\approx}}\tfrac{2}{11}≈ divide start_ARG 2 end_ARG start_ARG 11 end_ARG ≈423absent423{\scriptstyle{\approx}}\tfrac{4}{23}≈ divide start_ARG 4 end_ARG start_ARG 23 end_ARG ≈16absent16{\scriptstyle{\approx}}\tfrac{1}{6}≈ divide start_ARG 1 end_ARG start_ARG 6 end_ARG ≈4d+⌈d/3⌉absent4𝑑𝑑3{\scriptstyle{\approx}}\tfrac{4}{d+\lceil d/3\rceil}≈ divide start_ARG 4 end_ARG start_ARG italic_d + ⌈ italic_d / 3 ⌉ end_ARG (G𝐺Gitalic_G is bigon-free) Table 1: Bounds on the d𝑑ditalic_d-independence number of 1-planar graphs. ‘≈{\scriptstyle{\approx}}≈’ means lower-order terms are omitted. Our constructions for d=3,4,5𝑑345d=3,4,5italic_d = 3 , 4 , 5 actually happen to have minimum degree d𝑑ditalic_d, so requiring the minimum degree of the graph to be d𝑑ditalic_d makes no difference for d=3,4,5𝑑345d=3,4,5italic_d = 3 , 4 , 5. What happens for d=6,7𝑑67d=6,7italic_d = 6 , 7? (A 1-planar graph has at most 4⁢n−84𝑛84n-84 italic_n - 8 edges, and so cannot have a minimum degree 8 or more.) For d=6𝑑6d=6italic_d = 6 we can modify our construction slightly to achieve a minimum degree 6 while weakening the lower bound by only a constant term. For d=7𝑑7d=7italic_d = 7 we give an entirely different construction that has a fairly large independent set, but we leave a multiplicative gap to the upper bound, see Table 2. δ⁢(G)=𝛿𝐺absent\delta(G)=italic_δ ( italic_G ) = 3333 4444 5555 6666 7777 αδ⁢(G)⁢(G)≤subscript𝛼𝛿𝐺𝐺absent\alpha_{\delta(G)}(G)\leqitalic_α start_POSTSUBSCRIPT italic_δ ( italic_G ) end_POSTSUBSCRIPT ( italic_G ) ≤ 67⁢(n−2)67𝑛2\tfrac{6}{7}(n-2)divide start_ARG 6 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ) 23⁢(n−2)23𝑛2\tfrac{2}{3}(n-2)divide start_ARG 2 end_ARG start_ARG 3 end_ARG ( italic_n - 2 ) 47⁢(n−2)47𝑛2\tfrac{4}{7}(n-2)divide start_ARG 4 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ) ⌈12⁢(n−4)⌉12𝑛4\lceil\tfrac{1}{2}(n-4)\rceil⌈ divide start_ARG 1 end_ARG start_ARG 2 end_ARG ( italic_n - 4 ) ⌉ 410⁢(n−2)410𝑛2\tfrac{4}{10}(n-2)divide start_ARG 4 end_ARG start_ARG 10 end_ARG ( italic_n - 2 ) ∃G:αδ⁢(G)≥:𝐺subscript𝛼𝛿𝐺absent\exists G:\alpha_{\delta(G)}\geq∃ italic_G : italic_α start_POSTSUBSCRIPT italic_δ ( italic_G ) end_POSTSUBSCRIPT ≥ 67⁢(n−2)67𝑛2\tfrac{6}{7}(n-2)divide start_ARG 6 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ) 23⁢(n−2)23𝑛2\tfrac{2}{3}(n-2)divide start_ARG 2 end_ARG start_ARG 3 end_ARG ( italic_n - 2 ) 47⁢(n−2)47𝑛2\tfrac{4}{7}(n-2)divide start_ARG 4 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ) 12⁢(n−4)12𝑛4\tfrac{1}{2}(n-4)divide start_ARG 1 end_ARG start_ARG 2 end_ARG ( italic_n - 4 ) 821⁢(n−13.5)821𝑛13.5\tfrac{8}{21}(n-13.5)divide start_ARG 8 end_ARG start_ARG 21 end_ARG ( italic_n - 13.5 ) Table 2: Bounds on the d𝑑ditalic_d-independence number of 1111-planar graphs with minimum degree δ⁢(G)=d𝛿𝐺𝑑\delta(G)=ditalic_δ ( italic_G ) = italic_d. All constructed graphs are simple. We also study the special situation concerns optimal 1-planar graphs, which have the maximum-possible number 4⁢n−84𝑛84n-84 italic_n - 8 of edges. (This is motivated by the observation that the lower-bound constructions of Caro and Roditty all use planar graphs with the maximum possible number of edges, whereas our earlier construction usually does not have the maximum number of edges.) Here we can show that the independence number is at most 2d⁢(n−2)2𝑑𝑛2\tfrac{2}{d}(n-2)divide start_ARG 2 end_ARG start_ARG italic_d end_ARG ( italic_n - 2 ), and this is tight if we allow parallel edges (and, for small d𝑑ditalic_d, even for simple optimal 1-planar graphs). Our results are summarized in Table 3. d𝑑ditalic_d 6 8 10 12 ≥14absent14\geq 14≥ 14 even αδ⁢(G)⁢(G)≤subscript𝛼𝛿𝐺𝐺absent\alpha_{\delta(G)}(G)\leqitalic_α start_POSTSUBSCRIPT italic_δ ( italic_G ) end_POSTSUBSCRIPT ( italic_G ) ≤ 13⁢(n−2)13𝑛2\tfrac{1}{3}(n-2)divide start_ARG 1 end_ARG start_ARG 3 end_ARG ( italic_n - 2 ) 14⁢(n−2)14𝑛2\tfrac{1}{4}(n-2)divide start_ARG 1 end_ARG start_ARG 4 end_ARG ( italic_n - 2 ) 15⁢(n−2)15𝑛2\tfrac{1}{5}(n-2)divide start_ARG 1 end_ARG start_ARG 5 end_ARG ( italic_n - 2 ) 16⁢(n−2)16𝑛2\tfrac{1}{6}(n-2)divide start_ARG 1 end_ARG start_ARG 6 end_ARG ( italic_n - 2 ) 2d⁢(n−2)2𝑑𝑛2\tfrac{2}{d}(n-2)divide start_ARG 2 end_ARG start_ARG italic_d end_ARG ( italic_n - 2 ) (G𝐺Gitalic_G is bigon-free) ∃G:αδ⁢(G)≥:𝐺subscript𝛼𝛿𝐺absent\exists G:\alpha_{\delta(G)}\geq∃ italic_G : italic_α start_POSTSUBSCRIPT italic_δ ( italic_G ) end_POSTSUBSCRIPT ≥ 13⁢(n−2)13𝑛2\tfrac{1}{3}(n-2)divide start_ARG 1 end_ARG start_ARG 3 end_ARG ( italic_n - 2 ) 14⁢(n−2)14𝑛2\tfrac{1}{4}(n-2)divide start_ARG 1 end_ARG start_ARG 4 end_ARG ( italic_n - 2 ) 15⁢(n−2)15𝑛2\tfrac{1}{5}(n-2)divide start_ARG 1 end_ARG start_ARG 5 end_ARG ( italic_n - 2 ) 16⁢(n−4)16𝑛4\tfrac{1}{6}(n-4)divide start_ARG 1 end_ARG start_ARG 6 end_ARG ( italic_n - 4 ) 2d⁢(n−2)2𝑑𝑛2\tfrac{2}{d}(n-2)divide start_ARG 2 end_ARG start_ARG italic_d end_ARG ( italic_n - 2 ) (simple) (simple) (simple) (simple) (bigon-free) Table 3: Bounds on the d𝑑ditalic_d-independence number of optimal 1111-planar graphs. Our paper is organized as follows. After giving preliminaries, we first present in Section 3 upper bounds for the d𝑑ditalic_d-independence number of 1111-planar graphs, strongly inspired by techniques from [7] to bound matchings in 1111-planar graphs. In Section 4, we then construct a number of infinite families of 1111-planar graphs with large d𝑑ditalic_d-independent sets that match these bounds, and then further constructions when we require simplicity and/or minimum degree d𝑑ditalic_d. Section 5 focuses on the independence number of optimal 1111-planar graphs. Finally, we conclude our paper with further thoughts and pose some open questions."
https://arxiv.org/html/2411.00806v1,"Approximating Diffusion on Finite
Multi-Topology Systems Using Ultrametrics","Motivated by multi-topology building and city model data, first a lossless representation of multiple T0subscript𝑇0T_{0}italic_T start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT-topologies on a given finite set by a vertex-edge-weighted graph is given, and the subdominant ultrametric of the associated weighted graph distance matrix is proposed as an index structure for these data. This is applied in a heuristic parallel topological sort algorithm for edge-weighted directed acyclic graphs. Such structured data are of interest in simulation of processes like heat flows on building or city models on distributed processors. With this in view, the bulk of this article calculates the spectra of certain unbounded self-adjoint p𝑝pitalic_p-adic Laplacian operators on the L2superscript𝐿2L^{2}italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT-spaces of a compact open subdomain of the p𝑝pitalic_p-adic number field associated with a finite graph G𝐺Gitalic_G with respect to the restricted Haar measure. as well as to a Radon measure coming from an ultrametric on the vertices of G𝐺Gitalic_G with the help of p𝑝pitalic_p-adic polynomial interpolation. In the end, error bounds are given for the solutions of the corresponding heat equations by finite approximations of such operators.","A substantial part of data analysis deals with given finite data, viewed as nodes, and varying pairwise interaction or connectivity, viewed as edges, plus higher-order interaction or connectivity, viewed as simplices. The different graph or simplicial structures on the data help in their understanding by exploring underlying topological and geometrical properties. Diffusion on such structures can often be used as a further tool for understanding them. The diffusion on such structures itself is also often not well understood, and this gives rise to its analytical study. In order to facilitate a data exploration as described above, it is helpful to have an access method for the structered data, and in many cases to distribute the processing onto many different computational units. For both tasks, a hierarchical re-structuring of the data can lead to both, fast accessing and fast processing. This is one of the goals of the current research project Distributed Simulation of Processes in Buildings and City Models in order to facilitate the simulation of processes like heat flows in city models at varying levels of resolution. In particular, if the resolution is high, then substitute models become necessary, as otherwise computing huge Laplacian matrices becomes unfeasible. Hierarchical substitute models are natural candidates for efficient computations, as accessing trees is known to be possible in logarithmic time w.r.t. the number of leaf nodes. Since mathematics provides through the field ℚpsubscriptℚ𝑝\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT of p𝑝pitalic_p-adic numbers a natural hierarchical number system (aka ultrametric), it seemed natural to use these already for indexing point cloud data, i.e. in the case of dimension zero [7]. In any case, it becomes in the above perspective natural to resort to p𝑝pitalic_p-adic diffusion which was initiated via formulating the heat equation with the Vladimirov-Taibleson operator on ℚpsubscriptℚ𝑝\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT or other non-archimedean local fields [22, 23]. This p𝑝pitalic_p-adic Laplacian being a pseudodifferential operator necessitates the domain to be a locally compact abelian group. Another example is the group ℤpsubscriptℤ𝑝\mathds{Z}_{p}blackboard_Z start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT of p𝑝pitalic_p-adic integers [15, 20]. However, if the p𝑝pitalic_p-adic space itself does not have a group structure, then the Fourier transform is no longer available to construct a Laplacian. Its integral operator description was adapted by Zúñiga-Galindo to the study of Turing patterns on networks, leading to diffusion operators on general compact open subdomains of ℚpsubscriptℚ𝑝\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [24]. This approach lends to the idea of asking for diffusion operators on more general p𝑝pitalic_p-adic manifolds. In the case of Mumford curves (which can be viewed as compact closed p𝑝pitalic_p-adic algebraic manifolds), this is ongoing work containing operators which allow to extract topological information from these spaces [3, 4, 5, 6], or also from finite graphs [8]. Applications of ultrametric analysis outside of mathematics or mathematical physics include, but do not restrict to, image processing or microbiology [2, 12]. An important feature of p𝑝pitalic_p-adic or general ultrametric Laplacians is that a huge part of their spectra correspond to Haar-like wavelets of various types [16, 12]. Among p𝑝pitalic_p-adic analysts, the Kozyrev wavelets are the most well-known ones. The goal of this contribution is to define and study p𝑝pitalic_p-adically extended Laplace operators for finite graphs, based on • weighted graph adjacency • weighted graph distance • the subdominant ultrametric of the weighted graph distance and to investigate finite approximations of the solutions to the heat equation corresponding to the above Laplacian operators. The envisaged input data are not merely a graph, but representations of multiple T0subscript𝑇0T_{0}italic_T start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT-topologies on a finite point set (cf. [1]), as this is how data are assembled in the research project mentioned above. The representation is given in the form of a weighted graph, and the subdominant ultrametric of the corresponding graph distance function provides for an index structure in order to efficiently access the topologica data. The vertices of such a graph are now, as in Zúniga’s work [24], associated with disjoint subdiscs of ℚpsubscriptℚ𝑝\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT, and p𝑝pitalic_p-adic polynomial interpolation then allows to construct a Radon measure on this compact p𝑝pitalic_p-adic submanifold. It can be viewed as coming from a regular differential 1111-form on an open piece of a Mumford curve. The natural question arises, whether and when different datasets could be viewed as samples from open compact patches which form a covering of a Mumford curve. This is accompanied by a construction of unbounded p𝑝pitalic_p-adic diffusion operators of the three mentioned types, together with a study of their spectra, Cauchy problem and heat kernels. This complements the bounded Laplacians provided by Zúñiga-Galindo [24]. The last contribution consists of error estimates for the solutions of the different types of heat equations. An important concept on the way is given by ultrametric wavelets, a generalisation of Kozyrev wavelets to arbitrary ultrametric spaces, described in [14], whose corresponding trees are locally finite. Having been inspired by the Haar-like wavelets from [11], these ultrametric wavelets are presented here differently than in [14] by using characters of finite cyclic groups, while not making use of their special ultrametric distance and measure. The results of this study can be grouped as follows: 1. Indexing multi-topologies. Motivated by the building and city model data related to the mentioned project, and which consists of points having multiple topologies, because any binary partial ordering defines a T0subscript𝑇0T_{0}italic_T start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT-topologie (and vice versa) by [1], an index structure can be derived by first representing the multiple topologies in a single graph, and then using the subdominant ultrametric of the graph distance. Multiple topologies on a point set arise from various different acyclic binary relations on the same set, like e.g. boundary and aggregation relations, or time-dependent relationships. Observation (2.2). Multiple topologies on a finite point set have a lossless representation as a vertex-weighted graph. Hence, a proposed index structure simply requires a weighted graph: Proposal (2.3). As an index structure for a weighted graph is proposed the subdominant ultrametric of its weigted graph distance matrix. As an application of this index structure, a heuristic parallel topological sort is proposed: Algorithm (2.7). Given an edge-weighted directed acyclic graph, cluster the vertices in parallel, then sort and merge the clusters in parallel, using the subdominant ultrametric index structure. 2. Laplace spectra w.r.t. Haar measure d⁢x𝑑𝑥dxitalic_d italic_x. Unbounded p𝑝pitalic_p-adic kernel functions kpsubscript𝑘𝑝k_{p}italic_k start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT depending on the type of interaction between vertices of a finite simple connected graph are defined: adjacency, graph distance, (subdominant) ultrametric distance. The Cauchy problem for the heat equation w.r.t. the corresponding Laplacian operator ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT is studied, as well as its spectrum on L2⁢(Z,d⁢x)superscript𝐿2𝑍𝑑𝑥L^{2}(Z,dx)italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Z , italic_d italic_x ), where Z⊂ℚp𝑍subscriptℚ𝑝Z\subset\mathds{Q}_{p}italic_Z ⊂ blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT is the compact open subset given as the disjoint union of the p𝑝pitalic_p-adic discs defined by the vertices of a given finite simple and connected graph. In this first part, the measure used on Z𝑍Zitalic_Z is the restricted Haar measure d⁢x𝑑𝑥dxitalic_d italic_x from ℚpsubscriptℚ𝑝\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT. Theorem (3.5). There exists a probability measure pt⁢(x,⋅)subscript𝑝𝑡𝑥⋅p_{t}(x,\cdot)italic_p start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x , ⋅ ) with t≥0𝑡0t\geq 0italic_t ≥ 0, x∈Z𝑥𝑍x\in Zitalic_x ∈ italic_Z on the Borel σ𝜎\sigmaitalic_σ-algebra of the compact open Z⊂ℚp𝑍subscriptℚ𝑝Z\subset\mathds{Q}_{p}italic_Z ⊂ blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT such that the Cauchy problem for the heat equation with the (unbounded) p𝑝pitalic_p-adic Laplacian operator ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT has a unique solution of the form h⁢(x,t)=∫Zkp⁢(x,y)⁢pt⁢(x,d⁢y)ℎ𝑥𝑡subscript𝑍subscript𝑘𝑝𝑥𝑦subscript𝑝𝑡𝑥𝑑𝑦h(x,t)=\int_{Z}k_{p}(x,y)p_{t}(x,dy)italic_h ( italic_x , italic_t ) = ∫ start_POSTSUBSCRIPT italic_Z end_POSTSUBSCRIPT italic_k start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_x , italic_y ) italic_p start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x , italic_d italic_y ) In addition, pt⁢(x,⋅)subscript𝑝𝑡𝑥⋅p_{t}(x,\cdot)italic_p start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x , ⋅ ) is the transition function of a strong Markov process whose paths are càdlàg paths. Theorem (3.6). The space L2⁢(Z,d⁢x)superscript𝐿2𝑍𝑑𝑥L^{2}(Z,dx)italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Z , italic_d italic_x ) has an orthonormal basis consisting of the Kozyrev wavelets supported in the discs Uv⊂Zsubscript𝑈𝑣𝑍U_{v}\subset Zitalic_U start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ⊂ italic_Z associated with vertices v𝑣vitalic_v, and the locally constant functions Z→ℂ→𝑍ℂZ\to\mathds{C}italic_Z → blackboard_C associated with the eigenvectors of a certain Laplacian matrix. These wavelets and functions are all eigenfunctions of operator ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT. In the Kozyrev case, the corresponding eigenvalue can be explicitly given. the operator ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT is self-adjoint, negative semi-definite in case the discs associated with vertices are sufficiently small, and each eigenvalue has only finite multiplicity. Assuming now that ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT is also negative semi-definite, obtain: Corollary (3.7). The heat kernel of ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT exists and has the following form: p⁢(t,x,y)=∑λ∈Spec⁡(ℋ∙)eλ⁢t⁢ψλ⁢(x)⁢ψλ⁢(y)𝑝𝑡𝑥𝑦subscript𝜆Specsubscriptℋ∙superscript𝑒𝜆𝑡subscript𝜓𝜆𝑥subscript𝜓𝜆𝑦p(t,x,y)=\sum\limits_{\lambda\in\operatorname{Spec}(\mathcal{H}_{\bullet})}e^{% \lambda t}\psi_{\lambda}(x)\psi_{\lambda}(y)italic_p ( italic_t , italic_x , italic_y ) = ∑ start_POSTSUBSCRIPT italic_λ ∈ roman_Spec ( caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT ) end_POSTSUBSCRIPT italic_e start_POSTSUPERSCRIPT italic_λ italic_t end_POSTSUPERSCRIPT italic_ψ start_POSTSUBSCRIPT italic_λ end_POSTSUBSCRIPT ( italic_x ) italic_ψ start_POSTSUBSCRIPT italic_λ end_POSTSUBSCRIPT ( italic_y ) for t≥0𝑡0t\geq 0italic_t ≥ 0 and x,y∈Z𝑥𝑦𝑍x,y\in Zitalic_x , italic_y ∈ italic_Z, where ψλsubscript𝜓𝜆\psi_{\lambda}italic_ψ start_POSTSUBSCRIPT italic_λ end_POSTSUBSCRIPT is a normalised eigenfunction of ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT with eigenvalue λ∈Spec⁡(ℋ∙)𝜆Specsubscriptℋ∙\lambda\in\operatorname{Spec}(\mathcal{H}_{\bullet})italic_λ ∈ roman_Spec ( caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT ). 3. Spectrum of p𝑝pitalic_p-adic operators from an ultrametric. Using p𝑝pitalic_p-adic polynomial interpolation, a Radon measure ν𝜈\nuitalic_ν on Z𝑍Zitalic_Z is constructed from an ultrametric on the vertex set of a finite graph and the p𝑝pitalic_p-adic discs representing the vertices. In general, the interpolation polynomial is non-linear of high degree, expectedly depending on the number of vertices. The corresponding Radon measure can be viewed as coming from a differential 1111-form on Z𝑍Zitalic_Z, giving rise to the idea that a Mumford curve might be in the background. Furtheromore, Inspired by [11], ultrametric wavelets generalising Kozyrev wavelets are constructed. Then it holds true that: Theorem (3.13). The space L2⁢(Z,ν)superscript𝐿2𝑍𝜈L^{2}(Z,\nu)italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Z , italic_ν ) has an orthonormal basis consisting of the constant function ν⁢(Z)−1𝜈superscript𝑍1\nu(Z)^{-1}italic_ν ( italic_Z ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT, and the Kozyrev wavelets supported in the discs associated with the vertices of the graph, and the ultrametric wavelets. These functions are all eigenfunctions of the operator ℋδsubscriptℋ𝛿\mathcal{H}_{\delta}caligraphic_H start_POSTSUBSCRIPT italic_δ end_POSTSUBSCRIPT. The eigenvalues corresponding to the wavelets are explicitly given in terms of the differential 1111-form and quantities derived thereof for producing the Radon measure ν𝜈\nuitalic_ν. The operator ℋδsubscriptℋ𝛿\mathcal{H}_{\delta}caligraphic_H start_POSTSUBSCRIPT italic_δ end_POSTSUBSCRIPT is self-adjoint and negative-definite on L2⁢(Z,ν)superscript𝐿2𝑍𝜈L^{2}(Z,\nu)italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Z , italic_ν ). Here, δ𝛿\deltaitalic_δ is an ultrametric on the vertex set of the graph. It is a replacement for the ∙∙\bullet∙ in the previous set-up, where it instances the subdominant ultrametric of a weighted graph metric. 4. Convergence and error estimates. By discretising the space Z𝑍Zitalic_Z via finite rooted trees resulting from pruning, approximate finite-dimensional operators for ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT can be defined, and the errors in the solution to the Cauchy problem are estimated. Theorem (4.1). Let T∙ℓ⁢(t)superscriptsubscript𝑇∙ℓ𝑡T_{\bullet}^{\ell}(t)italic_T start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_ℓ end_POSTSUPERSCRIPT ( italic_t ) and T∙⁢(t)subscript𝑇∙𝑡T_{\bullet}(t)italic_T start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT ( italic_t ) be the semigroups attached to the operators ℋ∙ℓsuperscriptsubscriptℋ∙ℓ\mathcal{H}_{\bullet}^{\ell}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_ℓ end_POSTSUPERSCRIPT and ℋ∙subscriptℋ∙\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT, respectively. Let u∈C⁢(Z)𝑢𝐶𝑍u\in C(Z)italic_u ∈ italic_C ( italic_Z ) and t∈[0,γ]𝑡0𝛾t\in[0,\gamma]italic_t ∈ [ 0 , italic_γ ], then ‖T∙ℓ⁢(t)⁢u−T∙⁢(t)⁢u‖∞≤γ⁢‖u‖∞⁢(∑u≠v,[u]𝔫≡[v]𝔫Cu,v⁢Vol⁡(Uv)+Vol⁡(Zℓ∖Z)⁢maxx∈Z,y∈Zℓ∖Z⁡|k∙ℓ⁢(x,y)|).subscriptnormsuperscriptsubscript𝑇∙ℓ𝑡𝑢subscript𝑇∙𝑡𝑢𝛾subscriptnorm𝑢subscriptformulae-sequence𝑢𝑣subscriptdelimited-[]𝑢𝔫subscriptdelimited-[]𝑣𝔫subscript𝐶𝑢𝑣Volsubscript𝑈𝑣Volsubscript𝑍ℓ𝑍subscriptformulae-sequence𝑥𝑍𝑦subscript𝑍ℓ𝑍superscriptsubscript𝑘∙ℓ𝑥𝑦\begin{split}||T_{\bullet}^{\ell}(t)u-T_{\bullet}(t)u||_{\infty}\leq\gamma||u|% |_{\infty}\left(\sum_{u\neq v,[u]_{\mathfrak{n}}\equiv[v]_{\mathfrak{n}}}C_{u,% v}\operatorname{Vol}(U_{v})+\operatorname{Vol}(Z_{\ell}\setminus Z)\max_{x\in Z% ,y\in Z_{\ell}\setminus Z}|k_{\bullet}^{\ell}(x,y)|\right).\end{split}start_ROW start_CELL | | italic_T start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_ℓ end_POSTSUPERSCRIPT ( italic_t ) italic_u - italic_T start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT ( italic_t ) italic_u | | start_POSTSUBSCRIPT ∞ end_POSTSUBSCRIPT ≤ italic_γ | | italic_u | | start_POSTSUBSCRIPT ∞ end_POSTSUBSCRIPT ( ∑ start_POSTSUBSCRIPT italic_u ≠ italic_v , [ italic_u ] start_POSTSUBSCRIPT fraktur_n end_POSTSUBSCRIPT ≡ [ italic_v ] start_POSTSUBSCRIPT fraktur_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT italic_C start_POSTSUBSCRIPT italic_u , italic_v end_POSTSUBSCRIPT roman_Vol ( italic_U start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) + roman_Vol ( italic_Z start_POSTSUBSCRIPT roman_ℓ end_POSTSUBSCRIPT ∖ italic_Z ) roman_max start_POSTSUBSCRIPT italic_x ∈ italic_Z , italic_y ∈ italic_Z start_POSTSUBSCRIPT roman_ℓ end_POSTSUBSCRIPT ∖ italic_Z end_POSTSUBSCRIPT | italic_k start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_ℓ end_POSTSUPERSCRIPT ( italic_x , italic_y ) | ) . end_CELL end_ROW Theorem (4.2). Let ℋasubscriptℋ𝑎\mathcal{H}_{a}caligraphic_H start_POSTSUBSCRIPT italic_a end_POSTSUBSCRIPT and ℋbsubscriptℋ𝑏\mathcal{H}_{b}caligraphic_H start_POSTSUBSCRIPT italic_b end_POSTSUBSCRIPT, where a,b∈{κ,dE,δ}𝑎𝑏𝜅subscript𝑑𝐸𝛿a,b\in{\left\{\kappa,d_{E},\delta\right\}}italic_a , italic_b ∈ { italic_κ , italic_d start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT , italic_δ }. Let Tasubscript𝑇𝑎T_{a}italic_T start_POSTSUBSCRIPT italic_a end_POSTSUBSCRIPT and Tbsubscript𝑇𝑏T_{b}italic_T start_POSTSUBSCRIPT italic_b end_POSTSUBSCRIPT the respective attached subgroups. Then the following holds ‖Ta⁢(t)−Tb‖∞≤2⁢t⁢(∑u≠v,[u]𝔫≡[v]𝔫C~u,v⁢Vol⁡(Uv)).subscriptnormsubscript𝑇𝑎𝑡subscript𝑇𝑏2𝑡subscriptformulae-sequence𝑢𝑣subscriptdelimited-[]𝑢𝔫subscriptdelimited-[]𝑣𝔫subscript~𝐶𝑢𝑣Volsubscript𝑈𝑣||T_{a}(t)-T_{b}||_{\infty}\leq 2t\left(\sum_{u\neq v,[u]_{\mathfrak{n}}\equiv% [v]_{\mathfrak{n}}}\tilde{C}_{u,v}\operatorname{Vol}(U_{v})\right).| | italic_T start_POSTSUBSCRIPT italic_a end_POSTSUBSCRIPT ( italic_t ) - italic_T start_POSTSUBSCRIPT italic_b end_POSTSUBSCRIPT | | start_POSTSUBSCRIPT ∞ end_POSTSUBSCRIPT ≤ 2 italic_t ( ∑ start_POSTSUBSCRIPT italic_u ≠ italic_v , [ italic_u ] start_POSTSUBSCRIPT fraktur_n end_POSTSUBSCRIPT ≡ [ italic_v ] start_POSTSUBSCRIPT fraktur_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT over~ start_ARG italic_C end_ARG start_POSTSUBSCRIPT italic_u , italic_v end_POSTSUBSCRIPT roman_Vol ( italic_U start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) ) . Theorem (4.3). Let u∈X×[0,∞)𝑢𝑋0u\in X\times[0,\infty)italic_u ∈ italic_X × [ 0 , ∞ ) be a solution of the Cauchy problem for the heat equation ∂∂t⁢u⁢(x,t)𝑡𝑢𝑥𝑡\displaystyle\frac{\partial}{\partial t}u(x,t)divide start_ARG ∂ end_ARG start_ARG ∂ italic_t end_ARG italic_u ( italic_x , italic_t ) −ℋ∙⁢u⁢(x,t)=0subscriptℋ∙𝑢𝑥𝑡0\displaystyle-\mathcal{H}_{\bullet}u(x,t)=0- caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT italic_u ( italic_x , italic_t ) = 0 u⁢(x,0)𝑢𝑥0\displaystyle u(x,0)italic_u ( italic_x , 0 ) =u0⁢(x)∈Xabsentsubscript𝑢0𝑥𝑋\displaystyle=u_{0}(x)\in X= italic_u start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ( italic_x ) ∈ italic_X and un∈Xn×[0,∞)subscript𝑢𝑛subscript𝑋𝑛0u_{n}\in X_{n}\times[0,\infty)italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ∈ italic_X start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT × [ 0 , ∞ ) a solution of that for ∂∂t⁢un⁢([x]n,t)𝑡subscript𝑢𝑛subscriptdelimited-[]𝑥𝑛𝑡\displaystyle\frac{\partial}{\partial t}u_{n}([x]_{n},t)divide start_ARG ∂ end_ARG start_ARG ∂ italic_t end_ARG italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_t ) −ℋ∙(n)⁢un⁢([x]n,t)=0superscriptsubscriptℋ∙𝑛subscript𝑢𝑛subscriptdelimited-[]𝑥𝑛𝑡0\displaystyle-\mathcal{H}_{\bullet}^{(n)}u_{n}([x]_{n},t)=0- caligraphic_H start_POSTSUBSCRIPT ∙ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT ( italic_n ) end_POSTSUPERSCRIPT italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_t ) = 0 un⁢([x]n,0)subscript𝑢𝑛subscriptdelimited-[]𝑥𝑛0\displaystyle u_{n}([x]_{n},0)italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , 0 ) =Pn⁢u0⁢([x]n)∈Xnabsentsubscript𝑃𝑛subscript𝑢0subscriptdelimited-[]𝑥𝑛subscript𝑋𝑛\displaystyle=P_{n}u_{0}([x]_{n})\in X_{n}= italic_P start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT italic_u start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) ∈ italic_X start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT Then it holds true that limn→∞sup0≤t≤τ‖En⁢un⁢([x]n,t)−u⁢(x,t)‖=0subscript→𝑛subscriptsupremum0𝑡𝜏normsubscript𝐸𝑛subscript𝑢𝑛subscriptdelimited-[]𝑥𝑛𝑡𝑢𝑥𝑡0\lim\limits_{n\to\infty}\sup\limits_{0\leq t\leq\tau}\left\|E_{n}u_{n}([x]_{n}% ,t)-u(x,t)\right\|=0roman_lim start_POSTSUBSCRIPT italic_n → ∞ end_POSTSUBSCRIPT roman_sup start_POSTSUBSCRIPT 0 ≤ italic_t ≤ italic_τ end_POSTSUBSCRIPT ∥ italic_E start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_t ) - italic_u ( italic_x , italic_t ) ∥ = 0 for τ≥0𝜏0\tau\geq 0italic_τ ≥ 0. The article is structured as follows: In Section 2, finite multi-topologies are introduced as a system of finite states endowed with multple T0subscript𝑇0T_{0}italic_T start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT-topologies and interpreted as a complex system with transitions w.r.t. different kinds of topological structures, and diffusion on such. Section 3 defines unbounded p𝑝pitalic_p-adic graph operators on finite weighted graphs with different kinds of kernel functions representing the graph structure via adjacency, graph distance and subdominant ultrametric, defines the corresponding notion of hierarchical Parisi operator and studies the Cauchy problems and Markov process properties. Section 4 estimates errors of the different kinds of operators with respect to each other via tree truncation."
https://arxiv.org/html/2411.02197v1,Matroid Products via Submodular Coupling,"The study of matroid products traces back to the 1970s, when Lovász and Mason studied the existence of various types of matroid products with different strengths. Among these, the tensor product is arguably the most important, which can be considered as an extension of the tensor product from linear algebra. However, Las Vergnas showed that the tensor product of two matroids does not always exist. Over the following four decades, matroid products remained surprisingly underexplored, regaining attention only in recent years due to applications in tropical geometry and the limit theory of matroids.In this paper, inspired by the concept of coupling in probability theory, we introduce the notion of coupling for matroids – or, more generally, for submodular set functions. This operation can be viewed as a relaxation of the tensor product. Unlike the tensor product, however, we prove that a coupling always exists for any two submodular functions and can be chosen to be increasing if the original functions are increasing. As a corollary, we show that two matroids always admit a matroid coupling, leading to a novel operation on matroids. Our construction is algorithmic, providing an oracle for the coupling matroid through a polynomial number of oracle calls to the original matroids.We apply this construction to derive new necessary conditions for matroid representability and establish connection between tensor products and Ingleton’s inequality. Additionally, we verify the existence of set functions that are universal with respect to a given property, meaning any set function over a finite domain with that property can be obtained as a quotient.Keywords: Amalgams, Coupling, Coverage functions, Matroids, Product, Quasi-product, Quotients, Submodular functions, Tensor product","Coupling of probability measures, generally attributed to Doeblin [10], is a key concept in probability theory through which random variables can be compared with each other. For two probability measures, a coupling is a joint probability measure over the product of the underlying spaces, such that the marginals correspond to the given probability measures. Formally, if μ1subscript𝜇1\mu_{1}italic_μ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and μ2subscript𝜇2\mu_{2}italic_μ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are probability measures on spaces (S1,ℬ1)subscript𝑆1subscriptℬ1(S_{1},\mathcal{B}_{1})( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , caligraphic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) and (S2,ℬ2)subscript𝑆2subscriptℬ2(S_{2},\mathcal{B}_{2})( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , caligraphic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ), respectively, a coupling is a joint probability measure μ𝜇\muitalic_μ on the product space (S1×S2,ℬ1⊗ℬ2)subscript𝑆1subscript𝑆2tensor-productsubscriptℬ1subscriptℬ2(S_{1}\times S_{2},\mathcal{B}_{1}\otimes\mathcal{B}_{2})( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , caligraphic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ⊗ caligraphic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) such that the marginal of μ𝜇\muitalic_μ on Sisubscript𝑆𝑖S_{i}italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is μisubscript𝜇𝑖\mu_{i}italic_μ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT for i=1,2𝑖12i=1,2italic_i = 1 , 2, i.e., μ⁢(X1×S2)=μ1⁢(X1)𝜇subscript𝑋1subscript𝑆2subscript𝜇1subscript𝑋1\mu(X_{1}\times S_{2})=\mu_{1}(X_{1})italic_μ ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_μ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) for any X1∈ℬ1subscript𝑋1subscriptℬ1X_{1}\in\mathcal{B}_{1}italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ∈ caligraphic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and μ⁢(S1×X2)=μ2⁢(X2)𝜇subscript𝑆1subscript𝑋2subscript𝜇2subscript𝑋2\mu(S_{1}\times X_{2})=\mu_{2}(X_{2})italic_μ ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_μ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) for any X2∈ℬ2subscript𝑋2subscriptℬ2X_{2}\in\mathcal{B}_{2}italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ∈ caligraphic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Usually, the goal is to choose a coupling that allows for comparisons between the probability measures, such as minimizing differences or distances between them. Coupling techniques have found applications in various areas. In optimal transport theory, the goal is to find the most efficient way to transform one distribution into another, with applications in economics, statistical physics and machine learning [8]. In stochastic processes, coupling helps to describe the joint behavior of random variables and to analyze and bound convergence rates in chains with more complex dependencies [26, 1]. Interestingly, a similar notion has also appeared in a combinatorial line of research on matroids. Let M1=(S1,r1)subscript𝑀1subscript𝑆1subscript𝑟1M_{1}=(S_{1},r_{1})italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) and M2=(S2,r2)subscript𝑀2subscript𝑆2subscript𝑟2M_{2}=(S_{2},r_{2})italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = ( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) be finite matroids over ground sets S1subscript𝑆1S_{1}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and S2subscript𝑆2S_{2}italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT with rank functions r1subscript𝑟1r_{1}italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and r2subscript𝑟2r_{2}italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, respectively. A matroid M=(S1×S2,r)𝑀subscript𝑆1subscript𝑆2𝑟M=(S_{1}\times S_{2},r)italic_M = ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_r ) is called a quasi-product of M1subscript𝑀1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and M2subscript𝑀2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT if the restriction of M𝑀Mitalic_M to {x}×S2𝑥subscript𝑆2\{x\}\times S_{2}{ italic_x } × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is isomorphic to M2subscript𝑀2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT by the natural bijection with S2subscript𝑆2S_{2}italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT for all non-loops x∈S1𝑥subscript𝑆1x\in S_{1}italic_x ∈ italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and is the zero matroid for loops x𝑥xitalic_x, and analogously with the two factors interchanged. If furthermore X×Y𝑋𝑌X\times Yitalic_X × italic_Y is a flat of M𝑀Mitalic_M for all flats X𝑋Xitalic_X of M1subscript𝑀1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Y𝑌Yitalic_Y of M2subscript𝑀2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, then M𝑀Mitalic_M is called a product of M1subscript𝑀1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and M2subscript𝑀2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Finally, if r⁢(X×Y)=r1⁢(X)⋅r2⁢(Y)𝑟𝑋𝑌⋅subscript𝑟1𝑋subscript𝑟2𝑌r(X\times Y)=r_{1}(X)\cdot r_{2}(Y)italic_r ( italic_X × italic_Y ) = italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X ) ⋅ italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_Y ) holds for every X⊆S1,Y⊆S2formulae-sequence𝑋subscript𝑆1𝑌subscript𝑆2X\subseteq S_{1},Y\subseteq S_{2}italic_X ⊆ italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Y ⊆ italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, then M𝑀Mitalic_M is a tensor product of M1subscript𝑀1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and M2subscript𝑀2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Note that at this point, it is not clear whether any two matroids admit a tensor product, a product, or even a quasi-product. Mason [31] and Lovász [27] provided constructions yielding a product of rank r1⁢(S1)+r2⁢(S2)−1subscript𝑟1subscript𝑆1subscript𝑟2subscript𝑆21r_{1}(S_{1})+r_{2}(S_{2})-1italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) + italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) - 1 via Dilworth completion. The existence of a tensor product, however, was asked as an open question in [27]. Note that if both M1subscript𝑀1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and M2subscript𝑀2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are linear matroids over the same field, then it is easy to construct a tensor product by taking the tensor product of the matrices representing them. Nevertheless, Las Vergnas [25] later showed that the situation is generally not so fortunate, as, for example, the Vámos matroid and the rank-2 uniform matroid on three elements do not admit a tensor product. One can think of the tensor product of two matroids as the “freest” among their possible products as it provides an unrestricted way to combine two matroids while preserving structure along both dimensions, meaning that the product of independent sets is also independent. However, since a tensor product does not exist for every pair of matroids, Mason [30] raised the problem of whether a freest product exists among the possible products. Las Vergnas [25] answered this question in the negative, and showed that the matroid obtained via Dilworth completion as in [27, 30] is the freest quasi-product satisfying r⁢({x,x′}×{y,y′})≤3𝑟𝑥superscript𝑥′𝑦superscript𝑦′3r(\{x,x^{\prime}\}\times\{y,y^{\prime}\})\leq 3italic_r ( { italic_x , italic_x start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT } × { italic_y , italic_y start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT } ) ≤ 3 for all x,x′∈S1𝑥superscript𝑥′subscript𝑆1x,x^{\prime}\in S_{1}italic_x , italic_x start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT ∈ italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and y,y′∈S2𝑦superscript𝑦′subscript𝑆2y,y^{\prime}\in S_{2}italic_y , italic_y start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT ∈ italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, where r𝑟ritalic_r denotes the rank function of the product matroid. In summary, while the marginals of both couplings of probability measures and matroid tensor products match the original measures or rank functions up to a constant factor, they differ in key structural aspects. Couplings do not require measures to appear on sets of the form {x}×S2𝑥subscript𝑆2\{x\}\times S_{2}{ italic_x } × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT or S1×{y}subscript𝑆1𝑦S_{1}\times\{y\}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × { italic_y } called fibers, whereas matroid product constructions enforce this as a strict condition. Additionally, in probability couplings, the measure on the product space equals the product of the original measures, while for matroids, the rank of the product is typically lower than the product of the individual ranks. 1.1 Our results and techniques In this paper, we extend the concept of coupling to matroids and, more broadly, to submodular functions. We prove that, unlike tensor products, couplings always exist, leading to a novel operation on matroids. This result is particularly interesting because it shows that a finite number of matroids can be encoded into a single one, while also taking into account how these matroids interact with each other. As an application, we establish the existence of functions that are universal with respect to some property, meaning that any set function with that property can be obtained as a quotient. This result brings new insights into the developing limit theory of matroids and submodular functions. Let φ1:2S1→ℝ:subscript𝜑1→superscript2subscript𝑆1ℝ\varphi_{1}\colon 2^{S_{1}}\to\mathbb{R}italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT → blackboard_R and φ2:2S2→ℝ:subscript𝜑2→superscript2subscript𝑆2ℝ\varphi_{2}\colon 2^{S_{2}}\to\mathbb{R}italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT → blackboard_R be set functions defined over finite ground sets S1subscript𝑆1S_{1}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and S2subscript𝑆2S_{2}italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, respectively. The notion of a tensor product can be naturally extended to set functions by calling a function φ:2S1×S2→ℝ:𝜑→superscript2subscript𝑆1subscript𝑆2ℝ\varphi\colon 2^{S_{1}\times S_{2}}\to\mathbb{R}italic_φ : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT → blackboard_R a tensor product of φ1subscript𝜑1\varphi_{1}italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and φ2subscript𝜑2\varphi_{2}italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT if φ⁢(X1×X2)=φ1⁢(X1)⋅φ2⁢(X2)𝜑subscript𝑋1subscript𝑋2⋅subscript𝜑1subscript𝑋1subscript𝜑2subscript𝑋2\varphi(X_{1}\times X_{2})=\varphi_{1}(X_{1})\cdot\varphi_{2}(X_{2})italic_φ ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ⋅ italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) holds for every X1⊆S1subscript𝑋1subscript𝑆1X_{1}\subseteq S_{1}italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ⊆ italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and X2⊆S2subscript𝑋2subscript𝑆2X_{2}\subseteq S_{2}italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ⊆ italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. As a new concept, we call φ𝜑\varphiitalic_φ a coupling of φ1subscript𝜑1\varphi_{1}italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and φ2subscript𝜑2\varphi_{2}italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT if φ⁢(X1×S2)=φ1⁢(X1)⋅φ2⁢(S2)𝜑subscript𝑋1subscript𝑆2⋅subscript𝜑1subscript𝑋1subscript𝜑2subscript𝑆2\varphi(X_{1}\times S_{2})=\varphi_{1}(X_{1})\cdot\varphi_{2}(S_{2})italic_φ ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ⋅ italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) for every X1⊆S1subscript𝑋1subscript𝑆1X_{1}\subseteq S_{1}italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ⊆ italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and φ⁢(S1×X2)=φ1⁢(S1)⋅φ2⁢(X2)𝜑subscript𝑆1subscript𝑋2⋅subscript𝜑1subscript𝑆1subscript𝜑2subscript𝑋2\varphi(S_{1}\times X_{2})=\varphi_{1}(S_{1})\cdot\varphi_{2}(X_{2})italic_φ ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ⋅ italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) for every X2⊆S2subscript𝑋2subscript𝑆2X_{2}\subseteq S_{2}italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ⊆ italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. In other words, a coupling is a set function on the product set, where the projections onto each coordinate return the corresponding φisubscript𝜑𝑖\varphi_{i}italic_φ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, up to a constant multiplier. Motivated by the goal of defining the coupling of matroids, Section 3 focuses on submodular functions. First, we show that any two submodular functions admit a submodular coupling (Theorem 3.1). One remarkable feature of the proof is that it provides an explicit formula for the coupling function using two arbitrary modular functions. However, the proof itself does not imply that if both φ1subscript𝜑1\varphi_{1}italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and φ2subscript𝜑2\varphi_{2}italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are monotonically increasing, then the coupling function φ𝜑\varphiitalic_φ is also monotonically increasing. Since this property is essential for the coupling of two matroids to result in a matroid, next we show that a k1subscript𝑘1k_{1}italic_k start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-polymatroid function and a k2subscript𝑘2k_{2}italic_k start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-polymatroid function have a (k1⋅k2)⋅subscript𝑘1subscript𝑘2(k_{1}\cdot k_{2})( italic_k start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ⋅ italic_k start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )-polymatroid coupling, which is also integer-valued if the original functions are (Theorem 3.2). The proof follows a similar idea as that of the submodular case, but the modular functions in question need to be chosen to be elements in the base polyhedra of φ1subscript𝜑1\varphi_{1}italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and φ2subscript𝜑2\varphi_{2}italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, respectively. As a corollary, we get that any two matroids admit a coupling (Corollary 3.6) which in turn implies that there exists a finite matroid that contains every matroid of fixed rank over a ground set of fixed size (Corollary 3.7). We provide several equivalent characterizations of two matroids having a coupling that is also a tensor product (Theorem 3.11), and establish a strong connection between tensor products and Ingleton’s inequality, a fundamental tool in the theory of representable matroids (Theorem 3.14). As a corollary, we get a new proof for the fact that the uniform matroid U2,3subscript𝑈23U_{2,3}italic_U start_POSTSUBSCRIPT 2 , 3 end_POSTSUBSCRIPT and the Vámos matroid do not admit a tensor product. We separately study a subclass of increasing submodular functions with strong structural properties, called “coverage functions” in combinatorial optimization. These functions were originally introduced by Choquet for analytical studies. He defined them in terms of a sequence of inequalities strengthening submodularity, and proved their equivalence with what is now the combinatorial definition. We prove that a coverage function and an increasing submodular function have an increasing submodular tensor product (Corollary 3.17), and that any two coverage functions have a tensor product that is a coverage function (Corollary 3.19). The proofs rely on the characterization of the extreme rays of the cone of coverage functions, as established by Choquet. Finally, we describe how to extend our results on submodular functions defined on finite ground sets to those with infinite domains (Theorems 3.22 and 3.23). Let φ𝜑\varphiitalic_φ be a set function over some finite ground set S𝑆Sitalic_S, and let 𝒬=(S1,…,Sq)𝒬subscript𝑆1…subscript𝑆𝑞\mathcal{Q}=(S_{1},\dots,S_{q})caligraphic_Q = ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_S start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ) be a partition of S𝑆Sitalic_S into q𝑞qitalic_q possibly empty parts. The quotient of φ𝜑\varphiitalic_φ with respect to 𝒬𝒬\mathcal{Q}caligraphic_Q is a set function φ𝒬subscript𝜑𝒬\varphi_{\mathcal{Q}}italic_φ start_POSTSUBSCRIPT caligraphic_Q end_POSTSUBSCRIPT over S𝒬={s1,…,sq}subscript𝑆𝒬subscript𝑠1…subscript𝑠𝑞S_{\mathcal{Q}}=\{s_{1},\dots,s_{q}\}italic_S start_POSTSUBSCRIPT caligraphic_Q end_POSTSUBSCRIPT = { italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_s start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT } defined by φ𝒬⁢(X)=φ⁢(⋃si∈XSi)subscript𝜑𝒬𝑋𝜑subscriptsubscript𝑠𝑖𝑋subscript𝑆𝑖\varphi_{\mathcal{Q}}(X)=\varphi(\bigcup_{s_{i}\in X}S_{i})italic_φ start_POSTSUBSCRIPT caligraphic_Q end_POSTSUBSCRIPT ( italic_X ) = italic_φ ( ⋃ start_POSTSUBSCRIPT italic_s start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ∈ italic_X end_POSTSUBSCRIPT italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) for X⊆S𝒬𝑋subscript𝑆𝒬X\subseteq S_{\mathcal{Q}}italic_X ⊆ italic_S start_POSTSUBSCRIPT caligraphic_Q end_POSTSUBSCRIPT. In particular, if φ:2S1×S2→ℝ:𝜑→superscript2subscript𝑆1subscript𝑆2ℝ\varphi\colon 2^{S_{1}\times S_{2}}\to\mathbb{R}italic_φ : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT → blackboard_R is a coupling of φ1:2S1→ℝ:subscript𝜑1→superscript2subscript𝑆1ℝ\varphi_{1}\colon 2^{S_{1}}\to\mathbb{R}italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT → blackboard_R and φ2:2S2→ℝ:subscript𝜑2→superscript2subscript𝑆2ℝ\varphi_{2}\colon 2^{S_{2}}\to\mathbb{R}italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT → blackboard_R and 𝒬1subscript𝒬1\mathcal{Q}_{1}caligraphic_Q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and 𝒬2subscript𝒬2\mathcal{Q}_{2}caligraphic_Q start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are the partitions of S1×S2subscript𝑆1subscript𝑆2S_{1}\times S_{2}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT into fibers of the form {x}×S2𝑥subscript𝑆2\{x\}\times S_{2}{ italic_x } × italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and S1×{y}subscript𝑆1𝑦S_{1}\times\{y\}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × { italic_y }, respectively, then φ1=φ2⁢(S2)⋅φ𝒬1subscript𝜑1⋅subscript𝜑2subscript𝑆2subscript𝜑subscript𝒬1\varphi_{1}=\varphi_{2}(S_{2})\cdot\varphi_{\mathcal{Q}_{1}}italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) ⋅ italic_φ start_POSTSUBSCRIPT caligraphic_Q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT and φ2=φ1⁢(S1)⋅φ𝒬2subscript𝜑2⋅subscript𝜑1subscript𝑆1subscript𝜑subscript𝒬2\varphi_{2}=\varphi_{1}(S_{1})\cdot\varphi_{\mathcal{Q}_{2}}italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) ⋅ italic_φ start_POSTSUBSCRIPT caligraphic_Q start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT. The positive results of Section 3 motivate the following question: Given a property of set functions, is there a function that is universal with respect to that property, in the sense that every function exhibiting the property can be obtained as its quotient? In Section 4, we examine this problem and show that, under some natural assumptions, the answer is positive (Theorem 4.2). Although the proof is analytical and may therefore be less appealing to those interested in combinatorial optimization, the result has far-reaching implications for functions defined on finite ground sets as well. For example, we obtain that there exists a submodular function φ:2ℤ→[0,1]:𝜑→superscript2ℤ01\varphi\colon 2^{\mathbb{Z}}\to[0,1]italic_φ : 2 start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT → [ 0 , 1 ] such that any nonnegative normalized submodular function is a quotient of φ𝜑\varphiitalic_φ (Corollary 4.3), and we prove an analogous result for coverage functions as well (Corollary 4.4). We conclude the section by providing an explicit construction for a universal coverage function, being in sharp contrast with the preceding non-constructive universality results; the formula of the function is surprisingly simple (Theorem 4.6). It is worth emphasizing that for functions over finite ground sets, our proofs are algorithmic in the sense that given value oracles for φ1subscript𝜑1\varphi_{1}italic_φ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and φ2subscript𝜑2\varphi_{2}italic_φ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, one can construct a value oracle for their coupling φ𝜑\varphiitalic_φ with the desired properties in polynomial time. 1.2 Related work and motivation Understanding how matroids can be combined does not only help in studying properties of larger systems formed from simpler matroid components, but it is closely related to a range of problems and techniques in combinatorial optimization. In what follows, we give a brief overview of related topics. Tropical geometry. Tensor products of matroids have deep connections to tropical geometry. A key consequence of Las Vergnas’s counterexample is that the tensor product of tropical linear spaces does not always yield a tropical linear space, see e.g. [18]. The notion of tensor products can be extended to more than two matroids. If all k𝑘kitalic_k matroids in the product are identical to a given matroid M=(S,r)𝑀𝑆𝑟M=(S,r)italic_M = ( italic_S , italic_r ), the tensor product defines a matroid structure on the set of ordered k𝑘kitalic_k-tuples from S𝑆Sitalic_S, known as the k𝑘kitalic_k-th power of M𝑀Mitalic_M. For unordered k𝑘kitalic_k-tuples, we consider symmetric tensors, which remain invariant under any permutation of their variables. The concept of symmetric powers of matroids was first introduced by Lovász [27] and Mason [30], who noted that not all matroids admit higher symmetric powers. Draisma and Rincón [13] established a link between tropical ideals and matroid symmetric powers by showing that the Bergman fan of the direct sum of the Vámos matroid and U2,3subscript𝑈23U_{2,3}italic_U start_POSTSUBSCRIPT 2 , 3 end_POSTSUBSCRIPT is not a tropically realizable variety. In [2], Anderson proved an equivalence between valuated matroids with arbitrarily large symmetric powers and tropical linear spaces represented as varieties of tropical ideals. Brakensiek, Dhar, Gao, Gopi, and Larson [7] explored the connection between rigidity matroids of graphs and matroids arising from linear algebraic constructions like tensor products and symmetric products. Matroid tensor products in tropical geometry were also examined in [22, 14]. Linear matroids. A matroid is called linear if its independent sets can be represented by vectors in a vector space over some field 𝔽𝔽\mathbb{F}blackboard_F. Such matroids are particularly interesting because they allow for a rich connection between linear algebra and combinatorial structures. For deciding if a matroid is regular, i.e. representable over every field, Seymour’s decomposition theorem [35] implies an algorithm, as such decompositions can be found efficiently [36]. However, Truemper [36] showed that many representability questions cannot be efficiently solved. This includes deciding representability over a specific field, over all fields with a given characteristic, and, most importantly, over any field. Since determining representability is oracle-hard in general, the focus of research has shifted toward finding necessary or sufficient conditions. Ingleton’s inequality [21] is one of the most prominent examples, giving a necessary condition for a matroid to be linear. Surprisingly, we show that representability of a matroid is closely related to having a tensor product with U2,3subscript𝑈23U_{2,3}italic_U start_POSTSUBSCRIPT 2 , 3 end_POSTSUBSCRIPT. Limits of matroids. The limit theory of graphs provides powerful tools for analyzing sequences of graphs and their structural similarities through analytic methods. By defining convergence in terms of distributions of small subgraphs (left-convergence) and homomorphisms into small graphs (right-convergence), it aids in understanding complex networks and their applications in various fields of mathematics and computer science; we refer the interested reader to [28] for a thorough introduction. In [5], a new form of right-convergence called quotient-convergence was introduced for set functions, which eventually led to a notion of convergence of matroids through their rank functions. The limit object of such a sequence is a submodular function [29]. One of the main research subjects is understanding the structure and properties of these limit objects, which heavily relies on examining their quotients and the coupling of the functions in the sequence. Extended formulations. For a polytope P⊆ℝd𝑃superscriptℝ𝑑P\subseteq\mathbb{R}^{d}italic_P ⊆ blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT, an extension of P𝑃Pitalic_P is a polytope Q∈ℝd′𝑄superscriptℝsuperscript𝑑′Q\in\mathbb{R}^{d^{\prime}}italic_Q ∈ blackboard_R start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT such that P=π⁢(Q)𝑃𝜋𝑄P=\pi(Q)italic_P = italic_π ( italic_Q ) for some affine map π:ℝd′→ℝd:𝜋→superscriptℝsuperscript𝑑′superscriptℝ𝑑\pi\colon\mathbb{R}^{d^{\prime}}\to\mathbb{R}^{d}italic_π : blackboard_R start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT → blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT. The extension complexity xc⁡(P)xc𝑃\operatorname{xc}(P)roman_xc ( italic_P ) of P𝑃Pitalic_P is defined as the minimum number of facets of an extension of P𝑃Pitalic_P. If Q𝑄Qitalic_Q is given by a linear description Q={y∈ℝd′∣A⁢y≤b}𝑄conditional-set𝑦superscriptℝsuperscript𝑑′𝐴𝑦𝑏Q=\{y\in\mathbb{R}^{d^{\prime}}\mid Ay\leq b\}italic_Q = { italic_y ∈ blackboard_R start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT ∣ italic_A italic_y ≤ italic_b }, then {x∈ℝd∣A⁢y≤b,x=π⁢(y)}conditional-set𝑥superscriptℝ𝑑formulae-sequence𝐴𝑦𝑏𝑥𝜋𝑦\{x\in\mathbb{R}^{d}\mid Ay\leq b,x=\pi(y)\}{ italic_x ∈ blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ∣ italic_A italic_y ≤ italic_b , italic_x = italic_π ( italic_y ) } is called an extended formulation of P𝑃Pitalic_P. Using this terminology, the extension complexity of a polytope is the minimum number of inequality constraints in an extended formulation. Since the fundamental work of Yannakakis [38], the extension complexity of various families of polytopes that appear naturally in combinatorial and graph optimization problems has been settled, such as the traveling salesman and cut polytopes [15], the stable set polytope [15, 19], the matching polytope [34], and recently the independence polytope of regular matroids [3]. Taking the quotient of a function is similar to projection; however, instead of retaining only certain coordinates of a solution, the coordinates are partitioned and summed within each partition class. Consequently, the coupling of matroids, or more generally, submodular functions leads to a different type of “extended” formulation that is of independent combinatorial interest. 1.3 Organization The rest of the paper is organized as follows. In Section 2, we introduce basic definitions, notation, and relevant results on submodular functions, matroids, and polymatroids. Section 3 is devoted to verifying the existence of couplings for various functions, first focusing on submodular functions in Section 3.1 and then extending these results to polymatroid functions in Section 3.2. In Section 3.3, we show how these observations lead to one of the main results of the paper: the existence of matroidal couplings that are almost tensor products. Section 3.3.1 explores the relation between our construction and matroidal amalgams. To understand the fine line between couplings and tensor products, we establish a necessary and sufficient condition for a coupling to be a tensor product in Section 3.3.2. Finally, in Section 3.3.3, we provide new necessary conditions for matroid representability. As an application, we verify the existence of functions that are universal with respect to certain properties in Section 4. The proof is analytical and hence is not constructive; we encourage first-time readers to skip the technical parts of Sections 4.1 and 4.2. As an application of the abstract existence theorem, we deduce that universal functions exist for several set function properties; these examples can be found in Section 4.3. Finally, we give an explicit construction for a universal coverage function in Section 4.4."
https://arxiv.org/html/2411.02122v1,Centered colorings in minor-closed graph classes,"A vertex coloring φ𝜑\varphiitalic_φ of a graph G𝐺Gitalic_G is p𝑝pitalic_p-centered if for every connected subgraph H𝐻Hitalic_H of G𝐺Gitalic_G, either φ𝜑\varphiitalic_φ uses more than p𝑝pitalic_p colors on H𝐻Hitalic_H, or there is a color that appears exactly once on H𝐻Hitalic_H. We prove that for every fixed positive integer t𝑡titalic_t, every Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graph admits a p𝑝pitalic_p-centered coloring using 𝒪⁢(pt−1)𝒪superscript𝑝𝑡1\mathcal{O}(p^{t-1})caligraphic_O ( italic_p start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT ) colors.","Let G𝐺Gitalic_G be a graph, p𝑝pitalic_p be a positive integer, and C𝐶Citalic_C be a set of colors. A coloring φ:V⁢(G)→C:𝜑→𝑉𝐺𝐶\varphi\colon V(G)\to Citalic_φ : italic_V ( italic_G ) → italic_C of G𝐺Gitalic_G is p𝑝pitalic_p-centered if for every connected111 In this paper, connected graphs are nonnull, that is, they have at least one vertex. Note that a tree is defined as a connected forest, thus, trees and subtrees are also assumed to be nonnull. subgraph H𝐻Hitalic_H of G𝐺Gitalic_G, either φ𝜑\varphiitalic_φ uses more than p𝑝pitalic_p colors on H𝐻Hitalic_H, or there is a color that appears exactly once on H𝐻Hitalic_H. The p𝑝pitalic_p-centered chromatic number of G𝐺Gitalic_G, denoted by χp⁢(G)subscript𝜒𝑝𝐺\chi_{p}(G)italic_χ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ), is the least nonnegative integer k𝑘kitalic_k such that G𝐺Gitalic_G admits a p𝑝pitalic_p-centered coloring using k𝑘kitalic_k colors. The following theorem is the main contribution of this paper. Theorem 1. Let t𝑡titalic_t be an integer with t⩾2𝑡2t\geqslant 2italic_t ⩾ 2. There exists an integer c𝑐citalic_c such that for every Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graph G𝐺Gitalic_G and for every positive integer p𝑝pitalic_p, χp⁢(G)⩽c⋅pt−1.subscript𝜒𝑝𝐺⋅𝑐superscript𝑝𝑡1\chi_{p}(G)\leqslant c\cdot p^{t-1}.italic_χ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) ⩽ italic_c ⋅ italic_p start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT . This improves on the work of Pilipczuk and Siebertz [11] who proved that for every integer t𝑡titalic_t with t⩾2𝑡2t\geqslant 2italic_t ⩾ 2, Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs have p𝑝pitalic_p-centered chromatic number upper bounded by a polynomial in p𝑝pitalic_p. Contrary to Theorem 1, the degree of their polynomial is not explicitly given and arises from an application of the graph minor structure theorem by Robertson and Seymour [13]. On the other hand, Dębski, Micek, Schröder, and Felsner [5] showed that there exist Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs with p𝑝pitalic_p-centered chromatic number in Ω⁢(pt−2)Ωsuperscript𝑝𝑡2\Omega(p^{t-2})roman_Ω ( italic_p start_POSTSUPERSCRIPT italic_t - 2 end_POSTSUPERSCRIPT ). Hence, Theorem 1 is tight, up to an 𝒪⁢(p)𝒪𝑝\mathcal{O}(p)caligraphic_O ( italic_p ) factor. Let us provide some context for our theorem. One of the driving forces in graph theory continues to be the development of efficient algorithms for computationally hard problems for sparse graph classes. Nešetřil and Ossona de Mendez [10] introduced the concepts of bounded expansion and nowhere denseness of classes of graphs. These notions cover many well-studied classes of graphs, such as graphs excluding a fixed minor, graphs of bounded book-thickness or graphs that admit drawings with a bounded number of crossings per edge. A key reason why centered colorings have gained significant attention is that they encapsulate the concept of bounded expansion. Indeed, a class of graphs 𝒞𝒞\mathcal{C}caligraphic_C has bounded expansion if and only if there is a function f:ℕ→ℕ:𝑓→ℕℕf\colon\mathbb{N}\to\mathbb{N}italic_f : blackboard_N → blackboard_N such that for all positive integers p𝑝pitalic_p, we have χp⁢(G)⩽f⁢(p)subscript𝜒𝑝𝐺𝑓𝑝\chi_{p}(G)\leqslant f(p)italic_χ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) ⩽ italic_f ( italic_p ) for every graph G𝐺Gitalic_G in 𝒞𝒞\mathcal{C}caligraphic_C, see again [10]. Centered colorings are also a crucial tool in designing parameterized algorithms in classes of graphs of bounded expansion. For example, Pilipczuk and Siebertz [11] showed that if 𝒞𝒞\mathcal{C}caligraphic_C is a class of graphs excluding a fixed minor, then it can be decided whether a given p𝑝pitalic_p-vertex graph H𝐻Hitalic_H is a subgraph of a given n𝑛nitalic_n-vertex graph G𝐺Gitalic_G in 𝒞𝒞\mathcal{C}caligraphic_C in time 2𝒪⁢(p⁢log⁡p)⋅n𝒪⁢(1)⋅superscript2𝒪𝑝𝑝superscript𝑛𝒪12^{\mathcal{O}(p\log p)}\cdot n^{\mathcal{O}(1)}2 start_POSTSUPERSCRIPT caligraphic_O ( italic_p roman_log italic_p ) end_POSTSUPERSCRIPT ⋅ italic_n start_POSTSUPERSCRIPT caligraphic_O ( 1 ) end_POSTSUPERSCRIPT and space n𝒪⁢(1)superscript𝑛𝒪1n^{\mathcal{O}(1)}italic_n start_POSTSUPERSCRIPT caligraphic_O ( 1 ) end_POSTSUPERSCRIPT. This algorithm relies on a general fact that the union of any p𝑝pitalic_p color classes in a p𝑝pitalic_p-centered coloring induces a subgraph of treedepth at most p𝑝pitalic_p. Therefore, finding a p𝑝pitalic_p-centered coloring using p𝒪⁢(1)superscript𝑝𝒪1p^{\mathcal{O}(1)}italic_p start_POSTSUPERSCRIPT caligraphic_O ( 1 ) end_POSTSUPERSCRIPT colors, allows us to reduce the problem to graphs of bounded treedepth, on which the subgraph isomorphism problem can be solved efficiently. The running times of algorithms based on p𝑝pitalic_p-centered colorings heavily depend on the number of colors used. Another important family of graph parameters capturing sparsity are the weak coloring numbers. Let G𝐺Gitalic_G be a graph, let σ𝜎\sigmaitalic_σ be a vertex ordering of G𝐺Gitalic_G, and let r𝑟ritalic_r be a nonnegative integer. For all u𝑢uitalic_u and v𝑣vitalic_v vertices of G𝐺Gitalic_G, we say that v𝑣vitalic_v is weakly r𝑟ritalic_r-reachable from u𝑢uitalic_u in (G,σ)𝐺𝜎(G,\sigma)( italic_G , italic_σ ), if there exists a path between u𝑢uitalic_u and v𝑣vitalic_v in G𝐺Gitalic_G containing at most r𝑟ritalic_r edges such that for every vertex w𝑤witalic_w on the path, v⩽σwsubscript𝜎𝑣𝑤v\leqslant_{\sigma}witalic_v ⩽ start_POSTSUBSCRIPT italic_σ end_POSTSUBSCRIPT italic_w. Let WReachr⁡[G,σ,u]subscriptWReach𝑟𝐺𝜎𝑢\operatorname{WReach}_{r}[G,\sigma,u]roman_WReach start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT [ italic_G , italic_σ , italic_u ] be the set of all vertices that are weakly r𝑟ritalic_r-reachable from u𝑢uitalic_u in (G,σ)𝐺𝜎(G,\sigma)( italic_G , italic_σ ). The r𝑟ritalic_r-th weak coloring number of G𝐺Gitalic_G is defined as wcolr⁡(G)=minσ⁡maxu∈V⁢(G)⁡|WReachr⁡[G,σ,u]|,subscriptwcol𝑟𝐺subscript𝜎subscript𝑢𝑉𝐺subscriptWReach𝑟𝐺𝜎𝑢\operatorname{wcol}_{r}(G)=\min_{\sigma}\max_{u\in V(G)}\ |\operatorname{% WReach}_{r}[G,\sigma,u]|,roman_wcol start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_G ) = roman_min start_POSTSUBSCRIPT italic_σ end_POSTSUBSCRIPT roman_max start_POSTSUBSCRIPT italic_u ∈ italic_V ( italic_G ) end_POSTSUBSCRIPT | roman_WReach start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT [ italic_G , italic_σ , italic_u ] | , where σ𝜎\sigmaitalic_σ ranges over all vertex orderings of G𝐺Gitalic_G. Van den Heuvel, Ossona de Mendez, Quiroz, Rabinovich, and Siebertz [8] established that for every integer t𝑡titalic_t with t⩾2𝑡2t\geqslant 2italic_t ⩾ 2, for every Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graph G𝐺Gitalic_G, we have wcolr⁡(G)=𝒪⁢(rt−1)subscriptwcol𝑟𝐺𝒪superscript𝑟𝑡1\operatorname{wcol}_{r}(G)=\mathcal{O}(r^{t-1})roman_wcol start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_G ) = caligraphic_O ( italic_r start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT ). Their proof hinges on a carefully designed partition of the vertex set of G𝐺Gitalic_G, inspired by Andreae’s work [1] on the cops and robber game for Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs. This partition, now commonly referred to as a chordal partition, mimics an elimination ordering of vertices of a chordal graph. Chordal partitions have since become a significant tool in both structural and algorithmic graph theory. In particular, wcolr⁡(G)=𝒪⁢(rt−1)subscriptwcol𝑟𝐺𝒪superscript𝑟𝑡1\operatorname{wcol}_{r}(G)=\mathcal{O}(r^{t-1})roman_wcol start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_G ) = caligraphic_O ( italic_r start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT ) is obtained in [8] with a relatively simple and self-contained argument. However, there is currently no known analogous partitioning method that works well with p𝑝pitalic_p-centered colorings. In [11], the bound of χp⁢(G)=𝒪⁢(pg⁢(t))subscript𝜒𝑝𝐺𝒪superscript𝑝𝑔𝑡\chi_{p}(G)=\mathcal{O}(p^{g(t)})italic_χ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) = caligraphic_O ( italic_p start_POSTSUPERSCRIPT italic_g ( italic_t ) end_POSTSUPERSCRIPT ) for some function g𝑔gitalic_g was achieved by first proving the result for graphs of bounded Euler genus, and then lifting the argument using the graph minor structure theorem by Robertson and Seymour [13]. The degree of the polynomial bound in p𝑝pitalic_p they obtain depends on the constants of this structure theorem and is not explicitly given. Consequently, a significant gap exists between the state-of-art upper bounds for weak coloring numbers and the ones for centered chromatic numbers of Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs. In this work, we close this gap. The main novelty of the proof is a replacement of a Helly-type property well-known for graphs of bounded treewidth (see Lemma 4) by a statement on centered colorings that works in the broader class of Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs. See the definition of (p,c)𝑝𝑐(p,c)( italic_p , italic_c )-good colorings and Lemma 5. The final centered colorings are constructed in this paper in two steps. First, we prove this Helly-type property for Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs following a layered variant of Robertson-Seymour decomposition introduced by Dujmović, Joret, Micek, Morin, Ueckerdt, and Wood [3]. Second, using this property, we adapt a framework proposed by Illingworth, Scott, and Wood in [9]. This in result allows us to move most of the dependency on t𝑡titalic_t from the degree of the final polynomial to a multiplicative constant in front of it. For a more detailed outline of the proof, see Section 2. Graphs with bounded degree have p𝑝pitalic_p-centered chromatic number in 𝒪⁢(p)𝒪𝑝\mathcal{O}(p)caligraphic_O ( italic_p ) as proved in [5]. This combined with the structure theorem by Grohe and Marx [7] gives a polynomial in p𝑝pitalic_p upper bound on χp⁢(G)subscript𝜒𝑝𝐺\chi_{p}(G)italic_χ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) for all G𝐺Gitalic_G excluding Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT as a topological minor. Open problem. Let t𝑡titalic_t be an integer with t⩾2𝑡2t\geqslant 2italic_t ⩾ 2. Does there exist a nonnegative integer c𝑐citalic_c such that for every Ktsubscript𝐾𝑡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-topological-minor-free graph G𝐺Gitalic_G and for every positive integer p𝑝pitalic_p, χp⁢(G)⩽c⋅pt−1subscript𝜒𝑝𝐺⋅𝑐superscript𝑝𝑡1\chi_{p}(G)\leqslant c\cdot p^{t-1}italic_χ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) ⩽ italic_c ⋅ italic_p start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT?"
https://arxiv.org/html/2411.01630v1,"Optimal Inapproximability of Promise Equationsover Finite Groups††thanks:This work was supported by UKRI EP/X024431/1. For the purpose of Open Access, the authors have applied a CC BY public copyright licence to any Author Accepted Manuscript version arising from this submission. All data is provided in full in the results section of this paper.","A celebrated result of Håstad established that, for any constant ε>0𝜀0\varepsilon>0italic_ε > 0, it is NP-hard to find an assignment satisfying a (1/|𝒢|+ε)1𝒢𝜀(1/|\mathscr{G}|+\varepsilon)( 1 / | script_G | + italic_ε )-fraction of the constraints of a given 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance over an Abelian group 𝒢𝒢\mathscr{G}script_G even if one is promised that an assignment satisfying a (1−ε)1𝜀(1-\varepsilon)( 1 - italic_ε )-fraction of the constraints exists. Engebretsen, Holmerin, and Russell showed the same result for 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN instances over any finite (not necessarily Abelian) group. In other words, for almost-satisfiable instances of 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN the random assignment achieves an optimal approximation guarantee. We prove that the random assignment algorithm is still best possible under a stronger promise that the 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance is almost satisfiable over an arbitrarily more restrictive group.","The PCP theorem [AS98, ALM+98, Din07] is one of the jewels of computational complexity and theoretical computer science more broadly [AB09]. One of its equivalent statements is as follows: The maximum number of simultaneously satisfiable constraints of a Constraint Satisfaction Problem, or CSP for short, is NP-hard to approximate within some constant factor. That is, while NP-hardness of CSPs means that it is NP-hard to distinguish instances that are satisfiable from those that are unsatisfiable, the PCP theorem shows that there is an absolute constant α<1𝛼1\alpha<1italic_α < 1 such that it is NP-hard to distinguish satisfiable CSP instances from those in which strictly fewer than an α𝛼\alphaitalic_α-fraction of the constraints can be simultaneously satisfied. Thus it is NP-hard to find an assignment that satisfies an α𝛼\alphaitalic_α-fraction of the constraints even if one is promised that a satisfying assignment exists. For some CSPs, as we shall see shortly, the optimal value of α𝛼\alphaitalic_α is known. A classic example of a CSP is 3-SAT, the satisfiability problem of CNF-formulas in which each clause contains 3 literals. The random assignment gives a method to find an assignment that satisfies a 7/8787/87 / 8-fraction of the clauses. Håstad famously showed that this is optimal in the following sense: For any constant ε>0𝜀0\varepsilon>0italic_ε > 0, it is NP-hard to find an assignment satisfying a (7/8+ε)78𝜀(7/8+\varepsilon)( 7 / 8 + italic_ε )-fraction of the clauses of a 3-SAT instance even if one is promised that a satisfying assignment exists [Hås01]. Another classic CSP is 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN, the problem of solving linear equations in 3 variables over the Boolean domain {0,1}01\{0,1\}{ 0 , 1 }. If all equations can be satisfied simultaneously then a satisfying assignment can be found in polynomial time by Gaussian elimination. What can be done if no satisfying assignment exists? As for 3-SAT, the random assignment gives a method to find a somewhat satisfying assignment, namely one that satisfies a 1/2121/21 / 2-fraction of the constraints. As it turns out, this is best possible even for instances of 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN that are almost satisfiable. In detail, Håstad showed that for any constant ε>0𝜀0\varepsilon>0italic_ε > 0, it is NP-hard to find an assignment satisfying a (1/2+ε)12𝜀(1/2+\varepsilon)( 1 / 2 + italic_ε )-fraction of the constraints of a 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance even if one is promised that an assignment satisfying a (1−ε)1𝜀(1-\varepsilon)( 1 - italic_ε )-fraction of the constraints exists. In fact, Håstad established optimal inapproximability results for 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN over any finite Abelian group, not just {0,1}01\{0,1\}{ 0 , 1 }. This result was later extended by Engebretsen, Holmerin, and Russell to all finite groups [EHR04]. Since these foundational works, Guruswami and Raghavendra [GR09] showed NP-hardness of finding a barely satisfying assignment for a 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance over the reals (and thus also over the integers) even if a nearly satisfying assignment is promised to exist over the integers. The same result was later established for 2−LIN2LIN\operatorname{2-LIN}2 - roman_LIN for large enough cyclic groups [OWZ15]. Khot and Moshkovitz [KM13] studied inapproximability of 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN over the reals. In this work, we strengthen the optimal inapproximability results for 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN over finite groups by establishing NP-hardness of beating the random assignment threshold even if the instance is almost satisfiable in an arbitrarily more restrictive setting. Formally, this is captured by fixing (not one but) two groups and a homomorphism between them, following the framework of promise CSPs [AGH17, BBKO21]. In detail, (decision) promise CSPs [BBKO21] can be seen as a qualitative form of approximation: Each constraint comes in two forms, a strong one and a weak one. The promise is that there is a solution satisfying all constraints in the strong form while the (potentially easier) goal is to find a solution satisfying all constraints in the weak form. An example of a strong vs. weak constraint on the same, say Boolean, domain is 1111-in-3333 vs NAE, where the former is {(0,0,1),(0,1,0),(1,0,0)}001010100\{(0,0,1),(0,1,0),(1,0,0)\}{ ( 0 , 0 , 1 ) , ( 0 , 1 , 0 ) , ( 1 , 0 , 0 ) } and the latter is {(0,0,1),(0,1,0),(1,0,0),(1,1,0),(1,0,1),(0,1,1)}001010100110101011\{(0,0,1),(0,1,0),(1,0,0),(1,1,0),(1,0,1),(0,1,1)\}{ ( 0 , 0 , 1 ) , ( 0 , 1 , 0 ) , ( 1 , 0 , 0 ) , ( 1 , 1 , 0 ) , ( 1 , 0 , 1 ) , ( 0 , 1 , 1 ) }. NAE is weaker as the relation contains more tuples. While these two constraint relations capture the well-known NP-hard problems of 1-in-3-SAT and Not-All-Equal-SAT respectively [Sch78], finding an NAE-assignment turns out to be doable in polynomial time under the promise that a 1-in-3-assignment exists [BG21]! For constraints on different domains, the notion of strong vs. weak constraint is captured by a homomorphism between the (sets of all) constraint relations; in the example above, the homomorphism is just the identity function. The exact solvability of 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN in the promise setting was resolved in [LŽ24]. Recent work of Barto et al. [BBK+24] considered (quantitative) approximation of promise CSPs. In the context of 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN, here are two simple examples captured by this framework. First, let 𝒢𝒢\mathscr{G}script_G be a group and ℋℋ\mathscr{H}script_H be a subgroup of 𝒢𝒢\mathscr{G}script_G. Given an almost-satisfiable system over the subgroup ℋℋ\mathscr{H}script_H, maximise the number of satisfied equations over 𝒢𝒢\mathscr{G}script_G. Our results imply that beating the random assignment over ℋℋ\mathscr{H}script_H is NP-hard. In the second example, consider a group 𝒢𝒢\mathscr{G}script_G, a normal subgroup ℋℋ\mathscr{H}script_H, and an almost-satisfiable system over 𝒢𝒢\mathscr{G}script_G. The goal this time is to maximise the number of satisfied equations in the system over the quotient 𝒢/ℋ𝒢ℋ\mathscr{G}/\mathscr{H}script_G / script_H. Our results show that doing better than the random assignment over 𝒢/ℋ𝒢ℋ\mathscr{G}/\mathscr{H}script_G / script_H is NP-hard. More generally, going beyond subgroups and quotients of a given group, we fix two groups 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and a group homomorphism φ𝜑\varphiitalic_φ from a subgroup ℋ1subscriptℋ1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT of 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to a subgroup ℋ2subscriptℋ2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT with the property that φ𝜑\varphiitalic_φ extend to a group homomorphism from 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Given an almost-satisfiable system of equations over 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT with constants in ℋ1subscriptℋ1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, the goal is to maximise the number of satisfied equations over 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT where the constants are interpreted in ℋ2subscriptℋ2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT via φ𝜑\varphiitalic_φ. Our main result establishes that doing better than the random assignment over ℋ2subscriptℋ2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is NP-hard, cf. Theorem 1.3. Thus we give an optimal inapproximability result for a natural and fundamental fragment of promise CSPs, systems of linear equations. The general approach for establishing inapproximability of systems of equations, going back to [Hås01, EHR04], can be seen as a reduction from another CSP that is hard to approximate. In this reduction, one initially transforms an instance of the original CSP to a system of equations of the form x⁢y⁢z=1𝑥𝑦𝑧1xyz=1italic_x italic_y italic_z = 1. To guarantee the soundness of this reduction, one needs to show that any assignment that beats the random assignment in the target system of equations can be transformed into a “good” assignment of the original instance. To do this it is necessary to rule out vacuous assignments (e.g., the assignment that sends all variables to the group identity) through a procedure called folding, which introduces constants in the system of equations. Afterwards, the soundness bounds are shown by performing Fourier analysis on certain functions derived from the system. Our proof follows this general approach. The main obstacle to applying the techniques of [EHR04] directly is the fact that in our setting the constants lie in a proper subgroup of the ambient group, which precludes us from applying classical folding over groups. Instead, we use a weaker notion of folding. This, however, implies that in the soundness analysis we have to take care of functions whose Fourier expansion has non-zero value for the trivial term. To tackle this issue, we consider the behaviour of irreducible group representations when they are restricted to the subgroup of constants via Frobenius Reciprocity. Before formal description of our results, we mention other related work. First, extending the work from [Hås01], Austrin, Brown-Cohen, and Håstad established optimal inapproximability of 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN over Abelian groups with a universal factor graph [ABCH23]. Similarly, Bhangale and Stankovic established optimal inapproximability of 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN over non-Abelian groups with a universal factor graph [BS23]. Second, unlike over Abelian groups, for 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN over non-Abelian groups finding a satisfying assignment is NP-hard even under the promise that one exists. There is a folklore randomised algorithm for satisfiable 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN instances over non-Abelian groups (whose approximation factor depends on the group 𝒢𝒢\mathscr{G}script_G and is 1/|𝒢|1𝒢1/|\mathscr{G}|1 / | script_G | if 𝒢𝒢\mathscr{G}script_G is a so-called perfect group but can beat the naive random assignment for non-perfect groups). Bhangale and Khot showed that this algorithm is optimal [BK21]. Third, going beyond 3−LIN3LIN\operatorname{3-LIN}3 - roman_LIN, building on a long line of work Chan established optimal (up to a constant factor) NP-hardness for CSPs [Cha16]. There are other works on various inapproximability notions for CSPs, e.g., [AH13, KTW14a, KTW14b]. Finally, we mention that Khot’s influential Unique Games Conjecture [Kho02] postulates, in one of its equivalent forms, NP-hardness of finding a barely satisfying solution to a 2−LIN2LIN\operatorname{2-LIN}2 - roman_LIN instance given that an almost-satisfying assignment exists (for a large enough domain size). 1.1 Preliminaries and notation We use ⟦⋅⟧delimited-⟦⟧⋅\llbracket\cdot\rrbracket⟦ ⋅ ⟧ to denote the Iverson bracket; i.e., ⟦P⟧delimited-⟦⟧𝑃\llbracket P\rrbracket⟦ italic_P ⟧ is 1 if P𝑃Pitalic_P is true and 00 otherwise. As usual, [n]delimited-[]𝑛[n][ italic_n ] denotes the set {1,2,…,n}12…𝑛\{1,2,\ldots,n\}{ 1 , 2 , … , italic_n }. We consider matrices whose sets of indices are arbitrary finite sets. Given two finite sets N𝑁Nitalic_N and M𝑀Mitalic_M, an N×M𝑁𝑀N\times Mitalic_N × italic_M complex matrix A𝐴Aitalic_A consists of a family of complex numbers Ai,jsubscript𝐴𝑖𝑗A_{i,j}italic_A start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT indexed by pairs i∈N𝑖𝑁i\in Nitalic_i ∈ italic_N, j∈M𝑗𝑀j\in Mitalic_j ∈ italic_M. Algebraic notions such as matrix product, trace, and transpose are defined in the natural way. Given an N1×N2subscript𝑁1subscript𝑁2N_{1}\times N_{2}italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT complex matrix A𝐴Aitalic_A, and an M1×M2subscript𝑀1subscript𝑀2M_{1}\times M_{2}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT complex matrix B𝐵Bitalic_B, the tensor product A⊗Btensor-product𝐴𝐵A\otimes Bitalic_A ⊗ italic_B is an (N1×M1)×(N2×M2)subscript𝑁1subscript𝑀1subscript𝑁2subscript𝑀2(N_{1}\times M_{1})\times(N_{2}\times M_{2})( italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT × italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) × ( italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT × italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) matrix, where (A⊗B)(i,s)⁢(j,t)=Ai,j⁢Bs,tsubscripttensor-product𝐴𝐵𝑖𝑠𝑗𝑡subscript𝐴𝑖𝑗subscript𝐵𝑠𝑡(A\otimes B)_{(i,s)(j,t)}=A_{i,j}B_{s,t}( italic_A ⊗ italic_B ) start_POSTSUBSCRIPT ( italic_i , italic_s ) ( italic_j , italic_t ) end_POSTSUBSCRIPT = italic_A start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT italic_B start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT for each i∈N1,j∈N2,s∈M1,t∈M2formulae-sequence𝑖subscript𝑁1formulae-sequence𝑗subscript𝑁2formulae-sequence𝑠subscript𝑀1𝑡subscript𝑀2i\in N_{1},j\in N_{2},s\in M_{1},t\in M_{2}italic_i ∈ italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_j ∈ italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_s ∈ italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t ∈ italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. The group of invertible N×N𝑁𝑁N\times Nitalic_N × italic_N complex matrices (equipped with matrix multiplication and matrix inversion) is denoted by GL⁢(N)GL𝑁\mathrm{GL}(N)roman_GL ( italic_N ), and the set of N×M𝑁𝑀N\times Mitalic_N × italic_M complex matrices is denoted by ℂN×Msuperscriptℂ𝑁𝑀\mathbb{C}^{N\times M}blackboard_C start_POSTSUPERSCRIPT italic_N × italic_M end_POSTSUPERSCRIPT. A subset ℋ⊆𝒢ℋ𝒢\mathscr{H}\subseteq\mathscr{G}script_H ⊆ script_G of a group 𝒢𝒢\mathscr{G}script_G is called a subgroup of 𝒢𝒢\mathscr{G}script_G, denoted by ℋ≤𝒢ℋ𝒢\mathscr{H}\leq\mathscr{G}script_H ≤ script_G, if ℋℋ\mathscr{H}script_H equipped with the group operation of 𝒢𝒢\mathscr{G}script_G forms a group. Given a group 𝒢𝒢\mathscr{G}script_G, a subgroup ℋℋ\mathscr{H}script_H of 𝒢𝒢\mathscr{G}script_G, and an element g∈𝒢𝑔𝒢g\in\mathscr{G}italic_g ∈ script_G, the right coset of ℋℋ\mathscr{H}script_H in 𝒢𝒢\mathscr{G}script_G by g𝑔gitalic_g is the set ℋ⁢g:={h⁢g∣h∈ℋ}assignℋ𝑔conditional-setℎ𝑔ℎℋ\mathscr{H}g:=\{hg\mid h\in\mathscr{H}\}script_H italic_g := { italic_h italic_g ∣ italic_h ∈ script_H }. The set of right cosets of ℋℋ\mathscr{H}script_H in 𝒢𝒢\mathscr{G}script_G is denoted by ℋ\𝒢\ℋ𝒢\mathscr{H}\backslash\mathscr{G}script_H \ script_G. Let N𝑁Nitalic_N be a finite set. The Nthsuperscript𝑁thN^{\text{th}}italic_N start_POSTSUPERSCRIPT th end_POSTSUPERSCRIPT direct power of 𝒢𝒢\mathscr{G}script_G, denoted by 𝒢Nsuperscript𝒢𝑁\mathscr{G}^{N}script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT, is the group whose elements are N𝑁Nitalic_N-tuples 𝐠∈𝒢N𝐠superscript𝒢𝑁\mathbf{g}\in\mathscr{G}^{N}bold_g ∈ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT of elements from 𝒢𝒢\mathscr{G}script_G, and where the group operation is taken component-wise, i.e., 𝐠⋅𝐡⁢(n)=𝐠⁢(n)⋅𝐡⁢(n)⋅𝐠𝐡𝑛⋅𝐠𝑛𝐡𝑛\mathbf{g}\cdot\mathbf{h}(n)=\mathbf{g}(n)\cdot\mathbf{h}(n)bold_g ⋅ bold_h ( italic_n ) = bold_g ( italic_n ) ⋅ bold_h ( italic_n ) for each n∈N𝑛𝑁n\in Nitalic_n ∈ italic_N. If ℋ≤𝒢ℋ𝒢\mathscr{H}\leq\mathscr{G}script_H ≤ script_G, we define (h⋅𝐠)⁢(n)=h⋅𝐠⁢(n)⋅ℎ𝐠𝑛⋅ℎ𝐠𝑛(h\cdot\mathbf{g})(n)=h\cdot\mathbf{g}(n)( italic_h ⋅ bold_g ) ( italic_n ) = italic_h ⋅ bold_g ( italic_n ) for each h∈ℋℎℋh\in\mathscr{H}italic_h ∈ script_H and 𝐠∈𝒢N𝐠superscript𝒢𝑁\mathbf{g}\in\mathscr{G}^{N}bold_g ∈ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. With this notation, the notion of coset extends to include the right cosets of ℋℋ\mathscr{H}script_H in 𝒢Nsuperscript𝒢𝑁\mathscr{G}^{N}script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT in a natural way. A homomorphism from a group 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to a group 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is a map φ:𝒢1→𝒢2:𝜑→subscript𝒢1subscript𝒢2\varphi:\mathscr{G}_{1}\to\mathscr{G}_{2}italic_φ : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT → script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT which satisfies that φ⁢(g⋅h)=φ⁢(g)⋅φ⁢(h)𝜑⋅𝑔ℎ⋅𝜑𝑔𝜑ℎ\varphi(g\cdot h)=\varphi(g)\cdot\varphi(h)italic_φ ( italic_g ⋅ italic_h ) = italic_φ ( italic_g ) ⋅ italic_φ ( italic_h ) for every g,h∈𝒢1𝑔ℎsubscript𝒢1g,h\in\mathscr{G}_{1}italic_g , italic_h ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. The domain and image of φ𝜑\varphiitalic_φ are denoted Dom⁢(φ)Dom𝜑\textnormal{Dom}(\varphi)Dom ( italic_φ ) and Im⁢(φ)Im𝜑\textnormal{Im}(\varphi)Im ( italic_φ ) respectively. Let N𝑁Nitalic_N be a finite set, 𝒢isubscript𝒢𝑖\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT groups, i∈[2]𝑖delimited-[]2i\in[2]italic_i ∈ [ 2 ], ℋi≤𝒢isubscriptℋ𝑖subscript𝒢𝑖\mathscr{H}_{i}\leq\mathscr{G}_{i}script_H start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ≤ script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, and φ:ℋ1→ℋ2:𝜑→subscriptℋ1subscriptℋ2\varphi:\mathscr{H}_{1}\to\mathscr{H}_{2}italic_φ : script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT → script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT be a homomorphism. We say that a function f:𝒢1N→𝒢2:𝑓→superscriptsubscript𝒢1𝑁subscript𝒢2f:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT → script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is folded over φ𝜑\varphiitalic_φ if f⁢(h⁢𝐠)=φ⁢(h)⁢f⁢(𝐠)𝑓ℎ𝐠𝜑ℎ𝑓𝐠f(h\mathbf{g})=\varphi(h)f(\mathbf{g})italic_f ( italic_h bold_g ) = italic_φ ( italic_h ) italic_f ( bold_g ) for all h∈ℋ1ℎsubscriptℋ1h\in\mathscr{H}_{1}italic_h ∈ script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and 𝐠∈𝒢1N𝐠superscriptsubscript𝒢1𝑁\mathbf{g}\in\mathscr{G}_{1}^{N}bold_g ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. Given an arbitrary function f:𝒢1N→𝒢2:𝑓→superscriptsubscript𝒢1𝑁subscript𝒢2f:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT → script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and a homomorphism between subgroups, there is a natural way to construct a folded function that resembles f𝑓fitalic_f. Fix an arbitrary representative from each right coset of ℋ1subscriptℋ1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT in 𝒢1Nsuperscriptsubscript𝒢1𝑁\mathscr{G}_{1}^{N}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. For each 𝐠∈𝒢N𝐠superscript𝒢𝑁\mathbf{g}\in\mathscr{G}^{N}bold_g ∈ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT, denote by 𝐠†superscript𝐠†\mathbf{g}^{\dagger}bold_g start_POSTSUPERSCRIPT † end_POSTSUPERSCRIPT the representative of ℋ1⁢𝐠subscriptℋ1𝐠\mathscr{H}_{1}\mathbf{g}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT bold_g, and let h𝐠∈ℋ1subscriptℎ𝐠subscriptℋ1h_{\mathbf{g}}\in\mathscr{H}_{1}italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT ∈ script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT be such that 𝐠†=h𝐠⁢𝐠superscript𝐠†subscriptℎ𝐠𝐠\mathbf{g}^{\dagger}=h_{\mathbf{g}}\mathbf{g}bold_g start_POSTSUPERSCRIPT † end_POSTSUPERSCRIPT = italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT bold_g. Then the folding of f𝑓fitalic_f over φ𝜑\varphiitalic_φ (with respect to this choice of representatives) is the map fφ:𝒢1N→𝒢2:subscript𝑓𝜑→superscriptsubscript𝒢1𝑁subscript𝒢2f_{\varphi}:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT → script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT given by fφ⁢(𝐠)=φ⁢(h𝐠−1)⁢f⁢(𝐠†)subscript𝑓𝜑𝐠𝜑superscriptsubscriptℎ𝐠1𝑓superscript𝐠†f_{\varphi}(\mathbf{g})=\varphi(h_{\mathbf{g}}^{-1})f(\mathbf{g}^{\dagger})italic_f start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT ( bold_g ) = italic_φ ( italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) italic_f ( bold_g start_POSTSUPERSCRIPT † end_POSTSUPERSCRIPT ). Fix a pair of disjoint finite sets D𝐷Ditalic_D, E𝐸Eitalic_E, called the label sets, and a subset Π⊆EDΠsuperscript𝐸𝐷\Pi\subseteq E^{D}roman_Π ⊆ italic_E start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT of labeling functions. An instance of the Label Cover problem is a bipartite graph with vertex set U⊔Vsquare-union𝑈𝑉U\sqcup Vitalic_U ⊔ italic_V and a labeling function πu⁢v∈Πsubscript𝜋𝑢𝑣Π\pi_{uv}\in\Piitalic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ∈ roman_Π for each edge {u,v}𝑢𝑣\{u,v\}{ italic_u , italic_v } in the graph. The task is to decide whether there is a pair of assignments hD:U→D:subscriptℎ𝐷→𝑈𝐷h_{D}:U\to Ditalic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT : italic_U → italic_D, hE:V→E:subscriptℎ𝐸→𝑉𝐸h_{E}:V\to Eitalic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT : italic_V → italic_E that satisfies all the constraints, i.e., such that πu⁢v⁢(hD⁢(u))=hE⁢(v)subscript𝜋𝑢𝑣subscriptℎ𝐷𝑢subscriptℎ𝐸𝑣\pi_{uv}(h_{D}(u))=h_{E}(v)italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_u ) ) = italic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT ( italic_v ) for each edge {u,v}𝑢𝑣\{u,v\}{ italic_u , italic_v }. Given additionally a pair of rational constants 0<s≤c≤10𝑠𝑐10<s\leq c\leq 10 < italic_s ≤ italic_c ≤ 1, the gap version of this problem, known as the Gap Label Cover problem with completeness c𝑐citalic_c and soundness s𝑠sitalic_s and denoted GLCD,E⁢(c,s)subscriptGLC𝐷𝐸𝑐𝑠\mathrm{GLC}_{D,E}(c,s)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( italic_c , italic_s ), is the problem of distinguishing instances where a c𝑐citalic_c-fraction of the constraints can be satisfied from instances where not even an s𝑠sitalic_s-fraction of the constraints can be satisfied. The hardness of Gap Label Cover with perfect completeness stated below is a consequence of the PCP theorem [ALM+98, AS98] and the Parallel Repetition Theorem [Raz98]. Theorem 1.1. For every α>0𝛼0\alpha>0italic_α > 0 there exist finite sets D𝐷Ditalic_D, E𝐸Eitalic_E such that GLCD,E⁢(1,α)subscriptGLC𝐷𝐸1𝛼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_α ) is NP-hard. Fourier Analysis We follow closely [Ter99] for our main definitions and preliminary results. A representation of a group 𝒢𝒢\mathscr{G}script_G is a group homomorphism γ:𝒢→GL⁢(Nγ):𝛾→𝒢GLsubscript𝑁𝛾\gamma:\mathscr{G}\to\mathrm{GL}(N_{\gamma})italic_γ : script_G → roman_GL ( italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT ) for some finite set Nγsubscript𝑁𝛾N_{\gamma}italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT. We call |Nγ|subscript𝑁𝛾|N_{\gamma}|| italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT | the dimension of γ𝛾\gammaitalic_γ and write dimγ=|Nγ|subscriptdimension𝛾subscript𝑁𝛾\dim_{\gamma}=|N_{\gamma}|roman_dim start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT = | italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT |. Given a pair of indices i,j∈Nγ2𝑖𝑗superscriptsubscript𝑁𝛾2i,j\in N_{\gamma}^{2}italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, γi,jsubscript𝛾𝑖𝑗\gamma_{i,j}italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT denotes the (i,j)𝑖𝑗(i,j)( italic_i , italic_j )-th entry of γ𝛾\gammaitalic_γ. The character of a representation γ𝛾\gammaitalic_γ, denoted by χγsubscript𝜒𝛾\chi_{\gamma}italic_χ start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT, is its trace. The trivial representation, denoted 1111, maps all group elements to the number one (i.e., the one-dimensional identity matrix). A representation γ𝛾\gammaitalic_γ is said to be unitary if its image contains only unitary matrices. We say that two representations α𝛼\alphaitalic_α and β𝛽\betaitalic_β of some group 𝒢𝒢\mathscr{G}script_G are equivalent, written α≃βsimilar-to-or-equals𝛼𝛽\alpha\simeq\betaitalic_α ≃ italic_β, if there is an invertible Nβ×Nαsubscript𝑁𝛽subscript𝑁𝛼N_{\beta}\times N_{\alpha}italic_N start_POSTSUBSCRIPT italic_β end_POSTSUBSCRIPT × italic_N start_POSTSUBSCRIPT italic_α end_POSTSUBSCRIPT complex matrix T𝑇Titalic_T such that α⁢(g)=T−1⁢β⁢(g)⁢T𝛼𝑔superscript𝑇1𝛽𝑔𝑇\alpha(g)=T^{-1}\beta(g)Titalic_α ( italic_g ) = italic_T start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_β ( italic_g ) italic_T for all g∈𝒢𝑔𝒢g\in\mathscr{G}italic_g ∈ script_G. In particular, dimα=dimβsubscriptdimension𝛼subscriptdimension𝛽\dim_{\alpha}=\dim_{\beta}roman_dim start_POSTSUBSCRIPT italic_α end_POSTSUBSCRIPT = roman_dim start_POSTSUBSCRIPT italic_β end_POSTSUBSCRIPT. Similarly, the representation β𝛽\betaitalic_β is said to be a sub-representation of α𝛼\alphaitalic_α if there is an invertible matrix T𝑇Titalic_T, such that T−1⁢α⁢(g)⁢Tsuperscript𝑇1𝛼𝑔𝑇T^{-1}\alpha(g)Titalic_T start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_α ( italic_g ) italic_T can be written as (β⁢(g)∗0∗)matrix𝛽𝑔0\begin{pmatrix}\beta(g)&*\\ 0&*\end{pmatrix}( start_ARG start_ROW start_CELL italic_β ( italic_g ) end_CELL start_CELL ∗ end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL ∗ end_CELL end_ROW end_ARG ) for all g∈𝒢𝑔𝒢g\in\mathscr{G}italic_g ∈ script_G. The representation β𝛽\betaitalic_β is said to be irreducible if all its sub-representations are equivalent to itself. If β𝛽\betaitalic_β is irreducible, its multiplicity in α𝛼\alphaitalic_α is the non-negative integer n𝑛nitalic_n satisfying that α𝛼\alphaitalic_α is equivalent to a block diagonal representation with two diagonal blocks α1,α2subscript𝛼1subscript𝛼2\alpha_{1},\alpha_{2}italic_α start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_α start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, where (1) α1subscript𝛼1\alpha_{1}italic_α start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT is another block-diagonal representation consisting of n𝑛nitalic_n diagonal blocks equal to β𝛽\betaitalic_β, and (2) α2subscript𝛼2\alpha_{2}italic_α start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT does not have β𝛽\betaitalic_β as a sub-representation. Given a group 𝒢𝒢\mathscr{G}script_G, we use 𝒢^^𝒢\widehat{\mathscr{G}}over^ start_ARG script_G end_ARG to denote some arbitrary and fixed complete set of inequivalent irreducible unitary representations of 𝒢𝒢\mathscr{G}script_G; such a set exists by, e.g., [Ter99, Proposition 1]. The space ℒ2⁢(𝒢)superscriptℒ2𝒢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ) is the vector space of complex-valued functions over 𝒢𝒢\mathscr{G}script_G, equipped with the following inner product:111Note the additional normalising factor of 1|𝒢|1𝒢\frac{1}{|\mathscr{G}|}divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG compared to [Ter99]. ⟨F,H⟩=1|𝒢|⁢∑g∈𝒢F⁢(g)⁢H⁢(g)¯.𝐹𝐻1𝒢subscript𝑔𝒢𝐹𝑔¯𝐻𝑔\langle F,H\rangle=\frac{1}{|\mathscr{G}|}\sum_{g\in\mathscr{G}}F(g)\overline{% H(g)}.⟨ italic_F , italic_H ⟩ = divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG ∑ start_POSTSUBSCRIPT italic_g ∈ script_G end_POSTSUBSCRIPT italic_F ( italic_g ) over¯ start_ARG italic_H ( italic_g ) end_ARG . Let 𝒢𝒢\mathscr{G}script_G be a group, and let F:𝒢→ℂ:𝐹→𝒢ℂF:\mathscr{G}\rightarrow\mathbb{C}italic_F : script_G → blackboard_C be a complex-valued function. Given γ∈𝒢^𝛾^𝒢\gamma\in\widehat{\mathscr{G}}italic_γ ∈ over^ start_ARG script_G end_ARG and i,j∈Nγ𝑖𝑗subscript𝑁𝛾i,j\in N_{\gamma}italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT, the Fourier coefficient F^⁢(γi,j)^𝐹subscript𝛾𝑖𝑗\widehat{F}(\gamma_{i,j})over^ start_ARG italic_F end_ARG ( italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) is defined as the product ⟨F,γi,j⟩𝐹subscript𝛾𝑖𝑗\langle F,\gamma_{i,j}\rangle⟨ italic_F , italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ⟩. The matrix entries of the representations γ∈𝒢^𝛾^𝒢\gamma\in\widehat{\mathscr{G}}italic_γ ∈ over^ start_ARG script_G end_ARG form an orthogonal basis of ℒ2⁢(𝒢)superscriptℒ2𝒢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), and allow us to perform Fourier analysis on this space, as stated in the following theorem [Ter99, Theorem 2]. Theorem 1.2. Let 𝒢𝒢\mathscr{G}script_G be a finite group. Then the set {γi,j∣γ∈𝒢^,i,j∈Nγ}conditional-setsubscript𝛾𝑖𝑗formulae-sequence𝛾^𝒢𝑖𝑗subscript𝑁𝛾\{\gamma_{i,j}\mid\gamma\in\widehat{\mathscr{G}},\ i,j\in N_{\gamma}\}{ italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ∣ italic_γ ∈ over^ start_ARG script_G end_ARG , italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT } is an orthogonal basis of ℒ2⁢(𝒢)superscriptℒ2𝒢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), and dimγ∥γi,j∥2=1subscriptdimension𝛾superscriptdelimited-∥∥subscript𝛾𝑖𝑗21\dim_{\gamma}\lVert\gamma_{i,j}\rVert^{2}=1roman_dim start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT ∥ italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ∥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = 1 for all γi,jsubscript𝛾𝑖𝑗\gamma_{i,j}italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT. Moreover, the following hold: 1. Plancherel’s Theorem: Given F∈ℒ2⁢(𝒢)𝐹superscriptℒ2𝒢F\in\mathcal{L}^{2}(\mathscr{G})italic_F ∈ caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), ∥F∥2=∑γ∈𝒢^,i,j∈Nγdimγ|F^⁢(γi,j)|2.superscriptdelimited-∥∥𝐹2subscriptformulae-sequence𝛾^𝒢𝑖𝑗subscript𝑁𝛾subscriptdimension𝛾superscript^𝐹subscript𝛾𝑖𝑗2\lVert F\rVert^{2}=\sum_{\gamma\in\widehat{\mathscr{G}},i,j\in N_{\gamma}}\dim% _{\gamma}|\widehat{F}(\gamma_{i,j})|^{2}.∥ italic_F ∥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = ∑ start_POSTSUBSCRIPT italic_γ ∈ over^ start_ARG script_G end_ARG , italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT | over^ start_ARG italic_F end_ARG ( italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . 2. Fourier Inversion: Given F∈ℒ2⁢(𝒢)𝐹superscriptℒ2𝒢F\in\mathcal{L}^{2}(\mathscr{G})italic_F ∈ caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), F⁢(g)=∑γ∈𝒢^,i,j∈NγdimγF^⁢(γi,j)⁢γi,j⁢(g) for all ⁢g∈𝒢.formulae-sequence𝐹𝑔subscriptformulae-sequence𝛾^𝒢𝑖𝑗subscript𝑁𝛾subscriptdimension𝛾^𝐹subscript𝛾𝑖𝑗subscript𝛾𝑖𝑗𝑔 for all 𝑔𝒢F(g)=\sum_{\gamma\in\widehat{\mathscr{G}},i,j\in N_{\gamma}}\dim_{\gamma}% \widehat{F}(\gamma_{i,j})\gamma_{i,j}(g)\qquad\text{ for all }g\in\mathscr{G}.italic_F ( italic_g ) = ∑ start_POSTSUBSCRIPT italic_γ ∈ over^ start_ARG script_G end_ARG , italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT over^ start_ARG italic_F end_ARG ( italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( italic_g ) for all italic_g ∈ script_G . We also consider Fourier transforms of matrix-valued functions F:𝒢→ℂNF×NF:𝐹→𝒢superscriptℂsubscript𝑁𝐹subscript𝑁𝐹F:\mathscr{G}\rightarrow\mathbb{C}^{N_{F}\times N_{F}}italic_F : script_G → blackboard_C start_POSTSUPERSCRIPT italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT × italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT end_POSTSUPERSCRIPT. Given γ∈𝒢^𝛾^𝒢\gamma\in\widehat{\mathscr{G}}italic_γ ∈ over^ start_ARG script_G end_ARG and indices i,j∈Nγ𝑖𝑗subscript𝑁𝛾i,j\in N_{\gamma}italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_γ end_POSTSUBSCRIPT, we define the NF×NFsubscript𝑁𝐹subscript𝑁𝐹N_{F}\times N_{F}italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT × italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT matrix F^⁢(γi,j)^𝐹subscript𝛾𝑖𝑗\widehat{F}(\gamma_{i,j})over^ start_ARG italic_F end_ARG ( italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) as the one whose (s,t)𝑠𝑡(s,t)( italic_s , italic_t )-th entry is Fs,t^⁢(γi,j)^subscript𝐹𝑠𝑡subscript𝛾𝑖𝑗\widehat{F_{s,t}}(\gamma_{i,j})over^ start_ARG italic_F start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT end_ARG ( italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) for each s,t∈NF𝑠𝑡subscript𝑁𝐹s,t\in N_{F}italic_s , italic_t ∈ italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT. In other words, F^⁢(γi,j)=1|𝒢|⁢∑g∈𝒢F⁢(g)⁢γi,j⁢(g)¯.^𝐹subscript𝛾𝑖𝑗1𝒢subscript𝑔𝒢𝐹𝑔¯subscript𝛾𝑖𝑗𝑔\widehat{F}(\gamma_{i,j})=\frac{1}{|\mathscr{G}|}\sum_{g\in\mathscr{G}}F(g)% \overline{\gamma_{i,j}(g)}.over^ start_ARG italic_F end_ARG ( italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) = divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG ∑ start_POSTSUBSCRIPT italic_g ∈ script_G end_POSTSUBSCRIPT italic_F ( italic_g ) over¯ start_ARG italic_γ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( italic_g ) end_ARG . Let N𝑁Nitalic_N be a finite set. Given a pair of functions function F,H:𝒢→ℂN×N:𝐹𝐻→𝒢superscriptℂ𝑁𝑁F,H:\mathscr{G}\to\mathbb{C}^{N\times N}italic_F , italic_H : script_G → blackboard_C start_POSTSUPERSCRIPT italic_N × italic_N end_POSTSUPERSCRIPT, we define their convolution F∗H𝐹𝐻F*Hitalic_F ∗ italic_H by (F∗H)⁢(g):=1|𝒢|⁢∑h∈𝒢F⁢(h)⁢H⁢(h−1⁢g).assign𝐹𝐻𝑔1𝒢subscriptℎ𝒢𝐹ℎ𝐻superscriptℎ1𝑔(F*H)(g):=\frac{1}{|\mathscr{G}|}\sum_{h\in\mathscr{G}}F(h)H(h^{-1}g).( italic_F ∗ italic_H ) ( italic_g ) := divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG ∑ start_POSTSUBSCRIPT italic_h ∈ script_G end_POSTSUBSCRIPT italic_F ( italic_h ) italic_H ( italic_h start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_g ) . We will also need to perform Fourier analysis over powers of the form 𝒢Dsuperscript𝒢𝐷\mathscr{G}^{D}script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT for a given group 𝒢𝒢\mathscr{G}script_G and finite set D𝐷Ditalic_D. It is possible to identify 𝒢D^^superscript𝒢𝐷\widehat{\mathscr{G}^{D}}over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG with (𝒢^)Dsuperscript^𝒢𝐷(\widehat{\mathscr{G}})^{D}( over^ start_ARG script_G end_ARG ) start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT [Ter99]. This way, an element ρ∈𝒢D^𝜌^superscript𝒢𝐷\rho\in\widehat{\mathscr{G}^{D}}italic_ρ ∈ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG is given by a tuple (ρd)d∈Dsubscriptsuperscript𝜌𝑑𝑑𝐷(\rho^{d})_{d\in D}( italic_ρ start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ) start_POSTSUBSCRIPT italic_d ∈ italic_D end_POSTSUBSCRIPT where ρd∈𝒢^superscript𝜌𝑑^𝒢\rho^{d}\in\widehat{\mathscr{G}}italic_ρ start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ∈ over^ start_ARG script_G end_ARG for each d∈D𝑑𝐷d\in Ditalic_d ∈ italic_D in such a way that ρ⁢(𝐠)=⨂d∈Dρd⁢(𝐠⁢(d))𝜌𝐠subscripttensor-product𝑑𝐷superscript𝜌𝑑𝐠𝑑\rho(\mathbf{g})=\bigotimes_{d\in D}\rho^{d}(\mathbf{g}(d))italic_ρ ( bold_g ) = ⨂ start_POSTSUBSCRIPT italic_d ∈ italic_D end_POSTSUBSCRIPT italic_ρ start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ( bold_g ( italic_d ) ) for all 𝐠∈𝒢D𝐠superscript𝒢𝐷\mathbf{g}\in\mathscr{G}^{D}bold_g ∈ script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT. Observe we use superscripts for the “components” of the representation ρ𝜌\rhoitalic_ρ on the power group 𝒢Dsuperscript𝒢𝐷\mathscr{G}^{D}script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT, rather than subscripts, which we utilise to denote matrix entries. The degree of ρ𝜌\rhoitalic_ρ, written |ρ|𝜌|\rho|| italic_ρ |, is the number of indices d∈D𝑑𝐷d\in Ditalic_d ∈ italic_D for which ρdsuperscript𝜌𝑑\rho^{d}italic_ρ start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT is non-trivial.222This quantity is called “weight” in [EHR04, BS23]. 1.2 Results Let 𝒢1,𝒢2subscript𝒢1subscript𝒢2\mathscr{G}_{1},\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT be two groups and φ𝜑\varphiitalic_φ a group homomorphism with domain Dom⁢(φ)≤𝒢1Dom𝜑subscript𝒢1\textnormal{Dom}(\varphi)\leq\mathscr{G}_{1}Dom ( italic_φ ) ≤ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and image Im⁢(φ)≤𝒢2Im𝜑subscript𝒢2\textnormal{Im}(\varphi)\leq\mathscr{G}_{2}Im ( italic_φ ) ≤ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT that extends to a full homomorphism from 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. We shall refer to triples (𝒢1,𝒢2,φ)subscript𝒢1subscript𝒢2𝜑(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ ) of this kind as templates. Further, let 0<s≤c≤10𝑠𝑐10<s\leq c\leq 10 < italic_s ≤ italic_c ≤ 1 be rational constants. We consider the problem 3−LIN⁡(𝒢1,𝒢2,φ,c,s)3LINsubscript𝒢1subscript𝒢2𝜑𝑐𝑠\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , italic_c , italic_s ) which asks, given a weighted system of linear equations with exactly three variables in each equation and constants in Dom⁢(φ)Dom𝜑\textnormal{Dom}(\varphi)Dom ( italic_φ ) that is c𝑐citalic_c-satisfiable in 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, to decide whether there exists an s𝑠sitalic_s-approximation in 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, where the constants are interpreted through φ𝜑\varphiitalic_φ. To be more precise, an instance to 3−LIN⁡(𝒢1,𝒢2,φ,c,s)3LINsubscript𝒢1subscript𝒢2𝜑𝑐𝑠\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , italic_c , italic_s ) over a set of variables X𝑋Xitalic_X is a weighted systems of linear equations where each equation is of the form xi⁢yj⁢zk=gsuperscript𝑥𝑖superscript𝑦𝑗superscript𝑧𝑘𝑔x^{i}y^{j}z^{k}=gitalic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_y start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_z start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g for some x,y,z∈X𝑥𝑦𝑧𝑋x,y,z\in Xitalic_x , italic_y , italic_z ∈ italic_X, g∈Dom⁢(φ)𝑔Dom𝜑g\in\textnormal{Dom}(\varphi)italic_g ∈ Dom ( italic_φ ), i,j,k∈{−1,1}𝑖𝑗𝑘11i,j,k\in\{-1,1\}italic_i , italic_j , italic_k ∈ { - 1 , 1 }, and each equation has a non-negative rational weight. Without loss of generality, we assume that the weights are normalised, i.e., sum up to 1. For t∈[2]𝑡delimited-[]2t\in[2]italic_t ∈ [ 2 ], an assignment f:X→𝒢t:𝑓→𝑋subscript𝒢𝑡f:X\to\mathscr{G}_{t}italic_f : italic_X → script_G start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT satisfies an equation xi⁢yj⁢zk=gsuperscript𝑥𝑖superscript𝑦𝑗superscript𝑧𝑘𝑔x^{i}y^{j}z^{k}=gitalic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_y start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_z start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g in 𝒢tsubscript𝒢𝑡\mathscr{G}_{t}script_G start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT if f⁢(x)i⁢f⁢(y)j⁢f⁢(z)k=g𝑓superscript𝑥𝑖𝑓superscript𝑦𝑗𝑓superscript𝑧𝑘𝑔f(x)^{i}f(y)^{j}f(z)^{k}=gitalic_f ( italic_x ) start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_f ( italic_y ) start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_f ( italic_z ) start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g for t=1𝑡1t=1italic_t = 1, and f⁢(x)i⁢f⁢(y)j⁢f⁢(z)k=φ⁢(g)𝑓superscript𝑥𝑖𝑓superscript𝑦𝑗𝑓superscript𝑧𝑘𝜑𝑔f(x)^{i}f(y)^{j}f(z)^{k}=\varphi(g)italic_f ( italic_x ) start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_f ( italic_y ) start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_f ( italic_z ) start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_φ ( italic_g ) for t=2𝑡2t=2italic_t = 2. The task then is to accept if there is an assignment that satisfies a c𝑐citalic_c-fraction (i.e., a fraction of total weight c𝑐citalic_c) of equations in 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, and to reject if there is no assignment that satisfies an s𝑠sitalic_s-fraction of the equations in 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. It is easy to verify that, if (𝒢1,𝒢2,φ)subscript𝒢1subscript𝒢2𝜑(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ ) is a template and s≤c𝑠𝑐s\leq citalic_s ≤ italic_c, then the sets of accept and reject instances are, in fact, disjoint.3333−LIN3LIN\operatorname{3-LIN}3 - roman_LIN can be alternatively phrased as a promise constraint satisfaction problem, cf. Section 4 for details. 3−LIN⁡(𝒢1,𝒢2,φ,c,s)3LINsubscript𝒢1subscript𝒢2𝜑𝑐𝑠\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , italic_c , italic_s ) is trivially tractable when Im⁢(φ)={1}Im𝜑1\textnormal{Im}(\varphi)=\{1\}Im ( italic_φ ) = { 1 }, so we focus on the case where |Im⁢(φ)|≥2Im𝜑2|\textnormal{Im}(\varphi)|\geq 2| Im ( italic_φ ) | ≥ 2. The main result of this paper is that 3−LIN⁡(𝒢1,𝒢2,φ,1−ϵ,1/|Im⁢(φ)|+δ)3LINsubscript𝒢1subscript𝒢2𝜑1italic-ϵ1Im𝜑𝛿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , 1 - italic_ϵ , 1 / | Im ( italic_φ ) | + italic_δ ) in NP-hard for all ϵ,δ>0italic-ϵ𝛿0\epsilon,\delta>0italic_ϵ , italic_δ > 0 for which the problem is well-defined. This is achieved by a reduction from the Gap Label Cover problem with perfect completeness and soundness α=δ2/(4⁢κ⁢|𝒢1|κ⁢|𝒢2|4)𝛼superscript𝛿24𝜅superscriptsubscript𝒢1𝜅superscriptsubscript𝒢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_α = italic_δ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_κ | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_κ end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ), where κ=⌈(log2⁡δ−2)/(log2⁡(1−ϵ))⌉𝜅subscript2𝛿2subscript21italic-ϵ\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon))\rceilitalic_κ = ⌈ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_δ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_ϵ ) ) ⌉. Theorem 1.3 (Main). Let ϵ,δitalic-ϵ𝛿\epsilon,\deltaitalic_ϵ , italic_δ be positive constants satisfying 1−ϵ≥1/|Im⁢(φ)|+δ1italic-ϵ1Im𝜑𝛿1-\epsilon\geq 1/|\textnormal{Im}(\varphi)|+\delta1 - italic_ϵ ≥ 1 / | Im ( italic_φ ) | + italic_δ. Then, 3−LIN⁡(𝒢1,𝒢2,φ,1−ϵ,1/|Im⁢(φ)|+δ)3LINsubscript𝒢1subscript𝒢2𝜑1italic-ϵ1Im𝜑𝛿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , 1 - italic_ϵ , 1 / | Im ( italic_φ ) | + italic_δ ) is NP-hard. The hardness result in Theorem 1.3 is tight for many, but perhaps surprisingly not all, templates. We call a template (𝒢1,𝒢2,φ)subscript𝒢1subscript𝒢2𝜑(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ ) cubic if for every h∈Im⁢(φ)ℎIm𝜑h\in\textnormal{Im}(\varphi)italic_h ∈ Im ( italic_φ ) there is an element g∈𝒢2𝑔subscript𝒢2g\in\mathscr{G}_{2}italic_g ∈ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT satisfying g3=hsuperscript𝑔3ℎg^{3}=hitalic_g start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT = italic_h. Theorem 1.3 is tight for cubic templates. Indeed, for these templates, the random assignment over Im⁢(φ)Im𝜑\textnormal{Im}(\varphi)Im ( italic_φ ) achieves a 1/|Im⁢(φ)|1Im𝜑1/|\textnormal{Im}(\varphi)|1 / | Im ( italic_φ ) | expected fraction of satisfied equations (and this can be derandomised, e.g., by the method of conditional expectations). Theorem 1.4. Let (𝒢1,𝒢2,φ)subscript𝒢1subscript𝒢2𝜑(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ ) be a cubic template and 0<s≤c<10𝑠𝑐10<s\leq c<10 < italic_s ≤ italic_c < 1. Then, 3−LIN⁡(𝒢1,𝒢2,φ,c,s)3LINsubscript𝒢1subscript𝒢2𝜑𝑐𝑠\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , italic_c , italic_s ) is tractable if s≤1/|Im⁢(φ)|𝑠1Im𝜑s\leq 1/|\textnormal{Im}(\varphi)|italic_s ≤ 1 / | Im ( italic_φ ) | and NP-hard otherwise. Let us now turn to non-cubic templates. An equation is unsatisfiable if it is of the form x3=hsuperscript𝑥3ℎx^{3}=hitalic_x start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT = italic_h or x−3=hsuperscript𝑥3ℎx^{-3}=hitalic_x start_POSTSUPERSCRIPT - 3 end_POSTSUPERSCRIPT = italic_h for some h∈Dom⁢(φ)ℎDom𝜑h\in\textnormal{Dom}(\varphi)italic_h ∈ Dom ( italic_φ ) such that g3≠φ⁢(h)superscript𝑔3𝜑ℎg^{3}\neq\varphi(h)italic_g start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ≠ italic_φ ( italic_h ) for all g∈𝒢2𝑔subscript𝒢2g\in\mathscr{G}_{2}italic_g ∈ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Note that a template has unsatisfiable equations if and only if it is non-cubic. Note that the naive random assignment cannot achieve a positive approximation factor in systems of equations over non-cubic templates since the system could consist exclusively of unsatisfiable equations. However, there is a simple algorithm for 3−LIN⁡(𝒢1,𝒢2,φ,c,c/|Im⁢(φ)|)3LINsubscript𝒢1subscript𝒢2𝜑𝑐𝑐Im𝜑\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,c/|\textnormal{% Im}(\varphi)|)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , italic_c , italic_c / | Im ( italic_φ ) | ) that works even for non-cubic templates, which we describe next. Given a weighted system of equations over (𝒢1,𝒢2,φ)subscript𝒢1subscript𝒢2𝜑(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ ), consider its set of unsatisfiable equations. Since φ𝜑\varphiitalic_φ extends to a full homomorphism, if the total weight of the set of unsatisfiable equations is more than 1−c1𝑐1-c1 - italic_c, then the instance cannot be c𝑐citalic_c-satisfiable in 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, hence, reject. Otherwise, the random assignment over Im⁢(φ)Im𝜑\textnormal{Im}(\varphi)Im ( italic_φ ) satisfies at least a 1/|Im⁢(φ)|1Im𝜑1/|\textnormal{Im}(\varphi)|1 / | Im ( italic_φ ) |-fraction of the satisfiable equations over 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, which is at least a c/|Im⁢(φ)|𝑐Im𝜑c/|\textnormal{Im}(\varphi)|italic_c / | Im ( italic_φ ) |-fraction of the entire system. It is a simple corollary of Theorem 1.3 that this algorithm is optimal for non-cubic groups, leading to the following result. Details are deferred to Appendix A. Theorem 1.5. Let (𝒢1,𝒢2,φ)subscript𝒢1subscript𝒢2𝜑(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ ) be a non-cubic template and 0<s≤c<10𝑠𝑐10<s\leq c<10 < italic_s ≤ italic_c < 1. Then, 3−LIN⁡(𝒢1,𝒢2,φ,c,s)3LINsubscript𝒢1subscript𝒢2𝜑𝑐𝑠\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , italic_c , italic_s ) is tractable if s/c≤1/|Im⁢(φ)|𝑠𝑐1Im𝜑s/c\leq 1/|\textnormal{Im}(\varphi)|italic_s / italic_c ≤ 1 / | Im ( italic_φ ) | and NP-hard otherwise. The structure of the paper is as follows. The rest of this section gives a sketch of the main proof: In Section 1.3 we present the reduction from Gap Label Cover to 3−LIN⁡(𝒢1,𝒢2,φ,1−ϵ,1/|Im⁢(φ)|+δ)3LINsubscript𝒢1subscript𝒢2𝜑1italic-ϵ1Im𝜑𝛿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , 1 - italic_ϵ , 1 / | Im ( italic_φ ) | + italic_δ ), and in Section 1.4 we give an overview of the techniques used in the analysis of this reduction and of the main challenges that arise in extending previous work to the promise setting. The rest of the paper then gives all technical details. In Section 2 we set the notation and present the necessary technical background on Fourier analysis over non-Abelian groups. Section 3 is dedicated to the proof of the main result, with the completeness analysis in Section 3.1 and the soundness analysis in Section 3.2. Finally, in Section 4 we relate our results to a recent theory of Barto et al. [BBK+24], who developed a systematic approach to study (in)approximability of promise CSPs, which includes approximability of promise linear equations, from the viewpoint of universal algebra. In particular, we show that the proof of Theorem 1.3 implies that the collection of symmetries444called the valued minion of plurimorphisms in [BBK+24]. of 3−LIN⁡(𝒢1,𝒢2,φ,1−ϵ,1/|Im⁢(φ)|+δ)3LINsubscript𝒢1subscript𝒢2𝜑1italic-ϵ1Im𝜑𝛿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ , 1 - italic_ϵ , 1 / | Im ( italic_φ ) | + italic_δ ) can be mapped homomorphically to the collection of symmetries of Gap Label Cover, a condition that, based on the algebraic theory from [BBK+24], is known to guarantee NP-hardness of the former problem. 1.3 Reduction For the rest of the section we outline the proof of our main result, Theorem 1.3. From now on we fix a template (𝒢1,𝒢2,φ)subscript𝒢1subscript𝒢2𝜑(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_φ ), and positive constants δ,ϵ>0𝛿italic-ϵ0\delta,\epsilon>0italic_δ , italic_ϵ > 0 with 1/|Im⁢(φ)|+δ≤1−ϵ1Im𝜑𝛿1italic-ϵ1/|\textnormal{Im}(\varphi)|+\delta\leq 1-\epsilon1 / | Im ( italic_φ ) | + italic_δ ≤ 1 - italic_ϵ. We define ℋ1=Dom⁢(φ)≤𝒢1subscriptℋ1Dom𝜑subscript𝒢1\mathscr{H}_{1}=\textnormal{Dom}(\varphi)\leq\mathscr{G}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = Dom ( italic_φ ) ≤ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and ℋ2=Im⁢(φ)≤𝒢2subscriptℋ2Im𝜑subscript𝒢2\mathscr{H}_{2}=\textnormal{Im}(\varphi)\leq\mathscr{G}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = Im ( italic_φ ) ≤ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Our proof follows from a reduction from GLCD,E⁢(1,α)subscriptGLC𝐷𝐸1𝛼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_α ) where α=δ2/(4⁢κ⁢|𝒢1|κ⁢|𝒢2|4)𝛼superscript𝛿24𝜅superscriptsubscript𝒢1𝜅superscriptsubscript𝒢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_α = italic_δ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_κ | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_κ end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ), κ=⌈(log2⁡δ−2)/(log2⁡(1−ϵ))⌉𝜅subscript2𝛿2subscript21italic-ϵ\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon))\rceilitalic_κ = ⌈ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_δ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_ϵ ) ) ⌉, and D,E𝐷𝐸D,Eitalic_D , italic_E are chosen to be large enough so that GLCD,E⁢(1,α)subscriptGLC𝐷𝐸1𝛼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_α ) is NP-hard by the PCP theorem [ALM+98, AS98, Raz98] (cf. Theorem 1.1). This reduction constructs an instance ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT of 3−LIN(𝒢1,𝒢2,\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , φ,1−ϵ,1/|ℋ2|+δ)\varphi,1-\epsilon,1/|\mathscr{H}_{2}|+\delta)italic_φ , 1 - italic_ϵ , 1 / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | + italic_δ ) for any given instance ΣΣ\Sigmaroman_Σ of Gap Label Cover as described below. Let U⊔Vsquare-union𝑈𝑉U\sqcup Vitalic_U ⊔ italic_V be the underlying vertex set of ΣΣ\Sigmaroman_Σ, D,E𝐷𝐸D,Eitalic_D , italic_E be the disjoint sets of labels, and πu⁢vsubscript𝜋𝑢𝑣\pi_{uv}italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT be the labeling functions. We fix representatives from each right coset in ℋ1\𝒢1D\subscriptℋ1superscriptsubscript𝒢1𝐷\mathscr{H}_{1}\backslash\mathscr{G}_{1}^{D}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT \ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT and ℋ1\𝒢1E\subscriptℋ1superscriptsubscript𝒢1𝐸\mathscr{H}_{1}\backslash\mathscr{G}_{1}^{E}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT \ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT. Given a tuple 𝐱𝐱{\mathbf{x}}bold_x in either 𝒢1Dsuperscriptsubscript𝒢1𝐷\mathscr{G}_{1}^{D}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT or 𝒢1Esuperscriptsubscript𝒢1𝐸\mathscr{G}_{1}^{E}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT we write 𝐱†superscript𝐱†\mathbf{x}^{\dagger}bold_x start_POSTSUPERSCRIPT † end_POSTSUPERSCRIPT for the representative of the coset ℋ1⁢𝐱subscriptℋ1𝐱\mathscr{H}_{1}\mathbf{x}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT bold_x. Let X={u𝐛|u∈U,𝐛∈𝒢1D}⊔{v𝐚|v∈V,𝐚∈𝒢1E}𝑋square-unionconditional-setsubscript𝑢𝐛formulae-sequence𝑢𝑈𝐛superscriptsubscript𝒢1𝐷conditional-setsubscript𝑣𝐚formulae-sequence𝑣𝑉𝐚superscriptsubscript𝒢1𝐸X=\{u_{\mathbf{b}}\,|u\in U,{\mathbf{b}}\in\mathscr{G}_{1}^{D}\}\sqcup\{v_{% \mathbf{a}}\,|v\in V,{\mathbf{a}}\in\mathscr{G}_{1}^{E}\}italic_X = { italic_u start_POSTSUBSCRIPT bold_b end_POSTSUBSCRIPT | italic_u ∈ italic_U , bold_b ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT } ⊔ { italic_v start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT | italic_v ∈ italic_V , bold_a ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT }. Then ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT is the weighted system of equations over X𝑋Xitalic_X that contains the equation v𝐚†⁢u𝐛s1s1⁢u𝐜s2s2=g𝐚subscript𝑣superscript𝐚†superscriptsubscript𝑢superscript𝐛subscript𝑠1subscript𝑠1superscriptsubscript𝑢superscript𝐜subscript𝑠2subscript𝑠2subscript𝑔𝐚v_{{\mathbf{a}}^{\dagger}}u_{{\mathbf{b}}^{s_{1}}}^{s_{1}}u_{{\mathbf{c}}^{s_{% 2}}}^{s_{2}}=g_{{\mathbf{a}}}italic_v start_POSTSUBSCRIPT bold_a start_POSTSUPERSCRIPT † end_POSTSUPERSCRIPT end_POSTSUBSCRIPT italic_u start_POSTSUBSCRIPT bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_u start_POSTSUBSCRIPT bold_c start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT (1) for each edge {u,v}𝑢𝑣\{u,v\}{ italic_u , italic_v } of ΣΣ\Sigmaroman_Σ, 𝐚∈𝒢1E𝐚superscriptsubscript𝒢1𝐸{\mathbf{a}}\in\mathscr{G}_{1}^{E}bold_a ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT, 𝐛∈𝒢1D𝐛superscriptsubscript𝒢1𝐷{\mathbf{b}}\in\mathscr{G}_{1}^{D}bold_b ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT, s1,s2∈{−1,1}subscript𝑠1subscript𝑠211s_{1},s_{2}\in\{-1,1\}italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ∈ { - 1 , 1 }, where 𝐜𝐜{\mathbf{c}}bold_c stands for 𝐛−1⁢(𝐚∘πu⁢v)−1⁢𝝂superscript𝐛1superscript𝐚subscript𝜋𝑢𝑣1𝝂{\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu}bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a ∘ italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν and 𝝂∈𝒢1D𝝂superscriptsubscript𝒢1𝐷\bm{\nu}\in\mathscr{G}_{1}^{D}bold_italic_ν ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT is a small perturbation factor. The element g𝐚subscript𝑔𝐚g_{\mathbf{a}}italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT is chosen so that 𝐚†=g𝐚⁢𝐚superscript𝐚†subscript𝑔𝐚𝐚{\mathbf{a}}^{\dagger}=g_{\mathbf{a}}{\mathbf{a}}bold_a start_POSTSUPERSCRIPT † end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT bold_a. The weight of this equation in ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT is the joint probability of the independent events described in Figure 1. (1)The edge {u,v} is chosen uniformly at random among all edges of Σ.(2)The elements 𝐚 and 𝐛 are chosen uniformly at random from 𝒢1E and 𝒢1D respectively.(3)The element 𝝂∈𝒢1D is chosen so that for each d∈D, independently, 𝝂⁢(d)=1𝒢1 withprobability 1−ϵ, and 𝝂⁢(d) is selected uniformly at random from 𝒢1 with probability ϵ.(4)The signs s1,s2 are chosen uniformly at random from {−1,1}.(1)The edge {u,v} is chosen uniformly at random among all edges of Σ.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(2)The elements 𝐚 and 𝐛 are chosen uniformly at random from 𝒢1E and 𝒢1D respectively.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(3)The element 𝝂∈𝒢1D is chosen so that for each d∈D, independently, 𝝂⁢(d)=1𝒢1 withmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionprobability 1−ϵ, and 𝝂⁢(d) is selected uniformly at random from 𝒢1 with probability ϵ.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(4)The signs s1,s2 are chosen uniformly at random from {−1,1}.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression\displaystyle\boxed{\begin{array}[]{llllll}\mbox{($1$)}&\text{The edge $\{u,v\}$ is chosen uniformly at random among all edges of $\Sigma$.}\\[5% .0pt] \mbox{($2$)}&\text{The elements ${\mathbf{a}}$ and ${\mathbf{b}}$ are chosen % uniformly at random from $\mathscr{G}_{1}^{E}$ and $\mathscr{G}_{1}^{D}$ % respectively.}\\[5.0pt] \mbox{($3$)}&\text{The element $\bm{\nu}\in\mathscr{G}_{1}^{D}$ is chosen so % that for each $d\in D$, independently, $\bm{\nu}(d)=1_{\mathscr{G}_{1}}$ with}\\ &\text{probability $1-\epsilon$, and $\bm{\nu}(d)$ is selected uniformly at % random from $\mathscr{G}_{1}$ with probability $\epsilon$.}\\[5.0pt] \mbox{($4$)}&\text{The signs $s_{1},s_{2}$ are chosen uniformly at random from $\{-1,1\}$.}\end{array}}start_ARRAY start_ROW start_CELL ( 1 ) end_CELL start_CELL The edge { italic_u , italic_v } is chosen uniformly at random among all edges of roman_Σ . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 2 ) end_CELL start_CELL The elements bold_a and bold_b are chosen uniformly at random from script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT and script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT respectively. end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 3 ) end_CELL start_CELL The element bold_italic_ν ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT is chosen so that for each italic_d ∈ italic_D , independently, bold_italic_ν ( italic_d ) = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT with end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL start_CELL probability 1 - italic_ϵ , and bold_italic_ν ( italic_d ) is selected uniformly at random from script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT with probability italic_ϵ . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 4 ) end_CELL start_CELL The signs italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are chosen uniformly at random from { - 1 , 1 } . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW end_ARRAY Figure 1: The sampling procedure for ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT. Let us describe assignments of ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT over 𝒢isubscript𝒢𝑖\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT for i=1,2𝑖12i=1,2italic_i = 1 , 2. Formally, an assignment of ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT over 𝒢isubscript𝒢𝑖\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is a map h:X→𝒢i:ℎ→𝑋subscript𝒢𝑖h:X\rightarrow\mathscr{G}_{i}italic_h : italic_X → script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT. Such an assignment can be described by two families of maps A=(Av)v∈V𝐴subscriptsubscript𝐴𝑣𝑣𝑉A=(A_{v})_{v\in V}italic_A = ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_v ∈ italic_V end_POSTSUBSCRIPT from 𝒢1Esubscriptsuperscript𝒢𝐸1\mathscr{G}^{E}_{1}script_G start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to 𝒢isubscript𝒢𝑖\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and B=(Bu)u∈U𝐵subscriptsubscript𝐵𝑢𝑢𝑈B=(B_{u})_{u\in U}italic_B = ( italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_u ∈ italic_U end_POSTSUBSCRIPT from 𝒢1Dsuperscriptsubscript𝒢1𝐷\mathscr{G}_{1}^{D}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT to 𝒢isubscript𝒢𝑖\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT by letting Av⁢(𝐚)=h⁢(v𝐚)subscript𝐴𝑣𝐚ℎsubscript𝑣𝐚A_{v}({\mathbf{a}})=h(v_{{\mathbf{a}}})italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a ) = italic_h ( italic_v start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT ) for all v∈V,𝐚∈𝒢1Eformulae-sequence𝑣𝑉𝐚superscriptsubscript𝒢1𝐸v\in V,{\mathbf{a}}\in\mathscr{G}_{1}^{E}italic_v ∈ italic_V , bold_a ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT, and Bu⁢(𝐛)=h⁢(u𝐛)=subscript𝐵𝑢𝐛ℎsubscript𝑢𝐛absentB_{u}({\mathbf{b}})=h(u_{{\mathbf{b}}})=italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b ) = italic_h ( italic_u start_POSTSUBSCRIPT bold_b end_POSTSUBSCRIPT ) = for all u∈U,𝐛∈𝒢1Dformulae-sequence𝑢𝑈𝐛superscriptsubscript𝒢1𝐷u\in U,{\mathbf{b}}\in\mathscr{G}_{1}^{D}italic_u ∈ italic_U , bold_b ∈ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT. It will be more convenient to talk about the pair (A,B)𝐴𝐵(A,B)( italic_A , italic_B ) rather than the map hℎhitalic_h itself, so we will write ΦΣ𝒢i⁢(A,B)subscriptsuperscriptΦsubscript𝒢𝑖Σ𝐴𝐵\Phi^{\mathscr{G}_{i}}_{\Sigma}(A,B)roman_Φ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT ( italic_A , italic_B ) to refer to the proportion of equations satisfied by the assignment hℎhitalic_h. Let us give a more useful expression for ΦΣ𝒢i⁢(A,B)subscriptsuperscriptΦsubscript𝒢𝑖Σ𝐴𝐵\Phi^{\mathscr{G}_{i}}_{\Sigma}(A,B)roman_Φ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT ( italic_A , italic_B ). When i=1𝑖1i=1italic_i = 1, we can write ΦΣ𝒢1(A,B)=𝔼u⁢v,𝐚,𝐛,𝝂,s1,s2[⟦Av(𝐚†)Bu(𝐛s1)s1Bu((𝐛−1(𝐚∘πu⁢v)−1𝝂)s2)s2=g𝐚⟧],\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket A_{v}({\mathbf{a}}^{% \dagger})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{% a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=g_{{\mathbf{a}}}\rrbracket% \right],roman_Φ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_ν , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ ⟦ italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a start_POSTSUPERSCRIPT † end_POSTSUPERSCRIPT ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a ∘ italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT ⟧ ] , where the expectation is taken over the probabilities described in Figure 1, and we use u⁢v𝑢𝑣uvitalic_u italic_v as a shorthand for an edge {u,v}𝑢𝑣\{u,v\}{ italic_u , italic_v }. Folding the assignments Avsubscript𝐴𝑣A_{v}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT over the identity on ℋ1subscriptℋ1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and using the fact that (Av)idℋ1⁢(𝐚)=g𝐚−1⁢Av⁢(𝐚†)subscriptsubscript𝐴𝑣subscriptidsubscriptℋ1𝐚superscriptsubscript𝑔𝐚1subscript𝐴𝑣superscript𝐚†(A_{v})_{\mathrm{id}_{\mathscr{H}_{1}}}({\mathbf{a}})=g_{{\mathbf{a}}}^{-1}A_{% v}({\mathbf{a}}^{\dagger})( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( bold_a ) = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a start_POSTSUPERSCRIPT † end_POSTSUPERSCRIPT ), we obtain ΦΣ𝒢1(A,B)=𝔼u⁢v,𝐚,𝐛,𝝂,s1,s2[⟦(Av)idℋ1(𝐚)Bu(𝐛s1)s1Bu((𝐛−1(𝐚∘πu⁢v)−1𝝂)s2)s2=1𝒢1⟧].\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket(A_{v})_{\mathrm{id}_{% \mathscr{H}_{1}}}({\mathbf{a}})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({% \mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=1_{% \mathscr{G}_{1}}\rrbracket\right].roman_Φ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_ν , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ ⟦ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a ∘ italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT ⟧ ] . (2) Analogously, when i=2𝑖2i=2italic_i = 2 and Av,Busubscript𝐴𝑣subscript𝐵𝑢A_{v},B_{u}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT , italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are families of maps to 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, we obtain a similar expression for ΦΣ𝒢2⁢(A,B)subscriptsuperscriptΦsubscript𝒢2Σ𝐴𝐵\Phi^{\mathscr{G}_{2}}_{\Sigma}(A,B)roman_Φ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT ( italic_A , italic_B ): ΦΣ𝒢2(A,B)=𝔼u⁢v,𝐚,𝐛,𝝂,s1,s2[⟦(Av)φ(𝐚)Bu(𝐛s1)s1Bu((𝐛−1(𝐚∘πu⁢v)−1𝝂)s2)s2=1𝒢2⟧].\Phi^{\mathscr{G}_{2}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket(A_{v})_{\varphi}({\mathbf{% a}})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}% \circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=1_{\mathscr{G}_{2}}\rrbracket% \right].roman_Φ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_ν , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ ⟦ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a ∘ italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT ⟧ ] . (3) That is, a pair of assignments (A,B)𝐴𝐵(A,B)( italic_A , italic_B ) satisfies an equation in ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT if and only if the corresponding pair of assignments obtained by folding A𝐴Aitalic_A (over idℋ1subscriptidsubscriptℋ1\mathrm{id}_{\mathscr{H}_{1}}roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT and φ𝜑\varphiitalic_φ respectively) maps the equation to the group identity (respectively, in 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT). Thus, folding allows us to focus exclusively on the identity terms in these expectations, which will be useful in the analysis of the reduction. Theorem 1.3 follows from our completeness and soundness bounds for ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT, stated in the next results, using the fact that by Theorem 1.1, there are finite sets D,E𝐷𝐸D,Eitalic_D , italic_E such that GLCD,E⁢(1,α)subscriptGLC𝐷𝐸1𝛼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_α ) is NP-hard for the value of α𝛼\alphaitalic_α chosen in Theorem 1.7 below. The proofs of the completeness and soundness bounds can be found in Section 3.1 and Section 3.2 respectively. Theorem 1.6 (Completeness). Let ΣΣ\Sigmaroman_Σ be a Gap Label Cover instance and ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT be the system defined in (1). Suppose that ΣΣ\Sigmaroman_Σ is 1111-satisfiable. Then ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT is (1−ϵ)1italic-ϵ(1-\epsilon)( 1 - italic_ϵ )-satisfiable in 𝒢1subscript𝒢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. Theorem 1.7 (Soundness). Let ΣΣ\Sigmaroman_Σ be a Gap Label Cover instance and ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT be the system defined in (1). Suppose that ΦΣsubscriptΦΣ\Phi_{\Sigma}roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT is (1/|ℋ2|+δ)1subscriptℋ2𝛿(1/|\mathscr{H}_{2}|+\delta)( 1 / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | + italic_δ )-satisfiable in 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Then ΣΣ\Sigmaroman_Σ is α𝛼\alphaitalic_α-satisfiable, where α=δ2/(4⁢κ⁢|𝒢1|κ⁢|𝒢2|4)𝛼superscript𝛿24𝜅superscriptsubscript𝒢1𝜅superscriptsubscript𝒢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_α = italic_δ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_κ | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_κ end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) and κ=⌈(log2δ−2)/(log2(1−ϵ)⌉\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon)\rceilitalic_κ = ⌈ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_δ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_ϵ ) ⌉. 1.4 Proof Outline The main difficulty in proving the correctness of our reduction lies in showing the soundness bound (Theorem 1.7). The completeness result (Theorem 1.6) is relatively straightforward and follows as in [EHR04]. In summary, suppose the Gap Label Cover instance ΣΣ\Sigmaroman_Σ is satisfied by a pair of assignments hD:U→D:subscriptℎ𝐷→𝑈𝐷h_{D}:U\rightarrow Ditalic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT : italic_U → italic_D, hE:V→E:subscriptℎ𝐸→𝑉𝐸h_{E}:V\rightarrow Eitalic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT : italic_V → italic_E. Then we find families A,B𝐴𝐵A,Bitalic_A , italic_B such that ΦΣ𝒢1⁢(A,B)≥1−ϵsubscriptsuperscriptΦsubscript𝒢1Σ𝐴𝐵1italic-ϵ\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)\geq 1-\epsilonroman_Φ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT ( italic_A , italic_B ) ≥ 1 - italic_ϵ by letting Avsubscript𝐴𝑣A_{v}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT be the hE⁢(v)subscriptℎ𝐸𝑣h_{E}(v)italic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT ( italic_v )-th projection and Busubscript𝐵𝑢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT be the hD⁢(u)subscriptℎ𝐷𝑢h_{D}(u)italic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_u )-th projection for each v∈V,u∈Uformulae-sequence𝑣𝑉𝑢𝑈v\in V,u\in Uitalic_v ∈ italic_V , italic_u ∈ italic_U. As usual, the noise introduced by the perturbation factor 𝝂𝝂\bm{\nu}bold_italic_ν is what forces us to give up perfect completeness. The idea behind our soundness analysis has appeared many times in the literature (e.g., [Hås01, EHR04, BK21]), but the approach taken in [EHR04] is the most similar to ours. Suppose that there are assignments A,B𝐴𝐵A,Bitalic_A , italic_B, satisfying ΦΣ𝒢2⁢(A,B)≥1|ℋ2|+δ.superscriptsubscriptΦΣsubscript𝒢2𝐴𝐵1subscriptℋ2𝛿\Phi_{\Sigma}^{\mathscr{G}_{2}}(A,B)\geq\frac{1}{|\mathscr{H}_{2}|}+\delta.roman_Φ start_POSTSUBSCRIPT roman_Σ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ( italic_A , italic_B ) ≥ divide start_ARG 1 end_ARG start_ARG | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | end_ARG + italic_δ . (4) In view of (3), this inequality can be understood as a lower bound for the the success probability of the following 3333-query dictatorship test: Sample all parameters according to the distribution shown in Figure 1, and then query the values (Av)φ⁢(𝐚)subscriptsubscript𝐴𝑣𝜑𝐚(A_{v})_{\varphi}({\mathbf{a}})( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT ( bold_a ), Bu⁢(𝐛s1)s1subscript𝐵𝑢superscriptsuperscript𝐛subscript𝑠1subscript𝑠1B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT, and Bu⁢((𝐛−1⁢(𝐚∘πu⁢v)−1⁢𝝂)s2)s2subscript𝐵𝑢superscriptsuperscriptsuperscript𝐛1superscript𝐚subscript𝜋𝑢𝑣1𝝂subscript𝑠2subscript𝑠2B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_% {2}}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a ∘ italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT. The test is passed if the product of the three values is the group identity, and failed otherwise. The soundness proof consists in showing that (4) implies that the functions (Av)φ:𝒢1E→𝒢2:subscriptsubscript𝐴𝑣𝜑→superscriptsubscript𝒢1𝐸subscript𝒢2(A_{v})_{\varphi}:\mathscr{G}_{1}^{E}\rightarrow\mathscr{G}_{2}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT → script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and Bu:𝒢1D→𝒢2:subscript𝐵𝑢→superscriptsubscript𝒢1𝐷subscript𝒢2B_{u}:\mathscr{G}_{1}^{D}\rightarrow\mathscr{G}_{2}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT → script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are “close” to dictators (i.e., projections) for each v∈V𝑣𝑉v\in Vitalic_v ∈ italic_V, u∈U𝑢𝑈u\in Uitalic_u ∈ italic_U. Then, this fact allows us to find a good solution to the starting Gap Label Cover instance ΣΣ\Sigmaroman_Σ. Indeed, suppose that for each v∈V𝑣𝑉v\in Vitalic_v ∈ italic_V the map (Av)φsubscriptsubscript𝐴𝑣𝜑(A_{v})_{\varphi}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT is the projection on the evsubscript𝑒𝑣e_{v}italic_e start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT-th coordinate, and for each u∈U𝑢𝑈u\in Uitalic_u ∈ italic_U, the map Busubscript𝐵𝑢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT is the projection on the dusubscript𝑑𝑢d_{u}italic_d start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT-th coordinate. Then the assignment mapping v𝑣vitalic_v to evsubscript𝑒𝑣e_{v}italic_e start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT and u𝑢uitalic_u to dusubscript𝑑𝑢d_{u}italic_d start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT for each v∈V,u∈Uformulae-sequence𝑣𝑉𝑢𝑈v\in V,u\in Uitalic_v ∈ italic_V , italic_u ∈ italic_U is a good solution for ΣΣ\Sigmaroman_Σ. However, it is not clear how to extend this simple idea to the case where the maps (Av)φ,Busubscriptsubscript𝐴𝑣𝜑subscript𝐵𝑢(A_{v})_{\varphi},B_{u}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT , italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are not projections. In order to find a good solution for ΣΣ\Sigmaroman_Σ in this general case, we first find suitable maps γ1,γ2:𝒢2→ℂ:subscript𝛾1subscript𝛾2→subscript𝒢2ℂ\gamma_{1},\gamma_{2}:\mathscr{G}_{2}\rightarrow\mathbb{C}italic_γ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_γ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT → blackboard_C and analyse γ1∘(Av)φsubscript𝛾1subscriptsubscript𝐴𝑣𝜑\gamma_{1}\circ(A_{v})_{\varphi}italic_γ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ∘ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT, γ2∘Busubscript𝛾2subscript𝐵𝑢\gamma_{2}\circ B_{u}italic_γ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ∘ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT. Now, using the fact that (Av)φsubscriptsubscript𝐴𝑣𝜑(A_{v})_{\varphi}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT and Busubscript𝐵𝑢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are close to projections, we can prove that choosing the labels e,d𝑒𝑑e,ditalic_e , italic_d for the vertices v,u𝑣𝑢v,uitalic_v , italic_u according to the “low-degree influence” of the e𝑒eitalic_e-th coordinate in γ1∘(Av)φsubscript𝛾1subscriptsubscript𝐴𝑣𝜑\gamma_{1}\circ(A_{v})_{\varphi}italic_γ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ∘ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT and the d𝑑ditalic_d-th coordinate in γ2∘Busubscript𝛾2subscript𝐵𝑢\gamma_{2}\circ B_{u}italic_γ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ∘ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT yields a good randomised assignment of ΣΣ\Sigmaroman_Σ. This overview so far also applies to the soundness analysis of [EHR04]. Let us give more detail and highlight the main differences that sets our work apart. The first important difference has to do with the choice of γ1,γ2subscript𝛾1subscript𝛾2\gamma_{1},\gamma_{2}italic_γ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_γ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. We define γ1=ωx,ysubscript𝛾1subscript𝜔𝑥𝑦\gamma_{1}=\omega_{x,y}italic_γ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_ω start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT, and γ2=ωy,zsubscript𝛾2subscript𝜔𝑦𝑧\gamma_{2}=\omega_{y,z}italic_γ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_ω start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT, where ω𝜔\omegaitalic_ω is some irreducible representation of 𝒢2subscript𝒢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, and x,y,z𝑥𝑦𝑧x,y,zitalic_x , italic_y , italic_z are suitable indices in Nωsubscript𝑁𝜔N_{\omega}italic_N start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT. In [EHR04], the representation ω𝜔\omegaitalic_ω is a non-trivial representation chosen so that |𝔼⁢[χω⁢((Av)φ⁢(𝐚)⁢Bu⁢(𝐛s1)s1⁢Bu⁢((𝐛−1⁢(𝐚∘π)−1⁢𝝂)s2)s2)]|≥dimωδ.𝔼delimited-[]subscript𝜒𝜔subscriptsubscript𝐴𝑣𝜑𝐚subscript𝐵𝑢superscriptsuperscript𝐛subscript𝑠1subscript𝑠1subscript𝐵𝑢superscriptsuperscriptsuperscript𝐛1superscript𝐚𝜋1𝝂subscript𝑠2subscript𝑠2subscriptdimension𝜔𝛿\left|\mathbb{E}\left[\chi_{\omega}\left((A_{v})_{\varphi}({\mathbf{a}})B_{u}(% {\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi)^{-% 1}\bm{\nu})^{s_{2}})^{s_{2}}\right)\right]\right|\geq\dim_{\omega}\delta.| blackboard_E [ italic_χ start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT ( ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a ∘ italic_π ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) ] | ≥ roman_dim start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT italic_δ . Here the expectation is taken over the probability space described in Figure 1, and the dependence of π𝜋\piitalic_π on the edge {u,v}𝑢𝑣\{u,v\}{ italic_u , italic_v } is left implicit. In our case, rather than using the Fourier characters for choosing ω𝜔\omegaitalic_ω, we consider “penalized characters” χω~~subscript𝜒𝜔\widetilde{\chi_{\omega}}over~ start_ARG italic_χ start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT end_ARG. We define χω~:𝒢2→ℂ:~subscript𝜒𝜔→subscript𝒢2ℂ\widetilde{\chi_{\omega}}:\mathscr{G}_{2}\rightarrow\mathbb{C}over~ start_ARG italic_χ start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT end_ARG : script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT → blackboard_C as the map χω−ηωsubscript𝜒𝜔subscript𝜂𝜔\chi_{\omega}-\eta_{\omega}italic_χ start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT - italic_η start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT, where the penalty ηωsubscript𝜂𝜔\eta_{\omega}italic_η start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT is the multiplicity of the trivial representation in the restriction ω|ℋ2evaluated-at𝜔subscriptℋ2\omega|_{\mathscr{H}_{2}}italic_ω | start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT. This way, we pick ω∈𝒢2^𝜔^subscript𝒢2\omega\in\widehat{\mathscr{G}_{2}}italic_ω ∈ over^ start_ARG script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG so that the previous inequality holds after replacing χωsubscript𝜒𝜔\chi_{\omega}italic_χ start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT with χω~~subscript𝜒𝜔\widetilde{\chi_{\omega}}over~ start_ARG italic_χ start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT end_ARG. Equivalently, we find ω𝜔\omegaitalic_ω satisfying |𝔼⁢[χω⁢((Av)φ⁢(𝐚)⁢Bu⁢(𝐛s1)s1⁢Bu⁢((𝐛−1⁢(𝐚∘π)−1⁢𝝂)s2)s2)]|≥dimωδ+ηω.𝔼delimited-[]subscript𝜒𝜔subscriptsubscript𝐴𝑣𝜑𝐚subscript𝐵𝑢superscriptsuperscript𝐛subscript𝑠1subscript𝑠1subscript𝐵𝑢superscriptsuperscriptsuperscript𝐛1superscript𝐚𝜋1𝝂subscript𝑠2subscript𝑠2subscriptdimension𝜔𝛿subscript𝜂𝜔\left|\mathbb{E}\left[\chi_{\omega}\left((A_{v})_{\varphi}({\mathbf{a}})B_{u}(% {\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi)^{-% 1}\bm{\nu})^{s_{2}})^{s_{2}}\right)\right]\right|\geq\dim_{\omega}\delta+\eta_% {\omega}.| blackboard_E [ italic_χ start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT ( ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a ∘ italic_π ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) ] | ≥ roman_dim start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT italic_δ + italic_η start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT . (5) The fact that such ω𝜔\omegaitalic_ω exists is a consequence of (4) together with ∑ω∈𝒢2^dimωηω=|𝒢2|/|ℋ2|subscript𝜔^subscript𝒢2subscriptdimension𝜔subscript𝜂𝜔subscript𝒢2subscriptℋ2\sum_{\omega\in\widehat{\mathscr{G}_{2}}}\dim_{\omega}\eta_{\omega}=|\mathscr{% G}_{2}|/|\mathscr{H}_{2}|∑ start_POSTSUBSCRIPT italic_ω ∈ over^ start_ARG script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT italic_η start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT = | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT |, which follows from the Frobenius Reciprocity Theorem, as shown in Lemma 2.11. This additional factor of ηωsubscript𝜂𝜔\eta_{\omega}italic_η start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT is crucial to our soundness analysis, as we will see. Define the map 𝒜=ω∘(Av)φ𝒜𝜔subscriptsubscript𝐴𝑣𝜑\mathcal{A}=\omega\circ(A_{v})_{\varphi}caligraphic_A = italic_ω ∘ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT and the map ℬ:𝒢1D→𝒢2:ℬ→superscriptsubscript𝒢1𝐷subscript𝒢2\mathcal{B}:\mathscr{G}_{1}^{D}\rightarrow\mathscr{G}_{2}caligraphic_B : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT → script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT given by ℬ⁢(𝐛)=𝔼s∈{−1,1}⁢ω∘Bu⁢(𝐛s)sℬ𝐛subscript𝔼𝑠11𝜔subscript𝐵𝑢superscriptsuperscript𝐛𝑠𝑠\mathcal{B}({\mathbf{b}})=\mathbb{E}_{s\in\{-1,1\}}\omega\circ B_{u}({\mathbf{% b}}^{s})^{s}caligraphic_B ( bold_b ) = blackboard_E start_POSTSUBSCRIPT italic_s ∈ { - 1 , 1 } end_POSTSUBSCRIPT italic_ω ∘ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT, where s∈{−1,1}𝑠11s\in\{-1,1\}italic_s ∈ { - 1 , 1 } is distributed uniformly.555Observe that the maps 𝒜𝒜\mathcal{A}caligraphic_A and ℬℬ\mathcal{B}caligraphic_B depend on the hidden parameters v𝑣vitalic_v and u𝑢uitalic_u respectively. To show the soundness bound we consider the Fourier expansions of 𝒜𝒜\mathcal{A}caligraphic_A and ℬ∗ℬℬℬ\mathcal{B}*\mathcal{B}caligraphic_B ∗ caligraphic_B in the expression |tr⁢𝔼⁢[𝒜⁢(𝐚)⁢(ℬ∗ℬ)⁢((𝐚∘π)−1⁢𝝂)]|,tr𝔼delimited-[]𝒜𝐚ℬℬsuperscript𝐚𝜋1𝝂\left|\mathrm{tr}\,\mathbb{E}\left[\mathcal{A}({\mathbf{a}})(\mathcal{B}*% \mathcal{B})(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right]\right|,| roman_tr blackboard_E [ caligraphic_A ( bold_a ) ( caligraphic_B ∗ caligraphic_B ) ( ( bold_a ∘ italic_π ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) ] | , which is just a rearrangement of the left-hand-side in the previous inequality. More precisely, we look at the equivalent expression |tr⁢𝔼⁢[(∑τ∈𝒢E^,s,t∈Nτdimτ𝒜^⁢(τs,t)⁢τs,t⁢(𝐚))⁢(∑ρ∈𝒢D^,i,j∈Nρdimρ(ℬ∗ℬ)^⁢(ρi,j)⁢ρi,j⁢((𝐚∘π)−1⁢𝝂))]|.tr𝔼delimited-[]subscriptformulae-sequence𝜏^superscript𝒢𝐸𝑠𝑡subscript𝑁𝜏subscriptdimension𝜏^𝒜subscript𝜏𝑠𝑡subscript𝜏𝑠𝑡𝐚subscriptformulae-sequence𝜌^superscript𝒢𝐷𝑖𝑗subscript𝑁𝜌subscriptdimension𝜌^ℬℬsubscript𝜌𝑖𝑗subscript𝜌𝑖𝑗superscript𝐚𝜋1𝝂\left|\mathrm{tr}\,\mathbb{E}\left[\left(\sum_{\tau\in\widehat{\mathscr{G}^{E}% },s,t\in N_{\tau}}\dim_{\tau}\widehat{\mathcal{A}}(\tau_{s,t})\tau_{s,t}({% \mathbf{a}})\right)\left(\sum_{\rho\in\widehat{\mathscr{G}^{D}},i,j\in N_{\rho% }}\dim_{\rho}\widehat{(\mathcal{B}*\mathcal{B})}(\rho_{i,j})\rho_{i,j}(({% \mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right)\right]\right|.| roman_tr blackboard_E [ ( ∑ start_POSTSUBSCRIPT italic_τ ∈ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_s , italic_t ∈ italic_N start_POSTSUBSCRIPT italic_τ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_τ end_POSTSUBSCRIPT over^ start_ARG caligraphic_A end_ARG ( italic_τ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) italic_τ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ( bold_a ) ) ( ∑ start_POSTSUBSCRIPT italic_ρ ∈ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B ∗ caligraphic_B ) end_ARG ( italic_ρ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_ρ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a ∘ italic_π ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) ) ] | . (6) Our goal is to find a bound κ𝜅\kappaitalic_κ, independent of |D|,|E|𝐷𝐸|D|,|E|| italic_D | , | italic_E |, satisfying that the contribution to this expression of non-trivial representations τ,ρ𝜏𝜌\tau,\rhoitalic_τ , italic_ρ of degree less than κ𝜅\kappaitalic_κ is at least dimωδ/2subscriptdimension𝜔𝛿2\dim_{\omega}\delta/2roman_dim start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT italic_δ / 2. This is achieved by controlling the contribution of the trivial term and the contribution of high-degree terms, as indicated by Lemma 3.1 and Lemma 3.2 respectively. The second main difference of our soundness analysis compared to [EHR04] is our handling of the trivial term. In Lemma 3.1 we prove that |tr⁢𝔼⁢[𝒜^⁢(1)⁢(∑ρ∈𝒢D^,s,t∈Nρdimρ(ℬ∗ℬ)^⁢(ρi,j)⁢ρi,j⁢((𝐚∘π)−1⁢𝝂))]|≤ηω.tr𝔼delimited-[]^𝒜1subscriptformulae-sequence𝜌^superscript𝒢𝐷𝑠𝑡subscript𝑁𝜌subscriptdimension𝜌^ℬℬsubscript𝜌𝑖𝑗subscript𝜌𝑖𝑗superscript𝐚𝜋1𝝂subscript𝜂𝜔\left|\mathrm{tr}\,\mathbb{E}\left[\widehat{\mathcal{A}}(1)\left(\sum_{\rho\in% \widehat{\mathscr{G}^{D}},s,t\in N_{\rho}}\dim_{\rho}\widehat{(\mathcal{B}*% \mathcal{B})}(\rho_{i,j})\rho_{i,j}(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right% )\right]\right|\leq\eta_{\omega}.| roman_tr blackboard_E [ over^ start_ARG caligraphic_A end_ARG ( 1 ) ( ∑ start_POSTSUBSCRIPT italic_ρ ∈ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_s , italic_t ∈ italic_N start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B ∗ caligraphic_B ) end_ARG ( italic_ρ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_ρ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a ∘ italic_π ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) ) ] | ≤ italic_η start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT . In the non-promise setting, this bound is not necessary. Roughly, under the stronger notion of folding used in [EHR04], it is possible to show that 𝒜^⁢(1)^𝒜1\widehat{\mathcal{A}}(1)over^ start_ARG caligraphic_A end_ARG ( 1 ) vanishes. Our weaker notion of folding does not allow us to prove the same result, but we are still able to leverage folding to obtain the above bound. This mismatch with [EHR04] is the reason why the extra ηωsubscript𝜂𝜔\eta_{\omega}italic_η start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT term was required in (5). The key insight in the proof of Lemma 3.1 is that if F:𝒢1E→𝒢2:𝐹→superscriptsubscript𝒢1𝐸subscript𝒢2F:\mathscr{G}_{1}^{E}\rightarrow\mathscr{G}_{2}italic_F : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT → script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is folded over φ𝜑\varphiitalic_φ, then the trace of (ω∘F)^⁢(1)^𝜔𝐹1\widehat{(\omega\circ F)}(1)over^ start_ARG ( italic_ω ∘ italic_F ) end_ARG ( 1 ) is at most ηωsubscript𝜂𝜔\eta_{\omega}italic_η start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT in absolute value. Our analysis of high-degree terms is in the same spirit as previous works that show hardness of approximation in the imperfect completeness setting. In Lemma 3.2 we prove that |tr𝔼[(∑τ∈𝒢1E^,τ≠1∑s,t∈Nτdimτ𝒜^(τs,t)τs,t(𝐚))×\displaystyle\left|\mathrm{tr}\,\mathbb{E}\left[\left(\sum_{\tau\in\widehat{% \mathscr{G}_{1}^{E}},\tau\neq 1}\sum_{s,t\in N_{\tau}}\dim_{\tau}\widehat{% \mathcal{A}}(\tau_{s,t})\tau_{s,t}({\mathbf{a}})\right)\times\right.\right.| roman_tr blackboard_E [ ( ∑ start_POSTSUBSCRIPT italic_τ ∈ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_τ ≠ 1 end_POSTSUBSCRIPT ∑ start_POSTSUBSCRIPT italic_s , italic_t ∈ italic_N start_POSTSUBSCRIPT italic_τ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_τ end_POSTSUBSCRIPT over^ start_ARG caligraphic_A end_ARG ( italic_τ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) italic_τ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ( bold_a ) ) × (∑ρ∈𝒢1D^,|ρ|≥κ∑i,j∈Nρdimρ(ℬ∗ℬ)^(ρi,j)ρi,j((𝐚∘π)−1𝝂))]|≤(dimωδ)/2\displaystyle\left.\left.\left(\sum_{\rho\in\widehat{\mathscr{G}_{1}^{D}},|% \rho|\geq\kappa}\sum_{i,j\in N_{\rho}}\dim_{\rho}\widehat{(\mathcal{B}*% \mathcal{B})}(\rho_{i,j})\rho_{i,j}(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right% )\right]\right|\leq(\dim_{\omega}\delta)/2( ∑ start_POSTSUBSCRIPT italic_ρ ∈ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , | italic_ρ | ≥ italic_κ end_POSTSUBSCRIPT ∑ start_POSTSUBSCRIPT italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B ∗ caligraphic_B ) end_ARG ( italic_ρ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_ρ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a ∘ italic_π ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_ν ) ) ] | ≤ ( roman_dim start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT italic_δ ) / 2 for all κ≥(log2⁡δ−2)/log2⁡(1−ϵ)𝜅subscript2𝛿2subscript21italic-ϵ\kappa\geq(\log_{2}\delta-2)/\log_{2}(1-\epsilon)italic_κ ≥ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_δ - 2 ) / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_ϵ ). The essential idea is that the “noise vector” 𝝂𝝂\bm{\nu}bold_italic_ν has a smoothing effect that limits the contribution of high-degree terms in (6). Finally, having established that the contribution of non-trivial terms of degree less than κ𝜅\kappaitalic_κ in (6) is at least dimωδ/2subscriptdimension𝜔𝛿2\dim_{\omega}\delta/2roman_dim start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT italic_δ / 2, in Lemma 3.3 we give a good randomised strategy to solve ΣΣ\Sigmaroman_Σ. This strategy assigns the label e∈E𝑒𝐸e\in Eitalic_e ∈ italic_E to v∈V𝑣𝑉v\in Vitalic_v ∈ italic_V and the label d∈D𝑑𝐷d\in Ditalic_d ∈ italic_D to u∈U𝑢𝑈u\in Uitalic_u ∈ italic_U with probabilities Pr⁡(v↦e)=∑τ∈𝒢1E^,τe≠1∑s,t∈Nτdimτ|𝒜x,y^⁢(τs,t)|2|τ|Prmaps-to𝑣𝑒subscriptformulae-sequence𝜏^superscriptsubscript𝒢1𝐸superscript𝜏𝑒1subscript𝑠𝑡subscript𝑁𝜏subscriptdimension𝜏superscript^subscript𝒜𝑥𝑦subscript𝜏𝑠𝑡2𝜏\Pr(v\mapsto e)\ =\sum_{\tau\in\widehat{\mathscr{G}_{1}^{E}},\tau^{e}\neq 1}% \sum_{s,t\in N_{\tau}}\dim_{\tau}\frac{\left|\widehat{\mathcal{A}_{x,y}}(\tau_% {s,t})\right|^{2}}{|\tau|}roman_Pr ( italic_v ↦ italic_e ) = ∑ start_POSTSUBSCRIPT italic_τ ∈ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_τ start_POSTSUPERSCRIPT italic_e end_POSTSUPERSCRIPT ≠ 1 end_POSTSUBSCRIPT ∑ start_POSTSUBSCRIPT italic_s , italic_t ∈ italic_N start_POSTSUBSCRIPT italic_τ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_τ end_POSTSUBSCRIPT divide start_ARG | over^ start_ARG caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT end_ARG ( italic_τ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_τ | end_ARG and Pr⁡(u↦d)=∑ρ∈𝒢1D^,ρd≠1∑i,j∈Nρdimρ|ℬy,z^⁢(ρi,j)|2|ρ|,Prmaps-to𝑢𝑑subscriptformulae-sequence𝜌^superscriptsubscript𝒢1𝐷superscript𝜌𝑑1subscript𝑖𝑗subscript𝑁𝜌subscriptdimension𝜌superscript^subscriptℬ𝑦𝑧subscript𝜌𝑖𝑗2𝜌\Pr(u\mapsto d)\ =\sum_{\rho\in\widehat{\mathscr{G}_{1}^{D}},\rho^{d}\neq 1}% \sum_{i,j\in N_{\rho}}\dim_{\rho}\frac{\left|\widehat{\mathcal{B}_{y,z}}(\rho_% {i,j})\right|^{2}}{|\rho|},roman_Pr ( italic_u ↦ italic_d ) = ∑ start_POSTSUBSCRIPT italic_ρ ∈ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_ρ start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ≠ 1 end_POSTSUBSCRIPT ∑ start_POSTSUBSCRIPT italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT divide start_ARG | over^ start_ARG caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT end_ARG ( italic_ρ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_ρ | end_ARG , where x,y,z∈Nω𝑥𝑦𝑧subscript𝑁𝜔x,y,z\in N_{\omega}italic_x , italic_y , italic_z ∈ italic_N start_POSTSUBSCRIPT italic_ω end_POSTSUBSCRIPT are suitable indices found in Lemma 3.3. These probabilities are supposed to capture the influence of the e𝑒eitalic_e-th and d𝑑ditalic_d-th coordinates on 𝒜x,y=ωx,y∘(Av)φsubscript𝒜𝑥𝑦subscript𝜔𝑥𝑦subscriptsubscript𝐴𝑣𝜑\mathcal{A}_{x,y}=\omega_{x,y}\circ(A_{v})_{\varphi}caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT = italic_ω start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT ∘ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_φ end_POSTSUBSCRIPT and ℬy,z=ωy,z∘𝔼s⁢Bu⁢(⋅s)ssubscriptℬ𝑦𝑧subscript𝜔𝑦𝑧subscript𝔼𝑠subscript𝐵𝑢superscriptsuperscript⋅𝑠𝑠\mathcal{B}_{y,z}=\omega_{y,z}\circ\mathbb{E}_{s}B_{u}(\ \cdot^{s})^{s}caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT = italic_ω start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT ∘ blackboard_E start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ⋅ start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT respectively (compare with the notion of influence in [BK21, AM09]). This turns out to be a good randomised assignment for ΣΣ\Sigmaroman_Σ. That is, 𝔼u⁢v⁢[∑d∈DPr⁡(v↦πu⁢v⁢(d))⁢Pr⁡(u↦d)]≥α,subscript𝔼𝑢𝑣delimited-[]subscript𝑑𝐷Prmaps-to𝑣subscript𝜋𝑢𝑣𝑑Prmaps-to𝑢𝑑𝛼\mathbb{E}_{uv}\left[\sum_{d\in D}\Pr(v\mapsto\pi_{uv}(d))\Pr(u\mapsto d)% \right]\geq\alpha,blackboard_E start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT [ ∑ start_POSTSUBSCRIPT italic_d ∈ italic_D end_POSTSUBSCRIPT roman_Pr ( italic_v ↦ italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_d ) ) roman_Pr ( italic_u ↦ italic_d ) ] ≥ italic_α , (7) where the expectation is taken uniformly over the edges {u,v}𝑢𝑣\{u,v\}{ italic_u , italic_v } of ΣΣ\Sigmaroman_Σ, and α𝛼\alphaitalic_α is the soundness constant appearing in Theorem 1.7. We are being informal with the usage of the word “probability” here: the quantities Pr⁡(v↦e)Prmaps-to𝑣𝑒\Pr(v\mapsto e)roman_Pr ( italic_v ↦ italic_e ) and Pr⁡(u↦d)Prmaps-to𝑢𝑑\Pr(u\mapsto d)roman_Pr ( italic_u ↦ italic_d ) may add up to less than 1111, but this is easily fixed by normalising, or by letting our strategy default to the uniform assignment with some positive probability. Let us give some more detail. More precisely, Lemma 3.3 shows that truncating our assignment probabilities to terms of degree less than κ𝜅\kappaitalic_κ is enough to satisfy this last inequality. Let ℓ≥0ℓ0\ell\geq 0roman_ℓ ≥ 0. The probabilities Pr<ℓ⁡(v↦e)superscriptPrabsentℓmaps-to𝑣𝑒\Pr^{<\ell}(v\mapsto e)roman_Pr start_POSTSUPERSCRIPT < roman_ℓ end_POSTSUPERSCRIPT ( italic_v ↦ italic_e ), Pr<ℓ⁡(u↦d)superscriptPrabsentℓmaps-to𝑢𝑑\Pr^{<\ell}(u\mapsto d)roman_Pr start_POSTSUPERSCRIPT < roman_ℓ end_POSTSUPERSCRIPT ( italic_u ↦ italic_d ) are defined the same way as Pr⁡(v↦e)Prmaps-to𝑣𝑒\Pr(v\mapsto e)roman_Pr ( italic_v ↦ italic_e ) and Pr⁡(u↦d)Prmaps-to𝑢𝑑\Pr(u\mapsto d)roman_Pr ( italic_u ↦ italic_d ) but considering only representations τ,ρ𝜏𝜌\tau,\rhoitalic_τ , italic_ρ of degree less than ℓℓ\ellroman_ℓ. These modified probabilities can be understood as the “low-degree influences” of each coordinate in 𝒜x,ysubscript𝒜𝑥𝑦\mathcal{A}_{x,y}caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT and ℬy,zsubscriptℬ𝑦𝑧\mathcal{B}_{y,z}caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT. With this notation, in Lemma 3.3 we prove that (7) holds after replacing each assignment probability PrPr\Prroman_Pr with its truncated variant Pr<κsuperscriptPrabsent𝜅\Pr^{<\kappa}roman_Pr start_POSTSUPERSCRIPT < italic_κ end_POSTSUPERSCRIPT. In other words, we prove that 𝔼u⁢v⁢[∑d∈D∑ρ∈𝒢1D^,ρd≠1|ρ|<κ,i,j∈Nρ∑τ∈𝒢1E^,τπu⁢v⁢(d)≠1|τ|<κ,s,t∈Nτdimτ|𝒜x,y^⁢(τs,t)|2|τ|⁢dimρ|ℬy,z^⁢(ρi,j)|2|ρ|]≥α.subscript𝔼𝑢𝑣delimited-[]subscript𝑑𝐷subscriptformulae-sequence𝜌^superscriptsubscript𝒢1𝐷superscript𝜌𝑑1formulae-sequence𝜌𝜅𝑖𝑗subscript𝑁𝜌subscriptformulae-sequence𝜏^superscriptsubscript𝒢1𝐸superscript𝜏subscript𝜋𝑢𝑣𝑑1formulae-sequence𝜏𝜅𝑠𝑡subscript𝑁𝜏subscriptdimension𝜏superscript^subscript𝒜𝑥𝑦subscript𝜏𝑠𝑡2𝜏subscriptdimension𝜌superscript^subscriptℬ𝑦𝑧subscript𝜌𝑖𝑗2𝜌𝛼\mathbb{E}_{uv}\left[\sum_{d\in D}\sum_{\begin{subarray}{c}\rho\in\widehat{% \mathscr{G}_{1}^{D}},\rho^{d}\neq 1\\ |\rho|<\kappa,\,i,j\in N_{\rho}\end{subarray}}\sum_{\begin{subarray}{c}\tau\in% \widehat{\mathscr{G}_{1}^{E}},\tau^{\pi_{uv}(d)}\neq 1\\ |\tau|<\kappa,\,s,t\in N_{\tau}\end{subarray}}\frac{\dim_{\tau}\left|\widehat{% \mathcal{A}_{x,y}}(\tau_{s,t})\right|^{2}}{|\tau|}\frac{\dim_{\rho}\left|% \widehat{\mathcal{B}_{y,z}}(\rho_{i,j})\right|^{2}}{|\rho|}\right]\geq\alpha.blackboard_E start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT [ ∑ start_POSTSUBSCRIPT italic_d ∈ italic_D end_POSTSUBSCRIPT ∑ start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_ρ ∈ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_ρ start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ≠ 1 end_CELL end_ROW start_ROW start_CELL | italic_ρ | < italic_κ , italic_i , italic_j ∈ italic_N start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT ∑ start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_τ ∈ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_τ start_POSTSUPERSCRIPT italic_π start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_d ) end_POSTSUPERSCRIPT ≠ 1 end_CELL end_ROW start_ROW start_CELL | italic_τ | < italic_κ , italic_s , italic_t ∈ italic_N start_POSTSUBSCRIPT italic_τ end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT divide start_ARG roman_dim start_POSTSUBSCRIPT italic_τ end_POSTSUBSCRIPT | over^ start_ARG caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT end_ARG ( italic_τ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_τ | end_ARG divide start_ARG roman_dim start_POSTSUBSCRIPT italic_ρ end_POSTSUBSCRIPT | over^ start_ARG caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT end_ARG ( italic_ρ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_ρ | end_ARG ] ≥ italic_α . This shows that our proposed strategy produces a good randomised assignment for ΣΣ\Sigmaroman_Σ and completes the soundness proof."
https://arxiv.org/html/2411.01591v1,What Dosin⁡(x)𝑥\sin(x)roman_sin ( italic_x )andarcsinh⁡(x)arcsinh𝑥\operatorname{arcsinh}(x)roman_arcsinh ( italic_x )Have in Common?,"N. G. de Bruijn (1958) studied the asymptotic expansion of iterates of sin⁡(x)𝑥\sin(x)roman_sin ( italic_x ) with 0<x≤π/20𝑥𝜋20<x\leq\pi/20 < italic_x ≤ italic_π / 2. Bencherif & Robin (1994) generalized this result to increasing analytic functions f⁢(x)𝑓𝑥f(x)italic_f ( italic_x ) with an attractive fixed point at 00 and x>0𝑥0x>0italic_x > 0 suitably small. Mavecha & Laohakosol (2013) formulated an algorithm for explicitly deriving required parameters. We review their method, testing it initally on the logistic function ℓ⁢(x)ℓ𝑥\ell(x)roman_ℓ ( italic_x ), a certain radical function r⁢(x)𝑟𝑥r(x)italic_r ( italic_x ), and later on several transcendental functions. Along the way, we show how ℓ⁢(x)ℓ𝑥\ell(x)roman_ℓ ( italic_x ) and r⁢(x)𝑟𝑥r(x)italic_r ( italic_x ) are kindred functions; the same is also true for sin⁡(x)𝑥\sin(x)roman_sin ( italic_x ) and arcsinh⁡(x)arcsinh𝑥\operatorname{arcsinh}(x)roman_arcsinh ( italic_x ).","1 Basics Consider an analytic function f⁢(x)𝑓𝑥f(x)italic_f ( italic_x ) whose Taylor series at the origin starts as x+∑m=17am⁢xm⁢τ+1𝑥superscriptsubscript𝑚17subscript𝑎𝑚superscript𝑥𝑚𝜏1x+{\displaystyle\sum\limits_{m=1}^{7}}a_{m}x^{m\,\tau+1}italic_x + ∑ start_POSTSUBSCRIPT italic_m = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 7 end_POSTSUPERSCRIPT italic_a start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT italic_x start_POSTSUPERSCRIPT italic_m italic_τ + 1 end_POSTSUPERSCRIPT where a1<0subscript𝑎10a_{1}<0italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT < 0 and τ≥1𝜏1\tau\geq 1italic_τ ≥ 1 is an integer. We choose the upper limit 7777 for the sake of concreteness (the variable k𝑘kitalic_k is employed in [6] and leads to some confusion). Note that f⁢(0)=0𝑓00f(0)=0italic_f ( 0 ) = 0 and zeroes of both f𝑓fitalic_f & f−id𝑓idf-\operatorname{id}italic_f - roman_id are isolated, i.e., there is an ε>0𝜀0\varepsilon>0italic_ε > 0 such that both f⁢(x)≠0𝑓𝑥0f(x)\neq 0italic_f ( italic_x ) ≠ 0 & f⁢(x)≠x𝑓𝑥𝑥f(x)\neq xitalic_f ( italic_x ) ≠ italic_x for all 0<x<ε0𝑥𝜀0<x<\varepsilon0 < italic_x < italic_ε. Further, because limx→0+f⁢(x)x=1>0&limx→0+f⁢(x)−xxτ+1=a1<0,subscript→𝑥superscript0𝑓𝑥𝑥10missing-subexpression&missing-subexpressionsubscript→𝑥superscript0𝑓𝑥𝑥superscript𝑥𝜏1subscript𝑎10\begin{array}[c]{ccccc}\lim\limits_{x\rightarrow 0^{+}}\dfrac{f(x)}{x}=1>0&&% \text{\&}&&\lim\limits_{x\rightarrow 0^{+}}\dfrac{f(x)-x}{x^{\tau+1}}=a_{1}<0,% \end{array}start_ARRAY start_ROW start_CELL roman_lim start_POSTSUBSCRIPT italic_x → 0 start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT end_POSTSUBSCRIPT divide start_ARG italic_f ( italic_x ) end_ARG start_ARG italic_x end_ARG = 1 > 0 end_CELL start_CELL end_CELL start_CELL & end_CELL start_CELL end_CELL start_CELL roman_lim start_POSTSUBSCRIPT italic_x → 0 start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT end_POSTSUBSCRIPT divide start_ARG italic_f ( italic_x ) - italic_x end_ARG start_ARG italic_x start_POSTSUPERSCRIPT italic_τ + 1 end_POSTSUPERSCRIPT end_ARG = italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT < 0 , end_CELL end_ROW end_ARRAY we see in fact that 0<f⁢(x)<x0𝑓𝑥𝑥0<f(x)<x0 < italic_f ( italic_x ) < italic_x for all 0<x<ε0𝑥𝜀0<x<\varepsilon0 < italic_x < italic_ε. Given an initial value 0<x0<ε0subscript𝑥0𝜀0<x_{0}<\varepsilon0 < italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT < italic_ε, define a sequence xn=f⁢(xn−1)subscript𝑥𝑛𝑓subscript𝑥𝑛1x_{n}=f(x_{n-1})italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT = italic_f ( italic_x start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT ) for n≥1𝑛1n\geq 1italic_n ≥ 1. We clearly have 0<xn<xn−10subscript𝑥𝑛subscript𝑥𝑛10<x_{n}<x_{n-1}0 < italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT < italic_x start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT and thus {xn}subscript𝑥𝑛\{x_{n}\}{ italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } is monotone decreasing & bounded from below. It follows that L=limn→∞xn𝐿subscript→𝑛subscript𝑥𝑛L=\lim_{n\rightarrow\infty}x_{n}italic_L = roman_lim start_POSTSUBSCRIPT italic_n → ∞ end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT exists and 0≤L<ε0𝐿𝜀0\leq L<\varepsilon0 ≤ italic_L < italic_ε. Suppose that L>0𝐿0L>0italic_L > 0. By definition of xnsubscript𝑥𝑛x_{n}italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT, we must have L=f⁢(L)𝐿𝑓𝐿L=f(L)italic_L = italic_f ( italic_L ), which contradicts f⁢(L)≠L𝑓𝐿𝐿f(L)\neq Litalic_f ( italic_L ) ≠ italic_L. Therefore L=0𝐿0L=0italic_L = 0. Let (−t)k=(−t)⁢(−t−1)⁢(−t−2)⁢⋯⁢(−t−k+1)subscript𝑡𝑘𝑡𝑡1𝑡2⋯𝑡𝑘1(-t)_{k}=(-t)(-t-1)(-t-2)\cdots(-t-k+1)( - italic_t ) start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT = ( - italic_t ) ( - italic_t - 1 ) ( - italic_t - 2 ) ⋯ ( - italic_t - italic_k + 1 ) for any integer k≥1𝑘1k\geq 1italic_k ≥ 1 and define ∑(k,m,s)subscript𝑘𝑚𝑠{\textstyle\sum\nolimits_{(k,m,s)}}∑ start_POSTSUBSCRIPT ( italic_k , italic_m , italic_s ) end_POSTSUBSCRIPT to be the sum over all nonnegative integers n1,n2,…,nksubscript𝑛1subscript𝑛2…subscript𝑛𝑘n_{1},n_{2},\ldots,n_{k}italic_n start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_n start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , … , italic_n start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT such that n1+2⁢n2+3⁢n3+⋯+k⁢nk=mandn1+n2+n3+⋯+nk=m−s.subscript𝑛12subscript𝑛23subscript𝑛3⋯𝑘subscript𝑛𝑘𝑚missing-subexpressionandmissing-subexpressionsubscript𝑛1subscript𝑛2subscript𝑛3⋯subscript𝑛𝑘𝑚𝑠\begin{array}[c]{ccccc}n_{1}+2n_{2}+3n_{3}+\cdots+k\,n_{k}=m&&\text{and}&&n_{1% }+n_{2}+n_{3}+\cdots+n_{k}=m-s.\end{array}start_ARRAY start_ROW start_CELL italic_n start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + 2 italic_n start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT + 3 italic_n start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT + ⋯ + italic_k italic_n start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT = italic_m end_CELL start_CELL end_CELL start_CELL and end_CELL start_CELL end_CELL start_CELL italic_n start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + italic_n start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT + italic_n start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT + ⋯ + italic_n start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT = italic_m - italic_s . end_CELL end_ROW end_ARRAY This notation will be useful in the following section."
https://arxiv.org/html/2411.01486v1,The Gap Between Greedy Algorithm and Minimum Multiplicative Spanner,"Given any undirected graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) with n𝑛nitalic_n vertices, if its subgraph H⊆G𝐻𝐺H\subseteq Gitalic_H ⊆ italic_G satisfies 𝖽𝗂𝗌𝗍H⁢(u,v)≤k⋅𝖽𝗂𝗌𝗍G⁢(u,v)subscript𝖽𝗂𝗌𝗍𝐻𝑢𝑣⋅𝑘subscript𝖽𝗂𝗌𝗍𝐺𝑢𝑣\mathsf{dist}_{H}(u,v)\leq k\cdot\mathsf{dist}_{G}(u,v)sansserif_dist start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_u , italic_v ) ≤ italic_k ⋅ sansserif_dist start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u , italic_v ) for any two vertices (u,v)∈V×V𝑢𝑣𝑉𝑉(u,v)\in V\times V( italic_u , italic_v ) ∈ italic_V × italic_V, we call H𝐻Hitalic_H a k𝑘kitalic_k-spanner of G𝐺Gitalic_G. The greedy algorithm adapted from Kruskal’s algorithm is an efficient and folklore way to produce a k𝑘kitalic_k-spanner with girth at least k+2𝑘2k+2italic_k + 2. The greedy algorithm has shown to be ‘existentially optimal’, while it’s not ‘universally optimal’ for any constant k𝑘kitalic_k. Here, ‘universal optimality’ means an algorithm can produce the smallest k𝑘kitalic_k-spanner H𝐻Hitalic_H given any n𝑛nitalic_n-vertex input graph G𝐺Gitalic_G.However, how well the greedy algorithm works compared to ‘universal optimality’ is still unclear for superconstant k:=k⁢(n)assign𝑘𝑘𝑛k:=k(n)italic_k := italic_k ( italic_n ). In this paper, we aim to give a new and fine-grained analysis of this problem in undirected unweighted graph setting. Specifically, we show some bounds on this problem including the following twoOn the negative side, when k<13⁢n−O⁢(1)𝑘13𝑛𝑂1k<\frac{1}{3}n-O(1)italic_k < divide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n - italic_O ( 1 ), the greedy algorithm is not ‘universally optimal’.On the positive side, when k>23⁢n+O⁢(1)𝑘23𝑛𝑂1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ), the greedy algorithm is ‘universally optimal’.We also introduce an appropriate notion for ‘approximately universal optimality’. An algorithm is (α,β)𝛼𝛽(\alpha,\beta)( italic_α , italic_β )-universally optimal iff given any n𝑛nitalic_n-vertex input graph G𝐺Gitalic_G, it can produce a k𝑘kitalic_k-spanner H𝐻Hitalic_H of G𝐺Gitalic_G with size |H|≤n+α⁢(|H∗|−n)+β𝐻𝑛𝛼superscript𝐻𝑛𝛽|H|\leq n+\alpha(|H^{*}|-n)+\beta| italic_H | ≤ italic_n + italic_α ( | italic_H start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT | - italic_n ) + italic_β, where H∗superscript𝐻H^{*}italic_H start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT is the smallest k𝑘kitalic_k-spanner of G𝐺Gitalic_G. We show the following positive bounds.When k>47⁢n+O⁢(1)𝑘47𝑛𝑂1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ), the greedy algorithm is (2,O⁢(1))2𝑂1(2,O(1))( 2 , italic_O ( 1 ) )-universally optimal.When k>1223⁢n+O⁢(1)𝑘1223𝑛𝑂1k>\frac{12}{23}n+O(1)italic_k > divide start_ARG 12 end_ARG start_ARG 23 end_ARG italic_n + italic_O ( 1 ), the greedy algorithm is (18,O⁢(1))18𝑂1(18,O(1))( 18 , italic_O ( 1 ) )-universally optimal.When k>12⁢n+O⁢(1)𝑘12𝑛𝑂1k>\frac{1}{2}n+O(1)italic_k > divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_n + italic_O ( 1 ), the greedy algorithm is (32,O⁢(1))32𝑂1(32,O(1))( 32 , italic_O ( 1 ) )-universally optimal.All our proofs are constructive building on new structural analysis on spanners. We give some ideas about how to break small cycles in a spanner to increase the girth. These ideas may help us to understand the relation between girth and spanners.","A spanner of a graph is a subgraph that approximately preserves distances between all vertex pairs in the original graph. This notion was introduced by [PS89] and widely used in many areas such as graph algorithms [CKL+22, DJWW22], distributed networks [Awe85, BCLR86] and chip design [CKR+91, CKR+92]. In most applications, people aim to construct spanners as sparse as possible. The sparsity is measured by the number of edges in the spanner. In this paper, we will focus on multiplicative spanners for undirected unweighted graphs defined below. Unless otherwise stated, all graphs in this paper are undirected unweighted graphs. Definition 1.1. Given k:=k⁢(n)assign𝑘𝑘𝑛k:=k(n)italic_k := italic_k ( italic_n ) and an undirected unweighted graph G:=(V,E)assign𝐺𝑉𝐸G:=(V,E)italic_G := ( italic_V , italic_E ) with n𝑛nitalic_n vertices, a k𝑘kitalic_k-spanner of G𝐺Gitalic_G is a subgraph H=(V,E′),E′⊆Eformulae-sequence𝐻𝑉superscript𝐸′superscript𝐸′𝐸H=(V,E^{\prime}),E^{\prime}\subseteq Eitalic_H = ( italic_V , italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT ) , italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT ⊆ italic_E of G𝐺Gitalic_G such that for any vertex pair (u,v)∈V×V𝑢𝑣𝑉𝑉(u,v)\in V\times V( italic_u , italic_v ) ∈ italic_V × italic_V, there is 𝖽𝗂𝗌𝗍H⁢(u,v)≤k⋅𝖽𝗂𝗌𝗍G⁢(u,v)subscript𝖽𝗂𝗌𝗍𝐻𝑢𝑣⋅𝑘subscript𝖽𝗂𝗌𝗍𝐺𝑢𝑣\mathsf{dist}_{H}(u,v)\leq k\cdot\mathsf{dist}_{G}(u,v)sansserif_dist start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_u , italic_v ) ≤ italic_k ⋅ sansserif_dist start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u , italic_v ). We call k𝑘kitalic_k the stretch of H𝐻Hitalic_H. One of the simplest and most widely-used spanner construction algorithms is the greedy algorithm introduced by [ADD+93]. It is adapted from Kruskal’s algorithm for computing the minimum spanning tree. In undirected unweighted settings, the greedy algorithm runs like this: Given any input graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) and stretch k𝑘kitalic_k, we first choose an arbitrary total order σ𝜎\sigmaitalic_σ on its edges, denoted by σ⁢(E)=(e1<e2<⋯<em)𝜎𝐸subscript𝑒1subscript𝑒2⋯subscript𝑒𝑚\sigma(E)=(e_{1}<e_{2}<\dots<e_{m})italic_σ ( italic_E ) = ( italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT < italic_e start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < ⋯ < italic_e start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT ). Then, starting from empty subgraph H=(V,∅)𝐻𝑉H=(V,\varnothing)italic_H = ( italic_V , ∅ ), we proceed edges {ei}i∈[m]subscriptsubscript𝑒𝑖𝑖delimited-[]𝑚\{e_{i}\}_{i\in[m]}{ italic_e start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_i ∈ [ italic_m ] end_POSTSUBSCRIPT one by one. For each edge ei=(u,v)subscript𝑒𝑖𝑢𝑣e_{i}=(u,v)italic_e start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = ( italic_u , italic_v ), if 𝖽𝗂𝗌𝗍H⁢(u,v)>ksubscript𝖽𝗂𝗌𝗍𝐻𝑢𝑣𝑘\mathsf{dist}_{H}(u,v)>ksansserif_dist start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_u , italic_v ) > italic_k, we add eisubscript𝑒𝑖e_{i}italic_e start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT to edgeset of H𝐻Hitalic_H. Otherwise, we do nothing. After checking all m𝑚mitalic_m edges, we output the latest H𝐻Hitalic_H as the spanner. [ADD+93] proved the following fact about H𝐻Hitalic_H Proposition 1.2. The subgraph H𝐻Hitalic_H outputted by the greedy algorithm with input ⟨G,k⟩𝐺𝑘\langle G,k\rangle⟨ italic_G , italic_k ⟩ is a k𝑘kitalic_k-spanner of G𝐺Gitalic_G. Moreover, the girth of H𝐻Hitalic_H is at least k+2𝑘2k+2italic_k + 2. Proposition 1.2 shows that for any graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) with n𝑛nitalic_n vertices and k𝑘kitalic_k, we can use the greedy algorithm to compute one of its k𝑘kitalic_k-spanners with girth at least k+2𝑘2k+2italic_k + 2. A simple observation is that the backward direction also holds. Concretely, we have the following Proposition 1.3. Given any graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) with n𝑛nitalic_n vertices, stretch k𝑘kitalic_k and any of its k𝑘kitalic_k-spanner H𝐻Hitalic_H with girth at least k+2𝑘2k+2italic_k + 2, there exists an edge ordering σ𝜎\sigmaitalic_σ of E𝐸Eitalic_E such that the greedy algorithm outputs H𝐻Hitalic_H after running on σ𝜎\sigmaitalic_σ, with input ⟨G,k⟩𝐺𝑘\langle G,k\rangle⟨ italic_G , italic_k ⟩. Proof. Let H=(V,E′⊆E)𝐻𝑉superscript𝐸′𝐸H=(V,E^{\prime}\subseteq E)italic_H = ( italic_V , italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT ⊆ italic_E ). Consider the edge ordering σ𝜎\sigmaitalic_σ on E𝐸Eitalic_E such that all edges in E′superscript𝐸′E^{\prime}italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT appear earlier in σ𝜎\sigmaitalic_σ than any edge in E\E′\𝐸superscript𝐸′E\backslash E^{\prime}italic_E \ italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT. Let H′superscript𝐻′H^{\prime}italic_H start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT be the spanner outputted by the greedy algorithm running on σ𝜎\sigmaitalic_σ. Since we first proceed with edges in E′superscript𝐸′E^{\prime}italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT, all edges in E′superscript𝐸′E^{\prime}italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT will be in H′superscript𝐻′H^{\prime}italic_H start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT by the girth assumption. For any edge e=(u,v)∈E\E′𝑒𝑢𝑣\𝐸superscript𝐸′e=(u,v)\in E\backslash E^{\prime}italic_e = ( italic_u , italic_v ) ∈ italic_E \ italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT, since H𝐻Hitalic_H is a k𝑘kitalic_k-spanner of G𝐺Gitalic_G, there must be 𝖽𝗂𝗌𝗍H⁢(u,v)≤ksubscript𝖽𝗂𝗌𝗍𝐻𝑢𝑣𝑘\mathsf{dist}_{H}(u,v)\leq ksansserif_dist start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_u , italic_v ) ≤ italic_k, and therefore e𝑒eitalic_e won’t be added in H′superscript𝐻′H^{\prime}italic_H start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT after all edges in E′superscript𝐸′E^{\prime}italic_E start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT have been added. We conclude H′=Hsuperscript𝐻′𝐻H^{\prime}=Hitalic_H start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT = italic_H. ∎ Proposition 1.3 shows that: Given ⟨G=(V,E),k⟩delimited-⟨⟩𝐺𝑉𝐸𝑘\langle G=(V,E),k\rangle⟨ italic_G = ( italic_V , italic_E ) , italic_k ⟩, the set of subgraphs the greedy algorithm can output (by choosing arbitrary edge ordering) is exactly the set of k𝑘kitalic_k-spanners with girth at least k+2𝑘2k+2italic_k + 2. By the Moore bound [AHL02], all graphs H𝐻Hitalic_H with girth at least k+2𝑘2k+2italic_k + 2 and n𝑛nitalic_n vertices have at most m=O⁢(n1+2/k)𝑚𝑂superscript𝑛12𝑘m=O(n^{1+2/k})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 1 + 2 / italic_k end_POSTSUPERSCRIPT ) edges. Therefore, we can get a size upper bound of k𝑘kitalic_k-spanners possibly outputted by the greedy algorithm. There are also papers studying this upper bound on weighted graph setting [ADD+93, CDNS95, ENS14, Bod24]. Then, a natural question arises: How large is the gap between the minimum (optimal) spanners and spanners outputted by the greedy algorithm? Here, the minimum k𝑘kitalic_k-spanner of a graph G𝐺Gitalic_G is its k𝑘kitalic_k-spanner with the fewest edges. In a seminal work [FS20], it is shown that the greedy algorithm is existentially optimal. Namely, for any n,k𝑛𝑘n,kitalic_n , italic_k, they show that there exists an n𝑛nitalic_n-vertex graph G𝐺Gitalic_G and its minimum k𝑘kitalic_k-spanner H∗superscript𝐻H^{*}italic_H start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT such that any k𝑘kitalic_k-spanner H𝐻Hitalic_H outputted by the greedy algorithm running on any n𝑛nitalic_n-vertex input graph is no larger than H∗superscript𝐻H^{*}italic_H start_POSTSUPERSCRIPT ∗ end_POSTSUPERSCRIPT. A more classical and difficult notion is universally optimal. It requires the greedy algorithm to output a minimum k𝑘kitalic_k-spanner for any n𝑛nitalic_n-vertex graph. However, [FS20] also shows that for many parameter settings (n,k)𝑛𝑘(n,k)( italic_n , italic_k ), the greedy algorithm for weighted graphs is ‘far from’ universally optimal on stretch k𝑘kitalic_k and n𝑛nitalic_n-vertex graphs. It means that the greedy algorithm cannot be universally optimal on general parameters. On the other hand, there is still hope that the greedy algorithm is universally optimal on some specific parameters (n,k)𝑛𝑘(n,k)( italic_n , italic_k ). In fact, a simple observation is that when we set k=n−1𝑘𝑛1k=n-1italic_k = italic_n - 1, the k𝑘kitalic_k-spanners of n𝑛nitalic_n-vertex graphs are actually equivalent to their reachability preservers, and we can assert that the greedy algorithm is universally optimal on parameters (n,k=n−1)𝑛𝑘𝑛1(n,k=n-1)( italic_n , italic_k = italic_n - 1 ) since reachability preservers are just spanning trees, which can be outputted by the greedy algorithm. It is natural to ask: for what parameters (n,k)𝑛𝑘(n,k)( italic_n , italic_k ), the greedy algorithm is universally optimal? That is, it outputs a minimum k𝑘kitalic_k-spanner for any n𝑛nitalic_n-vertex graphs. In this paper, we will try to partially answer this question. 1.1 Our Results We first define some terms, which is closely related to the performance of the greedy algorithm. Definition 1.4. For any pair (n,k)∈ℕ×ℕ𝑛𝑘ℕℕ(n,k)\in\mathbb{N}\times\mathbb{N}( italic_n , italic_k ) ∈ blackboard_N × blackboard_N, we define: (a) If for any n𝑛nitalic_n-vertex graph, all of its minimum k𝑘kitalic_k-spanners have girth at least k+2𝑘2k+2italic_k + 2, we call (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) an extremely good pair. (b) If for any n𝑛nitalic_n-vertex graph, at least one of its minimum k𝑘kitalic_k-spanners has girth at least k+2𝑘2k+2italic_k + 2, we call (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) a good pair. (c) If for any n𝑛nitalic_n-vertex graph G𝐺Gitalic_G, all of its minimum k𝑘kitalic_k-spanners can be outputted by the greedy algorithm on some edge ordering σ𝜎\sigmaitalic_σ, we say the greedy algorithm is completely universally optimal on (n,k)𝑛𝑘(n,k)( italic_n , italic_k ). (d) If for any n𝑛nitalic_n-vertex graph G𝐺Gitalic_G, there exists one of its minimum k𝑘kitalic_k-spanners that can be outputted by the greedy algorithm on some edge ordering σ𝜎\sigmaitalic_σ, we say the greedy algorithm is universally optimal on (n,k)𝑛𝑘(n,k)( italic_n , italic_k ). From Proposition 1.3, we can connect the above notions Corollary 1.5. For any pair (n,k)∈ℕ×ℕ𝑛𝑘ℕℕ(n,k)\in\mathbb{N}\times\mathbb{N}( italic_n , italic_k ) ∈ blackboard_N × blackboard_N, we have: If (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is extremely good, then the greedy algorithm is completely universal optimal on (n,k)𝑛𝑘(n,k)( italic_n , italic_k ). If (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is good, then the greedy algorithm is universally optimal on (n,k)𝑛𝑘(n,k)( italic_n , italic_k ). By Corollary 1.5, if we want to argue (completely) universal optimality on specific (n,k)𝑛𝑘(n,k)( italic_n , italic_k ), it suffices to identify the category of (n,k)𝑛𝑘(n,k)( italic_n , italic_k ): extremely good, good or ‘not even good’. Lower Bound First, we give a lower (negative) bound. It asserts that if k𝑘kitalic_k is too small compared to n𝑛nitalic_n, then (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is not even a good pair. Theorem 1.6. For every sufficiently large n𝑛nitalic_n and O⁢(1)<k<13⁢n−O⁢(1)𝑂1𝑘13𝑛𝑂1O(1)<k<\frac{1}{3}n-O(1)italic_O ( 1 ) < italic_k < divide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n - italic_O ( 1 ), (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is not a good pair. In fact, the proof of Theorem 1.6 is constructive: We can construct a graph G𝐺Gitalic_G with n𝑛nitalic_n vertices such that all of its minimum k𝑘kitalic_k-spanners have girth at most k+1𝑘1k+1italic_k + 1. Upper Bound Extremely good (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is the strongest definition, so we first find an upper (positive) bound about it. Our proof is algorithmic. Concretely, if k𝑘kitalic_k is large enough compared to n𝑛nitalic_n, for any k𝑘kitalic_k-spanner H𝐻Hitalic_H of n𝑛nitalic_n-vertex graph G𝐺Gitalic_G with girth at most k+1𝑘1k+1italic_k + 1, we can algorithmically remove some edges of H𝐻Hitalic_H such that H𝐻Hitalic_H is still a k𝑘kitalic_k-spanner after removal. Theorem 1.7. There is a deterministic polynomial time algorithm A𝐴Aitalic_A such that for all sufficiently large n𝑛nitalic_n and any k>34⁢n+O⁢(1)𝑘34𝑛𝑂1k>\frac{3}{4}n+O(1)italic_k > divide start_ARG 3 end_ARG start_ARG 4 end_ARG italic_n + italic_O ( 1 ), given any n𝑛nitalic_n-vertex graph G𝐺Gitalic_G and its k𝑘kitalic_k-spanner H⊆G𝐻𝐺H\subseteq Gitalic_H ⊆ italic_G, A⁢(G,H,k)𝐴𝐺𝐻𝑘A(G,H,k)italic_A ( italic_G , italic_H , italic_k ) outputs a subgraph R⊆H𝑅𝐻R\subseteq Hitalic_R ⊆ italic_H of H𝐻Hitalic_H such that R𝑅Ritalic_R is a k𝑘kitalic_k-spanner of G𝐺Gitalic_G and R𝑅Ritalic_R has girth at least k+2𝑘2k+2italic_k + 2. This immediately gives us an upper bound for extremely good (n,k)𝑛𝑘(n,k)( italic_n , italic_k ). Corollary 1.8. For all sufficiently large n𝑛nitalic_n and any k>34⁢n+O⁢(1)𝑘34𝑛𝑂1k>\frac{3}{4}n+O(1)italic_k > divide start_ARG 3 end_ARG start_ARG 4 end_ARG italic_n + italic_O ( 1 ), (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is extremely good. Proof. Suppose by contradiction that for some n𝑛nitalic_n-vertex G𝐺Gitalic_G, it has some minimum k𝑘kitalic_k-spanner H𝐻Hitalic_H with girth at most k+1𝑘1k+1italic_k + 1. Then by Theorem 1.7 we can construct its subgraph R⊆H𝑅𝐻R\subseteq Hitalic_R ⊆ italic_H such that R𝑅Ritalic_R is also a k𝑘kitalic_k-spanner of G𝐺Gitalic_G. Since R𝑅Ritalic_R has strictly larger girth than H𝐻Hitalic_H, R𝑅Ritalic_R must be a strictly smaller k𝑘kitalic_k-spanner of G𝐺Gitalic_G than H𝐻Hitalic_H, which contradicts the assumption that H𝐻Hitalic_H is the minimum k𝑘kitalic_k-spanner. ∎ We can also give an upper bound using a similar but more complicated algorithm for the weaker notion, good pair (n,k)𝑛𝑘(n,k)( italic_n , italic_k ). Theorem 1.9. There is a deterministic polynomial time algorithm A𝐴Aitalic_A such that for all sufficiently large n𝑛nitalic_n and any k>23⁢n+O⁢(1)𝑘23𝑛𝑂1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ), given any n𝑛nitalic_n-vertex graph G𝐺Gitalic_G and its k𝑘kitalic_k-spanner H=(V,EH)⊆G𝐻𝑉subscript𝐸𝐻𝐺H=(V,E_{H})\subseteq Gitalic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) ⊆ italic_G, A⁢(G,H,k)𝐴𝐺𝐻𝑘A(G,H,k)italic_A ( italic_G , italic_H , italic_k ) outputs R=(V,ER)⊆G𝑅𝑉subscript𝐸𝑅𝐺R=(V,E_{R})\subseteq Gitalic_R = ( italic_V , italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT ) ⊆ italic_G such that R𝑅Ritalic_R is a k𝑘kitalic_k-spanner of G𝐺Gitalic_G with girth at least k+2𝑘2k+2italic_k + 2. Moreover, the size of R𝑅Ritalic_R satisfies |ER|≤|EH|subscript𝐸𝑅subscript𝐸𝐻|E_{R}|\leq|E_{H}|| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | ≤ | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT |. Similarly, this immediately gives us an upper bound for good pairs Corollary 1.10. For all sufficiently large n𝑛nitalic_n and any k>23⁢n+O⁢(1)𝑘23𝑛𝑂1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ), (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is good. Approximately Universally Optimal By the previous results, we have known whether the greedy algorithm is universally optimal when k<13⁢n−O⁢(1)𝑘13𝑛𝑂1k<\frac{1}{3}n-O(1)italic_k < divide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n - italic_O ( 1 ) or k>23⁢n+O⁢(1)𝑘23𝑛𝑂1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ). It remains open when 13⁢n<k<23⁢n13𝑛𝑘23𝑛\frac{1}{3}n<k<\frac{2}{3}ndivide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n < italic_k < divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n. To understand the gap between the greedy algorithm and minimum spanners in this range, we need to introduce a notion called ‘approximately universally optimal’. Since we actually have a polynomial time algorithm in Theorem 1.9, we can consider slacking the size requirement of outputted spanner R𝑅Ritalic_R. Concretely, rather than requiring |ER|≤|EH|subscript𝐸𝑅subscript𝐸𝐻|E_{R}|\leq|E_{H}|| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | ≤ | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT |, we can output a k𝑘kitalic_k-spanner R𝑅Ritalic_R with girth at least k+2𝑘2k+2italic_k + 2 that is just ‘slightly’ larger than H𝐻Hitalic_H. In the classical approximation algorithm setting, we use a multiplicative slack factor. Formally, Suppose H𝐻Hitalic_H is the minimum k𝑘kitalic_k-spanner, if our outputted large-girth k𝑘kitalic_k-spanner R𝑅Ritalic_R has size |ER|≤α⁢|EH|subscript𝐸𝑅𝛼subscript𝐸𝐻|E_{R}|\leq\alpha|E_{H}|| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | ≤ italic_α | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT |, we can call it α𝛼\alphaitalic_α-optimal. However, there is a critical issue about the multiplicative approximation factor in our setting. Since we are considering the case when k>Ω⁢(n)𝑘Ω𝑛k>\Omega(n)italic_k > roman_Ω ( italic_n ), by Moore bound [AHL02] the classical greedy algorithm will always give a k𝑘kitalic_k-spanner with girth at least k+2𝑘2k+2italic_k + 2 and size at most n1+O⁢(1/n)=n+O⁢(log⁡n)superscript𝑛1𝑂1𝑛𝑛𝑂𝑛n^{1+O(1/n)}=n+O(\log{n})italic_n start_POSTSUPERSCRIPT 1 + italic_O ( 1 / italic_n ) end_POSTSUPERSCRIPT = italic_n + italic_O ( roman_log italic_n ). Since a trivial lower bound on the size of minimum k𝑘kitalic_k-spanner H=(V,EH)𝐻𝑉subscript𝐸𝐻H=(V,E_{H})italic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) of a connected graph is |EH|≥n−1subscript𝐸𝐻𝑛1|E_{H}|\geq n-1| italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | ≥ italic_n - 1, any constant multiplicative approximation factor α=1+Ω⁢(1)𝛼1Ω1\alpha=1+\Omega(1)italic_α = 1 + roman_Ω ( 1 ) will become trivial since the well-known greedy algorithm always outputs a k𝑘kitalic_k-spanner with size n+o⁢(n)≤(1+o⁢(1))⁢|EH|≤α⁢|EH|𝑛𝑜𝑛1𝑜1subscript𝐸𝐻𝛼subscript𝐸𝐻n+o(n)\leq(1+o(1))|E_{H}|\leq\alpha|E_{H}|italic_n + italic_o ( italic_n ) ≤ ( 1 + italic_o ( 1 ) ) | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | ≤ italic_α | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT |. These spanners are usually called ultrasparse spanners [Pet08, BEG+22]. Therefore, we must introduce a more refined notion of ‘approximation’. The first observation is that since different connected components are isolated when considering spanners, we can only focus on connected graphs without loss of generality. For any connected n𝑛nitalic_n-vertex graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) and its minimum k𝑘kitalic_k-spanner H=(V,EH)𝐻𝑉subscript𝐸𝐻H=(V,E_{H})italic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ), since |EH|≥n−1subscript𝐸𝐻𝑛1|E_{H}|\geq n-1| italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | ≥ italic_n - 1 is a trivial lower bound, we can use α=|ER|−n|EH|−n𝛼subscript𝐸𝑅𝑛subscript𝐸𝐻𝑛\alpha=\frac{|E_{R}|-n}{|E_{H}|-n}italic_α = divide start_ARG | italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | - italic_n end_ARG start_ARG | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | - italic_n end_ARG as a new definition for the approximation factor, where R=(V,ER)𝑅𝑉subscript𝐸𝑅R=(V,E_{R})italic_R = ( italic_V , italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT ) denotes the k𝑘kitalic_k-spanner of G𝐺Gitalic_G outputted by some approximation algorithm. Definition 1.11. For any pair (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) and constants α>1,β≥0formulae-sequence𝛼1𝛽0\alpha>1,\beta\geq 0italic_α > 1 , italic_β ≥ 0, if any n𝑛nitalic_n-vertex connected graph G=(V,E)𝐺𝑉𝐸G=(V,E)italic_G = ( italic_V , italic_E ) has a k𝑘kitalic_k-spanner H=(V,EH)𝐻𝑉subscript𝐸𝐻H=(V,E_{H})italic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) with girth at least k+2𝑘2k+2italic_k + 2 such that |EH|−n≤α⁢(𝖮𝖯𝖳−n)+βsubscript𝐸𝐻𝑛𝛼𝖮𝖯𝖳𝑛𝛽|E_{H}|-n\leq\alpha(\mathsf{OPT}-n)+\beta| italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | - italic_n ≤ italic_α ( sansserif_OPT - italic_n ) + italic_β, we call (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) an (α,β)𝛼𝛽(\alpha,\beta)( italic_α , italic_β )-approx good pair. Here 𝖮𝖯𝖳𝖮𝖯𝖳\mathsf{OPT}sansserif_OPT denotes the number of edges in any minimum k𝑘kitalic_k-spanner of G𝐺Gitalic_G. We can observe that the fact (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is (α,β)𝛼𝛽(\alpha,\beta)( italic_α , italic_β )-approx good is equivalent to ‘(α,β)𝛼𝛽(\alpha,\beta)( italic_α , italic_β )-approximately universal optimality’ of the greedy algorithm. Namely, the greedy algorithm is ‘(α,β)𝛼𝛽(\alpha,\beta)( italic_α , italic_β )-approximately universally optimal’ on (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) iff for any n𝑛nitalic_n-vertex graph G𝐺Gitalic_G, the greedy algorithm can output a (α,β)𝛼𝛽(\alpha,\beta)( italic_α , italic_β )-approximately minimum k𝑘kitalic_k-spanner of G𝐺Gitalic_G on some edge ordering σ𝜎\sigmaitalic_σ. Using the above definitions, we can try to understand the power of the greedy algorithm when 13⁢n≤k≤23⁢n13𝑛𝑘23𝑛\frac{1}{3}n\leq k\leq\frac{2}{3}ndivide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n ≤ italic_k ≤ divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n. The first bound is the following Theorem 1.12. There is a deterministic polynomial time algorithm A𝐴Aitalic_A such that for all sufficiently large n𝑛nitalic_n and any k>47⁢n+O⁢(1)𝑘47𝑛𝑂1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ), given any n𝑛nitalic_n-vertex graph G𝐺Gitalic_G and its k𝑘kitalic_k-spanner H=(V,EH)⊆G𝐻𝑉subscript𝐸𝐻𝐺H=(V,E_{H})\subseteq Gitalic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) ⊆ italic_G, A⁢(G,H,k)𝐴𝐺𝐻𝑘A(G,H,k)italic_A ( italic_G , italic_H , italic_k ) outputs a k𝑘kitalic_k-spanner R=(V,ER)𝑅𝑉subscript𝐸𝑅R=(V,E_{R})italic_R = ( italic_V , italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT ) of G𝐺Gitalic_G with girth at least k+2𝑘2k+2italic_k + 2. Moreover, the size of R𝑅Ritalic_R satisfies |ER|−n≤2⁢(E⁢(H)−n)+1subscript𝐸𝑅𝑛2𝐸𝐻𝑛1|E_{R}|-n\leq 2(E(H)-n)+1| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | - italic_n ≤ 2 ( italic_E ( italic_H ) - italic_n ) + 1. As Corollaries 1.5 and 1.8, we can use Theorem 1.12 to derive the following Corollary 1.13. For all sufficiently large n𝑛nitalic_n and every k>47⁢n+O⁢(1)𝑘47𝑛𝑂1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ), (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is (2,O⁢(1))2𝑂1(2,O(1))( 2 , italic_O ( 1 ) )-approx good. We also generalize Theorem 1.12 (but use a less fine-grained way to analyze it) to smaller k𝑘kitalic_k but with a larger approximation factor as follows: Theorem 1.14. For t∈{1,2,3,4}𝑡1234t\in\{1,2,3,4\}italic_t ∈ { 1 , 2 , 3 , 4 }, there is a deterministic polynomial time algorithm A𝐴Aitalic_A such that for all sufficiently large n𝑛nitalic_n and any k>4⁢t9⁢t−4⁢n+O⁢(1)𝑘4𝑡9𝑡4𝑛𝑂1k>\frac{4t}{9t-4}n+O(1)italic_k > divide start_ARG 4 italic_t end_ARG start_ARG 9 italic_t - 4 end_ARG italic_n + italic_O ( 1 ), given any n𝑛nitalic_n-vertex graph G𝐺Gitalic_G and its k𝑘kitalic_k-spanner H=(V,EH)⊆G𝐻𝑉subscript𝐸𝐻𝐺H=(V,E_{H})\subseteq Gitalic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) ⊆ italic_G, A⁢(G,H,k)𝐴𝐺𝐻𝑘A(G,H,k)italic_A ( italic_G , italic_H , italic_k ) outputs a k𝑘kitalic_k-spanner R=(V,ER)𝑅𝑉subscript𝐸𝑅R=(V,E_{R})italic_R = ( italic_V , italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT ) of G𝐺Gitalic_G with girth at least k+2𝑘2k+2italic_k + 2. Moreover, the size of R𝑅Ritalic_R satisfies |ER|−n≤2⁢t2⁢(E⁢(H)−n)+2⁢t2subscript𝐸𝑅𝑛2superscript𝑡2𝐸𝐻𝑛2superscript𝑡2|E_{R}|-n\leq 2t^{2}(E(H)-n)+2t^{2}| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | - italic_n ≤ 2 italic_t start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_E ( italic_H ) - italic_n ) + 2 italic_t start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. When t=2𝑡2t=2italic_t = 2, the requirement for k𝑘kitalic_k is just k>47⁢n+O⁢(1)𝑘47𝑛𝑂1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ) which is the same as Theorem 1.12, but the approximation factor 2⁢t2=82superscript𝑡282t^{2}=82 italic_t start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = 8 is worse. Theorem 1.14 is useful when t={3,4}𝑡34t=\{3,4\}italic_t = { 3 , 4 }, which gives us k>1223⁢n+O⁢(1)𝑘1223𝑛𝑂1k>\frac{12}{23}n+O(1)italic_k > divide start_ARG 12 end_ARG start_ARG 23 end_ARG italic_n + italic_O ( 1 ) and k>12⁢n+O⁢(1)𝑘12𝑛𝑂1k>\frac{1}{2}n+O(1)italic_k > divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_n + italic_O ( 1 ) bounds respectively. In fact, Theorem 1.14 is a ‘bucket-decomposition’ generalized version of Theorem 1.12, and t𝑡titalic_t is a decomposition parameter that can be set to any positive integer. However, setting t≥5𝑡5t\geq 5italic_t ≥ 5 cannot derive new approximation bounds so larger t𝑡titalic_t is useless in the current technique. We give a detailed explanation in Remark 4.8. Corollary 1.15. For t∈{1,2,3,4}𝑡1234t\in\{1,2,3,4\}italic_t ∈ { 1 , 2 , 3 , 4 }, for all sufficiently large n𝑛nitalic_n and any k>4⁢t9⁢t−4⁢n+O⁢(1)𝑘4𝑡9𝑡4𝑛𝑂1k>\frac{4t}{9t-4}n+O(1)italic_k > divide start_ARG 4 italic_t end_ARG start_ARG 9 italic_t - 4 end_ARG italic_n + italic_O ( 1 ), (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) is (2⁢t2,O⁢(1))2superscript𝑡2𝑂1(2t^{2},O(1))( 2 italic_t start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , italic_O ( 1 ) )-approx good. Remark 1.16. All proofs of our upper (positive) bounds are ‘partially constructive’. Informally, Theorems 1.7, 1.9, 1.12 and 1.14 all provide algorithms to enlarge the girth of an input k𝑘kitalic_k-spanner H𝐻Hitalic_H to at least k+2𝑘2k+2italic_k + 2, and guarantee the outputted graph is still a k𝑘kitalic_k-spanner whose size won’t become too large compared to the size of H𝐻Hitalic_H. These algorithms can be appended behind some other good algorithms that don’t care about girth as ‘girth enlarger’. For example, suppose there is an algorithm B𝐵Bitalic_B that constructs very sparse spanners but doesn’t guarantee the girth of the outputted spanner, we can feed its output spanner into our algorithms A𝐴Aitalic_A such that the final spanner outputted by A𝐴Aitalic_A has large girth, and at the same time it is only ‘slightly’ larger than B𝐵Bitalic_B’s original output. Figure 1: Different Bounds To the best of our knowledge, our proofs are built upon new ideas of analyzing the structure of spanners using the girth information. We hope these ideas could help us to understand the relation between girth and sparse spanners. Figure 1 is a summary of our main results. 1.2 Notations For any n∈ℕ𝑛ℕn\in\mathbb{N}italic_n ∈ blackboard_N, let [n]={1,…,n}delimited-[]𝑛1…𝑛[n]=\{1,\dots,n\}[ italic_n ] = { 1 , … , italic_n }. For any undirected graph G𝐺Gitalic_G, we use VGsubscript𝑉𝐺V_{G}italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT and EGsubscript𝐸𝐺E_{G}italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT to denote its vertex-set and edge-set unless otherwise stated. For any (u,v)∈VG×VG𝑢𝑣subscript𝑉𝐺subscript𝑉𝐺(u,v)\in V_{G}\times V_{G}( italic_u , italic_v ) ∈ italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT × italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT, we use 𝖽𝗂𝗌𝗍G⁢(u,v)subscript𝖽𝗂𝗌𝗍𝐺𝑢𝑣\mathsf{dist}_{G}(u,v)sansserif_dist start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u , italic_v ) to denote the length of the shortest path between u,v𝑢𝑣u,vitalic_u , italic_v in G𝐺Gitalic_G. For any vertex-subset U⊆VG𝑈subscript𝑉𝐺U\subseteq V_{G}italic_U ⊆ italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT, we use G⁢[U]𝐺delimited-[]𝑈G[U]italic_G [ italic_U ] to denote the induced subgraph of G𝐺Gitalic_G on U𝑈Uitalic_U. For any two graphs G,H𝐺𝐻G,Hitalic_G , italic_H, we use G\H\𝐺𝐻G\backslash Hitalic_G \ italic_H to denote the graph (VG\VH,EG\EH)\subscript𝑉𝐺subscript𝑉𝐻\subscript𝐸𝐺subscript𝐸𝐻(V_{G}\backslash V_{H},E_{G}\backslash E_{H})( italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT \ italic_V start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT , italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT \ italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ). We can similarly define G\VH:=(VG\VH,EG)assign\𝐺subscript𝑉𝐻\subscript𝑉𝐺subscript𝑉𝐻subscript𝐸𝐺G\backslash V_{H}:=(V_{G}\backslash V_{H},E_{G})italic_G \ italic_V start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT := ( italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT \ italic_V start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT , italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) and G\EH:=(VG,EG\EH)assign\𝐺subscript𝐸𝐻subscript𝑉𝐺\subscript𝐸𝐺subscript𝐸𝐻G\backslash E_{H}:=(V_{G},E_{G}\backslash E_{H})italic_G \ italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT := ( italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT \ italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ). For a simple path p𝑝pitalic_p and any two vertices s,t∈Vp𝑠𝑡subscript𝑉𝑝s,t\in V_{p}italic_s , italic_t ∈ italic_V start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT, we use p⁢[s,t]𝑝𝑠𝑡p[s,t]italic_p [ italic_s , italic_t ] to denote the sub-path between s𝑠sitalic_s and t𝑡titalic_t. p⁢[s,t),p⁢(s,t],p⁢(s,t)𝑝𝑠𝑡𝑝𝑠𝑡𝑝𝑠𝑡p[s,t),p(s,t],p(s,t)italic_p [ italic_s , italic_t ) , italic_p ( italic_s , italic_t ] , italic_p ( italic_s , italic_t ) are similarly defined. We use S⁢CG𝑆subscript𝐶𝐺SC_{G}italic_S italic_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT to denote an arbitrary smallest cycle of G𝐺Gitalic_G, and LG:=|VS⁢CG|assignsubscript𝐿𝐺subscript𝑉𝑆subscript𝐶𝐺L_{G}:=|V_{SC_{G}}|italic_L start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT := | italic_V start_POSTSUBSCRIPT italic_S italic_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT end_POSTSUBSCRIPT |. 1.3 Paper Organization and Overview In Section 2, we give a brief illustration of the negative lower bound regarding the greedy algorithm as stated in Theorem 1.6. Then, in Section 3 we give detailed proofs of positive upper bounds Theorem 1.7 and Theorem 1.9. Finally, we will prove Theorem 1.12 and Theorem 1.14 in Section 4. Let’s give an overview of our proof strategy used in establishing positive upper bounds. Let H𝐻Hitalic_H be a minimum (in fact arbitrary) k𝑘kitalic_k-spanner of G𝐺Gitalic_G and S⁢CH𝑆subscript𝐶𝐻SC_{H}italic_S italic_C start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT denote its smallest cycle. Let LH=|VS⁢CH|subscript𝐿𝐻subscript𝑉𝑆subscript𝐶𝐻L_{H}=|V_{SC_{H}}|italic_L start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT = | italic_V start_POSTSUBSCRIPT italic_S italic_C start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUBSCRIPT |. If LH≥k+2subscript𝐿𝐻𝑘2L_{H}\geq k+2italic_L start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ≥ italic_k + 2, our girth lower bound has been satisfied and we are done. Otherwise, we want to find a cycle-edge e∈ES⁢CH𝑒subscript𝐸𝑆subscript𝐶𝐻e\in E_{SC_{H}}italic_e ∈ italic_E start_POSTSUBSCRIPT italic_S italic_C start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUBSCRIPT and at most m𝑚mitalic_m edges e1,…,em∈EGsubscript𝑒1…subscript𝑒𝑚subscript𝐸𝐺e_{1},\dots,e_{m}\in E_{G}italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_e start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT ∈ italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT, such that we can break the smallest cycle S⁢CH𝑆subscript𝐶𝐻SC_{H}italic_S italic_C start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT by removing e𝑒eitalic_e, and then preserve the property of k𝑘kitalic_k-spanner by adding these m𝑚mitalic_m edges. Formally, let H′superscript𝐻′H^{\prime}italic_H start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT denote (H\{e})∪{e1,…,em}\𝐻𝑒subscript𝑒1…subscript𝑒𝑚\left(H\backslash\{e\}\right)\cup\{e_{1},\dots,e_{m}\}( italic_H \ { italic_e } ) ∪ { italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_e start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT }, we want • H′superscript𝐻′H^{\prime}italic_H start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT is a k𝑘kitalic_k-spanner. • e1,…,emsubscript𝑒1…subscript𝑒𝑚e_{1},\dots,e_{m}italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_e start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT don’t create any new cycle with length at most k+1𝑘1k+1italic_k + 1 in H′superscript𝐻′H^{\prime}italic_H start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT compared to H𝐻Hitalic_H. If for some pair (n,k)𝑛𝑘(n,k)( italic_n , italic_k ), the above condition can be met, then the greedy algorithm is (m,O⁢(m))𝑚𝑂𝑚(m,O(m))( italic_m , italic_O ( italic_m ) )-Approximately universally optimal on (n,k)𝑛𝑘(n,k)( italic_n , italic_k ). (See the proof of Theorem 4.4 for details.) Therefore, our goal is to prove the above statement in different m𝑚mitalic_m and (n,k)𝑛𝑘(n,k)( italic_n , italic_k ) settings. First, in Section 3.1 we will show that as long as LH>2⁢(n−k)subscript𝐿𝐻2𝑛𝑘L_{H}>2(n-k)italic_L start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT > 2 ( italic_n - italic_k ), we can achieve m=0𝑚0m=0italic_m = 0 regardless. It suffices to consider the case when LH≤2⁢(n−k)subscript𝐿𝐻2𝑛𝑘L_{H}\leq 2(n-k)italic_L start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ≤ 2 ( italic_n - italic_k ): In Section 3.2, we give a common structural framework required in all following proofs. Then, we work on different parameter settings as follows • In Section 3.3, we will prove when k>34⁢n+O⁢(1)𝑘34𝑛𝑂1k>\frac{3}{4}n+O(1)italic_k > divide start_ARG 3 end_ARG start_ARG 4 end_ARG italic_n + italic_O ( 1 ), we can achieve m=0𝑚0m=0italic_m = 0, and derive Theorem 1.7. • In Section 3.4, we will prove when k>23⁢n+O⁢(1)𝑘23𝑛𝑂1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ), we can achieve m=1𝑚1m=1italic_m = 1, which confirms Theorem 1.9. • In Section 4.1, we will prove when k>47⁢n+O⁢(1)𝑘47𝑛𝑂1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ), we can achieve m=2𝑚2m=2italic_m = 2 and derive Theorem 1.12. The proof strategy is a generalization of Section 3.4 • In Section 4.2, we will prove when k>1223⁢n+O⁢(1)𝑘1223𝑛𝑂1k>\frac{12}{23}n+O(1)italic_k > divide start_ARG 12 end_ARG start_ARG 23 end_ARG italic_n + italic_O ( 1 ), we can achieve m=18𝑚18m=18italic_m = 18, and when k>12⁢n+O⁢(1)𝑘12𝑛𝑂1k>\frac{1}{2}n+O(1)italic_k > divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_n + italic_O ( 1 ), we can achieve m=32𝑚32m=32italic_m = 32. These two results follow from a ‘bucket-decomposition’ generalized version of Theorem 1.12."
https://arxiv.org/html/2411.01407v1,Reducing Data Fragmentation in Data Deduplication Systems via Partial Repetition and Coding,"Data deduplication, one of the key features of modern Big Data storage devices, is the process of removing replicas of data chunks stored by different users. Despite the importance of deduplication, several drawbacks of the method, such as storage robustness and file fragmentation, have not been previously analyzed from a theoretical point of view. Storage robustness pertains to ensuring that deduplicated data can be used to reconstruct the original files without service disruptions and data loss. Fragmentation pertains to the problems of placing deduplicated data chunks of different user files in a proximity-preserving linear order, since neighboring chunks of the same file may be stored in sectors far apart on the server. This work proposes a new theoretical model for data fragmentation and introduces novel graph- and coding-theoretic approaches for reducing fragmentation via limited duplication (repetition coding) and coded deduplication (e.g., linear coding). In addition to alleviating issues with fragmentation, limited duplication and coded deduplication can also serve the dual purpose of increasing the robusteness of the system design. The contributions of our work are three-fold. First, we describe a new model for file structures in the form of self-avoiding (simple) paths in specialized graphs. Second, we introduce several new metrics for measuring the fragmentation level in deduplication systems on graph-structured files, including the stretch metric that captures the worst-case “spread” of adjacent data chunks within a file when deduplicated and placed on the server; and, the jump metric that captures the worst-case number of times during the reconstruction process of a file that one has to change the readout location on the server. For the stretch metric, we establish a connection between the level of fragmentation and the bandwidth of the file-graph. In particular, we derive lower and upper bounds on degree of fragmentation and describe instances of the problem where repetition and coding reduce fragmentation. The key ideas behind our approach are graph folding and information-theoretic arguments coupled with graph algorithms such as matching. For the jump metric, we provide a new algorithm for computing the jump number of hierarchical data structures captured by trees. Third, we describe how controlled repetition and coded redundancy added after deduplication can ensure valuable trade-offs between the storage volume and the degree of fragmentation.","Data deduplication is a data management technique employed in modern large-scale data storage systems to increase storage efficiency by removing content replicas of different users [1, 2, 3, 4]. For example, cloud storage providers such as Microsoft and Dropbox, as well as intelligent data infrastructure companies such as NetApp, actively support deduplication schemes in their storage systems. A typical deduplication algorithm first splits the input files into smaller data subunits, referred to as “chunks” [5, 6, 7], then removes duplicate data chunks and proceeds to place the chunks on servers. For duplicate chunk identification, one typically uses hash values [5, 6, 7]. The chunk placement is based either on some predetermined protocol or the order of arrival of new chunks. After deduplication, each file is stored in ‘compressed’ form, involving a set of pointers explaining how to assemble it (e.g., a set of hash values pointing to the actual locations of the data chunks and labels indicating their order). During the file restoration phase, the server uses the compressed description to recreate files by retrieving chunks guided by the pointers. The trade-off between the chunk size and the length of the assembly instruction under various chunking strategies is an important practical system compression feature, addressed in [5]. Since the volume of the assembly instruction data is usually negligible compared to the actual user data, this consideration is irrelevant for protocol-level analyses of deduplication. Although deduplication algorithms provide significant storage savings, they introduce a number of readout issues, including data fragmentation [8] and data instability [9, 10]. Data fragmentation arises due to storing information chunks of a single file at multiple potentially distal locations, which slows down data retrieval and potentially creates problems with accessing large volumes of secondary, unwanted interspersing data. Deduplication instability, on the other hand, refers to the vulnerability to data loss (i.e., lack of robustness) of the file system when only one replica of each chunk is maintained. These problems are partly mitigated in practice by using caches and specialized chunk placements [11], as well as ‘incomplete deduplication’ protocols, where not all redundant chunks are removed but only a portion of them, dictated by their popularity [1, 2]. Despite the widespread use of deduplication and the many practical implementations of the method, little is known about the theoretical performance limits of such systems with regards to data fragmentation. Prior work [4] provided a mathematical analysis of the influence of deduplication on distributed storage codes, while [5] initiated an information-theoretic study of deduplication as a form of compression. Some other works [7, 6] focused on examining the influence of errors on chunking and deduplication. None of these contributions considered fragmentation problems or issues associated with partial deduplication and file retrieval robustness. Here, we initiate the first analytical study of the trade-off between storage redundancy and file fragmentation. The key features supporting our analysis are: a) A new model for files that share chunks in terms of self-avoiding (simple) paths/walks in what we call a chunk or file graph. In particular, we model the data as being either generated by a sparse Hamiltonian-path graph in which nodes represent chunks and nodes on connected paths correspond to files to be stored; or, as hierarchical structures whose chunks are organized on a tree. The Hamiltonian path requirement is used to both model a natural linear ordering of concatenated files and to simplify challenging analyses. Similarly, tree models are used to capture chunk organizations in omnipresent hierarchical data; b) Several new metrics for measuring the level of fragmentation, including a worst-case metric which examines the maximum stretch of allotted locations of adjacent data chunks (i.e., the stretch metric) and a metric that captures the worst-case number of times the location on a server needs to be changed to retrieve a file (i.e., the jump metric). Average-case metrics, although formally defined in this work will be examined elsewhere. Our main contributions are bounds on the worst-case fragmentation metrics and algorithms for chunk placements that produce provably good fragmentation results. Most importantly, we examine these key features of deduplication systems for the case of completely deduplicated files (for which the solution involves optimization over permutations, i.e., over the symmetric group), partially deduplicated files with data chunk repetitions (repetition-coded deduplication) and coded deduplication, in which the stored chunks may represent linear (or, in general nonlinear) combinations of systematic user chunks. The outlined analysis involves information-theoretic arguments but also strongly relies on results in graph theory pertaining to the graph bandwith and related concepts [12], as well as matchings in graphs. In the former context, we introduce graph folding which allows one to transfer the domain of the problem from graphs to functions. Additional ideas used in this context include graph factorization and concatenation of different permutations of the chunks, and results already established in the context of the related problem of graph bandwidth analysis [13]. We also describe a number of examples pertaining to deduplication systems in which one is either allowed to retain multiple copies of the same chunk or use coded chunks. In these settings, it is a priori clear that redundant chunks can help reduce fragmentation, since concatenating all files (e.g., not performing deduplication) results in no fragmentation. What is at this point completely unknown is how much redundancy is needed to reduce fragmentation to practically acceptable levels. Furthermore, repeated and/or coded chunks both increase the robustness of the system, which is desirable, but at the cost of increasing the storage overhead of the system. The work closest to our new study is the work that established ultimate performance limits of information retrieval with and without redundancy [14]. There, the questions were posed in a probabilistic context that does not include deduplication nor fragmentation models. Furthermore, information is modelled as arising from a Markovian grid or torus, by traversing a path whose length increases in an unbounded manner. The main objective of the work was to explore the expansion of the average walk lengths of 1-D retrieval versus 2-D retrieval approaches. The work also included an analysis of coding approaches that can aid in reducing the gap introduced by lowering the dimension of the data space. A more detailed description of this work, which is of independent interest, is provided in Section VII. The paper is organized as follows. Section II provides a review of deduplication approaches and introduces terms needed for our analysis and the problem formulations that follow. Section III describes the problem formulation(s), based on the description of the file and chunk store model and the metrics used to measure the fragmentation level. Results pertaining to fragmentation bounds and limits for uncoded, repetition- and linearly encoded chunk stores under the stretch metrics are discussed in Section V. This section also contains the description of our graph folding approach and pertinent bounds based on it. Similar results for the jump fragmentation metric are presented in Section VI. A collection of open problems is discussed in Section VIII."
https://arxiv.org/html/2411.01061v1,Cyclic ordering of split matroids,"There is a long list of open questions rooted in the same underlying problem: understanding the structure of bases or common bases of matroids. These conjectures suggest that matroids may possess much stronger structural properties than are currently known. One example is related to cyclic orderings of matroids. A rank-r𝑟ritalic_r matroid is called cyclically orderable if its ground set admits a cyclic ordering such that any interval of r𝑟ritalic_r consecutive elements forms a basis. In this paper, we show that if the ground set of a split matroid decomposes into pairwise disjoint bases, then it is cyclically orderable. This result answers a conjecture of Kajitani, Ueno, and Miyano in a special case, and also strengthens Gabow’s conjecture for this class of matroids. Our proof is algorithmic, hence it provides a procedure for determining a cyclic ordering in question using a polynomial number of independence oracle calls.Keywords: Cyclic ordering, Paving matroids, Sequential symmetric basis exchanges, Split matroids","Throughout the paper, we denote a matroid by M=(S,ℬ)𝑀𝑆ℬM=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ), where S𝑆Sitalic_S is a finite ground set and ℬℬ\mathcal{B}caligraphic_B is the family of bases, satisfying the so-called basis axioms: (B1) ∅∈ℬℬ\emptyset\in\mathcal{B}∅ ∈ caligraphic_B, and (B2) for any B1,B2∈ℬsubscript𝐵1subscript𝐵2ℬB_{1},B_{2}\in\mathcal{B}italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ∈ caligraphic_B and e∈B1−B2𝑒subscript𝐵1subscript𝐵2e\in B_{1}-B_{2}italic_e ∈ italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT - italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, there exists f∈B2−B1𝑓subscript𝐵2subscript𝐵1f\in B_{2}-B_{1}italic_f ∈ italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT such that B1−e+f∈ℬsubscript𝐵1𝑒𝑓ℬB_{1}-e+f\in\mathcal{B}italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT - italic_e + italic_f ∈ caligraphic_B. The latter property, called the basis exchange axiom, is one of the most fundamental tools in matroid theory. Nevertheless, it only provides a local characterization of the relationship between bases, which presents a significant stumbling block to further progress. A rank-r𝑟ritalic_r matroid M=(S,ℬ)𝑀𝑆ℬM=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) with |S|=n𝑆𝑛|S|=n| italic_S | = italic_n is cyclically orderable if there exists an ordering S=s1,…,sn𝑆subscript𝑠1…subscript𝑠𝑛S={s_{1},\dots,s_{n}}italic_S = italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_s start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT such that si,si+1,…,si+r−1∈ℬsubscript𝑠𝑖subscript𝑠𝑖1…subscript𝑠𝑖𝑟1ℬ{s_{i},s_{i+1},\dots,s_{i+r-1}}\in\mathcal{B}italic_s start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT , … , italic_s start_POSTSUBSCRIPT italic_i + italic_r - 1 end_POSTSUBSCRIPT ∈ caligraphic_B for every i∈[n]𝑖delimited-[]𝑛i\in[n]italic_i ∈ [ italic_n ], where indices are understood in a cyclic order. While studying the structure of symmetric exchanges in matroids, Gabow [12] formulated a beautiful conjecture, stating that every matroid whose ground set decomposes into two disjoint bases is cyclically orderable. This question was raised independently by Wiedemann [21] and by Cordovil and Moreira [6]. The conjecture makes a stronger claim: for a fixed partition, the cyclic ordering can be chosen such that the elements of the two bases in the partition form contiguous intervals. Conjecture 1 (Gabow). Let M=(S,ℬ)𝑀𝑆ℬM=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) be a matroid and S=B1∪B2𝑆subscript𝐵1subscript𝐵2S=B_{1}\cup B_{2}italic_S = italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ∪ italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT be a partition of the ground set into two disjoint bases. Then, M𝑀Mitalic_M has a cyclic ordering in which the elements of B1subscript𝐵1B_{1}italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and B2subscript𝐵2B_{2}italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT form intervals. It is not difficult to see that the statement holds for strongly base orderable matroids. The conjecture was settled for graphic matroids [14, 6, 21], sparse paving matroids [5], matroids of rank at most 4444 [16] and 5555 [15], split matroids [4], and regular matroids [2]. However, the existence of a cyclic ordering remains open in general, even without the constraint of the bases forming intervals. In [14], Kajitani, Ueno, and Miyano proposed a conjecture that would provide a full characterization of cyclically orderable matroids. A matroid M=(S,ℬ)𝑀𝑆ℬM=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) with rank function rMsubscript𝑟𝑀r_{M}italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT is called uniformly dense if |S|⋅rM⁢(X)≥rM⁢(S)⋅|X|⋅𝑆subscript𝑟𝑀𝑋⋅subscript𝑟𝑀𝑆𝑋|S|\cdot r_{M}(X)\geq r_{M}(S)\cdot|X|| italic_S | ⋅ italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_X ) ≥ italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_S ) ⋅ | italic_X | holds for every X⊆S𝑋𝑆X\subseteq Sitalic_X ⊆ italic_S. It is not difficult to see that a cyclically orderable matroid is necessarily uniformly dense as well, and the conjecture states that this condition is also sufficient. Conjecture 2 (Kajitani, Ueno, and Miyano). A matroid is cyclically orderable if and only if it is uniformly dense. Despite the fact that the conjecture would provide entirely new insights into the structure of matroids, very little progress has been made so far. Van den Heuvel and Thomassé [19] showed that the conjecture is true if |S|𝑆|S|| italic_S | and r⁢(S)𝑟𝑆r(S)italic_r ( italic_S ) are coprimes, and Bonin’s result [5] for sparse paving matroids remains true also in this more general setting. Recently, McGuinness [17] made a significant progress by verifying the conjecture for paving matroids. It is worth taking a moment to consider the interpretation of the uniformly dense property. By the matroid union theorem of Edmonds and Fulkerson [7], the ground set of a matroid M=(S,ℬ)𝑀𝑆ℬM=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) can be covered by k𝑘kitalic_k bases if and only if k⋅rM⁢(X)≥|X|⋅𝑘subscript𝑟𝑀𝑋𝑋k\cdot r_{M}(X)\geq|X|italic_k ⋅ italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_X ) ≥ | italic_X | holds for every X⊆S𝑋𝑆X\subseteq Sitalic_X ⊆ italic_S. Using this, a matroid is uniformly dense if and only if its ground set can be covered by ⌈|S|/rM⁢(S)⌉𝑆subscript𝑟𝑀𝑆\lceil|S|/r_{M}(S)\rceil⌈ | italic_S | / italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_S ) ⌉ bases. In other words, the ground set can be decomposed in ‘almost’ disjoint bases, where almost means that the total overlapping between distinct bases is bounded by rM⁢(S)−1subscript𝑟𝑀𝑆1r_{M}(S)-1italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_S ) - 1. In particular, any matroid whose ground set decomposes into pairwise disjoint bases is uniformly dense. This observation motivates the following strengthening of Gabow’s conjecture. Conjecture 3. Let M=(S,ℬ)𝑀𝑆ℬM=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) be a matroid and S=B1∪⋯∪Bk𝑆subscript𝐵1⋯subscript𝐵𝑘S=B_{1}\cup\dots\cup B_{k}italic_S = italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ∪ ⋯ ∪ italic_B start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT be a partition of the ground set into k𝑘kitalic_k pairwise disjoint bases. Then, M𝑀Mitalic_M has a cyclic ordering in which the elements of Bisubscript𝐵𝑖B_{i}italic_B start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT form an interval for each i∈[k]𝑖delimited-[]𝑘i\in[k]italic_i ∈ [ italic_k ]. To the best of our knowledge, Conjecture 3 has not been previously considered and remains open even for very restricted classes of matroids, such as strongly base orderable matroids. Our main contribution is proving the conjecture for the class of split matroids. Split matroids were first introduced by Joswig and Schröter [13] while studying matroid polytopes from a geometric point of view. Since then, this class of matroids has gained importance in many contexts, primarily due to the work of Ferroni and Schröter [8, 9, 10, 11]. Theorem 1. Conjecture 3 is true for split matroids. It is worth emphasizing that our proof is algorithmic, hence it provides a procedure for determining a cyclic ordering in question using a polynomial number of independence oracle calls. Remark 2. In fact, we prove a slightly stronger statement: in the cyclic ordering obtained, the bases B1,…,Bksubscript𝐵1…subscript𝐵𝑘B_{1},\dots,B_{k}italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … , italic_B start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT form intervals that follow each other in this order. The rest of the paper is organized as follows. Basic definitions and notation are introduced in Section 2. We prove Conjecture 3 for split matroids in Section 3. Finally, in Section 4, we give a list of related open questions and conjectures that are subject of future research."
https://arxiv.org/html/2411.00819v1,A Bellman-Ford algorithm for the path-length-weighted distance in graphs,"Consider a finite directed graph without cycles in which the arrows are weighted. We present an algorithm for the computation of a new distance, called path-length-weighted distance, which has proven useful for graph analysis in the context of fraud detection. The idea is that the new distance explicitly takes into account the size of the paths in the calculations. Thus, although our algorithm is based on arguments similar to those at work for the Bellman-Ford and Dijkstra methods, it is in fact essentially different. We lay out the appropriate framework for its computation, showing the constraints and requirements for its use, along with some illustrative examples.","Algorithms for calculating the (weighted) path-distance between vertices in a graph appeared in the middle of the 20th century, motivated by the growing interest of the time in the applications of mathematical analysis of graphs. The Bellman-Ford algorithm is the main reference of these early studies [2]. Dijkstra’s algorithm for solving the same problem appeared at about the same time [11], and differs from the other, being more efficient depending on the particular problem. After these original works, the growing interest in the subject (due to the numerous applications that graph theory has found in many fields) has given rise to a great deal of research on graph analysis, which often includes the study of these structures when considered as metric spaces. The idea of considering a graph also as a metric space goes back to the beginnings of the theory of graphs. Metric notions begin to appear explicitly in mathematical works in the second half of the last century. The main metric that was considered (and in a sense the only one until the latter part of the century) was the so-called path distance ([12, 15, 18]): for undirected and connected graphs, this metric evaluated between two vertices (nodes) is defined as the length of the shortest path between them (see for example [4, §.2.2.2]). One of the first advances in the metric analysis of graphs was the introduction of weights in the definition of the path distance, assigning weights to the individual paths connecting two consecutive nodes and calculating the infimum of the sum of these weights. Some recent papers on the subject using weighted distances that have inspired this paper are [8, 14]. As in the case of other notions of fundamental graph theory, the relevant theoretical ideas appeared together with research topics from other scientific fields, such as sociology [1, 16, 22]. The definition of different metrics and algorithms to compute them increased greatly in the last decade of the last century, often proposed by problems from other disciplines such as chemistry or crystallography (see [18, 19] and references therein). In this sense, there is a particular case that deserves attention, that is the resistance distance [9, 23]. Coming from some ideas in theoretical chemistry [19] and social network analysis [22], this definition turned out to be a useful tool in the study of molecular configurations in chemistry, although it has also been used in network analysis and other fields [24, 5, 3]. In general, metrics could play a relevant role when studying properties such as robustness (see for example the survey [21]; see also [20]). The interested reader can find more information on applications of metric graphs in the books [6, 4, 13]. In the same direction, in this paper we provide an algorithm to compute a new distance that also appeared in an applied context, in connection with the automatic analysis of fraud in economic networks (see [7]). In this paper, we show that this metric allows to consider vertices that are far away when the distance is measured using the path-distance, becoming close with respect to this metric. It is especially useful in the economic analysis of fraud in networks of companies, since very often the strategy used to hide such fraud is to use the path-distance. Technically, it is defined as a weighted metric, but by dividing the sums of weights appearing in the infimum that provides the value of the metric by a new term that depends on the number of steps involved in the summation. We will show that this change in the weighting process forces to radically change the algorithm to calculate it, since in this new case, longer paths could give shorter distances. However, in the present work we consider the case of acyclic directed graphs, in order to avoid restrictions that make it impossible to define a weighted path metric, since continuous passage through a cycle could always give a null value to the metric (which would mean that it is not a metric). There are other ways to avoid this (see for example Proposition 4.1 in [7]), but in our case we decided to compute the distance between vertices by restricting the set of possible paths in the infimum that gives it. The way to do this is to avoid cycles, and to consider directed graphs. As a result, what we compute is not a metric on the whole graph, but only a distance between two vertices chosen in it. Let us give now some basic definitions about graphs and metric spaces. Let us explain some concepts related to the general definition of what a metric is, which will adapted later to the graph theoretic framework. Let ℝ+superscriptℝ\mathbb{R}^{+}blackboard_R start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT be the non-negative real numbers. An (extended) quasi-metric on a set ΩΩ\Omegaroman_Ω is a function d:Ω×Ω→ℝ+∪{∞}:𝑑→ΩΩsuperscriptℝd:\Omega\times\Omega\to\mathbb{R}^{+}\cup\{\infty\}italic_d : roman_Ω × roman_Ω → blackboard_R start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT ∪ { ∞ } such that for all a,b,c∈Ω𝑎𝑏𝑐Ωa,b,c\in\Omegaitalic_a , italic_b , italic_c ∈ roman_Ω, the axioms (1) d⁢(a,b)=0=d⁢(b,a)𝑑𝑎𝑏0𝑑𝑏𝑎d(a,b)=0=d(b,a)italic_d ( italic_a , italic_b ) = 0 = italic_d ( italic_b , italic_a ) if and only if a=b,𝑎𝑏a=b,italic_a = italic_b , and (2) d⁢(a,b)≤d⁢(a,c)+d⁢(c,b)𝑑𝑎𝑏𝑑𝑎𝑐𝑑𝑐𝑏d(a,b)\leq d(a,c)+d(c,b)italic_d ( italic_a , italic_b ) ≤ italic_d ( italic_a , italic_c ) + italic_d ( italic_c , italic_b ) hold. The resulting quasi-metric structure (Ω,d)Ω𝑑(\Omega,d)( roman_Ω , italic_d ) is called a quasi-metric space. For the specific framework of this paper, a useful summary of the notions of distance in graphs, with sufficient explanation and many examples, is given in Chapter 15 in [10]. In this paper we will deal with the so called path-length-weighted distance, that was introduced in [7, §.4]. It should be noted that the version defined there is given for non-directed graphs, and so the definition we will use is slightly different. However, we will define an extended quasi-metric also in this case by giving the value d⁢(a,b)=∞𝑑𝑎𝑏d(a,b)=\inftyitalic_d ( italic_a , italic_b ) = ∞ when there is no path for going from a𝑎aitalic_a to b,𝑏b,italic_b , and considering only allowed paths between vertices. Since we are interested in how to compute the distance, and not in theoretical questions about its metric space structure, we will focus attention on the computational algorithm. All the notions on graph theory that are needed can be found in books on this subject, as for example [4]. We will introduce some of them in the next section."
https://arxiv.org/html/2411.00721v1,New classes of reversible cellular automata,"A Boolean function f𝑓fitalic_f on k𝑘kitalic_k bits induces a shift-invariant vectorial Boolean function F𝐹Fitalic_F from n𝑛nitalic_n bits to n𝑛nitalic_n bits for every n≥k𝑛𝑘n\geq kitalic_n ≥ italic_k. If F𝐹Fitalic_F is bijective for every n𝑛nitalic_n, we say that f𝑓fitalic_f is a proper lifting, and it is known that proper liftings are exactly those functions that arise as local rules of reversible cellular automata. We construct new families of such liftings for arbitrary large k𝑘kitalic_k and discuss whether all have been identified for k≤6𝑘6k\leq 6italic_k ≤ 6.","Shift-invariant functions are integral to symmetric cryptography, especially for lightweight cryptography, particularly in designing substitution boxes (S-boxes) for block ciphers and hash functions. These functions, and also connections to their associated cellular automata, which have a broad range of applications, have been studied by several authors, see e.g., [4] for a survey. Any shift-invariant function on n𝑛nitalic_n-bits is derived by a local rule, that is, a Boolean function on k𝑘kitalic_k-bits for some k≤n𝑘𝑛k\leq nitalic_k ≤ italic_n. Conversely, every Boolean function f:𝔽2k→𝔽2:𝑓→superscriptsubscript𝔽2𝑘subscript𝔽2f\colon\mathbb{F}_{2}^{k}\to\mathbb{F}_{2}italic_f : blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT → blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT induces a shift-invariant function F:𝔽2n→𝔽2n:𝐹→superscriptsubscript𝔽2𝑛superscriptsubscript𝔽2𝑛F\colon\mathbb{F}_{2}^{n}\to\mathbb{F}_{2}^{n}italic_F : blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT → blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT for every n≥k𝑛𝑘n\geq kitalic_n ≥ italic_k. If for every such n𝑛nitalic_n the induced map F𝐹Fitalic_F is bijective, then f𝑓fitalic_f is called a proper lifting, and the corresponding cellular automaton is reversible. This work constructs and classifies new families of proper liftings, thus advancing the understanding of reversible cellular automata, and evaluate their resistance to differential cryptanalysis. In Section 1, we describe a new way of produce proper liftings through composition of landscape functions, generalizing existing constructions coming from sets of landscapes, see e.g., [1]. In Section 2, we study in detail the case k=6𝑘6k=6italic_k = 6, and analyze whether these families are exhaustive. Finally, in Section 4, we present a few other constructions of families of proper liftings."
https://arxiv.org/html/2411.00708v2,Simplifying and Characterizing DAGs and Phylogenetic Networks via Least Common Ancestor Constraints,"Rooted phylogenetic networks, or more generally, directed acyclic graphs (DAGs), are widely used to model species or gene relationships that traditional rooted trees cannot fully capture, especially in the presence of reticulate processes or horizontal gene transfers. Such networks or DAGs are typically inferred from genomic data of extant taxa, providing only an estimate of the true evolutionary history. However, these inferred DAGs are often complex and difficult to interpret. In particular, many contain vertices that do not serve as least common ancestors (LCAs) for any subset of the underlying genes or species, thus lacking direct support from the observed data. In contrast, LCA vertices represent ancestral states substantiated by the data, offering important insights into evolutionary relationships among subsets of taxa. To reduce unnecessary complexity and eliminate unsupported vertices, we aim to simplify a DAG to retain only LCA vertices while preserving essential evolutionary information.In this paper, we characterize LCALCA\mathrm{LCA}roman_LCA-relevant and lcalca\mathrm{lca}roman_lca-relevant DAGs, defined as those in which every vertex serves as an LCA (or unique LCA) for some subset of taxa. We introduce methods to identify LCAs in DAGs and efficiently transform any DAG into an LCALCA\mathrm{LCA}roman_LCA-relevant or lcalca\mathrm{lca}roman_lca-relevant one while preserving key structural properties of the original DAG or network. This transformation is achieved using a simple operator “⊖symmetric-difference\ominus⊖” that mimics vertex suppression.","Rooted networks and, more generally, directed acyclic graphs (DAGs), are essential in mathematical phylogenetics for modeling complex evolutionary relationships that traditional rooted trees cannot fully represent [22, 25, 24]. In a DAG G𝐺Gitalic_G, the leaf set L⁢(G)𝐿𝐺L(G)italic_L ( italic_G ) represents extant taxa, such as genes or species, while internal vertices v∈V⁢(G)∖L⁢(G)𝑣𝑉𝐺𝐿𝐺v\in V(G)\setminus L(G)italic_v ∈ italic_V ( italic_G ) ∖ italic_L ( italic_G ) correspond to ancestral states and are associated with sets 𝙲G⁡(v)subscript𝙲𝐺𝑣\operatorname{\mathtt{C}}_{G}(v)typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) of descendant leaves known as “hardwired clusters” [24, 26, 23], or clusters [20] for short. Typically, only the leaf set L⁢(G)𝐿𝐺L(G)italic_L ( italic_G ) is available and a primary task is to reconstruct the evolutionary history - i.e., phylogenetic networks or DAGs - using information provided solely by the taxa in L⁢(G)𝐿𝐺L(G)italic_L ( italic_G ). This information, often derived from genomic sequence data and sequence similarities, can reveal clusters within the unknown DAG G𝐺Gitalic_G that are used to reconstruct G𝐺Gitalic_G [26, 23, 24, 13]. However, DAGs and networks inferred from genomic data can be highly complex and tangled, often containing redundant information [9, 12]. In particular, unlike phylogenetic trees, the number of vertices in a DAG G𝐺Gitalic_G is not generally bounded by the number of leaves. As a result, various methods have been developed to simplify DAGs while preserving their most significant features [17, 12, 21]. Our research builds on this line of work and focuses on eliminating vertices from a DAG G𝐺Gitalic_G that are “less relevant” in the sense that they are not least common ancestors of certain subsets of L⁢(G)𝐿𝐺L(G)italic_L ( italic_G ). A least common ancestor (LCA) of a subset A⊆L⁢(G)𝐴𝐿𝐺A\subseteq L(G)italic_A ⊆ italic_L ( italic_G ) is a vertex v𝑣vitalic_v that is an ancestor of all x∈A𝑥𝐴x\in Aitalic_x ∈ italic_A and has no descendant that also satisfies this property. LCAs are essential for understanding and interpreting evolutionary relationships in phylogenetics [39, 19, 30, 36]. In evolutionary biology, there is a general consensus that inferred networks and DAGs should be phylogenetic, that is, they should not contain vertices with in- and out-degree one. The reason is simple: such vertices cannot be observed from any biological data since there is no historical trace left justifying their existence [18]. By similar reasoning, LCA vertices should represent ancestral relationships evidenced by a clear phylogenetic signal in the data. Vertices that are not LCAs of any subset of taxa of the underlying data, i.e., the leaves in G𝐺Gitalic_G, lack direct relevance to the observed ancestral relationships; see, for example, vertex u𝑢uitalic_u or u′superscript𝑢′u^{\prime}italic_u start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT in the network N𝑁Nitalic_N in Figure 1. Consequently, non-LCA vertices may lack clear interpretation and could be considered less significant or redundant in an evolutionary context. Therefore, simplifying a DAG by “removal” of non-LCA vertices resulting in a DAG in which each vertex is a (unique) LCA of at least some leaves is a natural next step. We demonstrate that this transformation can be performed efficiently while preserving the structural integrity of the original DAG. The central questions considered here are as follows: 1. Is a given vertex a (unique) LCA of a specific, known subset A⊆L⁢(G)𝐴𝐿𝐺A\subseteq L(G)italic_A ⊆ italic_L ( italic_G )? 2. Is a given vertex a (unique) LCA of some unknown subset A⊆L⁢(G)𝐴𝐿𝐺A\subseteq L(G)italic_A ⊆ italic_L ( italic_G ), possibly with a prescribed size |A|𝐴|A|| italic_A |? 3. Can one characterize and recognize DAGs G𝐺Gitalic_G in which every vertex is a (unique) LCA of some subset of L⁢(G)𝐿𝐺L(G)italic_L ( italic_G )? 4. Is it possible to efficiently remove all vertices from a DAG G𝐺Gitalic_G that do not satisfy (1) or (2) and thus, to simplify G𝐺Gitalic_G to a DAG in which each vertex is a (unique) LCA of some subset of L⁢(G)𝐿𝐺L(G)italic_L ( italic_G ) while preserving as many structural features of G𝐺Gitalic_G as possible? We will address these problems from different perspectives. Numerous results have been established for Question 1 and 2 for the case |A|=2𝐴2|A|=2| italic_A | = 2 [29, 37, 4, 34, 8, 15, 5, 3, 28, 16], or when assuming that A=𝙲G⁡(v)𝐴subscript𝙲𝐺𝑣A=\operatorname{\mathtt{C}}_{G}(v)italic_A = typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) for a given vertex v𝑣vitalic_v [35]. Figure 1: Shown are three networks N𝑁Nitalic_N, N′superscript𝑁′N^{\prime}italic_N start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT and T𝑇Titalic_T. All have the same clustering system ℭ={{x},{y},{z},{x,y},{x,y,z}}ℭ𝑥𝑦𝑧𝑥𝑦𝑥𝑦𝑧\mathfrak{C}=\{\{x\},\{y\},\{z\},\{x,y\},\{x,y,z\}\}fraktur_C = { { italic_x } , { italic_y } , { italic_z } , { italic_x , italic_y } , { italic_x , italic_y , italic_z } } and leaf set X={x,y,z}𝑋𝑥𝑦𝑧X=\{x,y,z\}italic_X = { italic_x , italic_y , italic_z }. Here, only N′superscript𝑁′N^{\prime}italic_N start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT and T𝑇Titalic_T are phylogenetic. The network N𝑁Nitalic_N is not phylogenetic, since N𝑁Nitalic_N contains the vertex u′superscript𝑢′u^{\prime}italic_u start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT with in- and out-degree one. Moreover, vertices u𝑢uitalic_u and u′superscript𝑢′u^{\prime}italic_u start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT in N𝑁Nitalic_N are not LCAs of any subset of leaves. “Removing” u𝑢uitalic_u and u′superscript𝑢′u^{\prime}italic_u start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT from N𝑁Nitalic_N – as explained in detail in Section 6 – yields the simplified network N′superscript𝑁′N^{\prime}italic_N start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT in which all vertices are LCAs of some subset of X𝑋Xitalic_X. Hence, N′superscript𝑁′N^{\prime}italic_N start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT is LCALCA\operatorname{LCA}roman_LCA-Rel but not lcalca\operatorname{lca}roman_lca-Rel as the vertices v𝑣vitalic_v and w𝑤witalic_w are not unique LCAs in N′superscript𝑁′N^{\prime}italic_N start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT for any subset of X𝑋Xitalic_X. If desired, N′superscript𝑁′N^{\prime}italic_N start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT can now be further simplified by “removing” one of v𝑣vitalic_v or w𝑤witalic_w resulting in the phylogenetic and lcalca\operatorname{lca}roman_lca-Rel tree T𝑇Titalic_T. This paper is organized as follows. We start with introducing the basic definitions needed in Section 2. In Section 3, we define the notions of lcalca\operatorname{lca}roman_lca-Rel and LCALCA\operatorname{LCA}roman_LCA-Rel DAGs, as well as k𝑘kitalic_k-lcalca\operatorname{lca}roman_lca and k𝑘kitalic_k-LCALCA\operatorname{LCA}roman_LCA vertices. In short, a vertex v𝑣vitalic_v is a k𝑘kitalic_k-LCALCA\operatorname{LCA}roman_LCA (resp., k𝑘kitalic_k-lcalca\operatorname{lca}roman_lca) in G𝐺Gitalic_G if there exists a subset A⊆L⁢(G)𝐴𝐿𝐺A\subseteq L(G)italic_A ⊆ italic_L ( italic_G ) of size |A|=k𝐴𝑘|A|=k| italic_A | = italic_k such that v𝑣vitalic_v is a LCA (resp., unique LCA) of the vertices in A𝐴Aitalic_A. As we will see, a vertex v𝑣vitalic_v is a k𝑘kitalic_k-LCALCA\operatorname{LCA}roman_LCA vertex (resp., k𝑘kitalic_k-lcalca\operatorname{lca}roman_lca vertex) for some k𝑘kitalic_k precisely if v𝑣vitalic_v is a LCA (resp., unique LCA) of the vertices in 𝙲G⁡(v)subscript𝙲𝐺𝑣\operatorname{\mathtt{C}}_{G}(v)typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) (cf. Corollary 3.6). A DAG is LCALCA\operatorname{LCA}roman_LCA-Rel (resp., lcalca\operatorname{lca}roman_lca-Rel) if each of its vertices is a LCA (resp., unique LCA) for some subset A𝐴Aitalic_A. We then show that the set of least common ancestors of a set A⊆L⁢(G)𝐴𝐿𝐺A\subseteq L(G)italic_A ⊆ italic_L ( italic_G ) can be determined in linear time when |A|∈O⁢(1)𝐴𝑂1|A|\in O(1)| italic_A | ∈ italic_O ( 1 ) is constant. Additionally, we demonstrate that recognizing lcalca\operatorname{lca}roman_lca-Rel and LCALCA\operatorname{LCA}roman_LCA-Rel DAGs can be done in polynomial time. In Section 4, we continue by characterizing lcalca\operatorname{lca}roman_lca-Rel and LCALCA\operatorname{LCA}roman_LCA-Rel DAGs. As shown in Theorem 4.4, LCALCA\operatorname{LCA}roman_LCA-Rel DAGs are precisely those DAGs that do not contain adjacent vertices u𝑢uitalic_u and v𝑣vitalic_v with the same cluster, i.e., 𝙲G⁡(v)=𝙲G⁡(u)subscript𝙲𝐺𝑣subscript𝙲𝐺𝑢\operatorname{\mathtt{C}}_{G}(v)=\operatorname{\mathtt{C}}_{G}(u)typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) = typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u ). We then provide several characterizations of lcalca\operatorname{lca}roman_lca-Rel DAGs in Theorem 4.5. Among other results, lcalca\operatorname{lca}roman_lca-Rel DAGs are exactly those LCALCA\operatorname{LCA}roman_LCA-Rel DAGs with (PCC) property, meaning 𝙲G⁡(u)⊆𝙲G⁡(v)subscript𝙲𝐺𝑢subscript𝙲𝐺𝑣\operatorname{\mathtt{C}}_{G}(u)\subseteq\operatorname{\mathtt{C}}_{G}(v)typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u ) ⊆ typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) if and only if u𝑢uitalic_u is an ancestor of v𝑣vitalic_v or vice versa. Moreover, we show a close connection between lcalca\operatorname{lca}roman_lca-Rel DAGs and so-called regular DAGs where the latter, loosely speaking, are DAGs that are completely determined by their set of clusters. In particular, lcalca\operatorname{lca}roman_lca-Rel DAGs with all shortcuts removed are regular (cf. Corollary 4.9). Novel characterizations of regular DAGs are presented in Theorem 4.10. Similar to phylogenetic trees, the number of vertices in lcalca\operatorname{lca}roman_lca-Rel DAGs G𝐺Gitalic_G is bounded above by the number of leaves, see Lemma 4.12. Not all DAGs are lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel. Hence, the question arises whether one can transform a given DAG G𝐺Gitalic_G into an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel DAG H𝐻Hitalic_H while preserving as much of the structure of G𝐺Gitalic_G as possible. In Section 5, we provide an axiomatic framework for the phrase “preserving as much structure of G𝐺Gitalic_G as possible” resulting in five axioms (S1) – (S5). These include, among other conditions, that the vertex set of H𝐻Hitalic_H is a subset of the vertex set of G𝐺Gitalic_G, that the leaf-set L⁢(G)𝐿𝐺L(G)italic_L ( italic_G ) remains the set of leaves in H𝐻Hitalic_H and that the ancestor-relationship between the vertices in H𝐻Hitalic_H are consistent with those in G𝐺Gitalic_G. This in turn implies an additional Condition (S0): no new clusters in H𝐻Hitalic_H are introduced. To transform a given DAG into an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel one, we introduce a simple operator ⊖symmetric-difference\ominus⊖ that acts on the vertices and edges of G𝐺Gitalic_G [41]. Specifically, we denote with G⊖vsymmetric-difference𝐺𝑣G\ominus vitalic_G ⊖ italic_v the DAG obtained from G𝐺Gitalic_G by removing vertex v𝑣vitalic_v and its incident edges and connecting each parent of v𝑣vitalic_v with each child of v𝑣vitalic_v. Using this method, vertices v𝑣vitalic_v can be removed stepwise from G𝐺Gitalic_G, resulting in an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel DAG H𝐻Hitalic_H that satisfies the axioms (S1) – (S5). In particular, we provide conditions under which the set W𝑊Witalic_W of vertices such that G⊖Wsymmetric-difference𝐺𝑊G\ominus Witalic_G ⊖ italic_W is lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel is uniquely determined and of minimum size. Furthermore, polynomial-time algorithms are given to transform any DAG into an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel one. The established algorithms are implemented in Python and hosted at GitHub [31]. Following [17], we discuss in Section 6 a general framework for any transformation φ⁢(G)𝜑𝐺\varphi(G)italic_φ ( italic_G ) that “simplifies” a DAG G𝐺Gitalic_G, formalized through three axioms (P1) – (P3). Given a suitable notion of restriction of DAGs, we show that the ⊖symmetric-difference\ominus⊖-operator can be used to derive simplifications φ⁢(G)𝜑𝐺\varphi(G)italic_φ ( italic_G ) that satisfy axioms (P1) – (P3). We exemplify different types of simplification steps on a biological network with reticulation events that is based on a study of the Viola genus from Marcussen et al. [33]. While we have provided polynomial-time algorithms to verify whether a given DAG G𝐺Gitalic_G is lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel and to transform G𝐺Gitalic_G into an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel DAG if it is not, an open question remains: can it be decided in polynomial-time if a vertex v𝑣vitalic_v is a k𝑘kitalic_k-lcalca\operatorname{lca}roman_lca or k𝑘kitalic_k-LCALCA\operatorname{LCA}roman_LCA vertex for a given k𝑘kitalic_k? In Section 7, we show that this problem is NP-complete in general. However, it becomes polynomial-time solvable for DAGs with the (N3O) property, i.e., DAGs that do not contain three pairwise overlapping clusters. Such DAGs are of particular interest, as they include important subclasses of phylogenetic networks, such as rooted phylogenetic trees and galled-trees. We close this paper with Section 8, where we summarize the main results and provide open problems for future work."
https://arxiv.org/html/2411.00343v1,Treewidth 2 in thePlanar Graph Product Structure Theorem,"We prove that every planar graph is contained in H_⁢1⊠H_⁢2⊠K_⁢2⊠⊠subscript𝐻_1subscript𝐻_2subscript𝐾_2H_{\_}1\boxtimes H_{\_}2\boxtimes K_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 ⊠ italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 ⊠ italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 for some graphs H_⁢1subscript𝐻_1H_{\_}1italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 and H_⁢2subscript𝐻_2H_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 both with treewidth 2. This resolves a question of Liu, Norin and Wood [arXiv:2410.20333]. We also show this result is best possible in the following sense: for any c∈ℕ𝑐ℕc\in\mathbb{N}italic_c ∈ blackboard_N, there is a planar graph G𝐺Gitalic_G such that for any tree T𝑇Titalic_T and graph H𝐻Hitalic_H with tw⁡(H)⩽2tw𝐻2\operatorname{tw}(H)\leqslant 2roman_tw ( italic_H ) ⩽ 2, G𝐺Gitalic_G is not contained in H⊠T⊠K_⁢c⊠𝐻𝑇subscript𝐾_𝑐H\boxtimes T\boxtimes K_{\_}citalic_H ⊠ italic_T ⊠ italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT italic_c.","Graph product structure theory describes graphs in complicated graph classes as subgraphs of products of graphs in simpler graph classes, typically with bounded treewidth or bounded pathwidth. As defined in Section 2, the treewidth of a graph G𝐺Gitalic_G, denoted by tw⁡(G)tw𝐺\operatorname{tw}(G)roman_tw ( italic_G ), is the standard measure of how similar G𝐺Gitalic_G is to a tree. As illustrated in Figure 1, the strong product A⊠B⊠𝐴𝐵A\mathbin{\boxtimes}Bitalic_A ⊠ italic_B of graphs A𝐴Aitalic_A and B𝐵Bitalic_B has vertex-set V⁢(A)×V⁢(B)𝑉𝐴𝑉𝐵V(A)\times V(B)italic_V ( italic_A ) × italic_V ( italic_B ), where distinct vertices (v,x),(w,y)𝑣𝑥𝑤𝑦(v,x),(w,y)( italic_v , italic_x ) , ( italic_w , italic_y ) are adjacent if: • v=w𝑣𝑤v=witalic_v = italic_w and x⁢y∈E⁢(B)𝑥𝑦𝐸𝐵xy\in E(B)italic_x italic_y ∈ italic_E ( italic_B ), or • x=y𝑥𝑦x=yitalic_x = italic_y and v⁢w∈E⁢(A)𝑣𝑤𝐸𝐴vw\in E(A)italic_v italic_w ∈ italic_E ( italic_A ), or • v⁢w∈E⁢(A)𝑣𝑤𝐸𝐴vw\in E(A)italic_v italic_w ∈ italic_E ( italic_A ) and x⁢y∈E⁢(B)𝑥𝑦𝐸𝐵xy\in E(B)italic_x italic_y ∈ italic_E ( italic_B ). Figure 1: Strong product of two paths. The following Planar Graph Product Structure Theorem is the classical example of a graph product structure theorem. Here, a graph H𝐻Hitalic_H is contained in a graph G𝐺Gitalic_G if H𝐻Hitalic_H is isomorphic to a subgraph of G𝐺Gitalic_G, written H⊂∼Gsimilar-to𝐻𝐺H\mathrel{\begin{subarray}{c}\textstyle\subset\\[-2.58334pt] \textstyle\sim\\[-1.72218pt] \end{subarray}}Gitalic_H start_RELOP start_ARG start_ROW start_CELL ⊂ end_CELL end_ROW start_ROW start_CELL ∼ end_CELL end_ROW end_ARG end_RELOP italic_G. Theorem 1. For every planar graph G𝐺Gitalic_G: (a) G⊂∼H⊠Psimilar-to𝐺⊠𝐻𝑃G\mathrel{\begin{subarray}{c}\textstyle\subset\\[-2.58334pt] \textstyle\sim\\[-1.72218pt] \end{subarray}}H\mathbin{\boxtimes}Pitalic_G start_RELOP start_ARG start_ROW start_CELL ⊂ end_CELL end_ROW start_ROW start_CELL ∼ end_CELL end_ROW end_ARG end_RELOP italic_H ⊠ italic_P for some graph H𝐻Hitalic_H with tw⁡(H)⩽6tw𝐻6\operatorname{tw}(H)\leqslant 6roman_tw ( italic_H ) ⩽ 6 and path P𝑃Pitalic_P [20], (b) G⊂∼H⊠P⊠K_⁢2similar-to𝐺⊠𝐻𝑃subscript𝐾_2G\mathrel{\begin{subarray}{c}\textstyle\subset\\[-2.58334pt] \textstyle\sim\\[-1.72218pt] \end{subarray}}H\mathbin{\boxtimes}P\mathbin{\boxtimes}K_{\_}2italic_G start_RELOP start_ARG start_ROW start_CELL ⊂ end_CELL end_ROW start_ROW start_CELL ∼ end_CELL end_ROW end_ARG end_RELOP italic_H ⊠ italic_P ⊠ italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 for some graph H𝐻Hitalic_H with tw⁡(H)⩽4tw𝐻4\operatorname{tw}(H)\leqslant 4roman_tw ( italic_H ) ⩽ 4 and path P𝑃Pitalic_P [20], (c) G⊂∼H⊠P⊠K_⁢3similar-to𝐺⊠𝐻𝑃subscript𝐾_3G\mathrel{\begin{subarray}{c}\textstyle\subset\\[-2.58334pt] \textstyle\sim\\[-1.72218pt] \end{subarray}}H\mathbin{\boxtimes}P\mathbin{\boxtimes}K_{\_}3italic_G start_RELOP start_ARG start_ROW start_CELL ⊂ end_CELL end_ROW start_ROW start_CELL ∼ end_CELL end_ROW end_ARG end_RELOP italic_H ⊠ italic_P ⊠ italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 3 for some graph H𝐻Hitalic_H with tw⁡(H)⩽3tw𝐻3\operatorname{tw}(H)\leqslant 3roman_tw ( italic_H ) ⩽ 3 and path P𝑃Pitalic_P [8]. Dujmović et al. [8] first proved Theorem 1(a) with tw⁡(H)⩽8tw𝐻8\operatorname{tw}(H)\leqslant 8roman_tw ( italic_H ) ⩽ 8. In follow-up work, Ueckerdt et al. [20] improved the bound to tw⁡(H)⩽6tw𝐻6\operatorname{tw}(H)\leqslant 6roman_tw ( italic_H ) ⩽ 6. Part (b) is due to Dujmović, and is presented in [20]. Part (c) is in the original paper of Dujmović et al. [8]. Illingworth et al. [14] gave a new proof of part (c). Theorem 1 provides a powerful tool for studying questions about planar graphs, by reducing to graphs of bounded treewidth. Indeed, this result has been the key for resolving several open problems regarding queue layouts [8], nonrepetitive colourings [7], centred colourings [5], adjacency labelling schemes [11, 2, 10, 6], twin-width [3, 15], infinite graphs [13], and comparable box dimension [9]. In several of these applications, because the dependence on tw⁡(H)tw𝐻\operatorname{tw}(H)roman_tw ( italic_H ) is often exponential, the best bounds are obtained by applying the 3-term product in Theorem 1(c). The tw⁡(H)⩽3tw𝐻3\operatorname{tw}(H)\leqslant 3roman_tw ( italic_H ) ⩽ 3 bound in Theorem 1(c) is best possible in any result saying that every planar graph is contained H⊠P⊠K_⁢c⊠𝐻𝑃subscript𝐾_𝑐H\mathbin{\boxtimes}P\mathbin{\boxtimes}K_{\_}citalic_H ⊠ italic_P ⊠ italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT italic_c where P𝑃Pitalic_P is a path (see [8]). Liu et al. [17] relaxed the assumption that P𝑃Pitalic_P is a path, and studied products of two graphs of bounded treewidth. They asked whether every planar graph is contained in H_⁢1⊠H_⁢2⊠K_⁢c⊠⊠subscript𝐻_1subscript𝐻_2subscript𝐾_𝑐H_{\_}1\mathbin{\boxtimes}H_{\_}2\mathbin{\boxtimes}K_{\_}citalic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 ⊠ italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 ⊠ italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT italic_c for some graphs H_⁢1subscript𝐻_1H_{\_}1italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 and H_⁢2subscript𝐻_2H_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 with tw⁡(H_⁢1)⩽2twsubscript𝐻_12\operatorname{tw}(H_{\_}1)\leqslant 2roman_tw ( italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 ) ⩽ 2 and tw⁡(H_⁢2)⩽2twsubscript𝐻_22\operatorname{tw}(H_{\_}2)\leqslant 2roman_tw ( italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 ) ⩽ 2. We answer this question in the affirmative. Theorem 2. Every planar graph G𝐺Gitalic_G is contained in H_⁢1⊠H_⁢2⊠K_⁢2⊠⊠subscript𝐻_1subscript𝐻_2subscript𝐾_2H_{\_}1\mathbin{\boxtimes}H_{\_}2\mathbin{\boxtimes}K_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 ⊠ italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 ⊠ italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 for some graphs H_⁢1subscript𝐻_1H_{\_}1italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 and H_⁢2subscript𝐻_2H_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 with tw⁡(H_⁢1)⩽2twsubscript𝐻_12\operatorname{tw}(H_{\_}1)\leqslant 2roman_tw ( italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 ) ⩽ 2 and tw⁡(H_⁢2)⩽2twsubscript𝐻_22\operatorname{tw}(H_{\_}2)\leqslant 2roman_tw ( italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 ) ⩽ 2. We actually prove a strengthening of Theorem 2 that holds for a more general class of graphs G𝐺Gitalic_G, and with a more precise statement about the structure of H_⁢1subscript𝐻_1H_{\_}1italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 and H_⁢2subscript𝐻_2H_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2; see Theorem 8 below. We also show that Theorem 2 is best possible in the following sense. Theorem 3. For any integer c⩾1𝑐1c\geqslant 1italic_c ⩾ 1 there is a planar graph G𝐺Gitalic_G such that for any tree T𝑇Titalic_T and graph H𝐻Hitalic_H with tw⁡(H)⩽2tw𝐻2\operatorname{tw}(H)\leqslant 2roman_tw ( italic_H ) ⩽ 2, G𝐺Gitalic_G is not contained in H⊠T⊠K_⁢c⊠𝐻𝑇subscript𝐾_𝑐H\mathbin{\boxtimes}T\mathbin{\boxtimes}K_{\_}citalic_H ⊠ italic_T ⊠ italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT italic_c."
