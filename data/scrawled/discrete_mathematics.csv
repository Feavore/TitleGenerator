URL,Title,Abstract,Introduction
https://arxiv.org/html/2411.04479v1,On the number of partitions of the hypercubeğ™qnsuperscriptsubscriptğ™ğ‘ğ‘›{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPTinto large subcubes,"We prove that the number of partitions of the hypercube ğ™qnsuperscriptsubscriptğ™ğ‘ğ‘›{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT into qmsuperscriptğ‘ğ‘šq^{m}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT subcubes of dimension nâˆ’mğ‘›ğ‘šn-mitalic_n - italic_m each for fixed qğ‘qitalic_q, mğ‘šmitalic_m and growing nğ‘›nitalic_n is asymptotically equal to n(qmâˆ’1)/(qâˆ’1)superscriptğ‘›superscriptğ‘ğ‘š1ğ‘1n^{(q^{m}-1)/(q-1)}italic_n start_POSTSUPERSCRIPT ( italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT - 1 ) / ( italic_q - 1 ) end_POSTSUPERSCRIPT.For the proof, we introduce the operation of the bang of a star matrix and demonstrate that any star matrix, except for a fractal, is expandable under some bang, whereas a fractal remains to be a fractal under any bang.","Let q,m,nğ‘ğ‘šğ‘›q,m,nitalic_q , italic_m , italic_n be integers, qâ‰¥2ğ‘2q\geq 2italic_q â‰¥ 2, nâ‰¥mâ‰¥0ğ‘›ğ‘š0n\geq m\geq 0italic_n â‰¥ italic_m â‰¥ 0. The (nâˆ’mğ‘›ğ‘šn-mitalic_n - italic_m)-dimensional subcube in ğ™qnsuperscriptsubscriptğ™ğ‘ğ‘›{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is a subset of ğ™qnsuperscriptsubscriptğ™ğ‘ğ‘›{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT such that some mğ‘šmitalic_m components are fixed, and each of the remaining nâˆ’mğ‘›ğ‘šn-mitalic_n - italic_m components runs through all possible values from ğ™qsubscriptğ™ğ‘{\bf Z}_{q}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT. In partitioning into subcubes each vector of ğ™qnsuperscriptsubscriptğ™ğ‘ğ‘›{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT must fall into exactly one subcube. A partition into subcubes is called Agievich-primitive, or simply A-primitive222Agievich in [5] introduced the term â€primitiveâ€ for this concept (in more general case of partitioning into affine subspaces), but the use of this term is controversial, since it rather characterizes a certain non-degeneracy of the partition. In addition, such non-degeneracy of the partition can be defined in different ways, and the word â€primitiveâ€ is generally overloaded in mathematics. At the same time, giving another term also seems incorrect, therefore in [4] it was proposed to call such a partition Agievich-primitive or A-primitive. Note that in [2] the authors used the term â€tightâ€ for the same concept, which also does not seem to us to be â€tightâ€., if each component is fixed in at least one of the subcubes of the partition. The most well-known problem is the partitioning problem into small-dimensional subcubes. Thus, if all subcubes of a partition of a Boolean cube have dimension 1111, then these subcubes are edges, and the partitions are called perfect matchings, and the problem of their number is well known. In [1], the problems of partitioning a Boolean cube into subcubes are considered, mainly of small dimensions, which can also be different within a single partition. Partitions into subcubes (not necessarily of the same dimension) with an additional irreducibility condition are studied in [2]. Partitions into one-dimensional subcubes in a not necessarily binary case are the subject of [3]. The main subject of study in [4] was partitions into affine subspaces, and for partitions into subcubes, which are a special case of partitions into affine subspaces, the following statements were proved, oriented towards partitions into subcubes of the same large dimension. Theorem 1. [4] Let qâ‰¥2ğ‘2q\geq 2italic_q â‰¥ 2. For any natural mğ‘šmitalic_m there exists the smallest natural N=Nqcoordâ¢(m)ğ‘subscriptsuperscriptğ‘coordğ‘ğ‘šN=N^{\rm coord}_{q}(m)italic_N = italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) such that for n>Nğ‘›ğ‘n>Nitalic_n > italic_N there are no A-primitive partitions of ğ™qnsuperscriptsubscriptğ™ğ‘ğ‘›{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT into qmsuperscriptğ‘ğ‘šq^{m}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT subcubes of dimension nâˆ’mğ‘›ğ‘šn-mitalic_n - italic_m. Theorem 2. [4] The following formula is valid cqcoordâ¢(n,m)=âˆ‘h=mNqcoordâ¢(m)(nh)â¢cqcoordâ£âˆ—â¢(h,m),subscriptsuperscriptğ‘coordğ‘ğ‘›ğ‘šsuperscriptsubscriptâ„ğ‘šsubscriptsuperscriptğ‘coordğ‘ğ‘šbinomialğ‘›â„subscriptsuperscriptğ‘coordğ‘â„ğ‘šc^{\rm coord}_{q}(n,m)=\sum\limits_{h=m}^{N^{\rm coord}_{q}(m)}\binom{n}{h}c^{% \rm coord*}_{q}(h,m),italic_c start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_n , italic_m ) = âˆ‘ start_POSTSUBSCRIPT italic_h = italic_m end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) end_POSTSUPERSCRIPT ( FRACOP start_ARG italic_n end_ARG start_ARG italic_h end_ARG ) italic_c start_POSTSUPERSCRIPT roman_coord âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_h , italic_m ) , (1) where cqcoordâ¢(n,m)subscriptsuperscriptğ‘coordğ‘ğ‘›ğ‘šc^{\rm coord}_{q}(n,m)italic_c start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_n , italic_m ) is the number of different unordered partitions of ğ™qnsuperscriptsubscriptğ™ğ‘ğ‘›{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT into qmsuperscriptğ‘ğ‘šq^{m}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT subcubes of dimension nâˆ’mğ‘›ğ‘šn-mitalic_n - italic_m; cqcoordâ£âˆ—â¢(n,m)subscriptsuperscriptğ‘coordğ‘ğ‘›ğ‘šc^{\rm coord*}_{q}(n,m)italic_c start_POSTSUPERSCRIPT roman_coord âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_n , italic_m ) is the number of different unordered A-primitive partitions of ğ™qnsuperscriptsubscriptğ™ğ‘ğ‘›{\bf Z}_{q}^{n}bold_Z start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT into qmsuperscriptğ‘ğ‘šq^{m}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT subcubes of dimension nâˆ’mğ‘›ğ‘šn-mitalic_n - italic_m; (nh)binomialğ‘›â„\binom{n}{h}( FRACOP start_ARG italic_n end_ARG start_ARG italic_h end_ARG ) is the usual binomial coefficient. Theorem 3. [4] Let qğ‘qitalic_q and mğ‘šmitalic_m be fixed, nâ†’âˆâ†’ğ‘›n\to\inftyitalic_n â†’ âˆ. Then the following asymptotics holds cqcoordâ¢(n,m)âˆ¼Câ€²â¢nNqcoordâ¢(m),similar-tosubscriptsuperscriptğ‘coordğ‘ğ‘›ğ‘šsuperscriptğ¶â€²superscriptğ‘›subscriptsuperscriptğ‘coordğ‘ğ‘šc^{\rm coord}_{q}(n,m)\sim C^{\prime}n^{N^{\rm coord}_{q}(m)},italic_c start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_n , italic_m ) âˆ¼ italic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT italic_n start_POSTSUPERSCRIPT italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) end_POSTSUPERSCRIPT , where Câ€²=cqcoordâ£âˆ—â¢(Nqcoordâ¢(m),m)Nqcoordâ¢(m)!superscriptğ¶â€²subscriptsuperscriptğ‘coordğ‘subscriptsuperscriptğ‘coordğ‘ğ‘šğ‘šsubscriptsuperscriptğ‘coordğ‘ğ‘šC^{\prime}=\frac{c^{\rm coord*}_{q}(N^{\rm coord}_{q}(m),m)}{N^{\rm coord}_{q}% (m)!}italic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT = divide start_ARG italic_c start_POSTSUPERSCRIPT roman_coord âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) , italic_m ) end_ARG start_ARG italic_N start_POSTSUPERSCRIPT roman_coord end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( italic_m ) ! end_ARG."
https://arxiv.org/html/2411.04204v1,Online Budgeted Matching with General Bids,"Online Budgeted Matching (OBM) is a classic problem with important applications in online advertising, online service matching, revenue management, and beyond. Traditional online algorithms typically assume a small bid setting, where the maximum bid-to-budget ratio (Îºğœ…\kappaitalic_Îº) is infinitesimally small. While recent algorithms have tried to address scenarios with non-small or general bids, they often rely on the Fractional Last Matching (FLM) assumption, which allows for accepting partial bids when the remaining budget is insufficient. This assumption, however, does not hold for many applications with indivisible bids. In this paper, we remove the FLM assumption and tackle the open problem of OBM with general bids. We first establish an upper bound of 1âˆ’Îº1ğœ…1-\kappa1 - italic_Îº on the competitive ratio for any deterministic online algorithm. We then propose a novel meta algorithm, called MetaAd, which reduces to different algorithms with first known provable competitive ratios parameterized by the maximum bid-to-budget ratio Îºâˆˆ[0,1]ğœ…01\kappa\in[0,1]italic_Îº âˆˆ [ 0 , 1 ]. As a by-product, we extend MetaAd to the FLM setting and get provable competitive algorithms. Finally, we apply our competitive analysis to the design learning-augmented algorithms.","Online Budgeted Matching (OBM) with general bids is a fundamental online optimization problem that generalizes to many important settings, such as online bipartite matching and Adwords with equal bids [23]. It has applications in various domains, including online advertising, online resource allocation, and revenue management among others [5, 16, 32]. OBM is defined on a bipartite graph with a set of offline nodes (bidders) and a set of online nodes (queries). The task is to select an available offline node to match with an online query in each round. When an offline node is matched to an online node, a bid value is subtracted from the budget of the offline node, and a reward equal to the consumed budget is obtained. If the remaining budget of an offline node is less than the bid value of an online query, the offline node cannot be matched to the online query. The goal is to maximize the total reward throughout the entire online matching process. OBM is challenging due to the nature of online discrete decisions. Previous works have studied this problem under one of the following two additional assumptions on bids or matching rules: â€¢ Small bids. The small-bid assumption is a special case of general bids corresponding to the maximum bid-budget ratio Îºâ†’0â†’ğœ…0\kappa\to 0italic_Îº â†’ 0. That is, while the bid values can vary arbitrarily, the size of each individual bid is infinitely small compared to each offline nodeâ€™s budget, and there is always enough budget for matching. Under this assumption, the first online algorithm was provided by [24], achieving an optimal competitive ratio of 1âˆ’1/e11ğ‘’1-1/e1 - 1 / italic_e [23]. This competitive ratio has also been attained by subsequent algorithms based on primal-dual techniques [4, 7]. However, the small-bid assumption significantly limits these algorithms for broader applications in practice. Take the application of matching Virtual Machines (VMs) to physical servers as an example. An online VM request typically takes up a non-negligible fraction of the total computing units in a server. â€¢ Fractional last match (FLM). Under FLM, if an offline node has an insufficient budget for an online query, the offline node can still be matched to the query, obtaining a partial reward equal to the remaining budget. Given the limitations of small bids, some recent studies [15, 29, 30] have studied competitive algorithms for OBM with general bids by making the additional assumption of FLM. For example, under FLM, the greedy algorithm (Greedy) achieves a competitive ratio of 1/2121/21 / 2, while other studies [4, 15, 29, 30] aim to achieve a competitive ratio greater than 1/2121/21 / 2 under various settings and/or using randomized algorithms. Although FLM allows fractional matching of a query to an offline node with insufficient budgets, it essentially assumes that any bids are potentially divisible. This assumption may not hold in many real applications, e.g., allocating fractional physical resources to a VM can result in significant performance issues that render the allocation unacceptable, and charging a fractional advertising fee may not be allowed in online advertising. Despite its practical relevance and theoretical importance, OBM with general bids has remained a challenging open problem in the absence of the small-bid and FLM assumptions. Specifically, an offline node may have insufficient budget and cannot be matched to a later query with a large value, potentially causing large sub-optimality in the worst case. This issue does not apply to small bids, as the small-bid setting implies that insufficient budgets will never occur. Additionally, this challenge is alleviated in the FLM setting, where fractional matching in cases of insufficient budgets can reduce sub-optimality. Indeed, removing the small-bid and FLM assumptions fundamentally changes and add significant challenges to the problem of OBM [30]. To further highlight the intrinsic difficulty of OBM with general bids, we formally prove in Proposition 4.1 an upper bound of the competitive ratio, i.e., 1âˆ’Îº1ğœ…1-\kappa1 - italic_Îº, achieved by any deterministic online algorithm, where Îºâˆˆ[0,1]ğœ…01\kappa\in[0,1]italic_Îº âˆˆ [ 0 , 1 ] is the maximum bid-budget ratio. Contributions: In this paper, we address OBM without the small-bid or FLM assumptions and design a meta algorithm called MetaAd, which adapts to different algorithms with provable competitive ratios. To our knowledge, MetaAd is the first provable competitive algorithm for general bids without the FLM assumption. Specifically, MetaAd generates a discounted score for each offline node by a general discounting function, which is then used to select the offline node. The discounting function evaluates the degree of budget insufficiency given a bid-budget ratio Îºâˆˆ[0,1]ğœ…01\kappa\in[0,1]italic_Îº âˆˆ [ 0 , 1 ], addressing the challenge of infeasible matching due to insufficient budgets. Given different discounting functions, MetaAd yields concrete algorithms, and their competitive ratios are derived from Theorem 4.2, established through a novel proof technique. We show that with small bids (i.e., Îºâ†’0â†’ğœ…0\kappa\rightarrow 0italic_Îº â†’ 0), MetaAd recovers the optimal competitive ratio of 1âˆ’1e11ğ‘’1-\frac{1}{e}1 - divide start_ARG 1 end_ARG start_ARG italic_e end_ARG. Furthermore, we show that MetaAd, with discounting functions from the exponential and polynomial function classes, achieves a positive competitive ratio for Îºâˆˆ[0,1)ğœ…01\kappa\in[0,1)italic_Îº âˆˆ [ 0 , 1 ). As an extension, we adapt the design of MetaAd to the FLM setting, resulting in a meta-algorithm with provable competitive ratios for Îºâˆˆ[0,1]ğœ…01\kappa\in[0,1]italic_Îº âˆˆ [ 0 , 1 ] (Theorem 4.3). The framework of MetaAd potentially opens an interesting direction for exploring concrete discounting function designs that yield high competitive ratios for settings both with and without FLM. Finally, we apply our competitive analysis to the design of LOBM, a learning-augmented algorithm for OBM, which enhances average performance while still guaranteeing a competitive ratio (Theorem 5.1). We validate the empirical benefits of MetaAd and LOBM through numerical experiments on the applications of an online movie matching an VM placement on physical servers."
https://arxiv.org/html/2411.03776v1,"Reconstruction of multiple strings of constant weight from prefix-suffix compositionsâ€ â€ thanks:This paper was presented in part at the 2024 IEEE International Symposium on Information Theory (ISIT 2024)[1].
Y. Yang was with the School of Data Science, The Chinese University of Hong Kong, Shenzhen, China. (Email: yaoyuyang@link.cuhk.edu.cn) Z. Chen is with School of Science and Engineering, Future Networks of Intelligence Institute, The Chinese University of Hong Kong, Shenzhen, China. (Email: chenztan@cuhk.edu.cn)
This research was supported in part by the Basic Research Project of Hetao Shenzhen-Hong Kong Science and Technology Cooperation Zone under Project HZQB-KCZYZ-2021067,
the Guangdong Provincial Key Laboratory of Future Network of Intelligence under Project 2022B1212010001,
the National Natural Science Foundation of China under grants 62201487,
and the Shenzhen Science and Technology Stable Support Program.","Motivated by studies of data retrieval in polymer-based storage systems, we consider the problem of reconstructing a multiset of binary strings that have the same length and the same weight from the compositions of their prefixes and suffixes of every possible length. We provide necessary and sufficient conditions for which unique reconstruction up to reversal of the strings is possible. Additionally, we present two algorithms for reconstructing strings from the compositions of prefixes and suffixes of constant-length constant-weight strings.","The growing demand for archival data storage calls for innovative solutions to store information beyond traditional methods that rely on magnetic tapes or hard disk drives. Recent advancement in macromolecule synthesis and sequencing suggests that polymers such as DNA are promising media for future archival data storage, largely attributed to their high storage density and durability. Data retrieval in polymer-based storage systems depends on macromolecule sequencing technologies [2, 3] to read out the information stored in polymers. However, common sequencing technologies often only read random fragments of polymers. Thus, the task of data retrieval in these systems has to be based on the information provided by the fragments. Under proper assumptions, one may represent polymers by binary strings and turn the problem of data retrieval into the problem of string reconstruction from substring compositions, i.e., from the number of zeros and the number of ones in substrings of every possible length. In [4], the authors characterized the length for which strings can be uniquely reconstructed from their substring compositions up to reversal. Extending the work of [4], the authors of [5] and [6] studied the problem of string reconstruction from erroneous substring compositions. Specifically, [5] designed coding schemes capable of reconstructing strings in the presence of substitution errors and [6] further proposed codes that can deal with insertion and deletion errors. Observing that it may not be realistic to assume the compositions of all substrings are available, the authors of [7] initiated the study of string reconstruction based on the compositions of prefixes and suffixes of all possible lengths. In fact, [7] considered the more general problem of reconstructing multiple distinct strings of the same length simultaneously from the compositions of their prefixes and suffixes. The main result of [7] reveals that for reconstruction of no more than hâ„hitalic_h distinct strings of the same length, there exists a code with rate approaching 1/h1â„1/h1 / italic_h asymptotically. Following [7], the authors of [8] studied in depth the problem of reconstructing a single string from the compositions of its prefixes and suffixes. In particular, their work completely characterized the strings that can be reconstructed from its prefixes and suffixes compositions uniquely up to reversal. Efficiency of data retrieval is a major concern for practical polymer-based storage systems, and thus low complexity algorithms for string reconstruction are of great interest. In the case of reconstruction from error-free substring compositions, [4] described a backtracking algorithm for binary strings of length nğ‘›nitalic_n with worst-case time complexity exponential in nğ‘›\sqrt{n}square-root start_ARG italic_n end_ARG. Moreover, [5] and [9] constructed sets of binary strings that can be uniquely reconstructed with time complexity polynomial in nğ‘›nitalic_n. In the case of reconstruction from error-free compositions of prefixes and suffixes, [7] and [8] presented sets of binary strings that can be efficiently reconstructed. For reconstruction in the presence of substitution composition errors, [5] showed that when the number of errors is a constant independent of nğ‘›nitalic_n, there exist coding schemes with decoding complexity polynomial in nğ‘›nitalic_n. We note that string reconstruction is classic problem [10, 11, 12] and has been studied under various settings, including reconstruction from substrings [10, 13, 14] and from subsequences [11, 12, 15, 16, 17, 18] under either combinatorial or probabilistic assumptions. In this paper, we consider the problem of reconstructing hâ„hitalic_h strings that are not necessarily distinct but have the same length nâ‰¥1ğ‘›1n\geq 1italic_n â‰¥ 1 and weight wÂ¯â‰¤nÂ¯ğ‘¤ğ‘›\bar{w}\leq noverÂ¯ start_ARG italic_w end_ARG â‰¤ italic_n from their error-free compositions of prefixes and suffixes of all possible lengths. The problem of reconstructing multiple strings from prefix-suffix compositions becomes more amenable to analysis if the strings are of constant weight. This is because nice properties due to symmetry can be tethered to the prefix-suffix compositions. Our first result is a characterization of the properties of constant-weight strings that enable unique reconstruction up to reversal. Additionally, we present two algorithms that reconstruct constant-weight strings from prefix-suffix compositions. Given prefix-suffix compositions as input, one of the algorithms can efficiently output a multiset of strings whose prefix-suffix compositions are the same as the input, and the other is able to output all multisets of strings up to reversal that are allowed by the input. Our analysis relies on the running weight information of the strings that can be extracted from the prefix-suffix compositions and the inherent symmetry of constant-weight strings and their reversals. The rest of this paper is organized as follows. In Section II, we present the problem statement and introduce necessary notation and preliminaries that are helpful for later sections. In particular, we introduce the notion of cumulative weight functions that capture the running weight information of a multiset of strings, which is used throughout the paper. In Section III, we derive the necessary and sufficient conditions for unique reconstruction. Section IV is devoted to the reconstruction algorithms. We conclude this paper and mention a few open problems in Section V."
https://arxiv.org/html/2411.03407v1,Chorded Cycle Facets ofClique Partitioning Polytopes,"The qğ‘qitalic_q-chorded kğ‘˜kitalic_k-cycle inequalities are a class of valid inequalities for the clique partitioning polytope. It is known that for q=2ğ‘2q=2italic_q = 2 or q=kâˆ’12ğ‘ğ‘˜12q=\tfrac{k-1}{2}italic_q = divide start_ARG italic_k - 1 end_ARG start_ARG 2 end_ARG, these inequalities induce facets of the clique partitioning polytope if and only if kğ‘˜kitalic_k is odd. We solve the open problem of characterizing such facets for arbitrary kğ‘˜kitalic_k and qğ‘qitalic_q. More specifically, we prove that the qğ‘qitalic_q-chorded kğ‘˜kitalic_k-cycle inequalities induce facets of the clique partitioning polytope if and only if two conditions are satisfied: k=1ğ‘˜1k=1italic_k = 1 mod qğ‘qitalic_q, and if k=3â¢q+1ğ‘˜3ğ‘1k=3q+1italic_k = 3 italic_q + 1 then q=3ğ‘3q=3italic_q = 3 or qğ‘qitalic_q is even. This establishes the existence of many facets induced by qğ‘qitalic_q-chorded kğ‘˜kitalic_k-cycle inequalities beyond those previously known.","Given a complete graph with edge values that can be both positive and negative real numbers, the clique partitioning problem consists in finding a partition of the graph into disjoint cliques that maximizes the value of the edges within the cliques. This problem has a wide range of applications, including the aggregation of binary relations [12], community detection in social networks [5], and group technology [16]. Its feasible solutions are encoded by binary vectors with one entry for each edge of the graph, where an entry is 1 if and only if the associated edge is contained in a clique. The convex hull of these vectors is called the clique partitioning polytope [14]. While a complete outer description of this polytope in terms of its facets is not known, many classes of valid and facet-inducing inequalities have been discovered and are described in the literature. One such class of valid inequalities is that of the 2222-chorded kğ‘˜kitalic_k-cycle inequalities introduced in [14] and shown to induce a facet if and only if the cycle has odd length kğ‘˜kitalic_k. This class is generalized in [15] to the qğ‘qitalic_q-chorded kğ‘˜kitalic_k-cycle inequalities, where qğ‘qitalic_q is any integer between 2222 and k2ğ‘˜2\tfrac{k}{2}divide start_ARG italic_k end_ARG start_ARG 2 end_ARG. These inequalities are valid for the clique partitioning problem [15], but no claims have been made about facets induced by these inequalities. Recently, it was shown that for the special case of q=kâˆ’12ğ‘ğ‘˜12q=\tfrac{k-1}{2}italic_q = divide start_ARG italic_k - 1 end_ARG start_ARG 2 end_ARG, the qğ‘qitalic_q-chorded kğ‘˜kitalic_k-cycle inequalities induce facets of the clique partitioning polytope [1]. In this article, we establish for arbitrary kğ‘˜kitalic_k and qğ‘qitalic_q the exact condition under which the qğ‘qitalic_q-chorded kğ‘˜kitalic_k-cycle inequalities induce facets of the clique partitioning polytope (Theorem 2). For the special cases of q=2ğ‘2q=2italic_q = 2 and q=kâˆ’12ğ‘ğ‘˜12q=\tfrac{k-1}{2}italic_q = divide start_ARG italic_k - 1 end_ARG start_ARG 2 end_ARG, this condition specializes to the properties previously known. In its general form, our result implies the existence of many facets induced by qğ‘qitalic_q-chorded kğ‘˜kitalic_k-cycle inequalities for 2<q<kâˆ’122ğ‘ğ‘˜122<q<\tfrac{k-1}{2}2 < italic_q < divide start_ARG italic_k - 1 end_ARG start_ARG 2 end_ARG previously unknown."
https://arxiv.org/html/2411.03813v1,On the satisfiability of random3333-SAT formulaswithkğ‘˜kitalic_k-wise independent clauses,"The problem of identifying the satisfiability threshold of random 3333-SAT formulas has received a lot of attention during the last decades and has inspired the study of other threshold phenomena in random combinatorial structures. The classical assumption in this line of research is that, for a given set of nğ‘›nitalic_n Boolean variables, each clause is drawn uniformly at random among all sets of three literals from these variables, independently from other clauses. Here, we keep the uniform distribution of each clause, but deviate significantly from the independence assumption and consider richer families of probability distributions. For integer parameters nğ‘›nitalic_n, mğ‘šmitalic_m, and kğ‘˜kitalic_k, we denote by â„±kâ¢(n,m)subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) the family of probability distributions that produce formulas with mğ‘šmitalic_m clauses, each selected uniformly at random from all sets of three literals from the nğ‘›nitalic_n variables, so that the clauses are kğ‘˜kitalic_k-wise independent. Our aim is to make general statements about the satisfiability or unsatisfiability of formulas produced by distributions in â„±kâ¢(n,m)subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) for different values of the parameters nğ‘›nitalic_n, mğ‘šmitalic_m, and kğ‘˜kitalic_k.Our technical results are as follows: First, all probability distributions in â„±2â¢(n,m)subscriptâ„±2ğ‘›ğ‘š\mathcal{F}_{2}(n,m)caligraphic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_n , italic_m ) with mâˆˆÎ©â¢(n3)ğ‘šÎ©superscriptğ‘›3m\in\Omega(n^{3})italic_m âˆˆ roman_Î© ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) return unsatisfiable formulas with high probability. This result is tight. We show that there exists a probability distribution ğ’Ÿâˆˆâ„±3â¢(n,m)ğ’Ÿsubscriptâ„±3ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{3}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n , italic_m ) with mâˆˆOâ¢(n3)ğ‘šğ‘‚superscriptğ‘›3m\in O(n^{3})italic_m âˆˆ italic_O ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) so that a random formula drawn from ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is almost always satisfiable. In contrast, for m=Î©â¢(n2)ğ‘šÎ©superscriptğ‘›2m=\Omega(n^{2})italic_m = roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ), any probability distribution ğ’Ÿâˆˆâ„±4â¢(n,m)ğ’Ÿsubscriptâ„±4ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{4}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n , italic_m ) returns an unsatisfiable formula with high probability. This is our most surprising and technically involved result. Finally, for any integer kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2, any probability distribution ğ’Ÿâˆˆâ„±kâ¢(n,m)ğ’Ÿsubscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) with m=Oâ¢(n1âˆ’1/k)ğ‘šğ‘‚superscriptğ‘›11ğ‘˜m=O(n^{1-1/k})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) returns a satisfiable formula with high probability.","Satisfiability of propositional formulas (SAT) is one of the most renowned problems in theoretical computer science. It appeared in the first lists of NP-complete problems independently proposed by Cook and Levin, and is pivotal for many developments in modern complexity theory. Today, many lower bounds on the running time of algorithms rely on the Exponential Time Hypothesis for solving SAT [11, 18, 36, 37]. On the practical side, SAT solvers are frequently deployed in hardware circuit design, model checking, program verification, automated planning and scheduling, as well as in solving real-life instantiations of combinatorial optimization problems such as FCC spectrum auctions. Modern SAT solvers often find solutions to large industrial instances with thousands or even millions of variables despite the NP-hardness of the problem. However, there is still a large discrepancy between the performance of SAT solvers on those instances and theoretical average-case predictions, which have been studied in great depth under the line of research on random SAT. Random SAT. A jğ‘—jitalic_j-CNF formula Ï•italic-Ï•\phiitalic_Ï• over nğ‘›nitalic_n variables is composed of mğ‘šmitalic_m OR-clauses, each containing exactly jğ‘—jitalic_j literals of jğ‘—jitalic_j different variables. In the most commonly studied random SAT model, a formula Ï•italic-Ï•\phiitalic_Ï• is generated uniformly at random from all possible jğ‘—jitalic_j-CNF formulas over nğ‘›nitalic_n variables and mğ‘šmitalic_m clauses. The most prominent theoretical question related to random SAT is to identify the satisfiability threshold rjsubscriptğ‘Ÿğ‘—r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT such that limnâ†’âˆğğ«â¡[Ï•â¢ is satisfiable]subscriptâ†’ğ‘›ğğ«italic-Ï• is satisfiable\lim_{n\to\infty}\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is % satisfiable}\right]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}% ]}{[\phi\text{ is satisfiable}]}roman_lim start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT bold_Pr [ italic_Ï• is satisfiable ] is equal to 00 when m/n>rjğ‘šğ‘›subscriptğ‘Ÿğ‘—m/n>r_{j}italic_m / italic_n > italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT, and equal to 1111 when m/n<rjğ‘šğ‘›subscriptğ‘Ÿğ‘—m/n<r_{j}italic_m / italic_n < italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT. It has been established [15] that 2222-SAT has r2=1subscriptğ‘Ÿ21r_{2}=1italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = 1, and its phase transition window [10] is mâˆˆ[nâˆ’Î˜â¢(n1/3),n+Î˜â¢(n1/3)]ğ‘šğ‘›Î˜superscriptğ‘›13ğ‘›Î˜superscriptğ‘›13m\in[n-\Theta(n^{1/3}),n+\Theta(n^{1/3})]italic_m âˆˆ [ italic_n - roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 1 / 3 end_POSTSUPERSCRIPT ) , italic_n + roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 1 / 3 end_POSTSUPERSCRIPT ) ]. For jâ‰¥3ğ‘—3j\geq 3italic_j â‰¥ 3, the asymptotic jğ‘—jitalic_j-SAT threshold was shown to be 2jâ¢logâ¡2âˆ’12â¢(1+logâ¡2)Â±ojâ¢(1)plus-or-minussuperscript2ğ‘—21212subscriptğ‘œğ‘—12^{j}\log 2-\frac{1}{2}(1+\log 2)\pm o_{j}(1)2 start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT roman_log 2 - divide start_ARG 1 end_ARG start_ARG 2 end_ARG ( 1 + roman_log 2 ) Â± italic_o start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ( 1 ) as jâ†’âˆâ†’ğ‘—j\to\inftyitalic_j â†’ âˆ [17] (improving previous results from [3]), while for large enough jğ‘—jitalic_j the exact value of rjsubscriptğ‘Ÿğ‘—r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT was determined in [20]. However, the question of identifying rjsubscriptğ‘Ÿğ‘—r_{j}italic_r start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT for small values of jğ‘—jitalic_j remains open. In particular, random 3333-SAT has attracted a lot of attention. For the lower bound part, it has been shown in a series of papers [15, 12, 32, 1, 35, 39] that r3â‰¥3.52subscriptğ‘Ÿ33.52r_{3}\geq 3.52italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT â‰¥ 3.52 (the currently best known bound is due to [35, 39]). The upper bound part is studied by [27, 38, 21, 19]; the currently best known bound is r3<4.49subscriptğ‘Ÿ34.49r_{3}<4.49italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT < 4.49 due to [19]. The estimate r3â‰ˆ4.26subscriptğ‘Ÿ34.26r_{3}\approx 4.26italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT â‰ˆ 4.26 was derived from numerical experiments [40] (see also [14, 41]). A more recent line of work [29, 30, 31, 42] extends the standard model of random jğ‘—jitalic_j-SAT to non-uniform distributions. Their motivation comes from the empirical observation that, in practice, CNF formulas often have rather different frequencies/probabilities for the nğ‘›nitalic_n variables to appear in each clause (following a power-law distribution instead of a uniform one). Namely, Friedrich and Rothenberger [31] proposed a non-uniform random model, where the literals {xi,xiÂ¯}iâˆˆ[n]subscriptsubscriptğ‘¥ğ‘–Â¯subscriptğ‘¥ğ‘–ğ‘–delimited-[]ğ‘›\{x_{i},\overline{x_{i}}\}_{i\in[n]}{ italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , overÂ¯ start_ARG italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG } start_POSTSUBSCRIPT italic_i âˆˆ [ italic_n ] end_POSTSUBSCRIPT are selected independently at random in each clause cğ‘citalic_c of the random jğ‘—jitalic_j-CNF with ğğ«â¡[xiâˆˆc]=ğğ«â¡[xiÂ¯âˆˆc]=piğğ«subscriptğ‘¥ğ‘–ğ‘ğğ«Â¯subscriptğ‘¥ğ‘–ğ‘subscriptğ‘ğ‘–\operatorname{\mathbf{Pr}}\mathchoice{\left[x_{i}\in c\right]}{[x_{i}\in c]}{[% x_{i}\in c]}{[x_{i}\in c]}=\operatorname{\mathbf{Pr}}\mathchoice{\left[% \overline{x_{i}}\in c\right]}{[\overline{x_{i}}\in c]}{[\overline{x_{i}}\in c]% }{[\overline{x_{i}}\in c]}=p_{i}bold_Pr [ italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âˆˆ italic_c ] = bold_Pr [ overÂ¯ start_ARG italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_ARG âˆˆ italic_c ] = italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and where probabilities ğ©=(pi)iâˆˆ[n]ğ©subscriptsubscriptğ‘ğ‘–ğ‘–delimited-[]ğ‘›\mathbf{p}=(p_{i})_{i\in[n]}bold_p = ( italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_i âˆˆ [ italic_n ] end_POSTSUBSCRIPT may vary across different variables. They find satisfiability threshold r2â¢(ğ©)subscriptğ‘Ÿ2ğ©r_{2}(\mathbf{p})italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( bold_p ) of non-uniform random 2222-SAT for certain regimes depending on ğ©ğ©\mathbf{p}bold_p. However, the non-uniform model of [31] does not capture the community biases/correlations (i.e., the fact that certain variables are more likely to appear together in a clause), which are often observed in practice [6]. This leads us to the question of whether it is possible to relax the strong independence assumption in the existing random SAT literature. Relaxation of independence. We first observe that it does not make much sense to study distributions of SAT formulas with arbitrary correlations over the clauses. Indeed, by allowing correlation between several clauses, one may enforce that the random formula Ï•italic-Ï•\phiitalic_Ï• contains large fixed sub-formulas corresponding to NP-hard SAT variants. This would be at odds with our goal of studying average-case complexity. Therefore, we must keep a certain degree of independence in the distribution of instances. We propose to consider the relaxation of mutual independence over mğ‘šmitalic_m clauses in a random formula Ï•italic-Ï•\phiitalic_Ï• to kğ‘˜kitalic_k-wise independence for a small constant kğ‘˜kitalic_k. To keep the new model tractable, we focus on 3333-SAT and uniform distribution of literals within each clause. I.e., we assume that (i) every 3333-OR-clause cğ‘citalic_c of a random 3333-CNF formula Ï•italic-Ï•\phiitalic_Ï• has three literals of three distinct variables drawn uniformly at random among all such triplets of literals and that (ii) given this marginal distribution of each clause câˆ¼Funi.similar-toğ‘subscriptğ¹uni.c\sim F_{\text{uni.}}italic_c âˆ¼ italic_F start_POSTSUBSCRIPT uni. end_POSTSUBSCRIPT, the distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D over the clause set Cğ¶Citalic_C in Ï•italic-Ï•\phiitalic_Ï• is only kğ‘˜kitalic_k-wise independent instead of the mutually independent distribution ğ’ŸInd.=(Funi.)âŠ—msubscriptğ’ŸInd.superscriptsubscriptğ¹uni.tensor-productabsentğ‘š\mathcal{D}_{\text{Ind.}}=\left(F_{\text{uni.}}\right)^{\otimes m}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT = ( italic_F start_POSTSUBSCRIPT uni. end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT âŠ— italic_m end_POSTSUPERSCRIPT in the standard model. This is a natural generalization that has been considered in a number of different settings but, to the best of our knowledge, not in the context of random SAT. Note that the smaller kğ‘˜kitalic_k is, the bigger the set of possible distributions ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D. Furthermore, for small values of kğ‘˜kitalic_k, a kğ‘˜kitalic_k-wise independent distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D can still capture a large class of dependencies among clauses but at the same time does not allow correlation between any kğ‘˜kitalic_k-tuples of clauses. In mathematical terms, the family of discrete kğ‘˜kitalic_k-wise independent distributions naturally appears when we map the set of distributions to the set of their low-degree moments. Specifically, if a distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is supported on the nğ‘›nitalic_n-dimensional binary cube111Similar moment functions can be defined for any distribution with discrete marginals. suppâ¢(D)={âˆ’1,1}nsuppğ·superscript11ğ‘›\texttt{supp}(D)=\{-1,1\}^{n}supp ( italic_D ) = { - 1 , 1 } start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, then all its moments of degree up to kğ‘˜kitalic_k can be described as Î¼â¢(D)=(ğ„â¡[âˆiâˆˆSxi])|S|â‰¤kğœ‡ğ·subscriptğ„subscriptproductğ‘–ğ‘†subscriptğ‘¥ğ‘–ğ‘†ğ‘˜\mu(D)=(\operatorname{\mathbf{E}}\mathchoice{\left[\prod_{i\in S}x_{i}\right]}% {[\prod_{i\in S}x_{i}]}{[\prod_{i\in S}x_{i}]}{[\prod_{i\in S}x_{i}]})_{|S|% \leq k}italic_Î¼ ( italic_D ) = ( bold_E [ âˆ start_POSTSUBSCRIPT italic_i âˆˆ italic_S end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ] ) start_POSTSUBSCRIPT | italic_S | â‰¤ italic_k end_POSTSUBSCRIPT. As low-degree moments (basically, the image of Î¼ğœ‡\muitalic_Î¼) are extremely important in statistical analysis, it is equally important to study the kernel of the aforementioned mapping, which exactly corresponds to the family of kğ‘˜kitalic_k-wise independent distributions. Let us provide additional justifications of our framework by discussing some of the theoretical work on random 3333SAT and on other settings with similar kğ‘˜kitalic_k-wise independence relaxation. Pseudo-randomness. Historically, the kğ‘˜kitalic_k-wise relaxation of independence has been actively used in the literature on derandomization and pseudo-randomness, as it allows to significantly reduce the amount of random bits needed to generate random objects. For example, Alon and Nussboim [5] consider random ErdÅ‘s-RÃ©nyi graphs and examine the minimal degree kğ‘˜kitalic_k of independence needed to achieve a variety of graph properties and statistics (such as connectivity, existence of perfect matchings, existence of Hamiltonian cycles, clique and chromatic numbers, etc.) that match those in the mutually independent case. Benjamini et al. [9] consider similar questions for monotone boolean functions. The motivation in [5] comes from the fact that there are efficient constructions of kğ‘˜kitalic_k-wise independent distributions with â€œlow degree of independenceâ€ (say k=Oâ¢(logâ¡n)ğ‘˜ğ‘‚ğ‘›k=O(\log n)italic_k = italic_O ( roman_log italic_n )) that utilize only polylogâ¢(n)polylogğ‘›\text{polylog}(n)polylog ( italic_n ) random bits, i.e., much fewer than the polynomial number of random bits required to generate mutually independent distributions. While some of this motivation can be applied to our setting of random 3333-SAT, it is a conceptually different story. Indeed, the perspective of pseudo-random generation is through the lenses of â€œprobability theoryâ€, where one controls the distributions and can simply choose one that satisfies necessary conditions such as, e.g., (logâ¡n)ğ‘›(\log n)( roman_log italic_n )-wise independence. On the other hand, our motivation stems from â€œstatisticsâ€, as our ideal model should have a reasonable fit to empirical observations. So, we would like to use as minimal assumptions as possible and study small (constant) degrees of independence. Refutability of 3333-SAT. While the research on lower bounds for random 3333-SAT often comes up with certain simple heuristics that efficiently find a satisfying assignment (see, e.g., the surveys by Achlioptas [2] and Flaxman [26]), it is extremely hard to find an efficient refutation of a unsatisfiable 3333-SAT formula. Indeed, the common approach to refute a given SAT formula is proof in resolution. Chvatal and Szemeredi [16] first showed that a random 3333-CNF formula with m=Î˜â¢(n)ğ‘šÎ˜ğ‘›m=\Theta(n)italic_m = roman_Î˜ ( italic_n ) clauses (which is almost surely unsatisfiable) almost surely admits only exponential size proof in resolution. Later, Ben-Sasson and Wigderson [8] derived similar result for much larger m=Oâ¢(n3/2âˆ’Îµ)ğ‘šğ‘‚superscriptğ‘›32ğœ€m=O(n^{3/2-\varepsilon})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 - italic_Îµ end_POSTSUPERSCRIPT ). On the positive side, [28] gave the first polynomial time algorithm via spectral techniques that almost surely222Refutation in this case is an algorithm with one-sided error: it always refutes the formula correctly by producing certain certificates, or says that the formula might be correct. refutes a random 3333-SAT formula with m=n3/2+Îµğ‘šsuperscriptğ‘›32ğœ€m=n^{3/2+\varepsilon}italic_m = italic_n start_POSTSUPERSCRIPT 3 / 2 + italic_Îµ end_POSTSUPERSCRIPT clauses. The best known bound on mğ‘šmitalic_m is due to Feige and Ofek [25] who proved that, for a sufficiently large constant cğ‘citalic_c, random 3333-SAT formulas with m=câ‹…n3/2ğ‘šâ‹…ğ‘superscriptğ‘›32m=c\cdot n^{3/2}italic_m = italic_c â‹… italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT clauses can be almost surely refuted in polynomial time using another spectral graph algorithm. We note that a similar situation (extremely high probability of unsatisfiability for a random formula and inability to efficiently confirm it) is unlikely to happen in our kğ‘˜kitalic_k-clause independent model for constant kğ‘˜kitalic_k. Indeed, the main proof approach for dealing with arbitrary kğ‘˜kitalic_k-wise independent distribution is to define a kğ‘˜kitalic_k-wise statistic, which differentiates any satisfiable formula from a typical unsatisfiable one. Testing kğ‘˜kitalic_k-wise independence. The property of kğ‘˜kitalic_k-wise independence of a distribution with nğ‘›nitalic_n components can be tested using nOâ¢(k)=pâ¢oâ¢lâ¢yâ¢(n)superscriptğ‘›ğ‘‚ğ‘˜ğ‘ğ‘œğ‘™ğ‘¦ğ‘›n^{O(k)}=poly(n)italic_n start_POSTSUPERSCRIPT italic_O ( italic_k ) end_POSTSUPERSCRIPT = italic_p italic_o italic_l italic_y ( italic_n ) many samples in polynomial time, when kğ‘˜kitalic_k is a constant [4, 43]. This is a useful property to have, as it allows one to verify with only polynomially many instances of random 3333-SAT, whether these instances conform to kğ‘˜kitalic_k-wise independence or not. Robust mechanism design. A recent line of work in robust mechanism design also considers families of kğ‘˜kitalic_k-wise independent Bayesian priors in single and multi-unit auctions [13, 22, 33, 34]. Their motivation is similar to ours, as they also rely on the statistical point of view to justify the extension of the results for mutual independent priors typically assumed in Bayesian mechanism design to kğ‘˜kitalic_k-wise independent ones. 1.1 Problem formulation We consider random 3333-CNF formulas with nğ‘›nitalic_n variables generated from a distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D over mğ‘šmitalic_m clauses, where the mutual independence assumption over clauses is relaxed to kğ‘˜kitalic_k-wise independence. We use the term kğ‘˜kitalic_k-clause independence to refer to such distributions. We denote such families of distributions by â„±kâ¢(n,m)subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ), where each ğ’Ÿâˆˆâ„±kâ¢(n,m)ğ’Ÿsubscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) has identical marginals uniformly distributed over all possible OR-clauses and those marginals are only assumed to be kğ‘˜kitalic_k-wise independent in ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D. We would like to understand the following question for small values of kğ‘˜kitalic_k: How does the satisfiability threshold r3subscriptğ‘Ÿ3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT of random 3333-SAT formulas behave under any kğ‘˜kitalic_k-clause independent distribution ğ’Ÿâˆˆâ„±kâ¢(n,m)ğ’Ÿsubscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m )? As the distribution ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is not unique, there might be a large gap between lower and upper estimates of r3subscriptğ‘Ÿ3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT. To this end, we formally define the lower satisfiability threshold LSTkâ¢(n)subscriptLSTğ‘˜ğ‘›\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) as an upper bound on mğ‘šmitalic_m, such that a random formula Ï•italic-Ï•\phiitalic_Ï• drawn from a distribution in â„±kâ¢(n,m)subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{F}_{k}(n,m)caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) with mâ‰¤LSTkâ¢(n)ğ‘šsubscriptLSTğ‘˜ğ‘›m\leq\texttt{LST}_{k}(n)italic_m â‰¤ LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) clauses has ğğ«â¡[Ï•â¢ is satisfiable]â‰¥23ğğ«italic-Ï• is satisfiable23\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\geq\frac{2}{3}bold_Pr [ italic_Ï• is satisfiable ] â‰¥ divide start_ARG 2 end_ARG start_ARG 3 end_ARG. Similarly, the upper satisfiability threshold USTkâ¢(n)subscriptUSTğ‘˜ğ‘›\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) is a lower bound on mğ‘šmitalic_m, such that the random formula Ï•italic-Ï•\phiitalic_Ï• with mâ‰¥USTkâ¢(n)ğ‘šsubscriptUSTğ‘˜ğ‘›m\geq\texttt{UST}_{k}(n)italic_m â‰¥ UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) clauses has ğğ«â¡[Ï•â¢ is satisfiable]â‰¤13ğğ«italic-Ï• is satisfiable13\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\leq\frac{1}{3}bold_Pr [ italic_Ï• is satisfiable ] â‰¤ divide start_ARG 1 end_ARG start_ARG 3 end_ARG. What kind of bounds on upper USTkâ¢(n)subscriptUSTğ‘˜ğ‘›\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) and lower LSTkâ¢(n)subscriptLSTğ‘˜ğ‘›\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) thresholds should we expect? Reasonable expectations. The condition ğ’Ÿâˆˆâ„±kâ¢(n,m)ğ’Ÿsubscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{k}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ) only says something about configurations of at most kğ‘˜kitalic_k clauses and does not put any other restrictions on the random formula Ï•âˆ¼ğ’Ÿsimilar-toitalic-Ï•ğ’Ÿ\phi\sim\mathcal{D}italic_Ï• âˆ¼ caligraphic_D. As the degree of independence kğ‘˜kitalic_k is a small constant, any argument that gives bounds on LSTksubscriptLSTğ‘˜\texttt{LST}_{k}LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT or USTksubscriptUSTğ‘˜\texttt{UST}_{k}UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT can only rely on statistics of at most a constant number of clauses. Hence, it is rather likely that bounds on LSTksubscriptLSTğ‘˜\texttt{LST}_{k}LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT and USTksubscriptUSTğ‘˜\texttt{UST}_{k}UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT come together with efficient procedures of, respectively, finding a satisfying assignment for a random formula Ï•italic-Ï•\phiitalic_Ï•, or certifying that Ï•italic-Ï•\phiitalic_Ï• is not satisfiable. Hence, given the prior work on random 3333-SAT for ğ’ŸInd.âˆˆâ„±kâ¢(n,m)subscriptğ’ŸInd.subscriptâ„±ğ‘˜ğ‘›ğ‘š\mathcal{D}_{\text{Ind.}}\in\mathcal{F}_{k}(n,m)caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT âˆˆ caligraphic_F start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n , italic_m ), we get the following picture: Upper satisfiability threshold. The best known result for refuting 3333-CNF formulas efficiently is due to Feige and Ofek [25], who show how to do it only for a fairly large number of clauses m=câ‹…n3/2ğ‘šâ‹…ğ‘superscriptğ‘›32m=c\cdot n^{3/2}italic_m = italic_c â‹… italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT. Furthermore, for any smaller number of clauses m=Oâ¢(n3/2âˆ’Îµ)ğ‘šğ‘‚superscriptğ‘›32ğœ€m=O(n^{3/2-\varepsilon})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 - italic_Îµ end_POSTSUPERSCRIPT ), a random 3333-CNF formula is likely to have only exponential in nğ‘›nitalic_n proof size for any unsatisfiability proof in resolution [8]. Hence, it is out of reach to aim for a better bound on USTkâ¢(n)subscriptUSTğ‘˜ğ‘›\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) than Oâ¢(n3/2)ğ‘‚superscriptğ‘›32O(n^{3/2})italic_O ( italic_n start_POSTSUPERSCRIPT 3 / 2 end_POSTSUPERSCRIPT ) while relying only on kğ‘˜kitalic_k-wise independence for some constant kğ‘˜kitalic_k. In fact, the best known positive result on efficiently computable proofs of unsatisfiability in resolution is due to Beame et al. [7], who show that an ordered DLL algorithm executed on a random 3333-SAT instance with m=Î©â¢(n2/logâ¡n)ğ‘šÎ©superscriptğ‘›2ğ‘›m=\Omega(n^{2}/\log n)italic_m = roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / roman_log italic_n ) clauses terminates in polynomial time. Lower satisfiability threshold. As the proofs for the lower bounds on r3subscriptğ‘Ÿ3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT often establish simple procedures that find satisfying assignments with high probability, it is still possible that LSTkâ¢(n)subscriptLSTğ‘˜ğ‘›\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) is of similar order Î˜â¢(n)Î˜ğ‘›\Theta(n)roman_Î˜ ( italic_n ) as the lower bounds on r3subscriptğ‘Ÿ3r_{3}italic_r start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT for ğ’ŸInd.subscriptğ’ŸInd.\mathcal{D}_{\text{Ind.}}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT. Thus, the most ambitious result would be to show that LSTkâ¢(n)â‰¤ckâ‹…nsubscriptLSTğ‘˜ğ‘›â‹…subscriptğ‘ğ‘˜ğ‘›\texttt{LST}_{k}(n)\leq c_{k}\cdot nLST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) â‰¤ italic_c start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT â‹… italic_n for constant cksubscriptğ‘ğ‘˜c_{k}italic_c start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT that increases with kğ‘˜kitalic_k. A more modest goal is to aim for LSTkâ¢(n)=oâ¢(n)subscriptLSTğ‘˜ğ‘›ğ‘œğ‘›\texttt{LST}_{k}(n)=o(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_o ( italic_n ) for a constant kğ‘˜kitalic_k, where LSTkâ¢(n)â†’Î˜â¢(n)â†’subscriptLSTğ‘˜ğ‘›Î˜ğ‘›\texttt{LST}_{k}(n)\to\Theta(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) â†’ roman_Î˜ ( italic_n ) as kâ†’+âˆâ†’ğ‘˜k\to+\inftyitalic_k â†’ + âˆ. 1.2 Our results We obtain the following bounds on the lower and upper satisfiability thresholds LSTkâ¢(n)subscriptLSTğ‘˜ğ‘›\texttt{LST}_{k}(n)LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) and USTkâ¢(n)subscriptUSTğ‘˜ğ‘›\texttt{UST}_{k}(n)UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) for various values of kğ‘˜kitalic_k. Lower satisfiability thresholds. We show (in Theorem 6.1) that LSTkâ¢(n)â‰¥Î©â¢(n1âˆ’1/k)subscriptLSTğ‘˜ğ‘›Î©superscriptğ‘›11ğ‘˜\texttt{LST}_{k}(n)\geq\Omega(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) â‰¥ roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) for any kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2. I.e., any kğ‘˜kitalic_k-clause independent random formula is satisfiable with high probability if it contains at most Oâ¢(n1âˆ’1/k)ğ‘‚superscriptğ‘›11ğ‘˜O(n^{1-1/k})italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) clauses. The argument is simple: for any kğ‘˜kitalic_k-clause independent distribution, we look at the 3333-uniform hypergraph that corresponds to the variables of a random formula Ï•italic-Ï•\phiitalic_Ï• produced according to this distribution, and argue that this graph does not have Berge-cycles, with high probability. We also provide an informal justification that this bound is asymptotically tight, i.e., that LSTkâ¢(n)=Oâ¢(n1âˆ’1/k)subscriptLSTğ‘˜ğ‘›ğ‘‚superscriptğ‘›11ğ‘˜\texttt{LST}_{k}(n)=O(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ). Specifically, we outline a plausible approach for constructing a kğ‘˜kitalic_k-clause independent distribution with m=Oâ¢(n1âˆ’1/k)ğ‘šğ‘‚superscriptğ‘›11ğ‘˜m=O(n^{1-1/k})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) clauses such that most of its formulas are unsatisfiable. Our approach is built upon existing constructions of dense hyper-graphs with large girth. It is interesting to note that, in both the proof of the LSTkâ¢(n)=Î©â¢(n1âˆ’1/k)subscriptLSTğ‘˜ğ‘›Î©superscriptğ‘›11ğ‘˜\texttt{LST}_{k}(n)=\Omega(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ) result and the approach for showing that LSTkâ¢(n)=Oâ¢(n1âˆ’1/k)subscriptLSTğ‘˜ğ‘›ğ‘‚superscriptğ‘›11ğ‘˜\texttt{LST}_{k}(n)=O(n^{1-1/k})LST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 1 - 1 / italic_k end_POSTSUPERSCRIPT ), we only need to consider variables and can completely ignore the distribution over the literals. Upper satisfiability thresholds. We first consider small degrees of independence, i.e., kâˆˆ{2,3}ğ‘˜23k\in\{2,3\}italic_k âˆˆ { 2 , 3 }. In both cases, we show that USTkâ¢(n)=Î˜â¢(n3)subscriptUSTğ‘˜ğ‘›Î˜superscriptğ‘›3\texttt{UST}_{k}(n)=\Theta(n^{3})UST start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_n ) = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ), meaning that one needs almost all possible clauses in a 3333-clause (as well as 2222-clause) independent formula to ensure that it is unsatisfiable (see Theorem 3.1 and Theorem 4.1). The most nontrivial part is to construct the distribution ğ’Ÿâˆˆâ„±3â¢(n,m)ğ’Ÿsubscriptâ„±3ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{3}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n , italic_m ) with m=Î˜â¢(n3)ğ‘šÎ˜superscriptğ‘›3m=\Theta(n^{3})italic_m = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) and ğğ«â¡[Ï•â¢ is satisfiable]â‰¥23ğğ«italic-Ï• is satisfiable23\operatorname{\mathbf{Pr}}\mathchoice{\left[\phi\text{ is satisfiable}\right]}% {[\phi\text{ is satisfiable}]}{[\phi\text{ is satisfiable}]}{[\phi\text{ is % satisfiable}]}\geq\frac{2}{3}bold_Pr [ italic_Ï• is satisfiable ] â‰¥ divide start_ARG 2 end_ARG start_ARG 3 end_ARG. Our construction is based on â€œ3333-XOR formulasâ€ (i.e., OR-clauses that have either one or three literals that are satisfied by a randomly planted truth assignment), which aligns well with the intuition developed in previous work [24, 25]. The main technical difficulty is to ensure kğ‘˜kitalic_k-clause independence by adding a small fraction of unsatisfiable instances and checking all 3333-wise statistics. Our most exciting and technically involved result (see Theorem 5.1) is our proof that UST4â¢(n)=Oâ¢(n2)subscriptUST4ğ‘›ğ‘‚superscriptğ‘›2\texttt{UST}_{4}(n)=O(n^{2})UST start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ), i.e., a random formula Ï•âˆ¼ğ’Ÿsimilar-toitalic-Ï•ğ’Ÿ\phi\sim\mathcal{D}italic_Ï• âˆ¼ caligraphic_D with m=Oâ¢(n2)ğ‘šğ‘‚superscriptğ‘›2m=O(n^{2})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) clauses is unsatisfiable with large probability for any 4444-clause independent distribution ğ’Ÿâˆˆâ„±4â¢(n,m)ğ’Ÿsubscriptâ„±4ğ‘›ğ‘š\mathcal{D}\in\mathcal{F}_{4}(n,m)caligraphic_D âˆˆ caligraphic_F start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n , italic_m ). It is worth noting that such a bound is much harder to get under the 4444-wise independence assumption than in the case of a mutually independent distribution ğ’ŸInd.subscriptğ’ŸInd.\mathcal{D}_{\text{Ind.}}caligraphic_D start_POSTSUBSCRIPT Ind. end_POSTSUBSCRIPT. Indeed, Feige and Ofek [25] describe a very simple refutation algorithm for m=Î˜â¢(n2)ğ‘šÎ˜superscriptğ‘›2m=\Theta(n^{2})italic_m = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) that fixes a variable xğ‘¥xitalic_x and considers all clauses containing xğ‘¥xitalic_x or xÂ¯Â¯ğ‘¥\overline{x}overÂ¯ start_ARG italic_x end_ARG (there will be Î˜â¢(n)Î˜ğ‘›\Theta(n)roman_Î˜ ( italic_n ) such clauses in expectation). Then, after deleting xğ‘¥xitalic_x (or xÂ¯Â¯ğ‘¥\overline{x}overÂ¯ start_ARG italic_x end_ARG), one can reduce the problem to the refutation of the respective random 2222-CNF sub-instance, which can be easily verified in polynomial time and has a low satisfiability threshold of r2=1subscriptğ‘Ÿ21r_{2}=1italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = 1. This simple approach obviously fails for 4444-clause independent distributions. We instead construct a bipartite multigraph Gâ¢(Ï•)ğºitalic-Ï•G(\phi)italic_G ( italic_Ï• ) between pairs of distinct literals on one side and all singleton literals on the other, in which every OR-clause in Ï•italic-Ï•\phiitalic_Ï• corresponds to three different edges. We then carefully examine the statistic Îºâ¢(Ï•)ğœ…italic-Ï•\kappa(\phi)italic_Îº ( italic_Ï• ) that counts K2,2subscriptğ¾22K_{2,2}italic_K start_POSTSUBSCRIPT 2 , 2 end_POSTSUBSCRIPT subgraphs in Gâ¢(Ï•)ğºitalic-Ï•G(\phi)italic_G ( italic_Ï• ) for a random Ï•âˆ¼ğ’Ÿsimilar-toitalic-Ï•ğ’Ÿ\phi\sim\mathcal{D}italic_Ï• âˆ¼ caligraphic_D. We find that the expected value of Îºâ¢(Ï•)ğœ…italic-Ï•\kappa(\phi)italic_Îº ( italic_Ï• ) for random Ï•italic-Ï•\phiitalic_Ï• is only slightly larger than its absolute minimal value, while at the same time Îºâ¢(Ï•)ğœ…italic-Ï•\kappa(\phi)italic_Îº ( italic_Ï• ) is significantly larger than its expectation when Ï•italic-Ï•\phiitalic_Ï• is satisfiable. Our argument bears certain similarities with the argument in [25], which also looked at intersections of two literals between pairs of clauses but used the 3333-XOR principle and a differently constructed non-bipartite graph. 1.3 Roadmap The rest of the paper is structured as follows. We begin with preliminary definitions and notation in Section 2. Then, we warm up with our tight bounds on the upper satisfiability threshold UST2â¢(n)subscriptUST2ğ‘›\texttt{UST}_{2}(n)UST start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_n ) in Section 3. Our lower bound on UST3â¢(n)subscriptUST3ğ‘›\texttt{UST}_{3}(n)UST start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n ) is proved in Section 4 while our upper bound on UST4â¢(n)subscriptUST4ğ‘›\texttt{UST}_{4}(n)UST start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ( italic_n ) follows in Section 5. Section 6 is devoted to the study of the lower satisfiability threshold."
https://arxiv.org/html/2411.03451v1,Redundancy Is All You Need,"The seminal work of BenczÃºr and Karger demonstrated cut sparsifiers of near-linear size, with several applications throughout theoretical computer science. Subsequent extensions have yielded sparsifiers for hypergraph cuts and more recently linear codes over Abelian groups. A decade ago, Kogan and Krauthgamer asked about the sparsifiability of arbitrary constraint satisfaction problems (CSPs). For this question, a trivial lower bound is the size of a non-redundant CSP instance, which admits, for each constraint, an assignment satisfying only that constraint (so that no constraint can be dropped by the sparsifier). For instance, for graph cuts, spanning trees are non-redundant instances.Our main result is that redundant clauses are sufficient for sparsification: for any CSP predicate Rğ‘…Ritalic_R, every unweighted instance of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) has a sparsifier of size at most its non-redundancy (up to polylog factors). For weighted instances, we similarly pin down the sparsifiability to the so-called chain length of the predicate. These results precisely determine the extent to which any CSP can be sparsified. A key technical ingredient in our work is a novel application of the entropy method from Gilmerâ€™s recent breakthrough on the union-closed sets conjecture.As an immediate consequence of our main theorem, a number of results in the non-redundancy literature immediately extend to CSP sparsification. We also contribute new techniques for understanding the non-redundancy of CSP predicates. In particular, we give an explicit family of predicates whose non-redundancy roughly corresponds to the structure of matching vector families in coding theory. By adapting methods from the matching vector codes literature, we are able to construct an explicit predicate whose non-redundancy lies between Î©â¢(n1.5)Î©superscriptğ‘›1.5\Omega(n^{1.5})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) and O~â¢(n1.6)~ğ‘‚superscriptğ‘›1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ), the first example with a provably non-integral exponent.","The broad goal in sparsification is to replace an object by a more compact surrogate, typically a carefully chosen subsample, that preserves the behavior of the object under some metric of interest. For instance, for preserving cuts in undirected graphs, the influential works of Karger [Kar93] and BenczÃºr and Karger [BK96] showed that every graph has an edge-weighted subgraph with near-linear number of edges that preserves the value of all (edge) cuts up to a (1Â±Ïµ)plus-or-minus1italic-Ïµ(1\pm\epsilon)( 1 Â± italic_Ïµ ) multiplicative factor. These papers have had a substantial impact in shaping the last thirty years of work in areas such as spectral sparsifiers [ST11, BSS12, LS18], clustering [KVV04, SPR11], hypergraph sparsifiers [KK15, CKN20, KKTY21, KK23, KPS24c], linear solvers [ST04, Vis13, KMP14], convex optimization [LS14, AK16, Tod16], sketching/streaming algorithms [AG09, AGM12b, AGM12a, ACK+16, McG14, KLM+17, BHM+21], max-flow/min-cut algorithms [LR99, CKM+11, KLOS14, CKL+22], machine learning [LCY+21, CSZ22, ZSW+23, GBY+24], submodular functions [KK23, Sch24, Raf24, Qua24], differential privacy [BBDS12, AU19], PageRank [Chu14], and even theoretical physics [HKTH16, Van18, TN22], among many other works. Among the multiple exciting dimensions in which cut sparsification has been generalized, we now highlight two which form the backdrop for our work. Note that the graph cut problem can be modeled by the arity-two Boolean constraint x+y=1(mod2)ğ‘¥ğ‘¦annotated1pmod2x+y=1\pmod{2}italic_x + italic_y = 1 start_MODIFIER ( roman_mod start_ARG 2 end_ARG ) end_MODIFIER. One can thus generalize cut sparsification by allowing for arbitrary constraints (of any arity over some finite domain) as considered in the field of constraint satisfaction problems (CSPs), leading to CSP sparsification. This direction was proposed by Kogan and Krauthgamer [KK15] in their work on hypergraph cut sparsifiers, where the not-all-equal constraint captures hypergraph cut. As as special case, arbitrary binary CSPs (where each constraint has two variables) were studied in [FK17] for the Boolean domain and in [BÅ½20] for general domains, leading to a dichotomy: either near-linear sized sparsifiers exist, or no improvement over quadratic is possible. In another direction, one can instead look toward more general structures to sparsify. For instance, a recent line of work by Khanna, Putterman, and Sudan turned toward sparsifying linear codes [KPS24a], or more generally subgroups of powers of Abelian groups [KPS24b]. Beyond being algorithmically efficient [KPS24b], these structural results have led to exciting new results in CSP sparsification by constructing optimal sparsifiers when the constraints can be embedded into linear/Abelian equations. In this work, we obtain sparsifiers encompassing both these generalizations via a unified approach to sparsification of non-linear codes. The resulting sparsifiers for CSPs have optimal asymptotic size up to polylogarithmic factors, for every choice of predicate defining the CSP. In other words, we pinpoint the optimal extent to which an arbitrary CSP can be sparsified.111In this work we focus on the existence of sparsifiers, which is already highly non-trivial (e.g., [KPS24a, BÅ½20] are also non-algorithmic). Future directions (and barriers) for algorithmic aspects are briefly discussed in Sections 1.7 and 9. 1.1 Non-linear code sparsification We first state our result for codes as it is very general and crisply stated, and then turn to the consequences and further new results for CSPs. For a non-linear code CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, an Îµğœ€\varepsilonitalic_Îµ-sparsifier (for a parameter Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 )) is a weight function w:[m]â†’â„â‰¥0:ğ‘¤â†’delimited-[]ğ‘šsubscriptâ„absent0w:[m]\to\mathbb{R}_{\geq 0}italic_w : [ italic_m ] â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT such that for every codeword cğ‘citalic_c, adding up the weights of its nonzero positions, i.e., âˆ‘iwâ¢(i)â¢cisubscriptğ‘–ğ‘¤ğ‘–subscriptğ‘ğ‘–\sum_{i}w(i)c_{i}âˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_w ( italic_i ) italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, is an accurate estimate of the Hamming weight of cğ‘citalic_c (i.e., âˆ‘icisubscriptğ‘–subscriptğ‘ğ‘–\sum_{i}c_{i}âˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT) to within a (1Â±Îµ)plus-or-minus1ğœ€(1\pm\varepsilon)( 1 Â± italic_Îµ ) multiplicative factor (Definition 2.8). The goal is to minimize the support of wğ‘¤witalic_w (i.e., the number of nonzero entries wâ¢(i)ğ‘¤ğ‘–w(i)italic_w ( italic_i )), and the minimum value is called Îµğœ€\varepsilonitalic_Îµ-sparsifiability of Cğ¶Citalic_C and is denoted SPRâ¡(C,Îµ)SPRğ¶ğœ€\operatorname{SPR}(C,\varepsilon)roman_SPR ( italic_C , italic_Îµ ). One of our main results is an upper bound on the sparsifiability in terms of a natural combinatorial parameter of the code called its non-redundancy NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ), defined as follows: NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ) is the size of the largest subset of indices IâŠ†[m]ğ¼delimited-[]ğ‘šI\subseteq[m]italic_I âŠ† [ italic_m ] such that for each iâˆˆIğ‘–ğ¼i\in Iitalic_i âˆˆ italic_I, there is a codeword câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C with ci=1subscriptğ‘ğ‘–1c_{i}=1italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = 1 and ciâ€²=0subscriptğ‘superscriptğ‘–â€²0c_{i^{\prime}}=0italic_c start_POSTSUBSCRIPT italic_i start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUBSCRIPT = 0 for iâ€²âˆˆIâˆ–{i}superscriptğ‘–â€²ğ¼ğ‘–i^{\prime}\in I\setminus\{i\}italic_i start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ italic_I âˆ– { italic_i }. In other words, if we imagine the code as a matrix whose rows are codewords, its non-redundancy is largest square submatrix which is a permutation matrix. Our result can then be stated compactly as follows. Theorem 1.1 (Main). For all CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT and Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 ), SPRâ¡(C,Îµ)=Oâ¢(NRDâ¡(C)â¢(logâ¡m)6/Îµ2).SPRğ¶ğœ€ğ‘‚NRDğ¶superscriptğ‘š6superscriptğœ€2\operatorname{SPR}(C,\varepsilon)=O(\operatorname{NRD}(C)(\log m)^{6}/% \varepsilon^{2}).roman_SPR ( italic_C , italic_Îµ ) = italic_O ( roman_NRD ( italic_C ) ( roman_log italic_m ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . To see how our theorem generalizes linear code sparsification [KPS24a, KPS24b], let ğ”½ğ”½\mathbb{F}blackboard_F be a (finite) field and let VâŠ†ğ”½mğ‘‰superscriptğ”½ğ‘šV\subseteq\mathbb{F}^{m}italic_V âŠ† blackboard_F start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT be a subspace. Let C:={(ğŸâ¢[v1=0],â€¦,ğŸâ¢[vm=0]):vâˆˆV}assignğ¶conditional-set1delimited-[]subscriptğ‘£10â€¦1delimited-[]subscriptğ‘£ğ‘š0ğ‘£ğ‘‰C:=\{({\bf 1}[v_{1}=0],\ldots,{\bf 1}[v_{m}=0]):v\in V\}italic_C := { ( bold_1 [ italic_v start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = 0 ] , â€¦ , bold_1 [ italic_v start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT = 0 ] ) : italic_v âˆˆ italic_V } be the zero/non-zero pattern of Vğ‘‰Vitalic_V. Then, any Îµğœ€\varepsilonitalic_Îµ-sparsifier of Cğ¶Citalic_C is an Îµğœ€\varepsilonitalic_Îµ-sparsifier of Vğ‘‰Vitalic_V and NRDâ¡(C)=dimVNRDğ¶dimensionğ‘‰\operatorname{NRD}(C)=\dim Vroman_NRD ( italic_C ) = roman_dim italic_V. In fact, for any finite group GğºGitalic_G and subgroup Hâ‰¤Gmğ»superscriptğºğ‘šH\leq G^{m}italic_H â‰¤ italic_G start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, we can show for the corresponding Cğ¶Citalic_C that NRDâ¡(C)â‰¤log2â¡|H|NRDğ¶subscript2ğ»\operatorname{NRD}(C)\leq\log_{2}|H|roman_NRD ( italic_C ) â‰¤ roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_H | (see Theorem 5.1), matching [KPS24b]â€™s result for Abelian groups (modulo their efficiency). If we view CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT as a set family over the universe [m]delimited-[]ğ‘š[m][ italic_m ], the above result in effect says that the non-redundancy NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ) plays the role of the VC dimension of Cğ¶Citalic_C when the goal is to estimate the size of the set câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C rather than learn cğ‘citalic_c itself. In fact, it turns out that NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ) is precisely the VC dimension of the union-closure of Cğ¶Citalic_C. This connection to union-closed families plays a crucial role in the proof of Theorem 1.1. See the technical overview (Section 1.6) for more details, including discussion of a significantly simpler O~Îµâ¢(NRDâ¡(C)â¢logâ¡|C|)subscript~ğ‘‚ğœ€NRDğ¶ğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\log|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log | italic_C | )-sized sparsifier. 1.2 CSP sparsification We now turn to (unweighted222The weighted case is discussed in Section 1.4.) CSP sparsification. For a relation RâŠ†Drğ‘…superscriptğ·ğ‘ŸR\subseteq D^{r}italic_R âŠ† italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT of arity rğ‘Ÿritalic_r over a finite domain Dğ·Ditalic_D, an instance Î¨Î¨\Psiroman_Î¨ of the CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) problem consists a variable set Xğ‘‹Xitalic_X and a constraint set YâŠ†Xrğ‘Œsuperscriptğ‘‹ğ‘ŸY\subseteq X^{r}italic_Y âŠ† italic_X start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT. An assignment Ïƒ:Xâ†’D:ğœâ†’ğ‘‹ğ·\sigma:X\to Ditalic_Ïƒ : italic_X â†’ italic_D satisfies a constraint y=(x1,x2,â€¦,xr)âˆˆYğ‘¦subscriptğ‘¥1subscriptğ‘¥2â€¦subscriptğ‘¥ğ‘Ÿğ‘Œy=(x_{1},x_{2},\dots,x_{r})\in Yitalic_y = ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ) âˆˆ italic_Y if (Ïƒâ¢(x1),Ïƒâ¢(x2),â€¦,Ïƒâ¢(xr))âˆˆRğœsubscriptğ‘¥1ğœsubscriptğ‘¥2â€¦ğœsubscriptğ‘¥ğ‘Ÿğ‘…(\sigma(x_{1}),\sigma(x_{2}),\dots,\sigma(x_{r}))\in R( italic_Ïƒ ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) , italic_Ïƒ ( italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) , â€¦ , italic_Ïƒ ( italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ) ) âˆˆ italic_R. The value valâ¡(Î¨,Ïƒ)valÎ¨ğœ\operatorname{val}(\Psi,\sigma)roman_val ( roman_Î¨ , italic_Ïƒ ) of an assignment Ïƒğœ\sigmaitalic_Ïƒ is the number of constraints yâˆˆYğ‘¦ğ‘Œy\in Yitalic_y âˆˆ italic_Y that it satisfies. Similarly, for a weight function w:Yâ†’â„â‰¥0:ğ‘¤â†’ğ‘Œsubscriptâ„absent0w:Y\to\mathbb{R}_{\geq 0}italic_w : italic_Y â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT, the weighted value valâ¡(Î¨,w,Ïƒ)valÎ¨ğ‘¤ğœ\operatorname{val}(\Psi,w,\sigma)roman_val ( roman_Î¨ , italic_w , italic_Ïƒ ) is the sum of weights wâ¢(y)ğ‘¤ğ‘¦w(y)italic_w ( italic_y ) of all constraints yâˆˆYğ‘¦ğ‘Œy\in Yitalic_y âˆˆ italic_Y that Ïƒğœ\sigmaitalic_Ïƒ satisfies. The goal in CSP sparsification is to output a weight function w:Yâ†’â„â‰¥0:ğ‘¤â†’ğ‘Œsubscriptâ„absent0w:Y\to\mathbb{R}_{\geq 0}italic_w : italic_Y â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT of small support, such that for every assignment Ïƒ:Xâ†’D:ğœâ†’ğ‘‹ğ·\sigma:X\to Ditalic_Ïƒ : italic_X â†’ italic_D, (1âˆ’Îµ)â¢valâ¡(Î¨,Ïƒ)â‰¤valâ¡(Î¨,w,Ïƒ)â‰¤(1+Îµ)â¢valâ¡(Î¨,Ïƒ),1ğœ€valÎ¨ğœvalÎ¨ğ‘¤ğœ1ğœ€valÎ¨ğœ(1-\varepsilon)\operatorname{val}(\Psi,\sigma)\leq\operatorname{val}(\Psi,w,% \sigma)\leq(1+\varepsilon)\operatorname{val}(\Psi,\sigma)\ ,( 1 - italic_Îµ ) roman_val ( roman_Î¨ , italic_Ïƒ ) â‰¤ roman_val ( roman_Î¨ , italic_w , italic_Ïƒ ) â‰¤ ( 1 + italic_Îµ ) roman_val ( roman_Î¨ , italic_Ïƒ ) , and minimum such support size is denoted SPRâ¡(Î¨,Îµ)SPRÎ¨ğœ€\operatorname{SPR}(\Psi,\varepsilon)roman_SPR ( roman_Î¨ , italic_Îµ ). The Îµğœ€\varepsilonitalic_Îµ-sparsifiability of the relation RâŠ†Drğ‘…superscriptğ·ğ‘ŸR\subseteq D^{r}italic_R âŠ† italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT, as a function of number of variables, is defined to the maximum (i.e., worst-case) value of SPRâ¡(Î¨,Îµ)SPRÎ¨ğœ€\operatorname{SPR}(\Psi,\varepsilon)roman_SPR ( roman_Î¨ , italic_Îµ ) over all nğ‘›nitalic_n-variables instances Î¨Î¨\Psiroman_Î¨ of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ). We denote it by SPRâ¡(R,n,Îµ)SPRğ‘…ğ‘›ğœ€\operatorname{SPR}(R,n,\varepsilon)roman_SPR ( italic_R , italic_n , italic_Îµ ) and it is the chief object of our study. Note that this is for the unweighted case, see Section 1.4 how this result can be (tightly) applied to the weighted case. Let us note an obvious obstruction to sparsification. Suppose we have an instance Î¨=(X,Y)Î¨ğ‘‹ğ‘Œ\Psi=(X,Y)roman_Î¨ = ( italic_X , italic_Y ) of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) such that for each of its constraints yâˆˆYğ‘¦ğ‘Œy\in Yitalic_y âˆˆ italic_Y, there is an assignment Ïƒy:Xâ†’D:subscriptğœğ‘¦â†’ğ‘‹ğ·\sigma_{y}:X\to Ditalic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT : italic_X â†’ italic_D that satisfies only yğ‘¦yitalic_y and no other constraint. Then clearly Î¨Î¨\Psiroman_Î¨ cannot be sparsified at allâ€”dropping any constraint yğ‘¦yitalic_y would make the value of Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT drop from 1111 to 00. We call such an instance a non-redundant instance of CSPâ¡(RÂ¯)CSPÂ¯ğ‘…\operatorname{CSP}(\overline{R})roman_CSP ( overÂ¯ start_ARG italic_R end_ARG ), where RÂ¯=Drâˆ–RÂ¯ğ‘…superscriptğ·ğ‘Ÿğ‘…\overline{R}=D^{r}\setminus RoverÂ¯ start_ARG italic_R end_ARG = italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT âˆ– italic_R (cf., [BCH+13, BCK20]).333We use RÂ¯Â¯ğ‘…\overline{R}overÂ¯ start_ARG italic_R end_ARG rather than Rğ‘…Ritalic_R due to the conventions of each community. See Remark 2.6 for deeper technical reasons. As introduced by Bessiere, Carbonnel, and Katsirelos [BCK20], we denote the size of the largest such non-redundant instance of CSPâ¡(RÂ¯)CSPÂ¯ğ‘…\operatorname{CSP}(\overline{R})roman_CSP ( overÂ¯ start_ARG italic_R end_ARG ) on nğ‘›nitalic_n-variables by NRDâ¡(RÂ¯,n)NRDÂ¯ğ‘…ğ‘›\operatorname{NRD}(\overline{R},n)roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) and call it the non-redundancy of RÂ¯Â¯ğ‘…\overline{R}overÂ¯ start_ARG italic_R end_ARG. Thus a trivial lower bound on sparsifiability of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ), regardless of the choice of Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 ), is given by SPRâ¡(R,n,Îµ)â‰¥NRDâ¡(RÂ¯,n),SPRğ‘…ğ‘›ğœ€NRDÂ¯ğ‘…ğ‘›\displaystyle\operatorname{SPR}(R,n,\varepsilon)\geq\operatorname{NRD}(% \overline{R},n)\ ,roman_SPR ( italic_R , italic_n , italic_Îµ ) â‰¥ roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) , (1) and this holds even if the goal is merely to preserve which assignments have nonzero value. Rather remarkably, this simplistic lower bound can be met and one can sparsify all the way down to NRDâ¡(RÂ¯,n)NRDÂ¯ğ‘…ğ‘›\operatorname{NRD}(\overline{R},n)roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) times polylogarithmic factors! In fact, this turns out to be an easy corollary of Theorem 1.1. One can associate a canonical code CÎ¨âŠ†{0,1}Ysubscriptğ¶Î¨superscript01ğ‘ŒC_{\Psi}\subseteq\{0,1\}^{Y}italic_C start_POSTSUBSCRIPT roman_Î¨ end_POSTSUBSCRIPT âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_Y end_POSTSUPERSCRIPT with any CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) instance Î¨=(X,Y)Î¨ğ‘‹ğ‘Œ\Psi=(X,Y)roman_Î¨ = ( italic_X , italic_Y ) whose codewords cÏƒsubscriptğ‘ğœc_{\sigma}italic_c start_POSTSUBSCRIPT italic_Ïƒ end_POSTSUBSCRIPT correspond to the assignments Ïƒ:Xâ†’D:ğœâ†’ğ‘‹ğ·\sigma:X\to Ditalic_Ïƒ : italic_X â†’ italic_D, and cÏƒ,ysubscriptğ‘ğœğ‘¦c_{\sigma,y}italic_c start_POSTSUBSCRIPT italic_Ïƒ , italic_y end_POSTSUBSCRIPT is 1111 precisely when Ïƒğœ\sigmaitalic_Ïƒ satisfies yğ‘¦yitalic_y. It is easy to check that CSP sparsification of Î¨Î¨\Psiroman_Î¨ reduces to code sparsification of CÎ¨subscriptğ¶Î¨C_{\Psi}italic_C start_POSTSUBSCRIPT roman_Î¨ end_POSTSUBSCRIPT, and the non-redundancy of Cğ¶Citalic_C equals the size of the largest non-redundant sub-instance of Î¨Î¨\Psiroman_Î¨ (viewed as an instance of CSPâ¡(RÂ¯)CSPÂ¯ğ‘…\operatorname{CSP}(\overline{R})roman_CSP ( overÂ¯ start_ARG italic_R end_ARG )). Combining Theorem 1.1 and (1), we therefore have our main result pinning down the sparsifiability of every CSP up to polylogarithmic factors. Theorem 1.2. For every nonempty RâŠŠDrğ‘…superscriptğ·ğ‘ŸR\subsetneq D^{r}italic_R âŠŠ italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT and Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 ), we have that NRDâ¡(RÂ¯,n)â‰¤SPRâ¡(R,n,Îµ)â‰¤Oâ¢(NRDâ¡(RÂ¯,n)â¢(râ¢logâ¡n)6/Îµ2).NRDÂ¯ğ‘…ğ‘›SPRğ‘…ğ‘›ğœ€ğ‘‚NRDÂ¯ğ‘…ğ‘›superscriptğ‘Ÿğ‘›6superscriptğœ€2\operatorname{NRD}(\overline{R},n)\leq\operatorname{SPR}(R,n,\varepsilon)\leq O% (\operatorname{NRD}(\overline{R},n)(r\log n)^{6}/\varepsilon^{2}).roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) â‰¤ roman_SPR ( italic_R , italic_n , italic_Îµ ) â‰¤ italic_O ( roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) ( italic_r roman_log italic_n ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . 1.3 Non-redundancy of specific relations The non-redundancy of relations is readily computed in some simple cases. For example, for the relation ORr:=Drâˆ–{0r}assignsubscriptORğ‘Ÿsuperscriptğ·ğ‘Ÿsuperscript0ğ‘Ÿ\operatorname{OR}_{r}:=D^{r}\setminus\{0^{r}\}roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT := italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT âˆ– { 0 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT }, we have that NRDâ¡(ORr,n)=Î˜â¢(nr)NRDsubscriptORğ‘Ÿğ‘›Î˜superscriptğ‘›ğ‘Ÿ\operatorname{NRD}(\operatorname{OR}_{r},n)=\Theta(n^{r})roman_NRD ( roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT , italic_n ) = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ). Indeed Y=(Xr)ğ‘Œbinomialğ‘‹ğ‘ŸY=\binom{X}{r}italic_Y = ( FRACOP start_ARG italic_X end_ARG start_ARG italic_r end_ARG ) is a non-redundant instance because setting all but rğ‘Ÿritalic_r variables to 1111 fails to satisfy exactly that rğ‘Ÿritalic_r-tuple (see [FK17, Car22, KPS24b]). When Rğ‘…Ritalic_R is affine, NRDâ¡(R,n)=Î˜â¢(n)NRDğ‘…ğ‘›Î˜ğ‘›\operatorname{NRD}(R,n)=\Theta(n)roman_NRD ( italic_R , italic_n ) = roman_Î˜ ( italic_n ), and when Rğ‘…Ritalic_R is defined as the zero set of a degree kğ‘˜kitalic_k polynomial, NRDâ¡(R,n)=Oâ¢(nk)NRDğ‘…ğ‘›ğ‘‚superscriptğ‘›ğ‘˜\operatorname{NRD}(R,n)=O(n^{k})roman_NRD ( italic_R , italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ); these follow from simple rank arguments (e.g., [LW20]). Via Theorem 1.2, these special cases (plus simple gadget reductions) already capture all the previously known upper and lower bounds for CSP sparsification (see Section 1.5 for more details on the CSP sparsification literature). Furthermore, there are also some non-trivial upper bounds known on NRD in the literature, which we can now import to sparsifiability for free courtesy Theorem 1.2. For instance, the so-called Malâ€™tsev relations, which generalize affine predicates (i.e., cosets) over Abelian groups, have been shown to have ODâ¢(n)subscriptğ‘‚ğ·ğ‘›O_{D}(n)italic_O start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_n ) non-redundancy [LW20, BCK20], and therefore by Theorem 1.2 their complements have near-linear sparsifiability. Carbonnel [Car22] showed that if Rğ‘…Ritalic_R is an arity rğ‘Ÿritalic_r relation that doesnâ€™t contain444See Theorem 5.2 for a precise definition. any copy of ORrsubscriptORğ‘Ÿ\operatorname{OR}_{r}roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT, then NRDâ¡(R,n)â‰¤Oâ¢(nrâˆ’Î´r)NRDğ‘…ğ‘›ğ‘‚superscriptğ‘›ğ‘Ÿsubscriptğ›¿ğ‘Ÿ\operatorname{NRD}(R,n)\leq O(n^{r-\delta_{r}})roman_NRD ( italic_R , italic_n ) â‰¤ italic_O ( italic_n start_POSTSUPERSCRIPT italic_r - italic_Î´ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) for Î´r=21âˆ’rsubscriptğ›¿ğ‘Ÿsuperscript21ğ‘Ÿ\delta_{r}=2^{1-r}italic_Î´ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT = 2 start_POSTSUPERSCRIPT 1 - italic_r end_POSTSUPERSCRIPT (the specific bound arises from a classic hypergraph TurÃ¡n result [Erd64]). By Theorem 1.2 this immediately implies SPRâ¡(RÂ¯,n,Îµ)â‰¤O~Îµâ¢(nrâˆ’Î´r)SPRÂ¯ğ‘…ğ‘›ğœ€subscript~ğ‘‚ğœ€superscriptğ‘›ğ‘Ÿsubscriptğ›¿ğ‘Ÿ\operatorname{SPR}(\overline{R},n,\varepsilon)\leq\widetilde{O}_{\varepsilon}(% n^{r-\delta_{r}})roman_SPR ( overÂ¯ start_ARG italic_R end_ARG , italic_n , italic_Îµ ) â‰¤ over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r - italic_Î´ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ), where O~â¢(â‹…)~ğ‘‚â‹…\widetilde{O}(\cdot)over~ start_ARG italic_O end_ARG ( â‹… ) hides polylogarithmic factors in nğ‘›nitalic_n, yielding an Î©â¢(nr)Î©superscriptğ‘›ğ‘Ÿ\Omega(n^{r})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ) vs O~â¢(nrâˆ’Î´r)~ğ‘‚superscriptğ‘›ğ‘Ÿsubscriptğ›¿ğ‘Ÿ\widetilde{O}(n^{r-\delta_{r}})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT italic_r - italic_Î´ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) dichotomy for sparsification of arity rğ‘Ÿritalic_r CSPs. (This was known for the Boolean case [KPS24b]; see the related work subsection.) The non-redundancy of a relation can in general be difficult to estimate. Thus while in principle Theorem 1.2 pins down the sparisifiability of every CSP, for specific relations, it can still be non-trivial to actually determine the asymptotic behavior of its sparsifiability. Our next set of results makes progress in this direction via novel methods to bound non-redundancy. Given that the non-redundancy of linear predicates is easy to pin down, we consider a natural family of relations which are very close to being linear. Specifically, let 3â¢Lâ¢Iâ¢NG={(x,y,z)âˆ£x+y+z=0}subscript3LINğºconditional-setğ‘¥ğ‘¦ğ‘§ğ‘¥ğ‘¦ğ‘§0\operatorname{3LIN}_{G}=\{(x,y,z)\mid x+y+z=0\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = { ( italic_x , italic_y , italic_z ) âˆ£ italic_x + italic_y + italic_z = 0 } over an Abelian group GğºGitalic_G, and consider 3â¢Lâ¢Iâ¢NGâˆ—=3â¢Lâ¢Iâ¢NGâˆ–{(0,0,0)}subscriptsuperscript3LINğºsubscript3LINğº000\operatorname{3LIN}^{*}_{G}=\operatorname{3LIN}_{G}\setminus\{(0,0,0)\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT âˆ– { ( 0 , 0 , 0 ) }. (We pick arity 3333 since the arity 2222 case is already fully resolved [FK17, BÅ½20].) Being defined by a linear equation over an Abelian group, we already know that NRDâ¡(3â¢Lâ¢Iâ¢NG,n)=Î˜Gâ¢(n)NRDsubscript3LINğºğ‘›subscriptÎ˜ğºğ‘›\operatorname{NRD}(\operatorname{3LIN}_{G},n)=\Theta_{G}(n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) = roman_Î˜ start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n ). However the non-redundancy of 3â¢Lâ¢Iâ¢NGâˆ—subscriptsuperscript3LINğº\operatorname{3LIN}^{*}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT seems challenging to understand. Existing methods in the literature only yield NRDâ¡(3â¢Lâ¢Iâ¢NGâˆ—,n)âˆˆ[Î©Gâ¢(n),OGâ¢(n2)]NRDsubscriptsuperscript3LINğºğ‘›subscriptÎ©ğºğ‘›subscriptğ‘‚ğºsuperscriptğ‘›2\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)\in[\Omega_{G}(n),O_{G}(n^{2})]roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) âˆˆ [ roman_Î© start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n ) , italic_O start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) ]. We introduce a new method for bounding the non-redundancy of predicates like 3â¢Lâ¢Iâ¢NGâˆ—subscriptsuperscript3LINğº\operatorname{3LIN}^{*}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT by connecting them to the theory of matching vector (MV) families [Yek08, DGY11] that have been used in the construction of locally decodable codes. Exploiting this connection, we construct a non-redundant instance to establish that NRDâ¡(3â¢Lâ¢Iâ¢NG,n)â‰¥Î©â¢(n1.5)NRDsubscript3LINğºğ‘›Î©superscriptğ‘›1.5\operatorname{NRD}(\operatorname{3LIN}_{G},n)\geq\Omega(n^{1.5})roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) â‰¥ roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) for all Abelian groups of order â‰¥3absent3\geq 3â‰¥ 3. Adapting ideas from the analysis of MV families together with some combinatorial ideas, we also prove an upper bound NRDâ¡(3â¢Lâ¢Iâ¢Nâ„¤/pâ¢â„¤,n)=O~pâ¢(n2âˆ’Îµp)NRDsubscript3LINâ„¤ğ‘â„¤ğ‘›subscript~ğ‘‚ğ‘superscriptğ‘›2subscriptğœ€ğ‘\operatorname{NRD}(\operatorname{3LIN}_{\mathbb{Z}/p\mathbb{Z}},n)=\widetilde{% O}_{p}(n^{2-\varepsilon_{p}})roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT blackboard_Z / italic_p blackboard_Z end_POSTSUBSCRIPT , italic_n ) = over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT 2 - italic_Îµ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) for Îµp=22â¢pâˆ’1subscriptğœ€ğ‘22ğ‘1\varepsilon_{p}=\tfrac{2}{2p-1}italic_Îµ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT = divide start_ARG 2 end_ARG start_ARG 2 italic_p - 1 end_ARG and pğ‘pitalic_p prime. Specializing for p=3ğ‘3p=3italic_p = 3, we have the following result, which also gives the first examples of relations whose non-redundancy and sparsifiability have a non-integral exponent. Theorem 1.3. We have NRDâ¡(3â¢Lâ¢Iâ¢Nâ„¤/3â¢â„¤âˆ—,n)NRDsubscriptsuperscript3LINâ„¤3â„¤ğ‘›\displaystyle\operatorname{NRD}(\operatorname{3LIN}^{*}_{\mathbb{Z}/3\mathbb{Z% }},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT , italic_n ) âˆˆ[Î©â¢(n1.5),O~â¢(n1.6)], andabsentÎ©superscriptğ‘›1.5~ğ‘‚superscriptğ‘›1.6 and\displaystyle\in[\Omega(n^{1.5}),\widetilde{O}(n^{1.6})],\ \ \ \text{ and }âˆˆ [ roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) , over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) ] , and SPRâ¡(3â¢Lâ¢Iâ¢Nâ„¤/3â¢â„¤âˆ—Â¯,n,Îµ)SPRÂ¯subscriptsuperscript3LINâ„¤3â„¤ğ‘›ğœ€\displaystyle\operatorname{SPR}(\overline{\operatorname{3LIN}^{*}_{\mathbb{Z}/% 3\mathbb{Z}}},n,\varepsilon)roman_SPR ( overÂ¯ start_ARG start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT end_ARG , italic_n , italic_Îµ ) âˆˆ[Î©â¢(n1.5),O~â¢(n1.6/Îµ2)].absentÎ©superscriptğ‘›1.5~ğ‘‚superscriptğ‘›1.6superscriptğœ€2\displaystyle\in[\Omega(n^{1.5}),\widetilde{O}(n^{1.6}/\varepsilon^{2})].âˆˆ [ roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) , over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) ] . 1.4 Weighted CSP sparsification The discussion so far has focused on unweighted CSP instances, and we now shift our focus to the weighted case, where each constraint of Yğ‘ŒYitalic_Y comes with a weight. We also get a tight characterization of weighted CSP sparsifiablity, in terms of a parameter called the chain length, which was defined by Lagerkvist and WahlstrÃ¶m [LW17, LW20] in the context of CSP kernelization and later utilized by Bessiere, Carbonnel, and Katsirelos [BCK20] in the context of learning CSPs in a certain query model (see Section 1.5 for more details on these connections). As before, the result is obtained in the setting of weighted non-linear codes, with the consequence for weighted CSPs being an easy corollary. We just state the result for codes here (see Section 8 for the full treatment of weighted CSPs). For weighted sparsification of a code CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, we might have an arbitrary input weighting Î¶:[m]â†’â„â‰¥0:ğœâ†’delimited-[]ğ‘šsubscriptâ„absent0\zeta:[m]\to\mathbb{R}_{\geq 0}italic_Î¶ : [ italic_m ] â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT of its coordinates, and we must find a sparsifier w~:[n]â†’â„â‰¥0:~ğ‘¤â†’delimited-[]ğ‘›subscriptâ„absent0\widetilde{w}:[n]\to\mathbb{R}_{\geq 0}over~ start_ARG italic_w end_ARG : [ italic_n ] â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT of low support that sparsifies Cğ¶Citalic_C with respect to the weighting Î¶ğœ\zetaitalic_Î¶, i.e., âŸ¨w~,câŸ©âˆˆ(1Â±Îµ)â¢âŸ¨Î¶,câŸ©~ğ‘¤ğ‘plus-or-minus1ğœ€ğœğ‘\langle\widetilde{w},c\rangle\in(1\pm\varepsilon)\langle\zeta,c\rangleâŸ¨ over~ start_ARG italic_w end_ARG , italic_c âŸ© âˆˆ ( 1 Â± italic_Îµ ) âŸ¨ italic_Î¶ , italic_c âŸ©. The minimum possible support of sparsifiers over all weightings Î¶ğœ\zetaitalic_Î¶ is called the weighted Îµğœ€\varepsilonitalic_Îµ-sparsity wSPRâ¡(C,Îµ)wSPRğ¶ğœ€\operatorname{wSPR}(C,\varepsilon)roman_wSPR ( italic_C , italic_Îµ ). Now we define chain length. If we line up the codewords of Cğ¶Citalic_C as rows of an |C|Ã—mğ¶ğ‘š|C|\times m| italic_C | Ã— italic_m matrix and allow arbitrary column permutations, the chain length of Cğ¶Citalic_C, denoted CLâ¡(C)CLğ¶\operatorname{CL}(C)roman_CL ( italic_C ), is the dimension of the largest upper triangular square submatrix with 1111â€™s on the diagonal.555In this view NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ) is the dimension of the largest identity submatrix, so clearly NRDâ¡(C)â‰¤CLâ¡(C)NRDğ¶CLğ¶\operatorname{NRD}(C)\leq\operatorname{CL}(C)roman_NRD ( italic_C ) â‰¤ roman_CL ( italic_C ). The quantity CLâ¡(C)CLğ¶\operatorname{CL}(C)roman_CL ( italic_C ) was called visible rank in [AG21] and served as a field independent lower bound on the rank of Cğ¶Citalic_C. In our main result for the weighted setting, we pin the sparsifiability of a weighted code to its chain length. Note that in the weighted case CLâ¡(C)CLğ¶\operatorname{CL}(C)roman_CL ( italic_C ) is also a lower bound. Theorem 1.4. For all CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT and Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 ), we have CLâ¡(C)â‰¤wSPRâ¡(C,Îµ)=Oâ¢(CLâ¡(C)â¢(logâ¡m)6/Îµ2).CLğ¶wSPRğ¶ğœ€ğ‘‚CLğ¶superscriptğ‘š6superscriptğœ€2\operatorname{CL}(C)\leq\operatorname{wSPR}(C,\varepsilon)=O(\operatorname{CL}% (C)(\log m)^{6}/\varepsilon^{2}).roman_CL ( italic_C ) â‰¤ roman_wSPR ( italic_C , italic_Îµ ) = italic_O ( roman_CL ( italic_C ) ( roman_log italic_m ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . The upper bound proceeds by using Theorem 1.1 as a black-box together with a geometric weight bucketing technique from [KPS24b]. The lower bound proceeds by applying an exponential sequence of weights to the indices i1,â€¦,iCLâ¡(C)âˆˆ[m]subscriptğ‘–1â€¦subscriptğ‘–CLğ¶delimited-[]ğ‘ši_{1},\ldots,i_{\operatorname{CL}{(C)}}\in[m]italic_i start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_i start_POSTSUBSCRIPT roman_CL ( italic_C ) end_POSTSUBSCRIPT âˆˆ [ italic_m ] forming a maximal chain. Of note, if for a particular set of weights, the ratio between maximum and minimal weights is Î»â‰ªexpâ¡(CLâ¡(C)/NRDâ¡(C))much-less-thanğœ†CLğ¶NRDğ¶\lambda\ll\exp(\operatorname{CL}(C)/\operatorname{NRD}(C))italic_Î» â‰ª roman_exp ( roman_CL ( italic_C ) / roman_NRD ( italic_C ) ), we get a sharper upper bound of O~Îµâ¢(NRDâ¡(C)â¢logâ¡Î»)subscript~ğ‘‚ğœ€NRDğ¶ğœ†\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\log\lambda)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log italic_Î» ) (see Corollary 8.18). We now transition to discussing the broader context of our work in the literature. 1.5 Related Work Our results and techniques have connections to many areas including computational complexity theory, extremal combinatorics, coding theory, and learning theory. We now give a general overview of these connections. CSP Sparsification. Since we already discussed the history of CSP sparsification, we give a comprehensive list of known results about CSP sparsification (up to polylog factors). â€¢ The case of binary CSPs (r=2ğ‘Ÿ2r=2italic_r = 2) is fully classified. In particular, for every finite domain Dğ·Ditalic_D and RâŠ†D2ğ‘…superscriptğ·2R\subseteq D^{2}italic_R âŠ† italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, we either have that SPRâ¡(R,n,Îµ)=Oâ¢(n/Îµ2)SPRğ‘…ğ‘›ğœ€ğ‘‚ğ‘›superscriptğœ€2\operatorname{SPR}(R,n,\varepsilon)=O(n/\varepsilon^{2})roman_SPR ( italic_R , italic_n , italic_Îµ ) = italic_O ( italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) or SPRâ¡(R,n,Îµ)=Î©â¢(n2)SPRğ‘…ğ‘›ğœ€Î©superscriptğ‘›2\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{2})roman_SPR ( italic_R , italic_n , italic_Îµ ) = roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) [BÅ½20]. However, the sparsification routine is only efficient in the Boolean case [FK17]. Of note, SPRâ¡(R,n,Îµ)=Î©â¢(n2)SPRğ‘…ğ‘›ğœ€Î©superscriptğ‘›2\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{2})roman_SPR ( italic_R , italic_n , italic_Îµ ) = roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) if and only if there exist D1,D2âŠ†Dsubscriptğ·1subscriptğ·2ğ·D_{1},D_{2}\subseteq Ditalic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âŠ† italic_D of size exactly 2222 such that |Râˆ©(D1Ã—D2)|=1ğ‘…subscriptğ·1subscriptğ·21|R\cap(D_{1}\times D_{2})|=1| italic_R âˆ© ( italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) | = 1 (informally Rğ‘…Ritalic_R has an â€œinduced copyâ€ of AND2subscriptAND2\operatorname{AND}_{2}roman_AND start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT). â€¢ For râ‰¥3ğ‘Ÿ3r\geq 3italic_r â‰¥ 3, much less is known. Kogan and Krauthgamer [KK15] contributed near-linear hypergraph cut sparsifiers (i.e., the predicate is NAEr:={0,1}râˆ–{0r,1r}assignsubscriptNAEğ‘Ÿsuperscript01ğ‘Ÿsuperscript0ğ‘Ÿsuperscript1ğ‘Ÿ\operatorname{NAE}_{r}:=\{0,1\}^{r}\setminus\{0^{r},1^{r}\}roman_NAE start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT := { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT âˆ– { 0 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT , 1 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT }). Since then, there have been multiple improvements in efficiently constructing hypergraph sparsifiers/sketches (e.g., [CKN20, KKTY21, KPS24c]). â€¢ The breakthroughs of Khanna, Putterman, and Sudan [KPS24a, KPS24b] construct non-linear sparsifiers for any predicate which can defined by a system of linear (in)equations (possibly over a higher domain). For example NAEr={xâˆˆ{0,1}r:x1+â‹¯+xrâ‰¢0modr}subscriptNAEğ‘Ÿconditional-setğ‘¥superscript01ğ‘Ÿnot-equivalent-tosubscriptğ‘¥1â‹¯subscriptğ‘¥ğ‘Ÿmodulo0ğ‘Ÿ\operatorname{NAE}_{r}=\{x\in\{0,1\}^{r}:x_{1}+\cdots+x_{r}\not\equiv 0\mod r\}roman_NAE start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT = { italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT : italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + â‹¯ + italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT â‰¢ 0 roman_mod italic_r }. Of note, their first paper [KPS24a] only proved the result over finite fields (and was nonalgorithmic), whereas their second paper [KPS24b] extended the result to all Abelian groups and was computationally efficient. â€¢ The framework of Khanna, Putterman, and Sudan [KPS24b] produced numerous corollaries. In particular, if a predicate can be expressed as the nonzero set of a degree kğ‘˜kitalic_k polynomial, then it has a sparsifier of size O~Îµâ¢(nk)subscript~ğ‘‚ğœ€superscriptğ‘›ğ‘˜\widetilde{O}_{\varepsilon}(n^{k})over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). Furthermore, they show if a predicate Rğ‘…Ritalic_R can express666More specifically, we say that RâŠ†{0,1}rğ‘…superscript01ğ‘ŸR\subseteq\{0,1\}^{r}italic_R âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT can express ANDksubscriptANDğ‘˜\operatorname{AND}_{k}roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT if there exits a map z:[r]â†’{0,1,x1,â€¦,xk,x1Â¯,â€¦,xkÂ¯}:ğ‘§â†’delimited-[]ğ‘Ÿ01subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜Â¯subscriptğ‘¥1â€¦Â¯subscriptğ‘¥ğ‘˜z:[r]\to\{0,1,x_{1},\ldots,x_{k},\overline{x_{1}},\ldots,\overline{x_{k}}\}italic_z : [ italic_r ] â†’ { 0 , 1 , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT , overÂ¯ start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_ARG , â€¦ , overÂ¯ start_ARG italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT end_ARG } such that Râ¢(zâ¢(1),â€¦,zâ¢(r))=ANDkâ¡(x1,â€¦,xk)ğ‘…ğ‘§1â€¦ğ‘§ğ‘ŸsubscriptANDğ‘˜subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜R(z(1),\ldots,z(r))=\operatorname{AND}_{k}(x_{1},\ldots,x_{k})italic_R ( italic_z ( 1 ) , â€¦ , italic_z ( italic_r ) ) = roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ). We discuss a more general framework of gadget reductions in Section 5.4. ANDk:={1k}assignsubscriptANDğ‘˜superscript1ğ‘˜\operatorname{AND}_{k}:=\{1^{k}\}roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT := { 1 start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT }, then SPRâ¡(R,n,Îµ)=Î©â¢(nk)SPRğ‘…ğ‘›ğœ€Î©superscriptğ‘›ğ‘˜\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{k})roman_SPR ( italic_R , italic_n , italic_Îµ ) = roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). As a consequence, they also classify all ternary Boolean predicates (r=3ğ‘Ÿ3r=3italic_r = 3) as well as which Boolean predicates of arity rğ‘Ÿritalic_r cannot be sparsified below Î©â¢(nr)Î©superscriptğ‘›ğ‘Ÿ\Omega(n^{r})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ) (just ANDrsubscriptANDğ‘Ÿ\operatorname{AND}_{r}roman_AND start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT and its bit flips), while also constructing a sparsifier of size O~Îµâ¢(nrâˆ’1)subscript~ğ‘‚ğœ€superscriptğ‘›ğ‘Ÿ1\widetilde{O}_{\varepsilon}(n^{r-1})over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r - 1 end_POSTSUPERSCRIPT ) in the other cases. â€¢ It appears that lower bounds with a nontrivial dependence on Îµğœ€\varepsilonitalic_Îµ are only known for cut sparsifiers (and thus hypergraph cut sparsifiers via a simple gadget reduction). See [ACK+16, CKST19] as well as Section 9 for further discussion. CSP Kernelization. Another question similar in spirit to CSP sparsification is that of CSP kernelization.777More commonly, CSP kernelization is referred to as CSP sparsification (e.g., [DvM14, LW20]). However, we refer to this line of work by the former name to reduce ambiguity. This similarity in name has been noted before in the literature (e.g., [BÅ½20]), but we appear to be the first work to notice both variants of â€œCSP sparsificationâ€ can be analyzed with similar techniques. The basic question is to, given an instance Î¨Î¨\Psiroman_Î¨ of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ), efficiently find as small of an instance Î¨â€²superscriptÎ¨â€²\Psi^{\prime}roman_Î¨ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) as possible (not necessarily a subinstance) such that Î¨Î¨\Psiroman_Î¨ and Î¨â€²superscriptÎ¨â€²\Psi^{\prime}roman_Î¨ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT are either both satisfiable or both unsatisfiable. This particular question can be attributed to Dell and van Melkebeek [DvM14], who were particularly inspired Impagliazzo, Paturi, and Zaneâ€™s sparsification lemma [IPZ01] and Harnik and Naorâ€™s compression framework [HN10]. See the literature review in [DvM14] for further motivations. At first, the problem seems rather unrelated to CSP sparsification. For example, if CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) is polynomial-time tractable, then there trivially exists a kernel of size Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 ). When CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) is NP-hard, however, the size of the smallest possible kernelization seems to much more closely track with the non-redundancy of Rğ‘…Ritalic_R. In particular, Dell and van Melkebeek [DvM14], proved that assuming ğ–¼ğ—ˆğ–­ğ–¯âŠˆğ–­ğ–¯/ğ—‰ğ—ˆğ—…ğ—’not-subset-of-nor-equalsğ–¼ğ—ˆğ–­ğ–¯ğ–­ğ–¯ğ—‰ğ—ˆğ—…ğ—’\mathsf{coNP}\nsubseteq\mathsf{NP/poly}sansserif_coNP âŠˆ sansserif_NP / sansserif_poly, the problem kğ‘˜kitalic_k-SAT cannot be kernelized below Î©â¢(nkâˆ’Îµ)Î©superscriptğ‘›ğ‘˜ğœ€\Omega(n^{k-\varepsilon})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_k - italic_Îµ end_POSTSUPERSCRIPT ) for any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, which is close to kğ‘˜kitalic_k-SATâ€™s non-redundancy of Î˜â¢(nk)Î˜superscriptğ‘›ğ‘˜\Theta(n^{k})roman_Î˜ ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). Furthermore, most upper bounds on the kernelization of NP-hard predicates follow from upper bounds on non-redundancy (see [Car22]). For example the works of Chen, Jansen, and Pieterse [CJP20] as well as Lagerkvist and WahlstrÃ¶m [LW17, LW20] develop various kernelization methods that happen to just be â€œefficientâ€ non-redundancy upper bounds. For example, these works show that if the predicate Rğ‘…Ritalic_R can be expressed as the zero set of a polynomial of degree kğ‘˜kitalic_k, then there exist a kernel of size Oâ¢(nk)ğ‘‚superscriptğ‘›ğ‘˜O(n^{k})italic_O ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). This kernel happens to preserve every solution to Rğ‘…Ritalic_R, so it is also a non-redundancy upper bound. Using techniques like these, they are able to prove a number of results similar to the state-of-the-art in CSP sparsification, such as a complete classification of ternary Boolean predicates and a Oâ¢(nrâˆ’1)ğ‘‚superscriptğ‘›ğ‘Ÿ1O(n^{r-1})italic_O ( italic_n start_POSTSUPERSCRIPT italic_r - 1 end_POSTSUPERSCRIPT ) vs Î©â¢(nrâˆ’Îµ)Î©superscriptğ‘›ğ‘Ÿğœ€\Omega(n^{r-\varepsilon})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_r - italic_Îµ end_POSTSUPERSCRIPT ) Boolean dichotomy [CJP20]. See [JP19, JW20, Jan20, Tak23, Beu21] and citations therein for related work. We seek to emphasize that any efficient CSP sparsification algorithm for CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) is by design a kernelization algorithm for CSPâ¡(RÂ¯)CSPÂ¯ğ‘…\operatorname{CSP}(\overline{R})roman_CSP ( overÂ¯ start_ARG italic_R end_ARG ) (since all codewords with weight 00 are preserved). As such, making Theorem 1.2 efficient would require explicitly proving that every CSP can be kernelized to (approximately) its non-redundancy, which is a significant open question in the CSP kernelization community (see [Car22]). See Section 1.7 and Section 9 for further discussion. The Union-closed Sets Conjecture. A family â„±â„±\mathcal{F}caligraphic_F of subsets of [n]delimited-[]ğ‘›[n][ italic_n ] is union-closed if A,Bâˆˆâ„±ğ´ğµâ„±A,B\in\mathcal{F}italic_A , italic_B âˆˆ caligraphic_F imply that AâˆªBâˆˆâ„±ğ´ğµâ„±A\cup B\in\mathcal{F}italic_A âˆª italic_B âˆˆ caligraphic_F. In 1979, Frankl [Fra95] conjectured that there always exists iâˆˆ[n]ğ‘–delimited-[]ğ‘›i\in[n]italic_i âˆˆ [ italic_n ] which appears in at least half of the sets of â„±â„±\mathcal{F}caligraphic_F. For decades, progress on the conjecture was minimal, with the best general result being that some iâˆˆ[n]ğ‘–delimited-[]ğ‘›i\in[n]italic_i âˆˆ [ italic_n ] appears in Î©â¢(1/log2â¡|â„±|)Î©1subscript2â„±\Omega(1/\log_{2}|\mathcal{F}|)roman_Î© ( 1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | caligraphic_F | ) of the sets [Kni94, WÃ³j99, Gil22]. However, in 2022, Gilmer [Gil22] shocked the combinatorics community by using an entropy-based approach to prove that some iâˆˆ[n]ğ‘–delimited-[]ğ‘›i\in[n]italic_i âˆˆ [ italic_n ] appears in 1/10011001/1001 / 100 of the sets. This immediately led to a large number of follow-up works refining Gilmerâ€™s entropy method [AHS22, CL22, Peb22, Saw23, Yu23, Cam22]. In particular, we can now replace â€˜1/10011001/1001 / 100â€™ with â€˜0.382â¢â€¦0.382â€¦0.382\ldots0.382 â€¦â€™, leaving Franklâ€™s conjecture (technically) still open. For our application to CSP sparsification, the entropy method used by Gilmer (and its subsequent refinements by many other reseachers) is the key idea needed to show that non-redundancy is essentially the optimal size for a CSP sparsifier. In particular, the improvement from 1/log2â¡|â„±|1subscript2â„±1/\log_{2}|\mathcal{F}|1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | caligraphic_F | to Î©â¢(1)Î©1\Omega(1)roman_Î© ( 1 ) is precisely the same â€œgainâ€ we utilize to go from a very simple O~Îµâ¢(NRDâ¡(C)â‹…log2â¡|C|)subscript~ğ‘‚ğœ€â‹…NRDğ¶subscript2ğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\cdot\log_{2}|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) â‹… roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C | ) sparsifier (see Section 3) to our O~Îµâ¢(NRDâ¡(C))subscript~ğ‘‚ğœ€NRDğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C))over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ) sparsifier. See the technical overview (Section 1.6) for more details. To the best of our knowledge, our work is the first application of Gilmerâ€™s entropy method to sparsification.888Gilmerâ€™s breakthough is cited in the literature review of [CDL+24], but the property-testing question they study on union-closed families has no technical connection to Gilmerâ€™s entropy method. See also [Wak24] for applications of the entropy method to learning theory and statistical physics. Matching Vector Families and Locally Decodable Codes. In coding theory, locally decodable codes (LDCs) are a class of codes which allow for jthe reliable recovery of any message symbol based on a small sample of codeword symbols, even in the presence of a constant fraction of errors. A particularly interesting familiy of constructions of LDCs has arisen out of a theory of matching vector codes [Yek08] and follow-ups [Rag07, Gop09, Efr09, DGY11]. See [DGY11] for a literature survey. Simply stated, a matching vector (MV) family over a (finite) ring â„›â„›\mathcal{R}caligraphic_R is a pair of lists of vectors u1,â€¦,uk,v1,â€¦,vkâˆˆâ„›dsubscriptğ‘¢1â€¦subscriptğ‘¢ğ‘˜subscriptğ‘£1â€¦subscriptğ‘£ğ‘˜superscriptâ„›ğ‘‘u_{1},\ldots,u_{k},v_{1},\ldots,v_{k}\in\mathcal{R}^{d}italic_u start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_u start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_v start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT âˆˆ caligraphic_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT such that the inner products âŸ¨ui,vjâŸ©subscriptğ‘¢ğ‘–subscriptğ‘£ğ‘—\langle u_{i},v_{j}\rangleâŸ¨ italic_u start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT âŸ© are nonzero999Or, more generally the inner products lie in some restricted subset of â„›â„›\mathcal{R}caligraphic_R. if and only iâ‰ jğ‘–ğ‘—i\neq jitalic_i â‰  italic_j. Informally, the uisubscriptğ‘¢ğ‘–u_{i}italic_u start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPTâ€™s play a role in the encoding of the iğ‘–iitalic_iâ€™th message symbol, with the matching vector visubscriptğ‘£ğ‘–v_{i}italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT helping with its local decoding. Given a choice of â„›â„›\mathcal{R}caligraphic_R and dğ‘‘ditalic_d, the primary question of interest is to find the maximal possible value of kğ‘˜kitalic_k. This â€œspin offâ€ question about LDCs has become a topic of interest in its own right [DGY11, Yek12, GHSY12, BDL13]. In this work, we demonstrate a novel application of matching vector families to the study of non-redundancy and thus (by Theorem 1.2) sparsification. In particular, we construct an explicit family of predicates such that their non-redundant instances can be viewed as a generalized MV family. We then use techniques developed for MV families to given nontrivial bounds on the non-redundancy of the predicates. See Section 6 and the technical overview (Section 1.6) for more details. Extremal Combinatorics. Computing the non-redundancy of a predicate can be viewed as a problem in extremal combinatorics known as a hypergraph TurÃ¡n problem. In particular, for an instance of a CSP to be non-redundant, every instance induced by a subset of the variables must also be non-redundant. In particular, if â„±â„±\mathcal{F}caligraphic_F is a family of hypergraphs which can never appear in non-redundant instances of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ), then NRDâ¡(R,n)â‰¤exrâ¡(n,â„±)NRDğ‘…ğ‘›subscriptexğ‘Ÿğ‘›â„±\operatorname{NRD}(R,n)\leq\operatorname{ex}_{r}(n,\mathcal{F})roman_NRD ( italic_R , italic_n ) â‰¤ roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ), where the hypergraph TurÃ¡n number exrâ¡(n,â„±)subscriptexğ‘Ÿğ‘›â„±\operatorname{ex}_{r}(n,\mathcal{F})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) is the size of the largest rğ‘Ÿritalic_r-uniform hypergraph on nğ‘›nitalic_n vertices without any Fâˆˆâ„±ğ¹â„±F\in\mathcal{F}italic_F âˆˆ caligraphic_F as a subgraph. This observation was first made explicit by Carbonnel [Car22] although the technique was also used in earlier work [BCK20]. As far as we are aware, ours is the first work to observe that these insights can also benefit the study of CSP sparsification. The literature on hypergraph TurÃ¡n numbers is quite rich. For instance, Keevash [Kee11] surveys the vast body of work on the â€œnon-degenerateâ€ case in which exrâ¡(n,â„±)=Î©râ¢(nr)subscriptexğ‘Ÿğ‘›â„±subscriptÎ©ğ‘Ÿsuperscriptğ‘›ğ‘Ÿ\operatorname{ex}_{r}(n,\mathcal{F})=\Omega_{r}(n^{r})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) = roman_Î© start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ). However, for our applications, we are mostly interested in the â€œdenegerateâ€ case in which exrâ¡(n,â„±)=Oâ¢(nc)subscriptexğ‘Ÿğ‘›â„±ğ‘‚superscriptğ‘›ğ‘\operatorname{ex}_{r}(n,\mathcal{F})=O(n^{c})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) = italic_O ( italic_n start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT ) for some câˆˆ[1,r)ğ‘1ğ‘Ÿc\in[1,r)italic_c âˆˆ [ 1 , italic_r ). The works [BCK20, Car22] apply some of the most well-known works in this setting [Erd64, SEB73, RS78] to get some nontrivial results such as classifying precisely which predicates Rğ‘…Ritalic_R have NRDâ¡(R,n)=Î˜â¢(nr)NRDğ‘…ğ‘›Î˜superscriptğ‘›ğ‘Ÿ\operatorname{NRD}(R,n)=\Theta(n^{r})roman_NRD ( italic_R , italic_n ) = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ), extending Chen, Jansen, and Pieterseâ€™s result for the Boolean case [CJP20]. See Sections 5.2, 7.1, and 8.4.2 for more details on specific applications. Query Complexity and Learning Theory. Rather surprisingly, the definition of non-redundancy appears to have come out of the artificial intelligence community [BCK20]. In particular, a rather broad and well-studied question (e.g., [FW02, PBS08, LLMV10, BK12, BCH+13, BCK20]) is that of constraint acquisition: how can an agent learn the constraints defining an instance of a constraint satisfaction problem? A model specifically relevant to our work is the partial membership queries model studied by Bessiere, Carbonnel, and Katsirelos [BCK20]. In this model, the domain Dğ·Ditalic_D, the constraint type Rğ‘…Ritalic_R (or types), and the set of variables Xğ‘‹Xitalic_X are known but the constraints are hidden. For each query, the agent picks some subset of variables Xâ€²âŠ†Xsuperscriptğ‘‹â€²ğ‘‹X^{\prime}\subseteq Xitalic_X start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âŠ† italic_X as well as a partial assignment Ïƒ:Xâ€²â†’D:ğœâ†’superscriptğ‘‹â€²ğ·\sigma:X^{\prime}\to Ditalic_Ïƒ : italic_X start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT â†’ italic_D. The response to the query is â€˜YESâ€™ if Ïƒğœ\sigmaitalic_Ïƒ satisfies every constraint induced by Xâ€²superscriptğ‘‹â€²X^{\prime}italic_X start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, and â€˜NOâ€™ otherwise. The goal is to construct an instance of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) with the same solution set as the hidden CSP. For every CSP predicate Rğ‘…Ritalic_R, they prove that the query complexity of an instance of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) on nğ‘›nitalic_n variables is bounded between Î©â¢(NRDâ¡(R,n))Î©NRDğ‘…ğ‘›\Omega(\operatorname{NRD}(R,n))roman_Î© ( roman_NRD ( italic_R , italic_n ) ) and Oâ¢(CLâ¡(R,n)â‹…logâ¡n)ğ‘‚â‹…CLğ‘…ğ‘›ğ‘›O(\operatorname{CL}(R,n)\cdot\log n)italic_O ( roman_CL ( italic_R , italic_n ) â‹… roman_log italic_n ). Notably, the lower bound is proved by showing that the VC dimension of the query complexity problem equals NRDâ¡(R,n)NRDğ‘…ğ‘›\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ).101010This observation is directly used in proving our main result, see Section 4.1. 1.6 Technical Overview We next describe the primary techniques we use to prove Theorem 1.1 and Theorem 1.3. A Simple Sparsifier. To begin, we discuss a warm-up version of Theorem 1.1 which proves a weaker upper bound of SPRâ¡(C,Îµ)â‰¤O~Îµâ¢(NRDâ¡(C)â‹…logâ¡|C|)SPRğ¶ğœ€subscript~ğ‘‚ğœ€â‹…NRDğ¶ğ¶\operatorname{SPR}(C,\varepsilon)\leq\widetilde{O}_{\varepsilon}(\operatorname% {NRD}(C)\cdot\log|C|)roman_SPR ( italic_C , italic_Îµ ) â‰¤ over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) â‹… roman_log | italic_C | ) (see Theorem 3.1), which for CSPs corresponds to an extra factor of the number of variables nğ‘›nitalic_n. The key technical insight (Lemma 3.3) is that for all dâˆˆ[m]ğ‘‘delimited-[]ğ‘šd\in[m]italic_d âˆˆ [ italic_m ], the set of codewords of Cğ¶Citalic_C with Hamming weight at most dğ‘‘ditalic_d (denoted by Câ‰¤dsubscriptğ¶absentğ‘‘C_{\leq d}italic_C start_POSTSUBSCRIPT â‰¤ italic_d end_POSTSUBSCRIPT) has total support size at most dâ‹…NRDâ¡(C)â‹…ğ‘‘NRDğ¶d\cdot\operatorname{NRD}(C)italic_d â‹… roman_NRD ( italic_C ). This can proved inductively by noticing that dropping a suitable non-redundant set of coordinates decreases the Hamming weight of every codeword of Cğ¶Citalic_C by at least one. With this lemma, we can recursively construct a sparsifier as follows, similar to the divide-and-conquer framework in [KPS24a, KPS24b] for linear codes. Pick dâ‰ˆÎ˜~Îµâ¢(logâ¡|C|)ğ‘‘subscript~Î˜ğœ€ğ¶d\approx\widetilde{\Theta}_{\varepsilon}(\log|C|)italic_d â‰ˆ over~ start_ARG roman_Î˜ end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_log | italic_C | ) and let IâŠ†[m]ğ¼delimited-[]ğ‘šI\subseteq[m]italic_I âŠ† [ italic_m ] be the support of Câ‰¤dsubscriptğ¶absentğ‘‘C_{\leq d}italic_C start_POSTSUBSCRIPT â‰¤ italic_d end_POSTSUBSCRIPT. Every iâˆˆIğ‘–ğ¼i\in Iitalic_i âˆˆ italic_I is given weight 1111 in our sparsifier. For the rest of [m]delimited-[]ğ‘š[m][ italic_m ], let JâŠ†[m]âˆ–Iğ½delimited-[]ğ‘šğ¼J\subseteq[m]\setminus Iitalic_J âŠ† [ italic_m ] âˆ– italic_I be a subsample where each iâˆˆ[m]âˆ–Iğ‘–delimited-[]ğ‘šğ¼i\in[m]\setminus Iitalic_i âˆˆ [ italic_m ] âˆ– italic_I is kept independently with probability 1/3131/31 / 3. Using a standard Chernoff bound, we can show that with positive111111We only need positive probability since we are focused on existence. This can easily be amplified to 1âˆ’1/mÎ©â¢(1)11superscriptğ‘šÎ©11-1/m^{\Omega(1)}1 - 1 / italic_m start_POSTSUPERSCRIPT roman_Î© ( 1 ) end_POSTSUPERSCRIPT probability by making dğ‘‘ditalic_d a factor of logâ¡mğ‘š\log mroman_log italic_m bigger. In applications to CSPs, the main algorithmic bottleneck is (approximately) finding Iğ¼Iitalic_I, which appears to be similar in difficulty to an open problem in CSP kernelization (see Section 1.7). probability the following holds for all câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C: 3â¢Hamâ¡(c|J)+Hamâ¡(c|I)âˆˆ[1âˆ’Îµ2â¢log2â¡m,1+Îµ2â¢log2â¡m]â‹…Hamâ¡(c).3Hamevaluated-atğ‘ğ½Hamevaluated-atğ‘ğ¼â‹…1ğœ€2subscript2ğ‘š1ğœ€2subscript2ğ‘šHamğ‘3\operatorname{Ham}(c|_{J})+\operatorname{Ham}(c|_{I})\in\left[1-\frac{% \varepsilon}{2\log_{2}m},1+\frac{\varepsilon}{2\log_{2}m}\right]\cdot% \operatorname{Ham}(c).3 roman_Ham ( italic_c | start_POSTSUBSCRIPT italic_J end_POSTSUBSCRIPT ) + roman_Ham ( italic_c | start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT ) âˆˆ [ 1 - divide start_ARG italic_Îµ end_ARG start_ARG 2 roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m end_ARG , 1 + divide start_ARG italic_Îµ end_ARG start_ARG 2 roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m end_ARG ] â‹… roman_Ham ( italic_c ) . By induction, we can find a O~Îµâ€²â¢(NRDâ¡(Câ€²)â‹…logâ¡|Câ€²|)subscript~ğ‘‚superscriptğœ€â€²â‹…NRDsuperscriptğ¶â€²superscriptğ¶â€²\widetilde{O}_{\varepsilon^{\prime}}(\operatorname{NRD}(C^{\prime})\cdot\log|C% ^{\prime}|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( roman_NRD ( italic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) â‹… roman_log | italic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT | ) Îµâ€²superscriptğœ€â€²\varepsilon^{\prime}italic_Îµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT-sparsifier for Câ€²:=C|Jassignsuperscriptğ¶â€²evaluated-atğ¶ğ½C^{\prime}:=C|_{J}italic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT := italic_C | start_POSTSUBSCRIPT italic_J end_POSTSUBSCRIPT with Îµâ€²:=(1âˆ’1/log2â¡m)â¢Îµassignsuperscriptğœ€â€²11subscript2ğ‘šğœ€\varepsilon^{\prime}:=(1-1/\log_{2}m)\varepsilonitalic_Îµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT := ( 1 - 1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m ) italic_Îµ. Scaling this sparsifier by 3333 and adding weights for Iğ¼Iitalic_I gives us an Îµğœ€\varepsilonitalic_Îµ-sparsifier of Cğ¶Citalic_C. Entropy-based Sparsification. The key inefficiency of the O~Îµâ¢(NRDâ¡(C)â‹…logâ¡|C|)subscript~ğ‘‚ğœ€â‹…NRDğ¶ğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\cdot\log|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) â‹… roman_log | italic_C | ) bound is that the use of Lemma 3.3 is too conservative. For the purposes of this overview, assume that all codewords of Cğ¶Citalic_C have the same Hamming weight dâ‰ˆNRDâ¡(C)ğ‘‘NRDğ¶d\approx\operatorname{NRD}(C)italic_d â‰ˆ roman_NRD ( italic_C ) as that is is the most representative case. Naively, Lemma 3.3 says we should set aside d2superscriptğ‘‘2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT coordinates of [m]delimited-[]ğ‘š[m][ italic_m ] to â€œsparsifyâ€ all codewords of weight dğ‘‘ditalic_d. However, we can give a heuristic argument that far fewer than d2superscriptğ‘‘2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT of these potential coordinates contain useful information for our sparsifier. Assume without loss of generality that the support of Cğ¶Citalic_C lies in [d2]delimited-[]superscriptğ‘‘2[d^{2}][ italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ]. For each iâˆˆ[d2]ğ‘–delimited-[]superscriptğ‘‘2i\in[d^{2}]italic_i âˆˆ [ italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ], let pisubscriptğ‘ğ‘–p_{i}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT be the probability that a codeword câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C selected uniformly at random has ci=1subscriptğ‘ğ‘–1c_{i}=1italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = 1. Since each codeword of Cğ¶Citalic_C has Hamming weight dğ‘‘ditalic_d, we have that p1+â‹¯+pd2=dsubscriptğ‘1â‹¯subscriptğ‘superscriptğ‘‘2ğ‘‘p_{1}+\cdots+p_{d^{2}}=ditalic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + â‹¯ + italic_p start_POSTSUBSCRIPT italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUBSCRIPT = italic_d. Thus, the average value of pisubscriptğ‘ğ‘–p_{i}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is 1/d1ğ‘‘1/d1 / italic_d. Consider the case in which each pi=Oâ¢(1/d)subscriptğ‘ğ‘–ğ‘‚1ğ‘‘p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ). In particular, no coordinate is distinguishing itself as a â€œmustâ€ to add to the sparsifier. A priori, the size of Cğ¶Citalic_C may be expâ¡(Î©~â¢(d))~Î©ğ‘‘\exp(\widetilde{\Omega}(d))roman_exp ( over~ start_ARG roman_Î© end_ARG ( italic_d ) ), so we cannot immediately use Chernoff bounds to analyze a random subsampling of the coordinates. To get around this issue, we need to prove a much stronger upper bound on the size of Cğ¶Citalic_C, similar to BenczÃºr and Kargerâ€™s cut-counting bound [BK96] and its adaptation to linear codes [KPS24a, KPS24b]. However, we use an entirely new method for proving such bounds based on the entropy method Gilmer [Gil22] developed to prove the union-closed sets conjecture up to a constant factor. In our context, pick t=Î˜~â¢(d)ğ‘¡~Î˜ğ‘‘t=\widetilde{\Theta}(d)italic_t = over~ start_ARG roman_Î˜ end_ARG ( italic_d ) and sample uniformly and independently tğ‘¡titalic_t codewords c1,â€¦,ctâˆˆCsubscriptğ‘1â€¦subscriptğ‘ğ‘¡ğ¶c_{1},\ldots,c_{t}\in Citalic_c start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_c start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT âˆˆ italic_C. Let cğ‘citalic_c be the bitwise OR of these tğ‘¡titalic_t codewords, and let ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D be the distribution of cğ‘citalic_c over {0,1}d2superscript01superscriptğ‘‘2\{0,1\}^{d^{2}}{ 0 , 1 } start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT (recall that the weight dğ‘‘ditalic_d codewords are supported on d2superscriptğ‘‘2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT coordinates). Since each pi=Oâ¢(1/d)subscriptğ‘ğ‘–ğ‘‚1ğ‘‘p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ), by adapting Gilmerâ€™s method (or more precisely, a refinement due to Sawin [Saw23]), we can show the entropy of ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is at least Î˜~â¢(t)=Î˜~â¢(d)~Î˜ğ‘¡~Î˜ğ‘‘\widetilde{\Theta}(t)=\widetilde{\Theta}(d)over~ start_ARG roman_Î˜ end_ARG ( italic_t ) = over~ start_ARG roman_Î˜ end_ARG ( italic_d ) times the entropy of the uniform distribution over Cğ¶Citalic_C (i.e., log2â¡|C|subscript2ğ¶\log_{2}|C|roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C |)â€“a similar inequality appears in [Wak24]. To apply this fact, observe that each sample of ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D lies in the â€œOROR\operatorname{OR}roman_OR-closureâ€ of Cğ¶Citalic_C (denoted by spanORâ¡(C)subscriptspanORğ¶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C )). As such, the entropy of ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is at most logâ¡|spanORâ¡(C)|subscriptspanORğ¶\log\lvert\operatorname{span}_{\operatorname{OR}}(C)\rvertroman_log | roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ) |, which by the Sauer-Shelah-Peres lemma is at most (up to log factors) the VC dimension of spanORâ¡(C)subscriptspanORğ¶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ). It is easily seen that the VC dimension of spanORâ¡(C)subscriptspanORğ¶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ) equals the non-redundancy of Cğ¶Citalic_C [BCK20]. Therefore, we have proved that Î˜~â¢(t)â‹…log2â¡(C)â‰¤O~â¢(NRDâ¡(C))â‹…~Î˜ğ‘¡subscript2ğ¶~ğ‘‚NRDğ¶\widetilde{\Theta}(t)\cdot\log_{2}(C)\leq\widetilde{O}(\operatorname{NRD}(C))over~ start_ARG roman_Î˜ end_ARG ( italic_t ) â‹… roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_C ) â‰¤ over~ start_ARG italic_O end_ARG ( roman_NRD ( italic_C ) ). Since tâ‰ˆdâ‰ˆNRDâ¡(C)ğ‘¡ğ‘‘NRDğ¶t\approx d\approx\operatorname{NRD}(C)italic_t â‰ˆ italic_d â‰ˆ roman_NRD ( italic_C ), Cğ¶Citalic_C is actually at most quasipolynomial in size! Thus we can now use a Chernoff bound to prove that Cğ¶Citalic_C can be subsampled to O~Îµâ¢(d)subscript~ğ‘‚ğœ€ğ‘‘\widetilde{O}_{\varepsilon}(d)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( italic_d ) coordinates while approximately preserving all Hamming weights. Recall this discussion was purely about the â€œuniformâ€ case pi=Oâ¢(1/d)subscriptğ‘ğ‘–ğ‘‚1ğ‘‘p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ). In general, we apply minimax theorem to prove the following â€œskewedâ€ versus â€œsparseâ€ dichotomy (see Proposition 4.14): for every code Cğ¶Citalic_C and parameter choice Î¸â‰¥1ğœƒ1\theta\geq 1italic_Î¸ â‰¥ 1 there is either a probability distribution ğ’«ğ’«\mathcal{P}caligraphic_P over Cğ¶Citalic_C for which each coordinate equals 1111 with probability at most 1/Î¸1ğœƒ1/\theta1 / italic_Î¸ (i.e., ğ’«ğ’«\mathcal{P}caligraphic_P is â€œÎ¸ğœƒ\thetaitalic_Î¸-sparseâ€); or, there is a probability distribution ğ’¬ğ’¬\mathcal{Q}caligraphic_Q over the coordinates of Cğ¶Citalic_C such that for every (nonzero) câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C, we have that ğ’¬ğ’¬\mathcal{Q}caligraphic_Qâ€™s measure of suppâ¡(c)suppğ‘\operatorname{supp}(c)roman_supp ( italic_c ) is at least 1/Î¸1ğœƒ1/\theta1 / italic_Î¸ (i.e., ğ’¬ğ’¬\mathcal{Q}caligraphic_Q is a â€œÎ¸ğœƒ\thetaitalic_Î¸-cover.â€) For a suitable choice of Î¸ğœƒ\thetaitalic_Î¸, we repeatedly apply Proposition 4.14 to recursively build the sparsifier: in the Î¸ğœƒ\thetaitalic_Î¸-sparse case, we use the entropy method to prove that a â€œsmallâ€ number of codewords of Cğ¶Citalic_C can be removed to put us in the Î¸ğœƒ\thetaitalic_Î¸-cover case (see Lemma 4.15); and in the Î¸ğœƒ\thetaitalic_Î¸-cover case, we sample from the Î¸ğœƒ\thetaitalic_Î¸-cover to get a coordinate to add to our sparsifier. This procedure culminates in showing that we can set aside O~Îµâ¢(NRDâ¡(C))subscript~ğ‘‚ğœ€NRDğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C))over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ) coordinates to have weight 1111 in our sparsifier with the remainder of the code being sufficiently sparse that subsampling can be used (Theorem 4.16). Note that the statement of Theorem 4.16 resembles the analogous decompositions for linear codes [KPS24a, KPS24b]. However, their method found all the coordinates to set aside in â€œone pass,â€ whereas we iteratively understand the dense and sparse structure of our non-linear code. With Theorem 4.16 in hand, we construct the sparsifier with a recursive argument similar to that of Theorem 3.1. As mentioned earlier, extended these ideas to weighted sparsification (Theorem 1.4) is relatively straightforward. We adapt a weight-binning argument of [KPS24b] by essentially computing an (unweighted) sparsifier for each group of coordinates that is similar in weight (within polyâ¡(m)polyğ‘š\operatorname{poly}(m)roman_poly ( italic_m )). We then analyze the aggregated size of these sparsifiers by comparing the sum of the non-redundancies of the groups of coordinates to the chain length of the code. Connections to Matching Vector Families. We now switch gears to briefly discussing the key ideas behind Theorem 1.3. Let G:=â„¤/3â¢â„¤assignğºâ„¤3â„¤G:=\mathbb{Z}/3\mathbb{Z}italic_G := blackboard_Z / 3 blackboard_Z and recall that 3â¢Lâ¢Iâ¢NG={(x,y,z)âˆ£x+y+z=0}subscript3LINğºconditional-setğ‘¥ğ‘¦ğ‘§ğ‘¥ğ‘¦ğ‘§0\operatorname{3LIN}_{G}=\{(x,y,z)\mid x+y+z=0\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = { ( italic_x , italic_y , italic_z ) âˆ£ italic_x + italic_y + italic_z = 0 } and 3â¢Lâ¢Iâ¢NGâˆ—=3â¢Lâ¢Iâ¢NGâˆ–{(0,0,0)}subscriptsuperscript3LINğºsubscript3LINğº000\operatorname{3LIN}^{*}_{G}=\operatorname{3LIN}_{G}\setminus\{(0,0,0)\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT âˆ– { ( 0 , 0 , 0 ) }. It is well-known that since 3â¢Lâ¢Iâ¢NGsubscript3LINğº\operatorname{3LIN}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT is an affine predicate, we have that NRDâ¡(3â¢Lâ¢Iâ¢NG,n)=Î˜â¢(n)NRDsubscript3LINğºğ‘›Î˜ğ‘›\operatorname{NRD}(\operatorname{3LIN}_{G},n)=\Theta(n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) = roman_Î˜ ( italic_n ), which is much smaller than our bound on NRDâ¡(3â¢Lâ¢Iâ¢NGâˆ—,n)NRDsubscriptsuperscript3LINğºğ‘›\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ). As such, we prove that to understand the asymptotics of NRDâ¡(3â¢Lâ¢Iâ¢NGâˆ—,n)NRDsubscriptsuperscript3LINğºğ‘›\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) it suffices to look at specially-structured non-redundant instances. Recall that an instance Î¨:=(X,Y)assignÎ¨ğ‘‹ğ‘Œ\Psi:=(X,Y)roman_Î¨ := ( italic_X , italic_Y ) of CSPâ¡(3â¢Lâ¢Iâ¢NGâˆ—)CSPsubscriptsuperscript3LINğº\operatorname{CSP}(\operatorname{3LIN}^{*}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) is non redundant if for every clause yâˆˆYğ‘¦ğ‘Œy\in Yitalic_y âˆˆ italic_Y there is an assignment Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT which satisfies every clause of Î¨Î¨\Psiroman_Î¨ except yğ‘¦yitalic_y. We show that with at most an additive Î˜â¢(n)Î˜ğ‘›\Theta(n)roman_Î˜ ( italic_n ) change in size, we can assume that Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT maps yğ‘¦yitalic_y to (0,0,0)000(0,0,0)( 0 , 0 , 0 ). In other words, each Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT is a satisfying assignment to Î¨Î¨\Psiroman_Î¨ when viewed as an instance of CSPâ¡(3â¢Lâ¢Iâ¢NG)CSPsubscript3LINğº\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) (see Proposition 6.3). This idea of â€œconditionalâ€ non-redundancy abstracts and generalizes an approach from [BCK20]. Since the set of solutions to an instance of CSPâ¡(3â¢Lâ¢Iâ¢NG)CSPsubscript3LINğº\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) form a vector space (of some dimension, say dğ‘‘ditalic_d) over ğ”½3subscriptğ”½3\mathbb{F}_{3}blackboard_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT, we can think of each variable xâˆˆXğ‘¥ğ‘‹x\in Xitalic_x âˆˆ italic_X of Î¨Î¨\Psiroman_Î¨ as a vector vxâˆˆğ”½3dsubscriptğ‘£ğ‘¥superscriptsubscriptğ”½3ğ‘‘v_{x}\in\mathbb{F}_{3}^{d}italic_v start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT âˆˆ blackboard_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT and the assignments as linear maps on the vectors. Because we are studying satisfying assignment to CSPâ¡(3â¢Lâ¢Iâ¢NG)CSPsubscript3LINğº\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ), these vectors are highly structured: for each y:=(x1,x2,x3)âˆˆYassignğ‘¦subscriptğ‘¥1subscriptğ‘¥2subscriptğ‘¥3ğ‘Œy:=(x_{1},x_{2},x_{3})\in Yitalic_y := ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ) âˆˆ italic_Y, we have that vx1+vx2+vx3=0subscriptğ‘£subscriptğ‘¥1subscriptğ‘£subscriptğ‘¥2subscriptğ‘£subscriptğ‘¥30v_{x_{1}}+v_{x_{2}}+v_{x_{3}}=0italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT + italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT + italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = 0. Further, Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT can be viewed as a linear map taking each of vx1,vx2,vx3subscriptğ‘£subscriptğ‘¥1subscriptğ‘£subscriptğ‘¥2subscriptğ‘£subscriptğ‘¥3v_{x_{1}},v_{x_{2}},v_{x_{3}}italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_POSTSUBSCRIPT to 00, while mapping at least one vector in every other triple in Yğ‘ŒYitalic_Y to a nonzero value. We call this family of vectors together with these assignments a GğºGitalic_G-ensemble (Definition 6.5), and note that it bears a strong resemblance to matching vector families. In particular, we adapt techniques used by Dvir, Gopalan, and Yekhanin [DGY11] for constraining the size of matching vector families to give nontrivial upper and lower bounds on the size of GğºGitalic_G-ensembles. For the lower bound (Theorem 6.8), we directly construct a non-redundant instance with Î©â¢(n1.5)Î©superscriptğ‘›1.5\Omega(n^{1.5})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) clauses. The proof is self-contained and elementary. The upper bound (Theorem 6.13) is slightly more technical. We break the proof into cases based on whether the embedding dimension dğ‘‘ditalic_d of the vectors is small (d=O~â¢(n0.4)ğ‘‘~ğ‘‚superscriptğ‘›0.4d=\widetilde{O}(n^{0.4})italic_d = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 0.4 end_POSTSUPERSCRIPT )) or large (d=Î©~â¢(n0.4)ğ‘‘~Î©superscriptğ‘›0.4d=\widetilde{\Omega}(n^{0.4})italic_d = over~ start_ARG roman_Î© end_ARG ( italic_n start_POSTSUPERSCRIPT 0.4 end_POSTSUPERSCRIPT )). For small dğ‘‘ditalic_d, we adapt the polynomial method used in [DGY11] to prove there can be at most Oâ¢(d4)=O~â¢(n1.6)ğ‘‚superscriptğ‘‘4~ğ‘‚superscriptğ‘›1.6O(d^{4})=\widetilde{O}(n^{1.6})italic_O ( italic_d start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) non-redundant clauses. On the other hand, when dğ‘‘ditalic_d is large, we ignore the assignments Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT and use a careful induction (Lemma 6.11) to show that the geometry of the vectors imply that some xâˆˆXğ‘¥ğ‘‹x\in Xitalic_x âˆˆ italic_X is a member of at most O~â¢(n/d)=O~â¢(n0.6)~ğ‘‚ğ‘›ğ‘‘~ğ‘‚superscriptğ‘›0.6\widetilde{O}(n/d)=\widetilde{O}(n^{0.6})over~ start_ARG italic_O end_ARG ( italic_n / italic_d ) = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 0.6 end_POSTSUPERSCRIPT ) clauses, thereby leading to a bound of at most O~â¢(n1.6)~ğ‘‚superscriptğ‘›1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) clauses total. Closing the gap between Î©â¢(n1.5)Î©superscriptğ‘›1.5\Omega(n^{1.5})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) and O~â¢(n1.6)~ğ‘‚superscriptğ‘›1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) for NRDâ¡(3â¢Lâ¢Iâ¢Nâ„¤/3â¢â„¤âˆ—,n)NRDsuperscriptsubscript3LINâ„¤3â„¤ğ‘›\operatorname{NRD}(\operatorname{3LIN}_{\mathbb{Z}/3\mathbb{Z}}^{*},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT , italic_n ) is a tantalizing open question. 1.7 Open Questions We conclude the introduction with a few directions of further study. See Section 7 and Section 9 for a more thorough discussion of directions for future exploration. â€¢ Making Theorem 1.2 efficient. Note that the underlying construction for Theorem 1.1, if made algorithmic, runs in polynomial time with respect to the size of the code, yielding an expâ¡(Oâ¢(n))ğ‘‚ğ‘›\exp(O(n))roman_exp ( italic_O ( italic_n ) )-time algorithm121212This is already nontrivial, as a naive guess-and-check algorithm would require expâ¡(O~â¢(NRDâ¡(RÂ¯,n)))~ğ‘‚NRDÂ¯ğ‘…ğ‘›\exp(\widetilde{O}(\operatorname{NRD}(\overline{R},n)))roman_exp ( over~ start_ARG italic_O end_ARG ( roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) ) ) time. for Theorem 1.2. The primary barrier in constructing our sparsifier in polyâ¡(n)polyğ‘›\operatorname{poly}(n)roman_poly ( italic_n ) time is the fact that an efficient sparsifier is also a kernelization algorithm, but kernelizing every CSP instance to its non-redundancy is a significant open question in the kernelization community [Car22]. â€¢ Computing NRDâ¡(R,n)NRDğ‘…ğ‘›\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ). For a general predicate RâŠ†Drğ‘…superscriptğ·ğ‘ŸR\subseteq D^{r}italic_R âŠ† italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT, there is no simple (even conjectured) expression for NRDâ¡(R,n)NRDğ‘…ğ‘›\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ). In fact, even determining when NRDâ¡(R,n)=Î˜â¢(n)NRDğ‘…ğ‘›Î˜ğ‘›\operatorname{NRD}(R,n)=\Theta(n)roman_NRD ( italic_R , italic_n ) = roman_Î˜ ( italic_n ) is an open question (e.g., [BCK20, Car22]). In Section 7, we explore a number of predicates from the various parts of the literature whose status is unresolved, including a predicate we categorize as the â€œsimplest unresolved predicate.â€ â€¢ Non-redundancy versus Chain Length. Recall we show that unweighted sparsification is closely tied to non-redundancy while weighted sparsification is closely tied to chain length. For non-linear codes, NRDNRD\operatorname{NRD}roman_NRD and CLCL\operatorname{CL}roman_CL can be very different (e.g., Example 8.8), but the relationship for CSPs is unknown [BCK20, Car22]. In particular, it seems quite possible that there exists a CSP predicate Rğ‘…Ritalic_R for which wSPRâ¡(R,n,Îµ)/SPRâ¡(R,n,Îµ)=nÎ©â¢(1).wSPRğ‘…ğ‘›ğœ€SPRğ‘…ğ‘›ğœ€superscriptğ‘›Î©1\operatorname{wSPR}(R,n,\varepsilon)/\operatorname{SPR}(R,n,\varepsilon)=n^{% \Omega(1)}.roman_wSPR ( italic_R , italic_n , italic_Îµ ) / roman_SPR ( italic_R , italic_n , italic_Îµ ) = italic_n start_POSTSUPERSCRIPT roman_Î© ( 1 ) end_POSTSUPERSCRIPT . â€¢ Average-case behavior. From Theorem 1.2, we know that every instance CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) has a sparsifier of size approximately its own non-redundancy, even if that value is much smaller than NRDâ¡(RÂ¯,n)NRDÂ¯ğ‘…ğ‘›\operatorname{NRD}(\overline{R},n)roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ). As such, it may be possible that â€˜averageâ€™ instances of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) admit sparsifiers much smaller than the worst case. 1.8 Organization In Section 2, we prove some basic facts about non-redundancy, sparsification and their relationship. In Section 3, we give a straightforward proof that SPRâ¡(C,Îµ)=O~Îµâ¢(NRDâ¡(C)â¢log2â¡|C|)SPRğ¶ğœ€subscript~ğ‘‚ğœ€NRDğ¶subscript2ğ¶\operatorname{SPR}(C,\varepsilon)=\widetilde{O}_{\varepsilon}(\operatorname{% NRD}(C)\log_{2}|C|)roman_SPR ( italic_C , italic_Îµ ) = over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C | ). In Section 4, we prove Theorem 1.2 by connecting CSP sparsification to non-redundancy via Gilmerâ€™s entropy method. In Section 5, we discuss the immediate applications of Theorem 1.2 based on what is known about non-redundancy in the literature. In Section 6, we bound the non-redundancy of a family of predicates via methods related to matching vector families. In Section 7, we give examples of CSP predicates in the literature whose non-redundancy is unresolved. In Section 8, we extend Theorem 1.2 to weighted instances. In Section 9, we wrap up with other directions of exploration. 1.9 Acknowledgments We thank Libor Barto, Dmitry Zhuk, Madhu Sudan, and Aaron Putterman for valuable conversations. This research was supported in part by a Simons Investigator award and NSF grant CCF-2211972."
https://arxiv.org/html/2411.03390v1,Six Candidates Suffice to Win a Voter Majority,"A cornerstone of social choice theory is Condorcetâ€™s paradox which says that in an election where nğ‘›nitalic_n voters rank mğ‘šmitalic_m candidates it is possible that, no matter which candidate is declared the winner, a majority of voters would have preferred an alternative candidate. Instead, can we always choose a small committee of winning candidates that is preferred to any alternative candidate by a majority of voters?Elkind, Lang, and Saffidine raised this question and called such a committee a Condorcet winning set. They showed that winning sets of size 2222 may not exist, but sets of size logarithmic in the number of candidates always do. In this work, we show that Condorcet winning sets of size 6666 always exist, regardless of the number of candidates or the number of voters. More generally, we show that if Î±1âˆ’lnâ¡Î±â‰¥2k+1ğ›¼1ğ›¼2ğ‘˜1\frac{\alpha}{1-\ln\alpha}\geq\frac{2}{k+1}divide start_ARG italic_Î± end_ARG start_ARG 1 - roman_ln italic_Î± end_ARG â‰¥ divide start_ARG 2 end_ARG start_ARG italic_k + 1 end_ARG, then there always exists a committee of size kğ‘˜kitalic_k such that less than an Î±ğ›¼\alphaitalic_Î± fraction of the voters prefer an alternate candidate. These are the first nontrivial positive results that apply for all kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2.Our proof uses the probabilistic method and the minimax theorem, inspired by recent work on approximately stable committee selection. We construct a distribution over committees that performs sufficiently well (when compared against any candidate on any small subset of the voters) so that this distribution must contain a committee with the desired property in its support.","Voting is a versatile model for the aggregation of individual preferences to reach a collective decision. Disparate situations, such as constituents choosing representatives, organizations hiring employees, judges choosing prize winners, and even friends choosing games to play, can all be understood as a group of voters choosing from a pool of candidates. Voting theory seeks to understand how winning candidates can be selected in a fair and representative manner. One of the longest known challenges with voting is Condorcetâ€™s paradox, discovered by Nicolas de Condorcet around the French Revolution [dC85].111It is plausible that in early academic explorations of voting, 13th-century philosopher Ramon Llull had already discovered the possibility of this paradoxical situation [Llu83, HP00]. The paradox is that in an election where voters have ranked preferences over candidates, the preferences of the â€œmajorityâ€ can be contradictory â€” no matter which candidate is declared the winner, a majority of the voters would have preferred another candidate. In fact, the contradiction can be even more dramatic, with â€œmajorityâ€ replaced by a fraction arbitrarily close to 1. An illustrative example is when the voters have cyclic preferences as, for example, displayed in Table 1. v1subscriptğ‘£1v_{1}italic_v start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT v2subscriptğ‘£2v_{2}italic_v start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT v3subscriptğ‘£3v_{3}italic_v start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT v4subscriptğ‘£4v_{4}italic_v start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT v5subscriptğ‘£5v_{5}italic_v start_POSTSUBSCRIPT 5 end_POSTSUBSCRIPT v6subscriptğ‘£6v_{6}italic_v start_POSTSUBSCRIPT 6 end_POSTSUBSCRIPT 1 2 3 4 5 6 2 3 4 5 6 1 3 4 5 6 1 2 4 5 6 1 2 3 5 6 1 2 3 4 6 1 2 3 4 5 Table 1: An election where voters have cyclic preferences. The column headed with visubscriptğ‘£ğ‘–v_{i}italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT represents the iğ‘–iitalic_ith voterâ€™s ranking of the candidates (labeled 1,2,â€¦,612â€¦61,2,\dots,61 , 2 , â€¦ , 6 from top to bottom). For each candidate, another candidate is preferred by every voter except one. Though it is impossible to always find a single candidate that is always preferred over the others by a majority (called a Condorcet winner), one hope is that relaxations of this condition are still possible to achieve. A natural relaxation arises in the setting of committee selection, where rather than choosing a single winner, the goal is to choose a committee of kğ‘˜kitalic_k winners. For example, a political system may have districts with multiple representatives, organizations may make many hires at once, and friends might play more than one game in an evening. Another view is that committee selection can be used as an filtering step in a process with more than one round, like primaries or runoffs, choosing interviewees for a position, or nominations for a prize. In this context, Elkind, Lang, and Saffidine [ELS11, ELS15] asked: is it always possible to find a small committee of candidates such that no other candidate is preferred by a majority of voters over each member of the committee? They called this committee-analogue of a Condorcet winner a Condorcet winning set, and defined the Condorcet dimension of an election as the size of its smallest Condorcet winning set. For example, the election depicted in Table 1 has Condorcet dimension 2, since any pair of diametrically opposite candidates such as {3,6}36\{3,6\}{ 3 , 6 } would be a Condorcet winning set. More generally, [ELS15] raised the following question for an arbitrary threshold of Î±ğ›¼\alphaitalic_Î± in place of 1212\frac{1}{2}divide start_ARG 1 end_ARG start_ARG 2 end_ARG, and a target committee size kğ‘˜kitalic_k. Question 1 ([ELS15]). A committee Sğ‘†Sitalic_S is Î±ğ›¼\alphaitalic_Î±-undominated if for all candidates aâˆ‰Sğ‘ğ‘†a\notin Sitalic_a âˆ‰ italic_S, less than an Î±ğ›¼\alphaitalic_Î± fraction of voters prefer ağ‘aitalic_a over each member of Sğ‘†Sitalic_S. For what values of kâˆˆâ„¤+ğ‘˜superscriptâ„¤k\in\mathbb{Z}^{+}italic_k âˆˆ blackboard_Z start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT and Î±âˆˆ(0,1]ğ›¼01\alpha\in(0,1]italic_Î± âˆˆ ( 0 , 1 ] does every election have an Î±ğ›¼\alphaitalic_Î±-undominated committee of size kğ‘˜kitalic_k? In particular, we would like to know, for each kğ‘˜kitalic_k, what is the smallest Î±ğ›¼\alphaitalic_Î± for which Î±ğ›¼\alphaitalic_Î±-undominated committees of size kğ‘˜kitalic_k always exist (and, equivalently, for each Î±ğ›¼\alphaitalic_Î±, the smallest kğ‘˜kitalic_k such that these committees always exist). Condorcetâ€™s paradox (or rather, its aformentioned generalization) shows that for k=1ğ‘˜1k=1italic_k = 1 and any Î±ğ›¼\alphaitalic_Î± bounded away from 1, there are elections with no Î±ğ›¼\alphaitalic_Î±-undominated singleton candidates. For the threshold of Î±=12ğ›¼12\alpha=\frac{1}{2}italic_Î± = divide start_ARG 1 end_ARG start_ARG 2 end_ARG, [ELS15] constructed instances with Condorcet dimension 3 by taking the Kronecker product of two elections with cyclic preferences (see Table 3). This construction can be easily extended to give a lower bound of 2k+12ğ‘˜1\frac{2}{k+1}divide start_ARG 2 end_ARG start_ARG italic_k + 1 end_ARG on the smallest Î±ğ›¼\alphaitalic_Î± such that there always exists an Î±ğ›¼\alphaitalic_Î±-undominated committee of size kğ‘˜kitalic_k (see Appendix B). They also showed that an election with mğ‘šmitalic_m candidates has Condorcet dimension at most âŒˆlog2â¡mâŒ‰subscript2ğ‘š\lceil\log_{2}m\rceilâŒˆ roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m âŒ‰; to see this, note that some candidate beats a majority of the other candidates, so we can iteratively add such a candidate to our committee and remove all the candidates that it beats. 1.1 Our Contributions We prove that every election has Condorcet dimension at most 6. This result is a corollary of our main theorem, which gives a nontrivial existence result for Î±ğ›¼\alphaitalic_Î±-undominated committees of size kâ‰¥2ğ‘˜2k\geq 2italic_k â‰¥ 2. We note that the final result we prove (Theorem 5) is stronger, but we start with the approximation below as it is easier to get a handle on. (For a comparison, see Table 2.) Theorem 1. If Î±1âˆ’lnâ¡Î±â‰¥2k+1ğ›¼1ğ›¼2ğ‘˜1\frac{\alpha}{1-\ln\alpha}\geq\frac{2}{k+1}divide start_ARG italic_Î± end_ARG start_ARG 1 - roman_ln italic_Î± end_ARG â‰¥ divide start_ARG 2 end_ARG start_ARG italic_k + 1 end_ARG, then in any election, there exists an Î±ğ›¼\alphaitalic_Î±-undominated committee of size kğ‘˜kitalic_k. For the specific threshold of Î±=12ğ›¼12\alpha=\frac{1}{2}italic_Î± = divide start_ARG 1 end_ARG start_ARG 2 end_ARG, Theorem 1 applies as long as kâ‰¥3+4â¢lnâ¡2â‰ˆ5.77ğ‘˜3425.77k\geq 3+4\ln 2\approx 5.77italic_k â‰¥ 3 + 4 roman_ln 2 â‰ˆ 5.77, and so any election has Condorcet dimension at most 6666 (which is not far from the lower bound of 3333). Taking k=2ğ‘˜2k=2italic_k = 2, Theorem 1 implies that there always exists a pair of candidates such that no third candidate is preferred by more than roughly 80%percent8080\%80 % of the voters. Even replacing 80%percent8080\%80 % with 99%percent9999\%99 %, this was previously unknown. These results show that just by having a few winners instead of one, the most dramatic failures of Condorcetâ€™s paradox are avoidable. We emphasize that these results hold for any election, regardless of the number of voters, the number of candidates, or the preferences that the voters have over candidates. Our starting point for proving Theorem 1 is the observation that 1 is closely linked to the problem of approximate stability in committee selection [JMW20]. The principle behind stability is that a subset of voters should have control over a subset of the committee of proportional size. That is, a committee of size kğ‘˜kitalic_k is stable (also referred to as in the core [Sca67, Fol70, FMS18]) if the fraction of voters that prefers any committee of size kâ€²superscriptğ‘˜â€²k^{\prime}italic_k start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT is less than kâ€²ksuperscriptğ‘˜â€²ğ‘˜\frac{k^{\prime}}{k}divide start_ARG italic_k start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_ARG start_ARG italic_k end_ARG. We note that in this setting, voters have preferences over committees rather than candidates. This more expressive space of preferences gives it the power to model a wide variety of preference structures, such as approval voting and participatory budgeting. Unfortunately, in many settings, stable committees do not always exist. To remedy this, [JMW20] put forth the following approximate notion of stability, and showed the surprising result that for any monotone preference structure and any kğ‘˜kitalic_k, a 32323232-stable committee of size kğ‘˜kitalic_k exists. Definition 1 (Approximately stable committees [JMW20]). A committee Sğ‘†Sitalic_S of kğ‘˜kitalic_k candidates is cğ‘citalic_c-stable if for any committee Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT of size kâ€²superscriptğ‘˜â€²k^{\prime}italic_k start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, the fraction of voters that prefers Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT over Sğ‘†Sitalic_S is less than câ‹…kâ€²kâ‹…ğ‘superscriptğ‘˜â€²ğ‘˜c\cdot\frac{k^{\prime}}{k}italic_c â‹… divide start_ARG italic_k start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_ARG start_ARG italic_k end_ARG. Consider the natural preference order over committees induced by rankings over candidates, where vğ‘£vitalic_v prefers Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT over Sğ‘†Sitalic_S if and only if she prefers her favorite candidate in Sâ€²superscriptğ‘†â€²S^{\prime}italic_S start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT over her favorite in Sğ‘†Sitalic_S. A simple observation (explained more fully in Appendix A) shows that a committee of size kğ‘˜kitalic_k is cğ‘citalic_c-stable if and only if it is ckğ‘ğ‘˜\frac{c}{k}divide start_ARG italic_c end_ARG start_ARG italic_k end_ARG-undominated. For this ranked preference structure, the constant of 32323232 in the result of [JMW20] can be improved to 16161616 using the existence of stable lotteries for these preferences [CJMW20]. Then, as a black box, [JMW20] implies that 16k16ğ‘˜\frac{16}{k}divide start_ARG 16 end_ARG start_ARG italic_k end_ARG-undominated committees of size kğ‘˜kitalic_k always exist, which in turn implies that we can always find Condorcet winning sets of size at most 32323232. Since this conclusion follows easily from [JMW20], we attribute the first constant upper bound on the size of Condorcet winning sets to their work. One can interpret the approximately stable committee problem as a version of 1 focused on the asymptotics of Î±ğ›¼\alphaitalic_Î± as the committee size kğ‘˜kitalic_k grows large. For this purpose, [JMW20] implies a result that is optimal up to a constant factor, but it says nothing nontrivial for committees of size at most 16161616. In contrast, Theorem 1 gives results even for k=2ğ‘˜2k=2italic_k = 2, and outperforms the bound implied by [JMW20] for kâ‰¤1.75Ã—104ğ‘˜1.75superscript104k\leq 1.75\times 10^{4}italic_k â‰¤ 1.75 Ã— 10 start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT, despite only implying the existence of Oâ¢(logâ¡k)ğ‘‚ğ‘˜O(\log k)italic_O ( roman_log italic_k )-stable committees. Nonetheless, we show that our techniques can be applied to the asymptotic setting as well, giving an improvement over [JMW20]. Theorem 2. In any election, there exists a 9.8217k9.8217ğ‘˜\frac{9.8217}{k}divide start_ARG 9.8217 end_ARG start_ARG italic_k end_ARG-undominated committee of size kğ‘˜kitalic_k. As a corollary, Theorem 2 implies the existence of 9.82179.82179.82179.8217-stable committees for preferences induced by rankings over candidates. We note that Theorem 2 improves Theorem 1 for kâ‰¥496ğ‘˜496k\geq 496italic_k â‰¥ 496. 1.2 Technical Overview Our approach, building on [JMW20], is to first construct a particular distribution over committees of size kğ‘˜kitalic_k, and then to show that by sampling from this distribution, the resulting committee is Î±ğ›¼\alphaitalic_Î±-undominated in expectation. In fact, [ELS15]â€™s proof that the existence of Oâ¢(logâ¡m)ğ‘‚ğ‘šO(\log m)italic_O ( roman_log italic_m ) size Condorcet winning committees in elections with mğ‘šmitalic_m candidates can also be viewed through this framework. There, we can consider the uniform distribution over candidates. To construct the committee, we sample from this distribution, remove the candidates that are beaten, and recurse on the remaining candidates. In expectation, half of the candidates are removed in each round, so the algorithm is likely to end with a committee of Oâ¢(logâ¡m)ğ‘‚ğ‘šO(\log m)italic_O ( roman_log italic_m ) candidates. The greedy algorithm of choosing the candidate that beats the most others in each round can be viewed as derandomization via conditional expectation. In this light, a natural approach to improving the Oâ¢(logâ¡m)ğ‘‚ğ‘šO(\log m)italic_O ( roman_log italic_m ) guarantee is to find a better distribution over committees. One of the insights in [JMW20] was to construct this distribution via the equilibrium of a zero-sum game. In the game, the defender chooses a committee Sğ‘†Sitalic_S of size kğ‘˜kitalic_k, and the attacker chooses a candidate ağ‘aitalic_a. After the choices are made, the defender pays the attacker a dollar for each voter that prefers ağ‘aitalic_a over all members of Sğ‘†Sitalic_S. The optimal strategy for the defender is to choose a committee randomly according to some distribution, which [JMW20] call the stable lottery. Then to create a committee of size kğ‘˜kitalic_k, [JMW20] take a recursive approach. First, they sample a committee Sğ‘†Sitalic_S of size k/2ğ‘˜2k/2italic_k / 2, and show that ignoring the 25% of voters that least like Sğ‘†Sitalic_S, any candidate ağ‘aitalic_a is preferred over Sğ‘†Sitalic_S by less than a 8k8ğ‘˜\frac{8}{k}divide start_ARG 8 end_ARG start_ARG italic_k end_ARG fraction of the voters (which are treated as an irrevocable loss). In the next step, they recurse on the ignored voters, sample a committee of size k/4ğ‘˜4k/4italic_k / 4, and lose less than another 4k4ğ‘˜\frac{4}{k}divide start_ARG 4 end_ARG start_ARG italic_k end_ARG fraction of the voters against any candidate ağ‘aitalic_a. The committee size and fraction of voters we lose continue to decrease exponentially, and in the end we have a committee of size kğ‘˜kitalic_k such that less than 16k16ğ‘˜\frac{16}{k}divide start_ARG 16 end_ARG start_ARG italic_k end_ARG voters prefer any candidate ağ‘aitalic_a. To prove Theorem 1, we introduce three twists into this framework. Two are part of how we set up the zero-sum game in order to construct a distribution over committees that individual candidates perform poorly against (Lemma 1), and one is in how we show that in expectation, a random committee sampled from the distribution performs well (Lemma 2 and 4). Improving the game by confining the adversary. First, we modify the setup of the game so that the adversary must choose both a candidate ağ‘aitalic_a and a subset Uğ‘ˆUitalic_U of an Î±ğ›¼\alphaitalic_Î± fraction of the voters. The adversary then only gets paid for the voters in Uğ‘ˆUitalic_U that prefer ağ‘aitalic_a over the committee Sğ‘†Sitalic_S. By tying the hands of the adversary in this way, we can drive down the value of the game, which gives a more favorable guarantee for the distribution over committees. Once we fix the distribution over committees (referred to by Î”Î”\Deltaroman_Î”), we measure the quality of a candidate ağ‘aitalic_a or committee Sğ‘†Sitalic_S with respect to a voter vğ‘£vitalic_v with a crucial notion that we call the rank, denoted rankvâ¡(a)subscriptrankğ‘£ğ‘\operatorname{rank}_{v}(a)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_a ) or rankvâ¡(S)subscriptrankğ‘£ğ‘†\operatorname{rank}_{v}(S)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_S ) (see Definition 3). Roughly speaking, this is simply the probability when we sample from Î”Î”\Deltaroman_Î” that we get a committee that is worse than ağ‘aitalic_a or Sğ‘†Sitalic_S in vğ‘£vitalic_vâ€™s preference. The activation function. The second twist is what we call the activation function gğ‘”gitalic_g, which allows us freedom in how we measure each voterâ€™s preferences for candidates and committees. This function may seem somewhat enigmatic in the proof, but here we try to give some rough intuition for the idea behind it. The initial observation is that by using versions of the zero-sum game with different committee sizes, we can construct distributions over committees of size kğ‘˜kitalic_k in a variety of ways. The simplest would be to take the optimal mixed strategy for the defender in the original game with committee size kğ‘˜kitalic_k, but we could also take the optimal strategy for size k/2ğ‘˜2k/2italic_k / 2, sample twice from it and take the union. These different ways of constructing the distributions can actually be interpreted as attaching different activation functions to the defenderâ€™s distribution in the payoffs of the original game. For example, sampling twice from the k/2ğ‘˜2k/2italic_k / 2 distribution is equivalent to attaching the function gâ¢(x)=xğ‘”ğ‘¥ğ‘¥g(x)=\sqrt{x}italic_g ( italic_x ) = square-root start_ARG italic_x end_ARG, and the reason corresponds to the fact that sampling two uniform reals from [0,1]01[0,1][ 0 , 1 ] and taking the max is equivalent to sampling one uniform real from [0,1]01[0,1][ 0 , 1 ] and taking the square root. In the end, thanks to the generality of the minimax theorem, the proof works for any non-constant, non-decreasing function g:[0,1]â†’â„â‰¥0:ğ‘”â†’01subscriptâ„absent0g\colon[0,1]\to\mathbb{R}_{\geq 0}italic_g : [ 0 , 1 ] â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT such that gâ¢(xk)ğ‘”superscriptğ‘¥ğ‘˜g(x^{k})italic_g ( italic_x start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ) is convex. These functions give a richer continuous space of options for modifying the game, some of which are not easily interpretable in terms of the intuition described above. Each choice of gğ‘”gitalic_g gives a different bound for Î±ğ›¼\alphaitalic_Î± as a function of kğ‘˜kitalic_k, and so we can simply choose the function that gives the best guarantee. A one-shot approach with finer accounting of all voters. Third, we use a more precise approach for showing that some committee in the support of our distribution performs well, by diligently accounting for the contributions of each voter. In each step of [JMW20]â€™s recursion, when they sample committee Sğ‘†Sitalic_S, they consider for each voter vğ‘£vitalic_v whether or not rankvâ¡(S)subscriptrankğ‘£ğ‘†\operatorname{rank}_{v}(S)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_S ) is above some threshold (called Î²ğ›½\betaitalic_Î², which is set to 1414\frac{1}{4}divide start_ARG 1 end_ARG start_ARG 4 end_ARG). The voters below the threshold are ignored, and then recursed on in the next iteration. There are two potential roadblocks in using this approach for small committee sizes. Intuitively, if we are aiming for a final committee size of around 6, the recursion cannot be very deep. Each iteration can only choose 2 or 3 candidates, for which the guarantee is insufficient. That is, the benefits of the recursion only kick in for sufficiently large committees, and for small committees, it is better to sample the whole committee in one shot (without recursion). Second, there is too much loss in evaluating each voter with a binary threshold, and without recursion, we need better accounting for voters with a low opinion of the committee. In Lemma 2 and 4, we give a smoother analysis, which allows us to more precisely account for the contributions of each voter. To give some rough intuition, what we would like to show is that there is some Sğ‘†Sitalic_S such that the total sum of rankvâ¡(S)subscriptrankğ‘£ğ‘†\operatorname{rank}_{v}(S)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_S ) is large for any subset of an Î±ğ›¼\alphaitalic_Î± fraction of the voters. If we fix Sğ‘†Sitalic_S and plot each rankvâ¡(S)subscriptrankğ‘£ğ‘†\operatorname{rank}_{v}(S)roman_rank start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( italic_S ), ordered from smallest to largest, it suffices to bound the area under the bottom Î±ğ›¼\alphaitalic_Î± fraction. It turns out that the worst case for these ranks (that minimizes the area for all Sğ‘†Sitalic_S) is not a step function with a sharp threshold, but rather a linear function with slope 1111 (akin to the cyclic preferences depicted in Table 1). Finally, to prove Theorem 2, we use our modifications in tandem with the recursive approach. In the proof of this theorem, the idea above that does the heavy lifting is the use of the activation function gğ‘”gitalic_g. 1.3 Related Work Proportionality in committee selection. In the context of committee selection, the principle of proportionality says that large voter coalitions should have their preferences fairly represented â€” an idea that dates back to at least the 19th century [Dro81]. Since its advent, a substantial body of research has been dedicated to studying the possibility and implications of proportionality. One of the most widely studied models is approval voting, where voters express their preferences by selecting a subset of candidates they approve of. We refer the reader to a survey by Lackner and Skowron [LS23] for a detailed discussion on the topic. A key appeal of this model is that there are a wide variety of proportionality axioms such as justified representation (JR) [ABC+17] and its variants (for example, [FEL+17, BP23]) that are satisfied by natural rules (such as Proportional Approval Voting (Thieleâ€™s rule) [Thi95, Kil10, ABC+17, PS20], PhragmÃ©nâ€™s rule [Phr94, PS20], and the Method of Equal Shares [PS20, PPS21]). These ideas have also been impactful in practice, with for example, the historical use of Thieleâ€™s rule and PhragmÃ©nâ€™s rule [Jan16], and the recent successful implementation of the Method of Equal Shares for participatory budgeting in several European cities [PS]. Additionally, this line of work is driven forward by intriguing conjectures that even stronger axioms, such as core stability [ABC+17, FMS18], might be universally satisfiable as well. In comparison, proportionality in committee selection with ranked preferences is relatively under-explored. As [LS23] suggest, part of the challenge is that notions of proportionality in the approval setting do not always generalize to the ranking setting. (Or, like with core stability, the analogous axioms are not always satisfiable [CJMW20].) One particularly well studied class of rank-based committee selection rules is that of committee scoring rules [EFSS17]. These voting rules, which generalize scoring rules in the single-winner setting, capture several natural committee selection rules, and have been axiomatically characterized [FSST19, SFS19]. We refer the reader to [FSST17] for a more in-depth discussion. Committee analogues of Condorcet winners. Grappling with Condorcetâ€™s paradox has been a major driving force in social choice theory, and naturally, other attempts have been made to extend the notion of Condorcet winners to the multi-winner setting. Fishburn [Fis81b, Fis81a] introduced the idea of a majority committee, defined as a committee preferred by a majority of voters over any other committee of the same size. The Smith set [Goo71, Smi73] Sğ‘†Sitalic_S is defined as the minimal committee such that for any aâˆ‰Sğ‘ğ‘†a\notin Sitalic_a âˆ‰ italic_S and bâˆˆSğ‘ğ‘†b\in Sitalic_b âˆˆ italic_S, a majority of voters prefers bğ‘bitalic_b over ağ‘aitalic_a. Uncovered sets [Fis77, Mil80], bipartisan sets [LLLB93] (the support of maximal lotteries [Fis84]), and other tournament solutions [BBH16] can also be viewed as multi-winner generalizations of Condorcet winners. However, these notions face the same challenge as Condorcet winners: they either do not always exist or sometimes coincide with the entire (potentially large) set of candidates. As in the single-winner case, the goal shifts to identifying Condorcet-consistent rules, which select a Condorcet winner (or the analogous multi-winner notion) when one exists [Coe05, BC08]. In this context, Theorem 1 highlights a distinct advantage of the approach by Elkind, Lang, and Saffidine [ELS15]: small Condorcet-undominated sets are guaranteed to exist. Other explorations of 1. Lastly, we mention a few other interesting explorations of Condorcet winning sets, and more generally Î±ğ›¼\alphaitalic_Î±-undominated sets. [Gei14] used SAT solving to determine the largest Condorcet dimension in elections with a small number of voters and candidates. Their search did not turn up any instances with dimension larger than 3, but they found an election with just 6 voters and candidates with dimension 3, and they showed that this is the smallest possible. (We include one such instance in Table 4.) [Blo18] also explored whether elections with Condorcet dimension 4 could be constructed by exploring dominating sets in tourament graphs, but that approach did not yield any such elections. On the positive side, [LVvS24] very recently showed that in elections where the voters and candidates are embedded in a 2-dimensional space, and their preferences are defined by their distance according to the â„“1subscriptâ„“1\ell_{1}roman_â„“ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT or â„“âˆsubscriptâ„“\ell_{\infty}roman_â„“ start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT norm, the Condorcet dimension is at most 3. In a more informal setting, a question isomorphic to 1 has also been explored from a combinatorial perspective in a series of Math Overflow posts [PÃ¡l13, Spe13, Bra13]. These posts offer an intriguing window into different approaches to resolving the problem, including why some natural approaches fall short. In their formulation [PÃ¡l13], each candidate ağ‘aitalic_a is represented by a function fa:[n]â†’â„•:subscriptğ‘“ğ‘â†’delimited-[]ğ‘›â„•f_{a}\colon[n]\to\mathbb{N}italic_f start_POSTSUBSCRIPT italic_a end_POSTSUBSCRIPT : [ italic_n ] â†’ blackboard_N, which can be thought of as a map from each voter vğ‘£vitalic_v to the rank of ağ‘aitalic_a in vğ‘£vitalic_vâ€™s preference order. They ask 1, with a particular focus on the case where k=2ğ‘˜2k=2italic_k = 2. The responses contain examples of elections with Condorcet dimension 3, including the general lower bound that Î±ğ›¼\alphaitalic_Î±-undominated committees of size kğ‘˜kitalic_k do not always exist when Î±<2k+1ğ›¼2ğ‘˜1\alpha<\frac{2}{k+1}italic_Î± < divide start_ARG 2 end_ARG start_ARG italic_k + 1 end_ARG [Zba14]. One natural approach towards positive results, suggested by Speyer [Spe13], is to solve the following graph theory question. Question 2. For what choices of â„“,kâˆˆâ„¤+â„“ğ‘˜superscriptâ„¤\ell,k\in\mathbb{Z}^{+}roman_â„“ , italic_k âˆˆ blackboard_Z start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT does there exist a directed graph with girth larger than â„“â„“\ellroman_â„“ such that every subset of kğ‘˜kitalic_k vertices has a common in-neighbor? If there does not exist such a graph for some choice of â„“â„“\ellroman_â„“ and kğ‘˜kitalic_k, then this implies that every election has a (1âˆ’1â„“)11â„“(1-\frac{1}{\ell})( 1 - divide start_ARG 1 end_ARG start_ARG roman_â„“ end_ARG )-undominated set of size kğ‘˜kitalic_k, by considering the graph on candidates where there is an edge (a,b)ğ‘ğ‘(a,b)( italic_a , italic_b ) whenever more than 1âˆ’1â„“11â„“1-\frac{1}{\ell}1 - divide start_ARG 1 end_ARG start_ARG roman_â„“ end_ARG fraction of the voters prefer ağ‘aitalic_a over bğ‘bitalic_b. In particular, if every triangle-free graph has a pair of vertices without a common in-neighbor (â„“=3â„“3\ell=3roman_â„“ = 3 and k=2ğ‘˜2k=2italic_k = 2), then this would imply that 2323\frac{2}{3}divide start_ARG 2 end_ARG start_ARG 3 end_ARG-undominated sets of size 2222 always exist, which would resolve 1 for k=2ğ‘˜2k=2italic_k = 2. Unfortunately, such graphs do exist. [AHL+15] gave a positive answer to 2 for every â„“,kâˆˆâ„¤+â„“ğ‘˜superscriptâ„¤\ell,k\in\mathbb{Z}^{+}roman_â„“ , italic_k âˆˆ blackboard_Z start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT, using a construction based on additive combinatorics."
https://arxiv.org/html/2411.03331v1,"Hypergraphs as Weighted Directed Self-Looped Graphs:Spectral Properties, Clustering, Cheeger Inequality","Hypergraphs naturally arise when studying group relations and have been widely used in the field of machine learning. There has not been a unified formulation of hypergraphs, yet the recently proposed edge-dependent vertex weights (EDVW) modeling [7] is one of the most generalized modeling methods of hypergraphs, i.e., most existing hypergraphs can be formulated as EDVW hypergraphs without any information loss to the best of our knowledge. However, the relevant algorithmic developments on EDVW hypergraphs remain nascent: compared to spectral graph theories, the formulations are incomplete, the spectral clustering algorithms are not well-developed, and one result regarding hypergraph Cheeger Inequality is even incorrect. To this end, deriving a unified random walk-based formulation, we propose our definitions of hypergraph Rayleigh Quotient, NCut, boundary/cut, volume, and conductance, which are consistent with the corresponding definitions on graphs. Then, we prove that the normalized hypergraph Laplacian is associated with the NCut value, which inspires our HyperClus-G algorithm for spectral clustering on EDVW hypergraphs. Finally, we prove that HyperClus-G can always find an approximately linearly optimal partitioning in terms of Both NCut111The NCut of the returned partition ğ’©ğ’©\mathcal{N}caligraphic_N and the optimal NCut of any partition ğ’©âˆ—superscriptğ’©\mathcal{N}^{*}caligraphic_N start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT satisfy ğ’©â‰¤Oâ¢(ğ’©âˆ—)ğ’©ğ‘‚superscriptğ’©\mathcal{N}\leq O(\mathcal{N}^{*})caligraphic_N â‰¤ italic_O ( caligraphic_N start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT ). and conductance 222The conductance of the returned partition Î¦Î¦\Phiroman_Î¦ and the optimal conductance Î¦âˆ—superscriptÎ¦\Phi^{*}roman_Î¦ start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT satisfy Î¦â‰¤Oâ¢(Î¦âˆ—)Î¦ğ‘‚superscriptÎ¦\Phi\leq O(\Phi^{*})roman_Î¦ â‰¤ italic_O ( roman_Î¦ start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT ). Additionally, we provide extensive experiments to validate our theoretical findings from an empirical perspective.","Higher-order relations are ubiquitous in nature, such as co-authorship [14, 48, 40], interactions between multiple proteins or chemicals [13, 47], items that are liked by the same person [49, 46], and interactions between multiple species in an ecosystem [20, 38]. Hypergraphs, extended from graphs, with the powerful capacity to model group interactions (i.e., higher-order relations), show extraordinary potential to be applied to many real-world tasks where the connections are beyond pair-wise. Therefore, hypergraphs have been used widely in recommendation systems [56, 36, 18], information retrieval [27, 53, 35] and link prediction [26, 12]. Hypergraphs modeled by edge-dependent vertex weights (EDVW) were necessitated in a recent work [7], with a motivating example that in citation networks, each scholar (i.e., vertex) may contribute differently to each co-authored publication (i.e., hyperedge). The authors show that hypergraphs with edge-independent vertex weights (EIVW) do not actually utilize the higher-order relations for the following two reasons. First, the hypergraph Laplacian matrix proposed by the seminal work [52], which serves as a basis of many follow-up algorithms, is equal to the Laplacian matrix of a closely related graph with only pair-wise relations. In this way, all the linear Laplacian operators utilize only pair-wise relationships between vertices [1]. Second, many hypergraph algorithms [37, 31, 4] are based on random walks [42, 9, 34], but it has been proved that for any EIVW hypergraph, there exists a weighted pair-wise graph on which a random walk is equivalent to that on the original hypergraph [7]. Table 1: Properties of graph models/formulations. EDVW hypergraphs generalized EIVW hypergraphs by allowing each hyperedge to distribute its vertex weights, bringing better formulation flexibility. Modeling/Formulation undirected graphs EIVW hypergraphs EDVW hypergraphs edge/hyperedge weights âˆšsquare-root\surdâˆš âˆšsquare-root\surdâˆš âˆšsquare-root\surdâˆš vertex weights âˆšsquare-root\surdâˆš âˆšsquare-root\surdâˆš âˆšsquare-root\surdâˆš hyperedges Ã—\timesÃ— âˆšsquare-root\surdâˆš âˆšsquare-root\surdâˆš edge-dependent vertex weights Ã—\timesÃ— Ã—\timesÃ— âˆšsquare-root\surdâˆš Figure 1: Undirected graphs âŠ‚\subsetâŠ‚ EIVW hypergraphs âŠ‚\subsetâŠ‚ EDVW hypergraphs. Each undirected graph can be reformulated to EIVW hypergraph by regarding each pair-wise edge as a hyperedge; each EIVW hypergraph can be reformulated to EDVW hypergraph by setting each vertexâ€™s weight to be the same across hyperedges, yet allowing different vertices to have different weights. In nature, â€EDVW hypergraphâ€ is not a special case of hypergraphs, but a more generalized way to model hypergraphs (Figure 1). Any algorithm designed for EDVW hypergraphs, taking EDVW inputs, also works on typical (EIVW) hypergraphs by setting all the EDVW to 1 (i.e., independent w.r.t. edge). In other words, the properties and algorithms on EDVW-formulated hypergraphs can be applied to most hypergraphs. In this paper, we focus on further developing the incomplete yet fundamental spectral theories for EDVW hypergraphs, with a straightforward application on spectral clustering, a.k.a., k-way global partitioning, where typically k=2ğ‘˜2k=2italic_k = 2. To be specific, k-way global partitioning aims to partition an entire graph into kğ‘˜kitalic_k clusters, where the vertices in one cluster are densely connected within this cluster while having sparser connections to vertices outside this cluster. On the one hand, although the spectral theories and spectral clustering on graphs have been well studied [10], converting the hypergraphs to graphs and applying those methods may ignore the higher-order relations and result in sub-optimal results [44]. On the other hand, despite the advantage of EDVW modeling in terms of utilizing high-order relations, directly developing a spectral clustering algorithm on EDVW hypergraphs is still an open question. To this end, for the first time, we propose a provably linearly optimal spectral clustering algorithm on EDVW hypergraphs, together with theoretical analysis concerning the Rayleigh Quotient, Normalized Cut (i.e., NCut), and conductance. In the context of EDVW hypergraphs, we bridge the eigensystem of Laplacian with the NCut value through our proposed Rayleigh Quotient. The proposed algorithm can also be applied to EIVW hypergraphs by setting all the vertex weights to 1, thus works generally for all hypergraphs. 1.1 Main Results In this paper, we further develop the spectral hypergraph theory for EDVW hypergraphs, and then study global partitioning on EDVW hypergraphs. Theorem 1. (algebraic connections between hypergraph NCut, Rayleigh Quotient and Laplacian) Given any hypergraph in the EDVW formatting â„‹=(ğ’±,â„°,Ï‰,Î³)â„‹ğ’±â„°ğœ”ğ›¾\mathcal{H}=(\mathcal{V},\mathcal{E},\omega,\gamma)caligraphic_H = ( caligraphic_V , caligraphic_E , italic_Ï‰ , italic_Î³ ) with positive edge weights Ï‰â¢(â‹…)>0ğœ”â‹…0\omega(\cdot)>0italic_Ï‰ ( â‹… ) > 0 and non-negative edge-dependent vertex weights Î³eâ¢(â‹…)subscriptğ›¾ğ‘’â‹…\gamma_{e}(\cdot)italic_Î³ start_POSTSUBSCRIPT italic_e end_POSTSUBSCRIPT ( â‹… ) for any eâˆˆâ„°ğ‘’â„°e\in\mathcal{E}italic_e âˆˆ caligraphic_E, define Normalized Cut Nâ¢Câ¢uâ¢tâ¢(â‹…)ğ‘ğ¶ğ‘¢ğ‘¡â‹…NCut(\cdot)italic_N italic_C italic_u italic_t ( â‹… ), Volume of a vertex set vâ¢oâ¢lâ¢(â‹…)ğ‘£ğ‘œğ‘™â‹…vol(\cdot)italic_v italic_o italic_l ( â‹… ), Rayleigh Quotient Râ¢(â‹…)ğ‘…â‹…R(\cdot)italic_R ( â‹… ), Laplacian Lğ¿Litalic_L, and stationary distribution matrix Î Î \Piroman_Î  as Definition 10, 8, 5, 13, and 4. For any vertex set ğ’®âŠ†ğ’±ğ’®ğ’±\mathcal{S}\subseteq\mathcal{V}caligraphic_S âŠ† caligraphic_V, we define a |ğ’±|ğ’±|\mathcal{V}|| caligraphic_V |-dimensional vector xğ‘¥xitalic_x such that, xâ¢(u)=vâ¢oâ¢lâ¢(ğ’®Â¯)vâ¢oâ¢lâ¢(ğ’®),âˆ€uâˆˆğ’®,xâ¢(uÂ¯)=âˆ’vâ¢oâ¢lâ¢(ğ’®)vâ¢oâ¢lâ¢(ğ’®Â¯),âˆ€uÂ¯âˆˆğ’®Â¯.formulae-sequenceğ‘¥ğ‘¢ğ‘£ğ‘œğ‘™Â¯ğ’®ğ‘£ğ‘œğ‘™ğ’®formulae-sequencefor-allğ‘¢ğ’®formulae-sequenceğ‘¥Â¯ğ‘¢ğ‘£ğ‘œğ‘™ğ’®ğ‘£ğ‘œğ‘™Â¯ğ’®for-allÂ¯ğ‘¢Â¯ğ’®\begin{split}x(u)&=\sqrt{\frac{vol(\bar{\mathcal{S}})}{vol(\mathcal{S})}},% \leavevmode\nobreak\ \forall\,\,u\in\mathcal{S},\\ x(\bar{u})&=-\sqrt{\frac{vol(\mathcal{S})}{vol(\bar{\mathcal{S}})}},% \leavevmode\nobreak\ \forall\,\,\bar{u}\in\bar{\mathcal{S}}.\\ \end{split}start_ROW start_CELL italic_x ( italic_u ) end_CELL start_CELL = square-root start_ARG divide start_ARG italic_v italic_o italic_l ( overÂ¯ start_ARG caligraphic_S end_ARG ) end_ARG start_ARG italic_v italic_o italic_l ( caligraphic_S ) end_ARG end_ARG , âˆ€ italic_u âˆˆ caligraphic_S , end_CELL end_ROW start_ROW start_CELL italic_x ( overÂ¯ start_ARG italic_u end_ARG ) end_CELL start_CELL = - square-root start_ARG divide start_ARG italic_v italic_o italic_l ( caligraphic_S ) end_ARG start_ARG italic_v italic_o italic_l ( overÂ¯ start_ARG caligraphic_S end_ARG ) end_ARG end_ARG , âˆ€ overÂ¯ start_ARG italic_u end_ARG âˆˆ overÂ¯ start_ARG caligraphic_S end_ARG . end_CELL end_ROW (1) then,â¢Nâ¢Câ¢uâ¢tâ¢(ğ’®,ğ’®Â¯)=12â¢Râ¢(x)=xTâ¢Lâ¢xxTâ¢Î â¢xthen,ğ‘ğ¶ğ‘¢ğ‘¡ğ’®Â¯ğ’®12ğ‘…ğ‘¥superscriptğ‘¥ğ‘‡ğ¿ğ‘¥superscriptğ‘¥ğ‘‡Î ğ‘¥\textit{then,}\,\,NCut(\mathcal{S},\bar{\mathcal{S}})=\frac{1}{2}R(x)=\frac{x^% {T}Lx}{x^{T}\Pi x}then, italic_N italic_C italic_u italic_t ( caligraphic_S , overÂ¯ start_ARG caligraphic_S end_ARG ) = divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_R ( italic_x ) = divide start_ARG italic_x start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT italic_L italic_x end_ARG start_ARG italic_x start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT roman_Î  italic_x end_ARG (2) This is the first work regarding the Rayleigh Quotient on hypergraphs. Inspired by this Theorem, we develop a spectral clustering algorithm HyperClus-G to optimize the NCut value by loosing the combinatorial optimization constraint. Theorem 2. (Hypergraph Spectral Clustering Algorithm) There exists a algorithm for hypergraph spectral clustering that can be applied to EDVW-formatted hypergraphs, and always returns approximately linearly optimal clustering in terms of Normalized Cut and conductance. In other words, approximately, the NCut of the returned partition ğ’©ğ’©\mathcal{N}caligraphic_N and the optimal NCut of any partition ğ’©âˆ—superscriptğ’©\mathcal{N}^{*}caligraphic_N start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT satisfy ğ’©â‰¤Oâ¢(ğ’©âˆ—)ğ’©ğ‘‚superscriptğ’©\mathcal{N}\leq O(\mathcal{N}^{*})caligraphic_N â‰¤ italic_O ( caligraphic_N start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT ). We name this algorithm as HyperClus-G. The pseudo code of HyperClus-G is given in Algorithm 1. Moreover, to extend the hypergraph spectral theory, for the first time we give a complete proof regarding the hypergraph Cheeger Inequality. In the mean time, by proving Theorem 3, the previous result on hypergraph Cheeger Inequality (Theorem 5.1 in [7]) is incorrect as it refers to the eigenvector of unnormalized hypergraph Laplacian. Theorem 3. (Hypergraph Cheeger Inequality) Let â„‹=(ğ’±,â„°,Ï‰,Î³)â„‹ğ’±â„°ğœ”ğ›¾\mathcal{H}=(\mathcal{V},\mathcal{E},\omega,\gamma)caligraphic_H = ( caligraphic_V , caligraphic_E , italic_Ï‰ , italic_Î³ ) be any hypergraph in the EDVW formatting with positive edge weights Ï‰â¢(â‹…)>0ğœ”â‹…0\omega(\cdot)>0italic_Ï‰ ( â‹… ) > 0 and non-negative edge-dependent vertex weights Î³eâ¢(â‹…)subscriptğ›¾ğ‘’â‹…\gamma_{e}(\cdot)italic_Î³ start_POSTSUBSCRIPT italic_e end_POSTSUBSCRIPT ( â‹… ) for any eâˆˆâ„°ğ‘’â„°e\in\mathcal{E}italic_e âˆˆ caligraphic_E. Define Î¦â¢(â„‹)=minğ’®âŠ†ğ’±Î¦â¢(ğ’®)Î¦â„‹subscriptğ’®ğ’±Î¦ğ’®\Phi(\mathcal{H})=\mathop{\min}_{\mathcal{S}\subseteq\mathcal{V}}{\Phi(% \mathcal{S})}roman_Î¦ ( caligraphic_H ) = roman_min start_POSTSUBSCRIPT caligraphic_S âŠ† caligraphic_V end_POSTSUBSCRIPT roman_Î¦ ( caligraphic_S ). Then the second smallest eigenvector Î»ğœ†\lambdaitalic_Î» of the normalized hypergraph Laplacian Î âˆ’12â¢Lâ¢Î âˆ’12superscriptÎ 12ğ¿superscriptÎ 12\Pi^{-\frac{1}{2}}L\Pi^{-\frac{1}{2}}roman_Î  start_POSTSUPERSCRIPT - divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_POSTSUPERSCRIPT italic_L roman_Î  start_POSTSUPERSCRIPT - divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_POSTSUPERSCRIPT satisfies Î¦â¢(â„‹)22â‰¤Î»â‰¤2â¢Î¦â¢(â„‹)Î¦superscriptâ„‹22ğœ†2Î¦â„‹\frac{\Phi(\mathcal{H})^{2}}{2}\leq\lambda\leq 2\Phi(\mathcal{H})divide start_ARG roman_Î¦ ( caligraphic_H ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG 2 end_ARG â‰¤ italic_Î» â‰¤ 2 roman_Î¦ ( caligraphic_H ) (3) In fact, this theorem shows that our HyperClus-G is also approximately linearly optimal in terms of conductance. In other words, the conductance of the returned cluster Î¦Î¦\Phiroman_Î¦ and the optimal conductance Î¦âˆ—superscriptÎ¦\Phi^{*}roman_Î¦ start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT satisfy Î¦â‰¤Oâ¢(Î¦âˆ—)Î¦ğ‘‚superscriptÎ¦\Phi\leq O(\Phi^{*})roman_Î¦ â‰¤ italic_O ( roman_Î¦ start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT ). It is worth mentioning that the previous non-proved result in [7] regarding hypergraph Cheeger Inequality now can be proved by using normalized Laplacian instead of the conjecture of combinatorial Laplacian. Technical Overview. Given the EDVW modeling, the relevant algorithmic development still remains in a nascent stage, which hinders the application of hypergraphs in many real-world scenarios. To this end, we first re-analyze the random walks on EDVW hypergraphs, then propose the HyperClus-G for hypergraph partitioning. Finally, we prove the approximation of normalized cut, as well as the upper bound of NCut and conductance. The key insight from the previous work [7] is to model the hypergraphs similar to directed graphs through the equivalence of random walks. Unlike classical graph theory, such directed graphs are edge-weighted, node-weighted, and contain self-loops. In this work, inspired by the definitions of Rayleigh Quotient, NCut, boundary/cut, volume, and conductance in graphs, we develop these definitions in the context of EDVW hypergraphs. We show that Theorem 1 and Theorem 3, properties that hold for graphs, still hold for hypergraphs using our unified definitions. From Theorem 3, we can further prove that our proposed HyperClus-G is approximately linearly optimal in terms of both NCut and conductance. Our Appendix contains supplementary contents, such as trivial proofs and experimental details. Paper Organization. This paper is organized as follows. In Section 2, we introduce necessary notations and our definitions regarding hypergraphs. In Section 3, we introduce our definition of hypergraph Rayleigh Quotient and show its connection with the Laplacian and NCut. Then, we propose our HyperClus-G inspired from such connection. In section 4, we give complete proof regarding hypergraph Cheeger Inequality, then show the linear optimality of our HyperClus-G in terms of both NCut and conductance. In Section 5, we analyze the complexity of our algorithms. Finally, in Section 6, we prepare comprehensive experiments to validate our theoretical findings. 1.2 Other Related Works Early Hypergraphs [6] typically model graph structures and do not allow node or hyperedge weights. Later formulations [52] start to allow hyperedge weights. Among various choices of modeling hypergraphs [6, 52, 15, 33], EDVW modeling [7] shows great generalization because it allows both hyperedge weights and node weights. Many hypergraph-related techniques have been proposed [17, 3, 30], while very few of them involve EDVW hypergraphs. Inhomogeneous hypergraph partitioning was proposed in [32]. Later on, authors of [33] proposed submodular hypergraphs, a special group of weighted hypergraphs, and analyzed their spectral clustering. A recent work [23] demonstrates how random walks with EDVW are used to construct the EDVW hypergraph Laplacian. However, it stops at the construction of the Laplacian and only uses partial information encoded in the Laplacian for clustering. Some recent works [2, 43, 11] study partitioning edge-colored hypergraphs. There are several research works [57, 54, 55] targeting EDVW hypergraph global partitioning, but they do not actually directly work on EDVW hypergraphs, but are based on submodular hypergraphs; They propose to construct a submodular hypergraph from the given EDVW hypergraph [33], then apply learning-based approaches to optimize the global partitioning objective. Several works also study specific applications of hypergraph clustering [28, 5]."
https://arxiv.org/html/2411.03274v1,Generalized Word-Representable Graphs:A Formal Language Approach,"The literature on word-representable graphs is quite rich, and a number of variations of the original definition have been proposed over the years. In this paper, we are initiating a systematic study of such variations based on formal languages. In our framework, we can associate a graph class to each language over the binary alphabet {0,1}01\{0,1\}{ 0 , 1 }. All graph classes that are language-representable in this sense are hereditary and enjoy further common properties. Besides word-representable graphs and, more generally, 1ksuperscript1ğ‘˜1^{k}1 start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT- or kğ‘˜kitalic_k-11-representable graphs, we can identify many more graph classes in our framework, like (co)bipartite graphs, (co)comparability graphs, to name a few.It was already known that any graph is 111111111111- or 2-11-representable. However, when such representations are considered for storing graphs (as in graph databases), 111111111111- or 2-11-representability bears the disadvantage of being significantly inferior to standard adjacency matrices or lists. We will prove that quite famous language like the palindrome language, the copy language or the language of Lyndon words, as well as their complements, can match the efficiency of standard graph representations in general.The perspective of language theory allows us to prove very general results that hold for all graph classes that can be defined in this framework. This includes certain closure properties (e.g., all language-definable graph classes are hereditary) as well as certain limitations (e.g., all language-representable graph classes contain graphs of arbitrarily large treewidth and graphs of arbitrarily large degeneracy, except a trivial case). As each language describes a graph class, we can also ask questions like: Given a language, say, by a context-free grammar, does the described graph class only contain graphs of treewidth at most 2? We show that this (and similar questions) are decidable.We also present a systematic study of graph classes that can be represented by binary languages in which each letter occurs at most twice. Here, we find graph classes like interval graphs, permutation graphs, circle graphs, bipartite chain graphs, convex graphs, and threshold graphs, to name the most prominent ones.","How to represent a graph? This question has come up and has been answered in many variations and has also led to the definition of many graph classes. For instance, geometric relations as intersection or containment are possible bases of definitions of interval, chordal or circle graphs, to give concrete examples. In the context of computer science, the study of implicit representations of graphs was initiated in [KanNaoRud92], but for instance the whole research on graph labeling (as testified by the ongoing survey of Gallian [Gal2023] with thousands of citations) can be interpreted in this way, as well as the already mentioned geometric representations. In this paper, we are generalizing the notion of word-representable graphs by linking it to formal language theory in a way that any language Lğ¿Litalic_L over the binary alphabet {0,1}01\{0,1\}{ 0 , 1 } defines a graph class ğ’¢Lsubscriptğ’¢ğ¿\mathcal{G}_{L}caligraphic_G start_POSTSUBSCRIPT italic_L end_POSTSUBSCRIPT. Now classical word representability defines a graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) via a word wğ‘¤witalic_w over the alphabet of vertices Vğ‘‰Vitalic_V, allowing an edge between two vertices u,vğ‘¢ğ‘£u,vitalic_u , italic_v if, in the scattered subword obtained from wğ‘¤witalic_w by omitting all letters but u,vğ‘¢ğ‘£u,vitalic_u , italic_v, never two subsequent letters are identical. This property can be expressed by the binary language (0âˆª1)âˆ—â¢11â¢(0âˆª1)âˆ—Â¯âˆ©(0âˆª1)âˆ—â¢00â¢(0âˆª1)âˆ—Â¯Â¯superscript0111superscript01Â¯superscript0100superscript01\overline{(0\cup 1)^{*}11(0\cup 1)^{*}}\cap\overline{(0\cup 1)^{*}00(0\cup 1)^% {*}}overÂ¯ start_ARG ( 0 âˆª 1 ) start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT 11 ( 0 âˆª 1 ) start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT end_ARG âˆ© overÂ¯ start_ARG ( 0 âˆª 1 ) start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT 00 ( 0 âˆª 1 ) start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT end_ARG in a natural way and our approach generalizes word representability exactly in this direction. Word-representable graphs have been introduced in [KitPya2008] as an analogue of a DAG model of words studied in [KitSei2008] in order to solve some complexity problems in the context of semigroup theory. This is remarkable due to the known links between automata and semigroup theory (via transition monoids) and as we are here presenting a completely different connection between formal languages and graphs. Many scientific works have been devoted to word representability. Instead of trying to list all of them, we only point to the monograph [KitLoz2015] and the survey papers [Kit2017, KitPya2018]. According to [CheKKKP2018], a graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) is kğ‘˜kitalic_k-11-represented by a word wâˆˆVâˆ—ğ‘¤superscriptğ‘‰w\in V^{*}italic_w âˆˆ italic_V start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT if, for all distinct vertices ğšŠ,ğš‹âˆˆVğšŠğš‹ğ‘‰\mathtt{a},\mathtt{b}\in Vtypewriter_a , typewriter_b âˆˆ italic_V, at most kğ‘˜kitalic_k times the pattern (factor) ğšŠğšŠğšŠğšŠ\mathtt{a}\mathtt{a}typewriter_aa and at most kğ‘˜kitalic_k-times the pattern ğš‹ğš‹ğš‹ğš‹\mathtt{b}\mathtt{b}typewriter_bb occurs in h{ğšŠ,ğš‹}â¢(w)subscriptâ„ğšŠğš‹ğ‘¤h_{\{\mathtt{a},\mathtt{b}\}}(w)italic_h start_POSTSUBSCRIPT { typewriter_a , typewriter_b } end_POSTSUBSCRIPT ( italic_w ), obtained from wğ‘¤witalic_w by deleting all vertices (letters) but ğšŠ,ğš‹ğšŠğš‹\mathtt{a},\mathtt{b}typewriter_a , typewriter_b. The 00-11-representable graphs are the classical word-representable graphs, while the 2-11-representable graphs are the class of all undirected graphs. These types of representability were further generalized in [GaeJi2020] towards avoiding arbitrary patterns, and in this paper, we are generalizing these approaches even more by allowing arbitrary languages (not only certain (local) regular languages) to prescribe how edges are defined by a word, so that each binary language describes a graph class. Yet another generalization of word representability was introduced in [KenMal2023]. The class of word-representable graphs also found some interest in the pure graph-theoretic literature, cf. [CheKitSun2016, ChoKimKim2019, EnrKit2019, GleKitPya2018, Gle2019, KitSai2020]. We finally mention that there are other ways to connect words to graphs and hence languages to graph classes. For instance, the notion of letter graphs introduced by PetkovÅ¡ek in [Pet2002] gives rise to an infinite chain of graph classes where the languages are simply restricted by their alphabet size; in this context, this yields the graph parameter lettericity that obtained a certain popularity recently, see [AleAALZ2023] and related papers. Quite akin to our studies are pattern avoiding words in [JonKPR2015, Kit2017a]. In general, this uğ‘¢uitalic_u-representation of a graph depends on the labelling of its vertices and hence is different from our approach. Also, permutation representability as defined in [KitSei2008] is different, as this gives additional conditions on the words that can be used to represent graphs, not only on the patterns that define edges. Lozin [Loz2008a] discussed several representations of graphs with finite automata. Another completely different way to connect the theory of regular languages with basic notions of graph theory, e.g., with bounded treewidth, was recently proposed in [DieFerWol2022]. The paper is structured as follows. We start with a preliminary Section 2 that is already relatively lengthy, as we are using standard not(at)ion from different mathematical areas. In Section 3, we introduce the main (new) definitions of this paper, in particular, we discuss the notion of Lğ¿Litalic_L-representable graphs, with Lğ¿Litalic_L being any binary language. We also provide a number of examples and first observations regarding this notion. In Section 4, we discuss several language and graph operations and how they relate. For instance, complementary languages can be used to describe graph complements, and taking induced subgraphs corresponds to certain projective morphisms on the language side. Section 5 provides structural insights into language-representable graphs by showing that their edge sets can be decomposed by paying attention to the number of times a vertex (letter) occurs in the word describing a graph. This motivates to systematically study some finite languages in Section 6. But first, we discuss in Section 5 some limitations of our approach, finding a number of graph classes that cannot be represented by any language in our setting. Also, we provide counting arguments that show that no finite language can represent all graphs, neither all word-representable graphs (in the classical sense), etc. In Section 6, we characterize all graph classes that can be described by languages that contain only binary words with at most two occurrences of 0 and at most two occurrences of 1. In fact, quite a number of well-known graph classes can be described in this (simple) way, including interval graphs, permutation graphs, circle graphs, convex graphs, and bipartite chain graphs. In Section 7, we approach this phenomenon from another angle by looking at rather famous language classes, formed palindromes, copy-words, Lyndon-words and Dyck-words. This way, we get descriptions of all graphs, of all bipartite graphs, as well as of all comparability graphs. We also argue that these new representations of all graphs is more parsimonious than earlier findings in the area of graphs representable by languages and might be useful in practice. The study of graphs that have a short word-representation with respect to a given language is also connected to [GaeJi2020, SriHar2024] where short representations with respect to the classical notion of word representability was investigated. We conclude in Section 8 by discussing several open questions and research directions that are opened up within our framework. Many graph classes encountered in this paper are defined in Section 9."
https://arxiv.org/html/2411.03273v1,Graph-Based Semi-Supervised Segregated Lipschitz Learning,"This paper presents an approach to semi-supervised learning for the classification of data using the Lipschitz Learning on graphs. We develop a graph-based semi-supervised learning framework that leverages the properties of the infinity Laplacian to propagate labels in a dataset where only a few samples are labeled. By extending the theory of spatial segregation from the Laplace operator to the infinity Laplace operator, both in continuum and discrete settings, our approach provides a robust method for dealing with class imbalance, a common challenge in machine learning. Experimental validation on several benchmark datasets demonstrates that our method not only improves classification accuracy compared to existing methods but also ensures efficient label propagation in scenarios with limited labeled data.","In recent years, nonlinear Partial Differential Equations (PDEs) on graphs have attracted increasing interest due to their natural emergence in various applications in mathematics, physics, biology, economics, and data science. For example, they are relevant in fields such as Internet and road networks, social networks, population dynamics, image processing, and machine learning. Indeed, a large amount of complex and irregular data is generated daily from various sources, including the internet, images, point clouds, 3D meshes, and biological networks. These datasets can be directly represented or modeled as graphs or functions defined on graphs. Consequently, intensive research aims to develop new methods for processing and analyzing data defined on graphs and adapt classical signal and image processing methods and concepts to graphs. Recently, several works have focused on the study of PDEs on graphs and their local or non-local continuous limits in the Euclidean domain. Among the significant contributions, we can mention the works of teams such as those of A. Bertozzi [7, 46, 34], Y. VanGuennip [51, 50, 10], S. Osher [48, 35], and J. Mazon [43, 45, 44], who have proposed to adapt several types of continuous PDEs and variational models to graphs. Other research aims to transpose various continuous PDEs to graphs, such as pğ‘pitalic_p-Laplacian equations [24, 30, 36], infinity Laplacian [30], â€gameâ€ pğ‘pitalic_p-Laplacian [28], Hamilton-Jacobi equations with or without diffusion [33, 31, 14], related to certain stochastic games [26, 29], mean curvature flow equation, or pğ‘pitalic_p-biharmonic equation [33]. In this paper, utilizing the characteristic of Infinity Laplacian in propagating, we propose a novel graph-based semi-supervised learning method aimed at classifying large volumes of unlabeled data, particularly in scenarios involving imbalanced datasets and limited labeled samples. Our approach exploits the geometric and topological characteristics of the unlabeled data, integrating these properties to enhance the development and performance of various algorithms."
https://arxiv.org/html/2411.03006v1,Neural Networks and (Virtual) Extended Formulations,"Neural networks with piecewise linear activation functions, such as rectified linear units (ReLU) or maxout, are among the most fundamental models in modern machine learning. We make a step towards proving lower bounds on the size of such neural networks by linking their representative capabilities to the notion of the extension complexity xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) of a polytope Pğ‘ƒPitalic_P, a well-studied quantity in combinatorial optimization and polyhedral geometry. To this end, we propose the notion of virtual extension complexity vxcâ¡(P)=minâ¡{xcâ¡(Q)+xcâ¡(R)âˆ£P+Q=R}vxcğ‘ƒxcğ‘„conditionalxcğ‘…ğ‘ƒğ‘„ğ‘…\operatorname{vxc}(P)=\min\{\operatorname{xc}(Q)+\operatorname{xc}(R)\mid P+Q=R\}roman_vxc ( italic_P ) = roman_min { roman_xc ( italic_Q ) + roman_xc ( italic_R ) âˆ£ italic_P + italic_Q = italic_R }. This generalizes xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) and describes the number of inequalities needed to represent the linear optimization problem over Pğ‘ƒPitalic_P as a difference of two linear programs. We prove that vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ) is a lower bound on the size of a neural network that optimizes over Pğ‘ƒPitalic_P. While it remains open to derive strong lower bounds on virtual extension complexity, we show that powerful results on the ordinary extension complexity can be converted into lower bounds for monotone neural networks, that is, neural networks with only nonnegative weights. Furthermore, we show that one can efficiently optimize over a polytope Pğ‘ƒPitalic_P using a small virtual extended formulation. We therefore believe that virtual extension complexity deserves to be studied independently from neural networks, just like the ordinary extension complexity. As a first step in this direction, we derive an example showing that extension complexity can go down under Minkowski sum.","While machine learning is nowadays driven by rapid empirical progress, our work focuses on the theoretical understanding of the underlying models and methods. A crucial building block are feedforward neural networks. These are directed, acyclic graphs in which each vertex (neuron) defines a simple computation, usually a linear transformation composed with a scalar-valued, continuous and piecewise linear (CPWL) activation function. While a standard choice for the activation function is the rectified linear unit (ReLU) xâ†¦maxâ¡{0,x}maps-toğ‘¥0ğ‘¥x\mapsto\max\{0,x\}italic_x â†¦ roman_max { 0 , italic_x }, in this paper we focus on the more general maxout networks. These allow to compute the maximum of constantly many linear functions at each neuron. As a result, the entire network computes a (potentially complex) CPWL function. One of the big challenges in the theoretical analysis of neural networks is to understand how many neurons one requires to exactly or approximately represent a given (CPWL) function. To the best of our knowledge, it is an open question whether there exists a family of CPWL functions, which we can evaluate in polynomial time, but which cannot be represented by polynomial-size neural networks. The piecewise linear nature of the studied networks suggests to tackle such questions by means of polyhedral geometry, see, e.g., the recent survey [25]. In fact, a similar problem to the question above used to be open for a long time in the context of linear programming, until RothvoÃŸ [37] resolved it affirmatively: does there exist a polytope Pğ‘ƒPitalic_P over which we can optimize in polynomial time, but any linear programming formulation must have exponential size? This question can be formalized with the notion of extension complexity xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ), which describes the minimal number of facets of any polytope Qğ‘„Qitalic_Q that projects onto Pğ‘ƒPitalic_P. In this case, we call Qğ‘„Qitalic_Q an extended formulation of Pğ‘ƒPitalic_P. RothvoÃŸ [37] proved that the matching polytope has exponential extension complexity even though Edmondsâ€™ algorithm [11] can be used to find the maximum weight matching or minimum weight perfect matching in polynomial time. Additionally, it was also proven that a couple of polytopes associated with NP-hard optimization problems like the travelling salesperson problem have exponential extension complexity [14]. There is a direct translation between polytopes (as feasible sets of linear programs) and CPWL functions (represented by neural networks) through the notion of the support function fPâ¢(c)=maxxâˆˆPâ¡câŠ¤â¢xsubscriptğ‘“ğ‘ƒğ‘subscriptğ‘¥ğ‘ƒsuperscriptğ‘topğ‘¥f_{P}(c)=\max_{x\in P}c^{\top}xitalic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT ( italic_c ) = roman_max start_POSTSUBSCRIPT italic_x âˆˆ italic_P end_POSTSUBSCRIPT italic_c start_POSTSUPERSCRIPT âŠ¤ end_POSTSUPERSCRIPT italic_x of a polytope Pğ‘ƒPitalic_P. This (convex) CPWL function, which has one linear region for each vertex of Pğ‘ƒPitalic_P, uniquely determines Pğ‘ƒPitalic_P via convex duality. Computing fPâ¢(c)subscriptğ‘“ğ‘ƒğ‘f_{P}(c)italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT ( italic_c ) means determining the objective value when optimizing over Pğ‘ƒPitalic_P in cğ‘citalic_c-direction. Each CPWL function fPsubscriptğ‘“ğ‘ƒf_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT can be represented by a neural network [1], though the required number of neurons can be large. To quantify this, we define the neural network complexity nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ) as the minimum number of neurons to represent fPsubscriptğ‘“ğ‘ƒf_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT by a maxout neural network. 1.1 Our Contributions The aim of this paper is to connect the world of extended formulations with the study of neural networks. A â€œdream resultâ€ in this direction would be to bound xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) polynomially in nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ). Then the breakthrough results on extension complexity would directly imply strong lower bounds on the size of neural networks. It turns out, however, that there is one feature of neural networks that seems to make the â€œdream resultâ€ difficult to obtain: namely the ability to use subtraction. To remedy this, we propose the notion of virtual extension complexity vxcâ¡(P)=minâ¡{xcâ¡(Q)+xcâ¡(R)âˆ£Q and R are polytopes with â¢P+Q=R},vxcğ‘ƒxcğ‘„conditionalxcğ‘…Q and R are polytopes with ğ‘ƒğ‘„ğ‘…\operatorname{vxc}(P)=\min\{\operatorname{xc}(Q)+\operatorname{xc}(R)\mid\text% {$Q$ and $R$ are polytopes with }P+Q=R\}\ ,roman_vxc ( italic_P ) = roman_min { roman_xc ( italic_Q ) + roman_xc ( italic_R ) âˆ£ italic_Q and italic_R are polytopes with italic_P + italic_Q = italic_R } , where P+Q={p+qâˆ£pâˆˆP,qâˆˆQ}ğ‘ƒğ‘„conditional-setğ‘ğ‘formulae-sequenceğ‘ğ‘ƒğ‘ğ‘„P+Q=\{p+q\mid p\in P,q\in Q\}italic_P + italic_Q = { italic_p + italic_q âˆ£ italic_p âˆˆ italic_P , italic_q âˆˆ italic_Q } is the Minkowski sum. In this definition, Pğ‘ƒPitalic_P is a (formal) Minkowski difference of two polytopes Qğ‘„Qitalic_Q and Rğ‘…Ritalic_R. Note that this is not the same as R+(âˆ’1)â‹…Qğ‘…â‹…1ğ‘„R+(-1)\cdot Qitalic_R + ( - 1 ) â‹… italic_Q but rather the inverse operation of Minkowski addition. The name virtual extension complexity is derived from virtual polytopes [33], a framework for the algebraic study of formal Minkowski differences of polytopes. Observe that vxcâ¡(P)â‰¤xcâ¡(P)vxcğ‘ƒxcğ‘ƒ\operatorname{vxc}(P)\leq\operatorname{xc}(P)roman_vxc ( italic_P ) â‰¤ roman_xc ( italic_P ) because we can always choose Q={0}ğ‘„0Q=\{0\}italic_Q = { 0 } with xcâ¡({0})=0xc00\operatorname{xc}(\{0\})=0roman_xc ( { 0 } ) = 0. In that sense, virtual extension complexity is really a strengthening of the ordinary extension complexity. In Section 3, we deduce that vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ) is indeed a lower bound for nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ), up to a constant factor. This leaves the open question to find ways to lower-bound vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ) in order to achieve the original goal to lower-bound nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ). A consequence of the discussion above is that, if one removes the ability to subtract within neural networks, we do indeed obtain our â€œdream resultâ€, namely lower bounds through xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ). The resulting model is the one of monotone neural networks, which are neural networks with only nonnegative weights. In analogy to nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ), we define the monotone neural network complexity mnncâ¡(P)mnncğ‘ƒ\operatorname{mnnc}(P)roman_mnnc ( italic_P ) as the minimum number of neurons to represent fPsubscriptğ‘“ğ‘ƒf_{P}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT by a monotone maxout neural network. In Section 4, we show how lower bounds on xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) imply lower bounds on exact and approximate representations of monotone neural networks. Studying monotone neural networks is justified both from a theoretical and a practical perspective. From the theoretical perspective, it is a natural approach in complexity theory to prove lower bounds first for monotone models of computation, to first circumvent some additional challenges of the general case; see, e.g., [42]. From the practical perspective, it is always a good idea to incorporate prior knowledge about a problem into a machine learning algorithm to solve that problem. If one knows that the target function should be a monotone function, then it might be a good idea to constrain each unit of the neural network to compute a monotone functionâ€”this exactly corresponds to nonnegative weights. See [29] and the references therein for recent studies of monotone neural networks in the machine learning community. Summarizing, in this paper, we discuss four ways to represent a polytope or its support function through (virtual) extended formulations and (monotone) neural networks. Figure 1 shows what we know about how the associated complexity measures xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ), vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ), nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ), and mnncâ¡(P)mnncğ‘ƒ\operatorname{mnnc}(P)roman_mnnc ( italic_P ) relate to each other. xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P )mnncâ¡(P)mnncğ‘ƒ\operatorname{mnnc}(P)roman_mnnc ( italic_P )vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P )nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P )?? Figure 1: Relations between complexity measures for a polytope Pğ‘ƒPitalic_P. A directed arc means that the tail can be polynomially bounded by the head. It remains an open question whether xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) and nncâ¡(P)nncğ‘ƒ\operatorname{nnc}(P)roman_nnc ( italic_P ) can be related this way. We conclude with some insights for vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ) and its relation to xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ). Observe that P+Q=Rğ‘ƒğ‘„ğ‘…P+Q=Ritalic_P + italic_Q = italic_R is equivalent to fP=fRâˆ’fQsubscriptğ‘“ğ‘ƒsubscriptğ‘“ğ‘…subscriptğ‘“ğ‘„f_{P}=f_{R}-f_{Q}italic_f start_POSTSUBSCRIPT italic_P end_POSTSUBSCRIPT = italic_f start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT - italic_f start_POSTSUBSCRIPT italic_Q end_POSTSUBSCRIPT pointwise. Therefore, intuitively, in order to optimize over Pğ‘ƒPitalic_P, one only needs to optimize over Rğ‘…Ritalic_R and Qğ‘„Qitalic_Q and subtract the results. We make this intuition formal in Section 5.1, implying that small extended formulations for Qğ‘„Qitalic_Q and Rğ‘…Ritalic_R are sufficient to optimize efficiently over Pğ‘ƒPitalic_P. Furthermore, in Section 5.2, we provide a class of examples with P+Q=Rğ‘ƒğ‘„ğ‘…P+Q=Ritalic_P + italic_Q = italic_R demonstrating that xcâ¡(R)xcğ‘…\operatorname{xc}(R)roman_xc ( italic_R ) can be much smaller than xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ). This gives important insights on how extension complexity behaves under Minkowski sum and implies that we really need to look at both xcâ¡(Q)xcğ‘„\operatorname{xc}(Q)roman_xc ( italic_Q ) and xcâ¡(R)xcğ‘…\operatorname{xc}(R)roman_xc ( italic_R ) in order to lower-bound vxcâ¡(P)vxcğ‘ƒ\operatorname{vxc}(P)roman_vxc ( italic_P ). 1.2 Further Related Work In this paper we aim to prove lower bounds on neural networks representing combinatorial optimization problems. Complementing upper bounds can be found in [22] for minimum spanning trees and maximum flows. Furthermore, in [23], similar upper bounds for the knapsack problem are given, even though they are different in flavor because some integrality assumptions are made. Concerning the general expressivity of (piecewise linear) neural networks, the celebrated universal approximation theorems state that a single layer of neurons is sufficient to approximate any continuous function on a bounded domain; see [10] for the original version for sigmoid activation functions and [27] for a version that encompasses ReLU. However, such shallow neural networks usually require a large number of neurons. A sequence of results demonstrates that deeper networks sometimes require exponentially fewer neurons to represent the same functions; see, e.g., [1, 12]. In terms of exact representation, it is known that a function can be represented if and only if it is CPWL [1], and it is still an open question whether constant depth is sufficient to do so [21, 20]. Interestingly, also for this question, monotone networks seem to be more amenable for proving lower bounds than their non-monotone counterparts [41]. Furthermore, the related question of how to efficiently write a non-convex CPWL function as a difference of two convex ones received quite some attention recently [5, 40]. We would like to emphasize that we view neural networks as a model of real-valued computation, as opposed to binary models of computation like Boolean circuits and Turing machines. In fact, if one restricts the inputs of a neural network to be binary, it is not too difficult to simulate AND-, OR-, and NOT-gates [32]. Thus, in such a binary model, every problem in P can be solved with polynomial-size neural networks. However, such networks would usually be very sensitive to single bits in the input and therefore cannot naturally be transformed into exact or approximate neural networks in the real-valued model. See also the discussion in [22] for more details. The more useful connection to circuit complexity is through arithmetic [38], and in particular tropical circuits [26], which are also real-valued models of computation. Again we refer to [22] for a more detailed discussion of how these models relate to neural networks. In fact, the extension complexity has been related before to Boolean and arithmetic circuits, see [13, 24]. This is also related to Goemansâ€™ proof that the permutahedron has extension complexity ğ’ªâ¢(nâ¢logâ¡n)ğ’ªğ‘›ğ‘›\mathcal{O}(n\log n)caligraphic_O ( italic_n roman_log italic_n ) [16], as this goes via sorting networks, which can be seen as a very specific version of a piecewise-linear arithmetic circuit."
https://arxiv.org/html/2411.03003v1,Fractional Chromatic Numbersfrom Exact Decision Diagrams,"Recently, Van Hoeve proposed an algorithm for graph coloring based on an integer flow formulation on decision diagrams for stable sets [10]. We prove that the solution to the linear flow relaxation on exact decision diagrams determines the fractional chromatic number of a graph. This settles the question whether the decision diagram formulation or the fractional chromatic number establishes a stronger lower bound. It also establishes that the integrality gap of the linear programming relaxation is ğ’ªâ¢(logâ¡n)ğ’ªğ‘›\mathcal{O}(\log n)caligraphic_O ( roman_log italic_n ), where nğ‘›nitalic_n represents the number of vertices in the graph.We also conduct experiments using exact decision diagrams and could determine the chromatic number of r1000.1c from the DIMACS benchmark set. It was previously unknown and is one of the few newly solved DIMACS instances in the last 10 years.","A (vertex) coloring of a graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) assigns a color to each vertex such that adjacent vertices have different colors. Thus, each set of vertices with the same color is a stable set (also called independent set) in GğºGitalic_G. The (vertex) coloring problem is to compute a coloring with the minimum possible number of colors. This number is denoted by Ï‡â¢(G)ğœ’ğº\chi(G)italic_Ï‡ ( italic_G ) and also called the chromatic number of GğºGitalic_G. Let ğ’®ğ’®\mathcal{S}caligraphic_S denote the set of all stable sets in GğºGitalic_G. Then, solving the following integer programming model yields the chromatic number [9]: Ï‡â¢(G)=ğœ’ğºabsent\displaystyle\chi(G)=italic_Ï‡ ( italic_G ) = minâ¢âˆ‘Sâˆˆğ’®zSminsubscriptğ‘†ğ’®subscriptğ‘§ğ‘†\displaystyle\text{min}\sum_{S\in\mathcal{S}}z_{S}min âˆ‘ start_POSTSUBSCRIPT italic_S âˆˆ caligraphic_S end_POSTSUBSCRIPT italic_z start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT (VCIP) s.t.â¢âˆ‘Sâˆˆğ’®:jâˆˆSziâ‰¥1âˆ€jâˆˆVformulae-sequences.t.subscript:ğ‘†ğ’®ğ‘—ğ‘†subscriptğ‘§ğ‘–1for-allğ‘—ğ‘‰\displaystyle\text{s.t.}\;\;\sum_{S\in\mathcal{S}:j\in S}z_{i}\geq 1\quad% \forall j\in Vs.t. âˆ‘ start_POSTSUBSCRIPT italic_S âˆˆ caligraphic_S : italic_j âˆˆ italic_S end_POSTSUBSCRIPT italic_z start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‰¥ 1 âˆ€ italic_j âˆˆ italic_V zSâˆˆ{0,1}âˆ€Sâˆˆğ’®formulae-sequencesubscriptğ‘§ğ‘†01for-allğ‘†ğ’®\displaystyle z_{S}\in\{0,1\}\quad\forall S\in\mathcal{S}italic_z start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT âˆˆ { 0 , 1 } âˆ€ italic_S âˆˆ caligraphic_S It is a special case of the set cover problem, where the vertex set Vğ‘‰Vitalic_V has to be covered with a minimum number of stable sets. The linear relaxation results in the fractional chromatic number Ï‡fâ¢(G)subscriptğœ’ğ‘“ğº\chi_{f}(G)italic_Ï‡ start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT ( italic_G ). Ï‡fâ¢(G):=assignsubscriptğœ’ğ‘“ğºabsent\displaystyle\chi_{f}(G):=italic_Ï‡ start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT ( italic_G ) := minâ¢âˆ‘Sâˆˆğ’®zIminsubscriptğ‘†ğ’®subscriptğ‘§ğ¼\displaystyle\text{min}\sum_{S\in\mathcal{S}}z_{I}min âˆ‘ start_POSTSUBSCRIPT italic_S âˆˆ caligraphic_S end_POSTSUBSCRIPT italic_z start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT (VCLP) s.t.â¢âˆ‘Sâˆˆğ’®:jâˆˆSzSâ‰¥1âˆ€jâˆˆVformulae-sequences.t.subscript:ğ‘†ğ’®ğ‘—ğ‘†subscriptğ‘§ğ‘†1for-allğ‘—ğ‘‰\displaystyle\text{s.t.}\;\;\sum_{S\in\mathcal{S}:j\in S}z_{S}\geq 1\quad% \forall j\in Vs.t. âˆ‘ start_POSTSUBSCRIPT italic_S âˆˆ caligraphic_S : italic_j âˆˆ italic_S end_POSTSUBSCRIPT italic_z start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT â‰¥ 1 âˆ€ italic_j âˆˆ italic_V 0â‰¤zSâ‰¤1âˆ€Sâˆˆğ’®.formulae-sequence0subscriptğ‘§ğ‘†1for-allğ‘†ğ’®\displaystyle 0\leq z_{S}\leq 1\quad\forall S\in\mathcal{S}.0 â‰¤ italic_z start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT â‰¤ 1 âˆ€ italic_S âˆˆ caligraphic_S . LovÃ¡sz showed that Ï‡â¢(G)â‰¤ğ’ªâ¢(logâ¡n)â‹…Ï‡fâ¢(G)ğœ’ğºâ‹…ğ’ªğ‘›subscriptğœ’ğ‘“ğº\chi(G)\leq\mathcal{O}(\log n)\cdot\chi_{f}(G)italic_Ï‡ ( italic_G ) â‰¤ caligraphic_O ( roman_log italic_n ) â‹… italic_Ï‡ start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT ( italic_G ) [7]. However for any Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0, approximating either Ï‡fâ¢(G)subscriptğœ’ğ‘“ğº\chi_{f}(G)italic_Ï‡ start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT ( italic_G ) or Ï‡â¢(G)ğœ’ğº\chi(G)italic_Ï‡ ( italic_G ) within a factor n1âˆ’Ïµsuperscriptğ‘›1italic-Ïµn^{1-\epsilon}italic_n start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT is NP-hard [12]. The IP formulation (VCIP) is the basis for several branch-&-price algorithms for vertex coloring [9, 8, 5]. Recently, Van Hoeve [10] proposed to tackle the graph coloring problem with decision diagrams. A (binary) decision diagram consists of an acyclic digraph with arc labels. It can represent the set of feasible solutions to an optimization problem Pğ‘ƒPitalic_P, e.g. the stable sets of a graph. They are called exact if they represent all solutions, e.g. all stable sets. Van Hoeve showed how to compute a graph coloring using a constrained network flow in the decision diagram. 1.1 Contributions We show that the linear relaxation of the integral network flow in an exact decision diagram describes the fractional chromatic number, i.e. the linear relaxations arising from (VCLP) and from exact decision diagrams lead to the same lower bound. Thus, fractional flows in relaxed decision diagrams provide fast lower bounds for the (fractional) chromatic number. Finally, we show that the exact decision diagrams are computationally efficient on dense instances. For the first time, we are able to compute the chromatic number of r1000.1c [6]. To provide a provably correct solution, we employ exact arithmetic using SCIP-exact [4]. In unsafe floating point arithmetic, we could also improve the best known lower bound of the instance DJSC500.9. The paper is organized as follows. In Section 2, we shortly describe decision diagrams for the stable set problem and how a graph coloring integer program based on such a decision diagram can be formulated (Section 2.2) as proposed by [10]. Then, in Section 3 we prove that the solution to the linear relaxation of the integer program determines the fractional chromatic number. Section 4 contains experimental results with exact arithmetic on the instances of the DIMACS benchmark set, followed by Conclusions."
https://arxiv.org/html/2411.02686v1,On thedğ‘‘ditalic_d-independence number in 1-planar graphs,"The dğ‘‘ditalic_d-independence number of a graph GğºGitalic_G is the largest possible size of an independent set Iğ¼Iitalic_I in GğºGitalic_G where each vertex of Iğ¼Iitalic_I has degree at least dğ‘‘ditalic_d in GğºGitalic_G. Upper bounds for the dğ‘‘ditalic_d-independence number in planar graphs are well-known for d=3,4,5ğ‘‘345d=3,4,5italic_d = 3 , 4 , 5, and can in fact be matched with constructions that actually have minimum degree dğ‘‘ditalic_d. In this paper, we explore the same questions for 1-planar graphs, i.e., graphs that can be drawn in the plane with at most one crossing per edge. We give upper bounds for the dğ‘‘ditalic_d-independence number for all dğ‘‘ditalic_d. Then we give constructions that match the upper bound, and (for small dğ‘‘ditalic_d) also have minimum degree dğ‘‘ditalic_d.Keywords: 1-planar graph, independent set, minimum degree","An independent set in a graph contains vertices that are not adjacent to each other. A maximum independent set is an independent set of largest possible size for a given graph, and its cardinality is known as the independence number of GğºGitalic_G and denoted by Î±â¢(G)ğ›¼ğº\alpha(G)italic_Î± ( italic_G ). The celebrated 4-color theorem [3, 36] immediately implies that Î±â¢(G)â‰¥n/4ğ›¼ğºğ‘›4\alpha(G)\geq n/4italic_Î± ( italic_G ) â‰¥ italic_n / 4 for every planar graph GğºGitalic_G, where nğ‘›nitalic_n is the number of vertices in the graph. Interestingly, this bound represents the maximum attainable, as there exist planar graphs without larger independent sets; for instance, consider disjoint copies of complete graphs with 4444 vertices. Some weaker lower bounds are also established [1, 20] that circumvent the complexity of the 4-color theorem (as suggested by ErdÅ‘s [5]) via charging and discharging argument. From an algorithmic standpoint, determining the maximum independent set in planar graphs is \NP-hard, even when restricted to planar graphs of maximum degree 3, see [27, 35] or planar triangle-free graphs, see [33]. Consequently, efforts have shifted towards finding large independent sets through methods like approximation algorithms [2, 4, 14, 18, 24, 33], parallel algorithms [19, 22, 28], fixed-parameter tractable algorithms [26, 31, 25, 21] or within certain minor-free planar graphs [24, 32, 34]. The size Î±â¢(G)ğ›¼ğº\alpha(G)italic_Î± ( italic_G ) serves as a crucial parameter in graph theory and holds significance in algorithmic contexts. For instance, Kirkpatrick [30] and Dobkin and Kirkpatrick [23] employed the repeated removal of independent sets from triangulations to devise data structures for efficient point location and distance computation between convex polytopes, respectively. For this technique, it is important that the vertices in the independent set have bounded degrees. Biedl and Wilkinson [6] further explored the size of bounded degree independent sets in triangulations. In addition, Bose, DujmoviÄ‡ and Wood [13] studied how to obtain graphs with large independent sets of bounded degrees in graphs of bounded treewidth. In the above context, â€˜bounded degree independent setâ€™ meant that every vertex of the independent set should have degree at most dğ‘‘ditalic_d, for some specified constant dğ‘‘ditalic_d. In contrast to this, we study here independent sets where every vertex of the independent set should have degree at least dğ‘‘ditalic_d. We call this a dğ‘‘ditalic_d-independent set111The term â€˜dğ‘‘ditalic_d-independent setâ€™ is heavily overloaded in the literature; for example, it has also been used for an independent set of cardinality dğ‘‘ditalic_d [11] or for an independent set that induces a graph of maximum degree dğ‘‘ditalic_d [16]. Unfortunately, more descriptive notations such as â€˜(degâ‰¥d)degreeğ‘‘(\deg\geq d)( roman_deg â‰¥ italic_d )-independent setâ€™ are rather difficult to parse. and the maximum size of a dğ‘‘ditalic_d-independent set in GğºGitalic_G is called the dğ‘‘ditalic_d-independence number of GğºGitalic_G and denoted Î±dâ¢(G)subscriptğ›¼ğ‘‘ğº\alpha_{d}(G)italic_Î± start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ). We also speak of the independence number of a graph class ğ’¢ğ’¢\mathcal{G}caligraphic_G (such as â€˜the 1-planar graphsâ€™), which is a function that depends on nğ‘›nitalic_n and denotes the maximum of Î±dâ¢(G)subscriptğ›¼ğ‘‘ğº\alpha_{d}(G)italic_Î± start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ) over all graphs GğºGitalic_G with nğ‘›nitalic_n vertices in ğ’¢ğ’¢\mathcal{G}caligraphic_G. The dğ‘‘ditalic_d-independence number for planar graphs was first studied by Caro and Roditty in [15] (they actually studied graphs of minimum degree dğ‘‘ditalic_d, which means that any independent set is a dğ‘‘ditalic_d-independent set). They showed that any independent set in a simple planar graph GğºGitalic_G with minimum degree dğ‘‘ditalic_d has size at most 2â¢nâˆ’4d2ğ‘›4ğ‘‘\tfrac{2n-4}{d}divide start_ARG 2 italic_n - 4 end_ARG start_ARG italic_d end_ARG. They also showed that these bounds are tight for 2â‰¤dâ‰¤52ğ‘‘52\leq d\leq 52 â‰¤ italic_d â‰¤ 5 by constructing infinite families of simpler planar graphs with minimum degree dğ‘‘ditalic_d and an independent set of size 2â¢nâˆ’4d2ğ‘›4ğ‘‘\tfrac{2n-4}{d}divide start_ARG 2 italic_n - 4 end_ARG start_ARG italic_d end_ARG. There are various generalizations of planar graphs, for example, a 1111-planar graph is a graph that can be drawn in the Euclidean plane with at most one crossing per edge. In this paper, we study the independence number of 1111-planar graphs. Borodin [12] establishes that every 1111-planar graph GğºGitalic_G has chromatic number at most 6666, therefore Î±â¢(G)â‰¥n/6ğ›¼ğºğ‘›6\alpha(G)\geq n/6italic_Î± ( italic_G ) â‰¥ italic_n / 6. This is tight; for example, a graph consisting of disjoint copies of K6subscriptğ¾6K_{6}italic_K start_POSTSUBSCRIPT 6 end_POSTSUBSCRIPT is 1111-planar and has chromatic number 6666. Unlike planar graphs, to the best of our knowledge, there are no prior results222Preliminary version appeared in [8]. on the upper bound for the dğ‘‘ditalic_d-independence number of 1111-planar graphs. Motivated by the work by Caro and Roditty, we ask the following: Problem 1. What is the dğ‘‘ditalic_d-independence number of 1-planar graphs? And does it change if we additionally require the graphs to have minimum degree dğ‘‘ditalic_d? In this paper, we address Problem 1 by giving upper bounds for the dğ‘‘ditalic_d-independence number of 1-planar graphs for dâ‰¥3ğ‘‘3d\geq 3italic_d â‰¥ 3. (No smaller values of dğ‘‘ditalic_d are worth studying, since K2,nsubscriptğ¾2ğ‘›K_{2,n}italic_K start_POSTSUBSCRIPT 2 , italic_n end_POSTSUBSCRIPT has a 2-independent set of size nâˆ’2ğ‘›2n-2italic_n - 2, and so only trivial bounds of nâˆ’Oâ¢(1)ğ‘›ğ‘‚1n-O(1)italic_n - italic_O ( 1 ) can be shown.) Specifically, we show that Î±dâ¢(n)â‰¤4d+âŒˆd/3âŒ‰â¢(nâˆ’2)subscriptğ›¼ğ‘‘ğ‘›4ğ‘‘ğ‘‘3ğ‘›2\alpha_{d}(n)\leq\tfrac{4}{d+\lceil d/3\rceil}(n-2)italic_Î± start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_n ) â‰¤ divide start_ARG 4 end_ARG start_ARG italic_d + âŒˆ italic_d / 3 âŒ‰ end_ARG ( italic_n - 2 ) for dâ‰¥3ğ‘‘3d\geq 3italic_d â‰¥ 3, and this bound holds not only for simple graphs but also in the presence of parallel edges as long as (in some 1-planar drawing) there are no bigons. For simple graphs we can prove the stronger bound Î±3â¢(n)â‰¤67â¢(nâˆ’2)subscriptğ›¼3ğ‘›67ğ‘›2\alpha_{3}(n)\leq\tfrac{6}{7}(n-2)italic_Î± start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ( italic_n ) â‰¤ divide start_ARG 6 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ). Then we construct classes of 1-planar graphs that match these bounds (at least if we permit parallel edges); for small values of dğ‘‘ditalic_d, we can construct the graphs such that they are simple and have minimum degree dğ‘‘ditalic_d. A concise summary of our results is in Table 1. dğ‘‘ditalic_d 3333 4444 5555 6666 7777 8888 9999 10101010 11111111 12121212 13131313 14141414 15151515 16161616 17171717 18181818 â‰¥19absent19{\geq}19â‰¥ 19 Î±dâ¢(G)/nâ‰¤subscriptğ›¼ğ‘‘ğºğ‘›absent\alpha_{d}(G)/n\leqitalic_Î± start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ) / italic_n â‰¤ â‰ˆ67absent67{\scriptstyle{\approx}}\tfrac{6}{7}â‰ˆ divide start_ARG 6 end_ARG start_ARG 7 end_ARG â‰ˆ23absent23{\scriptstyle{\approx}}\tfrac{2}{3}â‰ˆ divide start_ARG 2 end_ARG start_ARG 3 end_ARG â‰ˆ47absent47{\scriptstyle{\approx}}\tfrac{4}{7}â‰ˆ divide start_ARG 4 end_ARG start_ARG 7 end_ARG â‰ˆ12absent12{\scriptstyle{\approx}}\tfrac{1}{2}â‰ˆ divide start_ARG 1 end_ARG start_ARG 2 end_ARG â‰ˆ25absent25{\scriptstyle{\approx}}\tfrac{2}{5}â‰ˆ divide start_ARG 2 end_ARG start_ARG 5 end_ARG â‰ˆ411absent411{\scriptstyle{\approx}}\tfrac{4}{11}â‰ˆ divide start_ARG 4 end_ARG start_ARG 11 end_ARG â‰ˆ13absent13{\scriptstyle{\approx}}\tfrac{1}{3}â‰ˆ divide start_ARG 1 end_ARG start_ARG 3 end_ARG â‰ˆ27absent27{\scriptstyle{\approx}}\tfrac{2}{7}â‰ˆ divide start_ARG 2 end_ARG start_ARG 7 end_ARG â‰ˆ415absent415{\scriptstyle{\approx}}\tfrac{4}{15}â‰ˆ divide start_ARG 4 end_ARG start_ARG 15 end_ARG â‰ˆ14absent14{\scriptstyle{\approx}}\tfrac{1}{4}â‰ˆ divide start_ARG 1 end_ARG start_ARG 4 end_ARG â‰ˆ29absent29{\scriptstyle{\approx}}\tfrac{2}{9}â‰ˆ divide start_ARG 2 end_ARG start_ARG 9 end_ARG â‰ˆ419absent419{\scriptstyle{\approx}}\tfrac{4}{19}â‰ˆ divide start_ARG 4 end_ARG start_ARG 19 end_ARG â‰ˆ15absent15{\scriptstyle{\approx}}\tfrac{1}{5}â‰ˆ divide start_ARG 1 end_ARG start_ARG 5 end_ARG â‰ˆ211absent211{\scriptstyle{\approx}}\tfrac{2}{11}â‰ˆ divide start_ARG 2 end_ARG start_ARG 11 end_ARG â‰ˆ423absent423{\scriptstyle{\approx}}\tfrac{4}{23}â‰ˆ divide start_ARG 4 end_ARG start_ARG 23 end_ARG â‰ˆ16absent16{\scriptstyle{\approx}}\tfrac{1}{6}â‰ˆ divide start_ARG 1 end_ARG start_ARG 6 end_ARG â‰ˆ4d+âŒˆd/3âŒ‰absent4ğ‘‘ğ‘‘3{\scriptstyle{\approx}}\tfrac{4}{d+\lceil d/3\rceil}â‰ˆ divide start_ARG 4 end_ARG start_ARG italic_d + âŒˆ italic_d / 3 âŒ‰ end_ARG (GğºGitalic_G is bigon-free) (GğºGitalic_G simple) âˆƒG:Î±dâ¢(G)/nâ‰¥:ğºsubscriptğ›¼ğ‘‘ğºğ‘›absent\,\exists G:\alpha_{d}(G)/n\geqâˆƒ italic_G : italic_Î± start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ) / italic_n â‰¥ â‰ˆ67absent67{\scriptstyle{\approx}}\tfrac{6}{7}â‰ˆ divide start_ARG 6 end_ARG start_ARG 7 end_ARG â‰ˆ23absent23{\scriptstyle{\approx}}\tfrac{2}{3}â‰ˆ divide start_ARG 2 end_ARG start_ARG 3 end_ARG â‰ˆ47absent47{\scriptstyle{\approx}}\tfrac{4}{7}â‰ˆ divide start_ARG 4 end_ARG start_ARG 7 end_ARG â‰ˆ12absent12{\scriptstyle{\approx}}\tfrac{1}{2}â‰ˆ divide start_ARG 1 end_ARG start_ARG 2 end_ARG â‰ˆ25absent25{\scriptstyle{\approx}}\tfrac{2}{5}â‰ˆ divide start_ARG 2 end_ARG start_ARG 5 end_ARG â‰ˆ13absent13{\scriptstyle{\approx}}\tfrac{1}{3}â‰ˆ divide start_ARG 1 end_ARG start_ARG 3 end_ARG â‰ˆ27absent27{\scriptstyle{\approx}}\tfrac{2}{7}â‰ˆ divide start_ARG 2 end_ARG start_ARG 7 end_ARG â‰ˆ14absent14{\scriptstyle{\approx}}\tfrac{1}{4}â‰ˆ divide start_ARG 1 end_ARG start_ARG 4 end_ARG â‰ˆ313absent313{\scriptstyle{\approx}}\tfrac{3}{13}â‰ˆ divide start_ARG 3 end_ARG start_ARG 13 end_ARG â‰ˆ314absent314{\scriptstyle{\approx}}\tfrac{3}{14}â‰ˆ divide start_ARG 3 end_ARG start_ARG 14 end_ARG â‰ˆ15absent15{\scriptstyle{\approx}}\tfrac{1}{5}â‰ˆ divide start_ARG 1 end_ARG start_ARG 5 end_ARG â‰ˆ211absent211{\scriptstyle{\approx}}\tfrac{2}{11}â‰ˆ divide start_ARG 2 end_ARG start_ARG 11 end_ARG â‰ˆ16absent16{\scriptstyle{\approx}}\tfrac{1}{6}â‰ˆ divide start_ARG 1 end_ARG start_ARG 6 end_ARG â‰ˆ319absent319{\scriptstyle{\approx}}\tfrac{3}{19}â‰ˆ divide start_ARG 3 end_ARG start_ARG 19 end_ARG â‰ˆ320absent320{\scriptstyle{\approx}}\tfrac{3}{20}â‰ˆ divide start_ARG 3 end_ARG start_ARG 20 end_ARG â‰ˆ17absent17{\scriptstyle{\approx}}\tfrac{1}{7}â‰ˆ divide start_ARG 1 end_ARG start_ARG 7 end_ARG â‰ˆ2dâˆ’4absent2ğ‘‘4{\scriptstyle{\approx}}\tfrac{2}{d-4}â‰ˆ divide start_ARG 2 end_ARG start_ARG italic_d - 4 end_ARG (GğºGitalic_G is simple) âˆƒG:Î±dâ¢(G)/nâ‰¥:ğºsubscriptğ›¼ğ‘‘ğºğ‘›absent\,\exists G:\alpha_{d}(G)/n\geqâˆƒ italic_G : italic_Î± start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT ( italic_G ) / italic_n â‰¥ â‰ˆ1absent1{\scriptstyle{\approx}}1â‰ˆ 1 â‰ˆ23absent23{\scriptstyle{\approx}}\tfrac{2}{3}â‰ˆ divide start_ARG 2 end_ARG start_ARG 3 end_ARG â‰ˆ47absent47{\scriptstyle{\approx}}\tfrac{4}{7}â‰ˆ divide start_ARG 4 end_ARG start_ARG 7 end_ARG â‰ˆ12absent12{\scriptstyle{\approx}}\tfrac{1}{2}â‰ˆ divide start_ARG 1 end_ARG start_ARG 2 end_ARG â‰ˆ25absent25{\scriptstyle{\approx}}\tfrac{2}{5}â‰ˆ divide start_ARG 2 end_ARG start_ARG 5 end_ARG â‰ˆ411absent411{\scriptstyle{\approx}}\tfrac{4}{11}â‰ˆ divide start_ARG 4 end_ARG start_ARG 11 end_ARG â‰ˆ13absent13{\scriptstyle{\approx}}\tfrac{1}{3}â‰ˆ divide start_ARG 1 end_ARG start_ARG 3 end_ARG â‰ˆ27absent27{\scriptstyle{\approx}}\tfrac{2}{7}â‰ˆ divide start_ARG 2 end_ARG start_ARG 7 end_ARG â‰ˆ415absent415{\scriptstyle{\approx}}\tfrac{4}{15}â‰ˆ divide start_ARG 4 end_ARG start_ARG 15 end_ARG â‰ˆ14absent14{\scriptstyle{\approx}}\tfrac{1}{4}â‰ˆ divide start_ARG 1 end_ARG start_ARG 4 end_ARG â‰ˆ29absent29{\scriptstyle{\approx}}\tfrac{2}{9}â‰ˆ divide start_ARG 2 end_ARG start_ARG 9 end_ARG â‰ˆ419absent419{\scriptstyle{\approx}}\tfrac{4}{19}â‰ˆ divide start_ARG 4 end_ARG start_ARG 19 end_ARG â‰ˆ15absent15{\scriptstyle{\approx}}\tfrac{1}{5}â‰ˆ divide start_ARG 1 end_ARG start_ARG 5 end_ARG â‰ˆ211absent211{\scriptstyle{\approx}}\tfrac{2}{11}â‰ˆ divide start_ARG 2 end_ARG start_ARG 11 end_ARG â‰ˆ423absent423{\scriptstyle{\approx}}\tfrac{4}{23}â‰ˆ divide start_ARG 4 end_ARG start_ARG 23 end_ARG â‰ˆ16absent16{\scriptstyle{\approx}}\tfrac{1}{6}â‰ˆ divide start_ARG 1 end_ARG start_ARG 6 end_ARG â‰ˆ4d+âŒˆd/3âŒ‰absent4ğ‘‘ğ‘‘3{\scriptstyle{\approx}}\tfrac{4}{d+\lceil d/3\rceil}â‰ˆ divide start_ARG 4 end_ARG start_ARG italic_d + âŒˆ italic_d / 3 âŒ‰ end_ARG (GğºGitalic_G is bigon-free) Table 1: Bounds on the dğ‘‘ditalic_d-independence number of 1-planar graphs. â€˜â‰ˆ{\scriptstyle{\approx}}â‰ˆâ€™ means lower-order terms are omitted. Our constructions for d=3,4,5ğ‘‘345d=3,4,5italic_d = 3 , 4 , 5 actually happen to have minimum degree dğ‘‘ditalic_d, so requiring the minimum degree of the graph to be dğ‘‘ditalic_d makes no difference for d=3,4,5ğ‘‘345d=3,4,5italic_d = 3 , 4 , 5. What happens for d=6,7ğ‘‘67d=6,7italic_d = 6 , 7? (A 1-planar graph has at most 4â¢nâˆ’84ğ‘›84n-84 italic_n - 8 edges, and so cannot have a minimum degree 8 or more.) For d=6ğ‘‘6d=6italic_d = 6 we can modify our construction slightly to achieve a minimum degree 6 while weakening the lower bound by only a constant term. For d=7ğ‘‘7d=7italic_d = 7 we give an entirely different construction that has a fairly large independent set, but we leave a multiplicative gap to the upper bound, see Table 2. Î´â¢(G)=ğ›¿ğºabsent\delta(G)=italic_Î´ ( italic_G ) = 3333 4444 5555 6666 7777 Î±Î´â¢(G)â¢(G)â‰¤subscriptğ›¼ğ›¿ğºğºabsent\alpha_{\delta(G)}(G)\leqitalic_Î± start_POSTSUBSCRIPT italic_Î´ ( italic_G ) end_POSTSUBSCRIPT ( italic_G ) â‰¤ 67â¢(nâˆ’2)67ğ‘›2\tfrac{6}{7}(n-2)divide start_ARG 6 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ) 23â¢(nâˆ’2)23ğ‘›2\tfrac{2}{3}(n-2)divide start_ARG 2 end_ARG start_ARG 3 end_ARG ( italic_n - 2 ) 47â¢(nâˆ’2)47ğ‘›2\tfrac{4}{7}(n-2)divide start_ARG 4 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ) âŒˆ12â¢(nâˆ’4)âŒ‰12ğ‘›4\lceil\tfrac{1}{2}(n-4)\rceilâŒˆ divide start_ARG 1 end_ARG start_ARG 2 end_ARG ( italic_n - 4 ) âŒ‰ 410â¢(nâˆ’2)410ğ‘›2\tfrac{4}{10}(n-2)divide start_ARG 4 end_ARG start_ARG 10 end_ARG ( italic_n - 2 ) âˆƒG:Î±Î´â¢(G)â‰¥:ğºsubscriptğ›¼ğ›¿ğºabsent\exists G:\alpha_{\delta(G)}\geqâˆƒ italic_G : italic_Î± start_POSTSUBSCRIPT italic_Î´ ( italic_G ) end_POSTSUBSCRIPT â‰¥ 67â¢(nâˆ’2)67ğ‘›2\tfrac{6}{7}(n-2)divide start_ARG 6 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ) 23â¢(nâˆ’2)23ğ‘›2\tfrac{2}{3}(n-2)divide start_ARG 2 end_ARG start_ARG 3 end_ARG ( italic_n - 2 ) 47â¢(nâˆ’2)47ğ‘›2\tfrac{4}{7}(n-2)divide start_ARG 4 end_ARG start_ARG 7 end_ARG ( italic_n - 2 ) 12â¢(nâˆ’4)12ğ‘›4\tfrac{1}{2}(n-4)divide start_ARG 1 end_ARG start_ARG 2 end_ARG ( italic_n - 4 ) 821â¢(nâˆ’13.5)821ğ‘›13.5\tfrac{8}{21}(n-13.5)divide start_ARG 8 end_ARG start_ARG 21 end_ARG ( italic_n - 13.5 ) Table 2: Bounds on the dğ‘‘ditalic_d-independence number of 1111-planar graphs with minimum degree Î´â¢(G)=dğ›¿ğºğ‘‘\delta(G)=ditalic_Î´ ( italic_G ) = italic_d. All constructed graphs are simple. We also study the special situation concerns optimal 1-planar graphs, which have the maximum-possible number 4â¢nâˆ’84ğ‘›84n-84 italic_n - 8 of edges. (This is motivated by the observation that the lower-bound constructions of Caro and Roditty all use planar graphs with the maximum possible number of edges, whereas our earlier construction usually does not have the maximum number of edges.) Here we can show that the independence number is at most 2dâ¢(nâˆ’2)2ğ‘‘ğ‘›2\tfrac{2}{d}(n-2)divide start_ARG 2 end_ARG start_ARG italic_d end_ARG ( italic_n - 2 ), and this is tight if we allow parallel edges (and, for small dğ‘‘ditalic_d, even for simple optimal 1-planar graphs). Our results are summarized in Table 3. dğ‘‘ditalic_d 6 8 10 12 â‰¥14absent14\geq 14â‰¥ 14 even Î±Î´â¢(G)â¢(G)â‰¤subscriptğ›¼ğ›¿ğºğºabsent\alpha_{\delta(G)}(G)\leqitalic_Î± start_POSTSUBSCRIPT italic_Î´ ( italic_G ) end_POSTSUBSCRIPT ( italic_G ) â‰¤ 13â¢(nâˆ’2)13ğ‘›2\tfrac{1}{3}(n-2)divide start_ARG 1 end_ARG start_ARG 3 end_ARG ( italic_n - 2 ) 14â¢(nâˆ’2)14ğ‘›2\tfrac{1}{4}(n-2)divide start_ARG 1 end_ARG start_ARG 4 end_ARG ( italic_n - 2 ) 15â¢(nâˆ’2)15ğ‘›2\tfrac{1}{5}(n-2)divide start_ARG 1 end_ARG start_ARG 5 end_ARG ( italic_n - 2 ) 16â¢(nâˆ’2)16ğ‘›2\tfrac{1}{6}(n-2)divide start_ARG 1 end_ARG start_ARG 6 end_ARG ( italic_n - 2 ) 2dâ¢(nâˆ’2)2ğ‘‘ğ‘›2\tfrac{2}{d}(n-2)divide start_ARG 2 end_ARG start_ARG italic_d end_ARG ( italic_n - 2 ) (GğºGitalic_G is bigon-free) âˆƒG:Î±Î´â¢(G)â‰¥:ğºsubscriptğ›¼ğ›¿ğºabsent\exists G:\alpha_{\delta(G)}\geqâˆƒ italic_G : italic_Î± start_POSTSUBSCRIPT italic_Î´ ( italic_G ) end_POSTSUBSCRIPT â‰¥ 13â¢(nâˆ’2)13ğ‘›2\tfrac{1}{3}(n-2)divide start_ARG 1 end_ARG start_ARG 3 end_ARG ( italic_n - 2 ) 14â¢(nâˆ’2)14ğ‘›2\tfrac{1}{4}(n-2)divide start_ARG 1 end_ARG start_ARG 4 end_ARG ( italic_n - 2 ) 15â¢(nâˆ’2)15ğ‘›2\tfrac{1}{5}(n-2)divide start_ARG 1 end_ARG start_ARG 5 end_ARG ( italic_n - 2 ) 16â¢(nâˆ’4)16ğ‘›4\tfrac{1}{6}(n-4)divide start_ARG 1 end_ARG start_ARG 6 end_ARG ( italic_n - 4 ) 2dâ¢(nâˆ’2)2ğ‘‘ğ‘›2\tfrac{2}{d}(n-2)divide start_ARG 2 end_ARG start_ARG italic_d end_ARG ( italic_n - 2 ) (simple) (simple) (simple) (simple) (bigon-free) Table 3: Bounds on the dğ‘‘ditalic_d-independence number of optimal 1111-planar graphs. Our paper is organized as follows. After giving preliminaries, we first present in Section 3 upper bounds for the dğ‘‘ditalic_d-independence number of 1111-planar graphs, strongly inspired by techniques from [7] to bound matchings in 1111-planar graphs. In Section 4, we then construct a number of infinite families of 1111-planar graphs with large dğ‘‘ditalic_d-independent sets that match these bounds, and then further constructions when we require simplicity and/or minimum degree dğ‘‘ditalic_d. Section 5 focuses on the independence number of optimal 1111-planar graphs. Finally, we conclude our paper with further thoughts and pose some open questions."
https://arxiv.org/html/2411.00806v1,"Approximating Diffusion on Finite
Multi-Topology Systems Using Ultrametrics","Motivated by multi-topology building and city model data, first a lossless representation of multiple T0subscriptğ‘‡0T_{0}italic_T start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT-topologies on a given finite set by a vertex-edge-weighted graph is given, and the subdominant ultrametric of the associated weighted graph distance matrix is proposed as an index structure for these data. This is applied in a heuristic parallel topological sort algorithm for edge-weighted directed acyclic graphs. Such structured data are of interest in simulation of processes like heat flows on building or city models on distributed processors. With this in view, the bulk of this article calculates the spectra of certain unbounded self-adjoint pğ‘pitalic_p-adic Laplacian operators on the L2superscriptğ¿2L^{2}italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT-spaces of a compact open subdomain of the pğ‘pitalic_p-adic number field associated with a finite graph GğºGitalic_G with respect to the restricted Haar measure. as well as to a Radon measure coming from an ultrametric on the vertices of GğºGitalic_G with the help of pğ‘pitalic_p-adic polynomial interpolation. In the end, error bounds are given for the solutions of the corresponding heat equations by finite approximations of such operators.","A substantial part of data analysis deals with given finite data, viewed as nodes, and varying pairwise interaction or connectivity, viewed as edges, plus higher-order interaction or connectivity, viewed as simplices. The different graph or simplicial structures on the data help in their understanding by exploring underlying topological and geometrical properties. Diffusion on such structures can often be used as a further tool for understanding them. The diffusion on such structures itself is also often not well understood, and this gives rise to its analytical study. In order to facilitate a data exploration as described above, it is helpful to have an access method for the structered data, and in many cases to distribute the processing onto many different computational units. For both tasks, a hierarchical re-structuring of the data can lead to both, fast accessing and fast processing. This is one of the goals of the current research project Distributed Simulation of Processes in Buildings and City Models in order to facilitate the simulation of processes like heat flows in city models at varying levels of resolution. In particular, if the resolution is high, then substitute models become necessary, as otherwise computing huge Laplacian matrices becomes unfeasible. Hierarchical substitute models are natural candidates for efficient computations, as accessing trees is known to be possible in logarithmic time w.r.t. the number of leaf nodes. Since mathematics provides through the field â„špsubscriptâ„šğ‘\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT of pğ‘pitalic_p-adic numbers a natural hierarchical number system (aka ultrametric), it seemed natural to use these already for indexing point cloud data, i.e. in the case of dimension zero [7]. In any case, it becomes in the above perspective natural to resort to pğ‘pitalic_p-adic diffusion which was initiated via formulating the heat equation with the Vladimirov-Taibleson operator on â„špsubscriptâ„šğ‘\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT or other non-archimedean local fields [22, 23]. This pğ‘pitalic_p-adic Laplacian being a pseudodifferential operator necessitates the domain to be a locally compact abelian group. Another example is the group â„¤psubscriptâ„¤ğ‘\mathds{Z}_{p}blackboard_Z start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT of pğ‘pitalic_p-adic integers [15, 20]. However, if the pğ‘pitalic_p-adic space itself does not have a group structure, then the Fourier transform is no longer available to construct a Laplacian. Its integral operator description was adapted by ZÃºÃ±iga-Galindo to the study of Turing patterns on networks, leading to diffusion operators on general compact open subdomains of â„špsubscriptâ„šğ‘\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT [24]. This approach lends to the idea of asking for diffusion operators on more general pğ‘pitalic_p-adic manifolds. In the case of Mumford curves (which can be viewed as compact closed pğ‘pitalic_p-adic algebraic manifolds), this is ongoing work containing operators which allow to extract topological information from these spaces [3, 4, 5, 6], or also from finite graphs [8]. Applications of ultrametric analysis outside of mathematics or mathematical physics include, but do not restrict to, image processing or microbiology [2, 12]. An important feature of pğ‘pitalic_p-adic or general ultrametric Laplacians is that a huge part of their spectra correspond to Haar-like wavelets of various types [16, 12]. Among pğ‘pitalic_p-adic analysts, the Kozyrev wavelets are the most well-known ones. The goal of this contribution is to define and study pğ‘pitalic_p-adically extended Laplace operators for finite graphs, based on â€¢ weighted graph adjacency â€¢ weighted graph distance â€¢ the subdominant ultrametric of the weighted graph distance and to investigate finite approximations of the solutions to the heat equation corresponding to the above Laplacian operators. The envisaged input data are not merely a graph, but representations of multiple T0subscriptğ‘‡0T_{0}italic_T start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT-topologies on a finite point set (cf. [1]), as this is how data are assembled in the research project mentioned above. The representation is given in the form of a weighted graph, and the subdominant ultrametric of the corresponding graph distance function provides for an index structure in order to efficiently access the topologica data. The vertices of such a graph are now, as in ZÃºnigaâ€™s work [24], associated with disjoint subdiscs of â„špsubscriptâ„šğ‘\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT, and pğ‘pitalic_p-adic polynomial interpolation then allows to construct a Radon measure on this compact pğ‘pitalic_p-adic submanifold. It can be viewed as coming from a regular differential 1111-form on an open piece of a Mumford curve. The natural question arises, whether and when different datasets could be viewed as samples from open compact patches which form a covering of a Mumford curve. This is accompanied by a construction of unbounded pğ‘pitalic_p-adic diffusion operators of the three mentioned types, together with a study of their spectra, Cauchy problem and heat kernels. This complements the bounded Laplacians provided by ZÃºÃ±iga-Galindo [24]. The last contribution consists of error estimates for the solutions of the different types of heat equations. An important concept on the way is given by ultrametric wavelets, a generalisation of Kozyrev wavelets to arbitrary ultrametric spaces, described in [14], whose corresponding trees are locally finite. Having been inspired by the Haar-like wavelets from [11], these ultrametric wavelets are presented here differently than in [14] by using characters of finite cyclic groups, while not making use of their special ultrametric distance and measure. The results of this study can be grouped as follows: 1. Indexing multi-topologies. Motivated by the building and city model data related to the mentioned project, and which consists of points having multiple topologies, because any binary partial ordering defines a T0subscriptğ‘‡0T_{0}italic_T start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT-topologie (and vice versa) by [1], an index structure can be derived by first representing the multiple topologies in a single graph, and then using the subdominant ultrametric of the graph distance. Multiple topologies on a point set arise from various different acyclic binary relations on the same set, like e.g. boundary and aggregation relations, or time-dependent relationships. Observation (2.2). Multiple topologies on a finite point set have a lossless representation as a vertex-weighted graph. Hence, a proposed index structure simply requires a weighted graph: Proposal (2.3). As an index structure for a weighted graph is proposed the subdominant ultrametric of its weigted graph distance matrix. As an application of this index structure, a heuristic parallel topological sort is proposed: Algorithm (2.7). Given an edge-weighted directed acyclic graph, cluster the vertices in parallel, then sort and merge the clusters in parallel, using the subdominant ultrametric index structure. 2. Laplace spectra w.r.t. Haar measure dâ¢xğ‘‘ğ‘¥dxitalic_d italic_x. Unbounded pğ‘pitalic_p-adic kernel functions kpsubscriptğ‘˜ğ‘k_{p}italic_k start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT depending on the type of interaction between vertices of a finite simple connected graph are defined: adjacency, graph distance, (subdominant) ultrametric distance. The Cauchy problem for the heat equation w.r.t. the corresponding Laplacian operator â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT is studied, as well as its spectrum on L2â¢(Z,dâ¢x)superscriptğ¿2ğ‘ğ‘‘ğ‘¥L^{2}(Z,dx)italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Z , italic_d italic_x ), where ZâŠ‚â„špğ‘subscriptâ„šğ‘Z\subset\mathds{Q}_{p}italic_Z âŠ‚ blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT is the compact open subset given as the disjoint union of the pğ‘pitalic_p-adic discs defined by the vertices of a given finite simple and connected graph. In this first part, the measure used on Zğ‘Zitalic_Z is the restricted Haar measure dâ¢xğ‘‘ğ‘¥dxitalic_d italic_x from â„špsubscriptâ„šğ‘\mathds{Q}_{p}blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT. Theorem (3.5). There exists a probability measure ptâ¢(x,â‹…)subscriptğ‘ğ‘¡ğ‘¥â‹…p_{t}(x,\cdot)italic_p start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x , â‹… ) with tâ‰¥0ğ‘¡0t\geq 0italic_t â‰¥ 0, xâˆˆZğ‘¥ğ‘x\in Zitalic_x âˆˆ italic_Z on the Borel Ïƒğœ\sigmaitalic_Ïƒ-algebra of the compact open ZâŠ‚â„špğ‘subscriptâ„šğ‘Z\subset\mathds{Q}_{p}italic_Z âŠ‚ blackboard_Q start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT such that the Cauchy problem for the heat equation with the (unbounded) pğ‘pitalic_p-adic Laplacian operator â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT has a unique solution of the form hâ¢(x,t)=âˆ«Zkpâ¢(x,y)â¢ptâ¢(x,dâ¢y)â„ğ‘¥ğ‘¡subscriptğ‘subscriptğ‘˜ğ‘ğ‘¥ğ‘¦subscriptğ‘ğ‘¡ğ‘¥ğ‘‘ğ‘¦h(x,t)=\int_{Z}k_{p}(x,y)p_{t}(x,dy)italic_h ( italic_x , italic_t ) = âˆ« start_POSTSUBSCRIPT italic_Z end_POSTSUBSCRIPT italic_k start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_x , italic_y ) italic_p start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x , italic_d italic_y ) In addition, ptâ¢(x,â‹…)subscriptğ‘ğ‘¡ğ‘¥â‹…p_{t}(x,\cdot)italic_p start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ( italic_x , â‹… ) is the transition function of a strong Markov process whose paths are cÃ dlÃ g paths. Theorem (3.6). The space L2â¢(Z,dâ¢x)superscriptğ¿2ğ‘ğ‘‘ğ‘¥L^{2}(Z,dx)italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Z , italic_d italic_x ) has an orthonormal basis consisting of the Kozyrev wavelets supported in the discs UvâŠ‚Zsubscriptğ‘ˆğ‘£ğ‘U_{v}\subset Zitalic_U start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT âŠ‚ italic_Z associated with vertices vğ‘£vitalic_v, and the locally constant functions Zâ†’â„‚â†’ğ‘â„‚Z\to\mathds{C}italic_Z â†’ blackboard_C associated with the eigenvectors of a certain Laplacian matrix. These wavelets and functions are all eigenfunctions of operator â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT. In the Kozyrev case, the corresponding eigenvalue can be explicitly given. the operator â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT is self-adjoint, negative semi-definite in case the discs associated with vertices are sufficiently small, and each eigenvalue has only finite multiplicity. Assuming now that â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT is also negative semi-definite, obtain: Corollary (3.7). The heat kernel of â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT exists and has the following form: pâ¢(t,x,y)=âˆ‘Î»âˆˆSpecâ¡(â„‹âˆ™)eÎ»â¢tâ¢ÏˆÎ»â¢(x)â¢ÏˆÎ»â¢(y)ğ‘ğ‘¡ğ‘¥ğ‘¦subscriptğœ†Specsubscriptâ„‹âˆ™superscriptğ‘’ğœ†ğ‘¡subscriptğœ“ğœ†ğ‘¥subscriptğœ“ğœ†ğ‘¦p(t,x,y)=\sum\limits_{\lambda\in\operatorname{Spec}(\mathcal{H}_{\bullet})}e^{% \lambda t}\psi_{\lambda}(x)\psi_{\lambda}(y)italic_p ( italic_t , italic_x , italic_y ) = âˆ‘ start_POSTSUBSCRIPT italic_Î» âˆˆ roman_Spec ( caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT ) end_POSTSUBSCRIPT italic_e start_POSTSUPERSCRIPT italic_Î» italic_t end_POSTSUPERSCRIPT italic_Ïˆ start_POSTSUBSCRIPT italic_Î» end_POSTSUBSCRIPT ( italic_x ) italic_Ïˆ start_POSTSUBSCRIPT italic_Î» end_POSTSUBSCRIPT ( italic_y ) for tâ‰¥0ğ‘¡0t\geq 0italic_t â‰¥ 0 and x,yâˆˆZğ‘¥ğ‘¦ğ‘x,y\in Zitalic_x , italic_y âˆˆ italic_Z, where ÏˆÎ»subscriptğœ“ğœ†\psi_{\lambda}italic_Ïˆ start_POSTSUBSCRIPT italic_Î» end_POSTSUBSCRIPT is a normalised eigenfunction of â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT with eigenvalue Î»âˆˆSpecâ¡(â„‹âˆ™)ğœ†Specsubscriptâ„‹âˆ™\lambda\in\operatorname{Spec}(\mathcal{H}_{\bullet})italic_Î» âˆˆ roman_Spec ( caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT ). 3. Spectrum of pğ‘pitalic_p-adic operators from an ultrametric. Using pğ‘pitalic_p-adic polynomial interpolation, a Radon measure Î½ğœˆ\nuitalic_Î½ on Zğ‘Zitalic_Z is constructed from an ultrametric on the vertex set of a finite graph and the pğ‘pitalic_p-adic discs representing the vertices. In general, the interpolation polynomial is non-linear of high degree, expectedly depending on the number of vertices. The corresponding Radon measure can be viewed as coming from a differential 1111-form on Zğ‘Zitalic_Z, giving rise to the idea that a Mumford curve might be in the background. Furtheromore, Inspired by [11], ultrametric wavelets generalising Kozyrev wavelets are constructed. Then it holds true that: Theorem (3.13). The space L2â¢(Z,Î½)superscriptğ¿2ğ‘ğœˆL^{2}(Z,\nu)italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Z , italic_Î½ ) has an orthonormal basis consisting of the constant function Î½â¢(Z)âˆ’1ğœˆsuperscriptğ‘1\nu(Z)^{-1}italic_Î½ ( italic_Z ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT, and the Kozyrev wavelets supported in the discs associated with the vertices of the graph, and the ultrametric wavelets. These functions are all eigenfunctions of the operator â„‹Î´subscriptâ„‹ğ›¿\mathcal{H}_{\delta}caligraphic_H start_POSTSUBSCRIPT italic_Î´ end_POSTSUBSCRIPT. The eigenvalues corresponding to the wavelets are explicitly given in terms of the differential 1111-form and quantities derived thereof for producing the Radon measure Î½ğœˆ\nuitalic_Î½. The operator â„‹Î´subscriptâ„‹ğ›¿\mathcal{H}_{\delta}caligraphic_H start_POSTSUBSCRIPT italic_Î´ end_POSTSUBSCRIPT is self-adjoint and negative-definite on L2â¢(Z,Î½)superscriptğ¿2ğ‘ğœˆL^{2}(Z,\nu)italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Z , italic_Î½ ). Here, Î´ğ›¿\deltaitalic_Î´ is an ultrametric on the vertex set of the graph. It is a replacement for the âˆ™âˆ™\bulletâˆ™ in the previous set-up, where it instances the subdominant ultrametric of a weighted graph metric. 4. Convergence and error estimates. By discretising the space Zğ‘Zitalic_Z via finite rooted trees resulting from pruning, approximate finite-dimensional operators for â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT can be defined, and the errors in the solution to the Cauchy problem are estimated. Theorem (4.1). Let Tâˆ™â„“â¢(t)superscriptsubscriptğ‘‡âˆ™â„“ğ‘¡T_{\bullet}^{\ell}(t)italic_T start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT ( italic_t ) and Tâˆ™â¢(t)subscriptğ‘‡âˆ™ğ‘¡T_{\bullet}(t)italic_T start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT ( italic_t ) be the semigroups attached to the operators â„‹âˆ™â„“superscriptsubscriptâ„‹âˆ™â„“\mathcal{H}_{\bullet}^{\ell}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT and â„‹âˆ™subscriptâ„‹âˆ™\mathcal{H}_{\bullet}caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT, respectively. Let uâˆˆCâ¢(Z)ğ‘¢ğ¶ğ‘u\in C(Z)italic_u âˆˆ italic_C ( italic_Z ) and tâˆˆ[0,Î³]ğ‘¡0ğ›¾t\in[0,\gamma]italic_t âˆˆ [ 0 , italic_Î³ ], then â€–Tâˆ™â„“â¢(t)â¢uâˆ’Tâˆ™â¢(t)â¢uâ€–âˆâ‰¤Î³â¢â€–uâ€–âˆâ¢(âˆ‘uâ‰ v,[u]ğ”«â‰¡[v]ğ”«Cu,vâ¢Volâ¡(Uv)+Volâ¡(Zâ„“âˆ–Z)â¢maxxâˆˆZ,yâˆˆZâ„“âˆ–Zâ¡|kâˆ™â„“â¢(x,y)|).subscriptnormsuperscriptsubscriptğ‘‡âˆ™â„“ğ‘¡ğ‘¢subscriptğ‘‡âˆ™ğ‘¡ğ‘¢ğ›¾subscriptnormğ‘¢subscriptformulae-sequenceğ‘¢ğ‘£subscriptdelimited-[]ğ‘¢ğ”«subscriptdelimited-[]ğ‘£ğ”«subscriptğ¶ğ‘¢ğ‘£Volsubscriptğ‘ˆğ‘£Volsubscriptğ‘â„“ğ‘subscriptformulae-sequenceğ‘¥ğ‘ğ‘¦subscriptğ‘â„“ğ‘superscriptsubscriptğ‘˜âˆ™â„“ğ‘¥ğ‘¦\begin{split}||T_{\bullet}^{\ell}(t)u-T_{\bullet}(t)u||_{\infty}\leq\gamma||u|% |_{\infty}\left(\sum_{u\neq v,[u]_{\mathfrak{n}}\equiv[v]_{\mathfrak{n}}}C_{u,% v}\operatorname{Vol}(U_{v})+\operatorname{Vol}(Z_{\ell}\setminus Z)\max_{x\in Z% ,y\in Z_{\ell}\setminus Z}|k_{\bullet}^{\ell}(x,y)|\right).\end{split}start_ROW start_CELL | | italic_T start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT ( italic_t ) italic_u - italic_T start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT ( italic_t ) italic_u | | start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT â‰¤ italic_Î³ | | italic_u | | start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT ( âˆ‘ start_POSTSUBSCRIPT italic_u â‰  italic_v , [ italic_u ] start_POSTSUBSCRIPT fraktur_n end_POSTSUBSCRIPT â‰¡ [ italic_v ] start_POSTSUBSCRIPT fraktur_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT italic_C start_POSTSUBSCRIPT italic_u , italic_v end_POSTSUBSCRIPT roman_Vol ( italic_U start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) + roman_Vol ( italic_Z start_POSTSUBSCRIPT roman_â„“ end_POSTSUBSCRIPT âˆ– italic_Z ) roman_max start_POSTSUBSCRIPT italic_x âˆˆ italic_Z , italic_y âˆˆ italic_Z start_POSTSUBSCRIPT roman_â„“ end_POSTSUBSCRIPT âˆ– italic_Z end_POSTSUBSCRIPT | italic_k start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT roman_â„“ end_POSTSUPERSCRIPT ( italic_x , italic_y ) | ) . end_CELL end_ROW Theorem (4.2). Let â„‹asubscriptâ„‹ğ‘\mathcal{H}_{a}caligraphic_H start_POSTSUBSCRIPT italic_a end_POSTSUBSCRIPT and â„‹bsubscriptâ„‹ğ‘\mathcal{H}_{b}caligraphic_H start_POSTSUBSCRIPT italic_b end_POSTSUBSCRIPT, where a,bâˆˆ{Îº,dE,Î´}ğ‘ğ‘ğœ…subscriptğ‘‘ğ¸ğ›¿a,b\in{\left\{\kappa,d_{E},\delta\right\}}italic_a , italic_b âˆˆ { italic_Îº , italic_d start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT , italic_Î´ }. Let Tasubscriptğ‘‡ğ‘T_{a}italic_T start_POSTSUBSCRIPT italic_a end_POSTSUBSCRIPT and Tbsubscriptğ‘‡ğ‘T_{b}italic_T start_POSTSUBSCRIPT italic_b end_POSTSUBSCRIPT the respective attached subgroups. Then the following holds â€–Taâ¢(t)âˆ’Tbâ€–âˆâ‰¤2â¢tâ¢(âˆ‘uâ‰ v,[u]ğ”«â‰¡[v]ğ”«C~u,vâ¢Volâ¡(Uv)).subscriptnormsubscriptğ‘‡ğ‘ğ‘¡subscriptğ‘‡ğ‘2ğ‘¡subscriptformulae-sequenceğ‘¢ğ‘£subscriptdelimited-[]ğ‘¢ğ”«subscriptdelimited-[]ğ‘£ğ”«subscript~ğ¶ğ‘¢ğ‘£Volsubscriptğ‘ˆğ‘£||T_{a}(t)-T_{b}||_{\infty}\leq 2t\left(\sum_{u\neq v,[u]_{\mathfrak{n}}\equiv% [v]_{\mathfrak{n}}}\tilde{C}_{u,v}\operatorname{Vol}(U_{v})\right).| | italic_T start_POSTSUBSCRIPT italic_a end_POSTSUBSCRIPT ( italic_t ) - italic_T start_POSTSUBSCRIPT italic_b end_POSTSUBSCRIPT | | start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT â‰¤ 2 italic_t ( âˆ‘ start_POSTSUBSCRIPT italic_u â‰  italic_v , [ italic_u ] start_POSTSUBSCRIPT fraktur_n end_POSTSUBSCRIPT â‰¡ [ italic_v ] start_POSTSUBSCRIPT fraktur_n end_POSTSUBSCRIPT end_POSTSUBSCRIPT over~ start_ARG italic_C end_ARG start_POSTSUBSCRIPT italic_u , italic_v end_POSTSUBSCRIPT roman_Vol ( italic_U start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) ) . Theorem (4.3). Let uâˆˆXÃ—[0,âˆ)ğ‘¢ğ‘‹0u\in X\times[0,\infty)italic_u âˆˆ italic_X Ã— [ 0 , âˆ ) be a solution of the Cauchy problem for the heat equation âˆ‚âˆ‚tâ¢uâ¢(x,t)ğ‘¡ğ‘¢ğ‘¥ğ‘¡\displaystyle\frac{\partial}{\partial t}u(x,t)divide start_ARG âˆ‚ end_ARG start_ARG âˆ‚ italic_t end_ARG italic_u ( italic_x , italic_t ) âˆ’â„‹âˆ™â¢uâ¢(x,t)=0subscriptâ„‹âˆ™ğ‘¢ğ‘¥ğ‘¡0\displaystyle-\mathcal{H}_{\bullet}u(x,t)=0- caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT italic_u ( italic_x , italic_t ) = 0 uâ¢(x,0)ğ‘¢ğ‘¥0\displaystyle u(x,0)italic_u ( italic_x , 0 ) =u0â¢(x)âˆˆXabsentsubscriptğ‘¢0ğ‘¥ğ‘‹\displaystyle=u_{0}(x)\in X= italic_u start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ( italic_x ) âˆˆ italic_X and unâˆˆXnÃ—[0,âˆ)subscriptğ‘¢ğ‘›subscriptğ‘‹ğ‘›0u_{n}\in X_{n}\times[0,\infty)italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT âˆˆ italic_X start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT Ã— [ 0 , âˆ ) a solution of that for âˆ‚âˆ‚tâ¢unâ¢([x]n,t)ğ‘¡subscriptğ‘¢ğ‘›subscriptdelimited-[]ğ‘¥ğ‘›ğ‘¡\displaystyle\frac{\partial}{\partial t}u_{n}([x]_{n},t)divide start_ARG âˆ‚ end_ARG start_ARG âˆ‚ italic_t end_ARG italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_t ) âˆ’â„‹âˆ™(n)â¢unâ¢([x]n,t)=0superscriptsubscriptâ„‹âˆ™ğ‘›subscriptğ‘¢ğ‘›subscriptdelimited-[]ğ‘¥ğ‘›ğ‘¡0\displaystyle-\mathcal{H}_{\bullet}^{(n)}u_{n}([x]_{n},t)=0- caligraphic_H start_POSTSUBSCRIPT âˆ™ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT ( italic_n ) end_POSTSUPERSCRIPT italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_t ) = 0 unâ¢([x]n,0)subscriptğ‘¢ğ‘›subscriptdelimited-[]ğ‘¥ğ‘›0\displaystyle u_{n}([x]_{n},0)italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , 0 ) =Pnâ¢u0â¢([x]n)âˆˆXnabsentsubscriptğ‘ƒğ‘›subscriptğ‘¢0subscriptdelimited-[]ğ‘¥ğ‘›subscriptğ‘‹ğ‘›\displaystyle=P_{n}u_{0}([x]_{n})\in X_{n}= italic_P start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT italic_u start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) âˆˆ italic_X start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT Then it holds true that limnâ†’âˆsup0â‰¤tâ‰¤Ï„â€–Enâ¢unâ¢([x]n,t)âˆ’uâ¢(x,t)â€–=0subscriptâ†’ğ‘›subscriptsupremum0ğ‘¡ğœnormsubscriptğ¸ğ‘›subscriptğ‘¢ğ‘›subscriptdelimited-[]ğ‘¥ğ‘›ğ‘¡ğ‘¢ğ‘¥ğ‘¡0\lim\limits_{n\to\infty}\sup\limits_{0\leq t\leq\tau}\left\|E_{n}u_{n}([x]_{n}% ,t)-u(x,t)\right\|=0roman_lim start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT roman_sup start_POSTSUBSCRIPT 0 â‰¤ italic_t â‰¤ italic_Ï„ end_POSTSUBSCRIPT âˆ¥ italic_E start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT italic_u start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ( [ italic_x ] start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT , italic_t ) - italic_u ( italic_x , italic_t ) âˆ¥ = 0 for Ï„â‰¥0ğœ0\tau\geq 0italic_Ï„ â‰¥ 0. The article is structured as follows: In Section 2, finite multi-topologies are introduced as a system of finite states endowed with multple T0subscriptğ‘‡0T_{0}italic_T start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT-topologies and interpreted as a complex system with transitions w.r.t. different kinds of topological structures, and diffusion on such. Section 3 defines unbounded pğ‘pitalic_p-adic graph operators on finite weighted graphs with different kinds of kernel functions representing the graph structure via adjacency, graph distance and subdominant ultrametric, defines the corresponding notion of hierarchical Parisi operator and studies the Cauchy problems and Markov process properties. Section 4 estimates errors of the different kinds of operators with respect to each other via tree truncation."
https://arxiv.org/html/2411.02197v1,Matroid Products via Submodular Coupling,"The study of matroid products traces back to the 1970s, when LovÃ¡sz and Mason studied the existence of various types of matroid products with different strengths. Among these, the tensor product is arguably the most important, which can be considered as an extension of the tensor product from linear algebra. However, Las Vergnas showed that the tensor product of two matroids does not always exist. Over the following four decades, matroid products remained surprisingly underexplored, regaining attention only in recent years due to applications in tropical geometry and the limit theory of matroids.In this paper, inspired by the concept of coupling in probability theory, we introduce the notion of coupling for matroids â€“ or, more generally, for submodular set functions. This operation can be viewed as a relaxation of the tensor product. Unlike the tensor product, however, we prove that a coupling always exists for any two submodular functions and can be chosen to be increasing if the original functions are increasing. As a corollary, we show that two matroids always admit a matroid coupling, leading to a novel operation on matroids. Our construction is algorithmic, providing an oracle for the coupling matroid through a polynomial number of oracle calls to the original matroids.We apply this construction to derive new necessary conditions for matroid representability and establish connection between tensor products and Ingletonâ€™s inequality. Additionally, we verify the existence of set functions that are universal with respect to a given property, meaning any set function over a finite domain with that property can be obtained as a quotient.Keywords: Amalgams, Coupling, Coverage functions, Matroids, Product, Quasi-product, Quotients, Submodular functions, Tensor product","Coupling of probability measures, generally attributed to Doeblin [10], is a key concept in probability theory through which random variables can be compared with each other. For two probability measures, a coupling is a joint probability measure over the product of the underlying spaces, such that the marginals correspond to the given probability measures. Formally, if Î¼1subscriptğœ‡1\mu_{1}italic_Î¼ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Î¼2subscriptğœ‡2\mu_{2}italic_Î¼ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are probability measures on spaces (S1,â„¬1)subscriptğ‘†1subscriptâ„¬1(S_{1},\mathcal{B}_{1})( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , caligraphic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) and (S2,â„¬2)subscriptğ‘†2subscriptâ„¬2(S_{2},\mathcal{B}_{2})( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , caligraphic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ), respectively, a coupling is a joint probability measure Î¼ğœ‡\muitalic_Î¼ on the product space (S1Ã—S2,â„¬1âŠ—â„¬2)subscriptğ‘†1subscriptğ‘†2tensor-productsubscriptâ„¬1subscriptâ„¬2(S_{1}\times S_{2},\mathcal{B}_{1}\otimes\mathcal{B}_{2})( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , caligraphic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŠ— caligraphic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) such that the marginal of Î¼ğœ‡\muitalic_Î¼ on Sisubscriptğ‘†ğ‘–S_{i}italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is Î¼isubscriptğœ‡ğ‘–\mu_{i}italic_Î¼ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT for i=1,2ğ‘–12i=1,2italic_i = 1 , 2, i.e., Î¼â¢(X1Ã—S2)=Î¼1â¢(X1)ğœ‡subscriptğ‘‹1subscriptğ‘†2subscriptğœ‡1subscriptğ‘‹1\mu(X_{1}\times S_{2})=\mu_{1}(X_{1})italic_Î¼ ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_Î¼ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) for any X1âˆˆâ„¬1subscriptğ‘‹1subscriptâ„¬1X_{1}\in\mathcal{B}_{1}italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âˆˆ caligraphic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Î¼â¢(S1Ã—X2)=Î¼2â¢(X2)ğœ‡subscriptğ‘†1subscriptğ‘‹2subscriptğœ‡2subscriptğ‘‹2\mu(S_{1}\times X_{2})=\mu_{2}(X_{2})italic_Î¼ ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_Î¼ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) for any X2âˆˆâ„¬2subscriptğ‘‹2subscriptâ„¬2X_{2}\in\mathcal{B}_{2}italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âˆˆ caligraphic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Usually, the goal is to choose a coupling that allows for comparisons between the probability measures, such as minimizing differences or distances between them. Coupling techniques have found applications in various areas. In optimal transport theory, the goal is to find the most efficient way to transform one distribution into another, with applications in economics, statistical physics and machine learning [8]. In stochastic processes, coupling helps to describe the joint behavior of random variables and to analyze and bound convergence rates in chains with more complex dependencies [26, 1]. Interestingly, a similar notion has also appeared in a combinatorial line of research on matroids. Let M1=(S1,r1)subscriptğ‘€1subscriptğ‘†1subscriptğ‘Ÿ1M_{1}=(S_{1},r_{1})italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) and M2=(S2,r2)subscriptğ‘€2subscriptğ‘†2subscriptğ‘Ÿ2M_{2}=(S_{2},r_{2})italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = ( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) be finite matroids over ground sets S1subscriptğ‘†1S_{1}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and S2subscriptğ‘†2S_{2}italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT with rank functions r1subscriptğ‘Ÿ1r_{1}italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and r2subscriptğ‘Ÿ2r_{2}italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, respectively. A matroid M=(S1Ã—S2,r)ğ‘€subscriptğ‘†1subscriptğ‘†2ğ‘ŸM=(S_{1}\times S_{2},r)italic_M = ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_r ) is called a quasi-product of M1subscriptğ‘€1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and M2subscriptğ‘€2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT if the restriction of Mğ‘€Mitalic_M to {x}Ã—S2ğ‘¥subscriptğ‘†2\{x\}\times S_{2}{ italic_x } Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is isomorphic to M2subscriptğ‘€2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT by the natural bijection with S2subscriptğ‘†2S_{2}italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT for all non-loops xâˆˆS1ğ‘¥subscriptğ‘†1x\in S_{1}italic_x âˆˆ italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and is the zero matroid for loops xğ‘¥xitalic_x, and analogously with the two factors interchanged. If furthermore XÃ—Yğ‘‹ğ‘ŒX\times Yitalic_X Ã— italic_Y is a flat of Mğ‘€Mitalic_M for all flats Xğ‘‹Xitalic_X of M1subscriptğ‘€1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Yğ‘ŒYitalic_Y of M2subscriptğ‘€2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, then Mğ‘€Mitalic_M is called a product of M1subscriptğ‘€1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and M2subscriptğ‘€2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Finally, if râ¢(XÃ—Y)=r1â¢(X)â‹…r2â¢(Y)ğ‘Ÿğ‘‹ğ‘Œâ‹…subscriptğ‘Ÿ1ğ‘‹subscriptğ‘Ÿ2ğ‘Œr(X\times Y)=r_{1}(X)\cdot r_{2}(Y)italic_r ( italic_X Ã— italic_Y ) = italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X ) â‹… italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_Y ) holds for every XâŠ†S1,YâŠ†S2formulae-sequenceğ‘‹subscriptğ‘†1ğ‘Œsubscriptğ‘†2X\subseteq S_{1},Y\subseteq S_{2}italic_X âŠ† italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Y âŠ† italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, then Mğ‘€Mitalic_M is a tensor product of M1subscriptğ‘€1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and M2subscriptğ‘€2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Note that at this point, it is not clear whether any two matroids admit a tensor product, a product, or even a quasi-product. Mason [31] and LovÃ¡sz [27] provided constructions yielding a product of rank r1â¢(S1)+r2â¢(S2)âˆ’1subscriptğ‘Ÿ1subscriptğ‘†1subscriptğ‘Ÿ2subscriptğ‘†21r_{1}(S_{1})+r_{2}(S_{2})-1italic_r start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) + italic_r start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) - 1 via Dilworth completion. The existence of a tensor product, however, was asked as an open question in [27]. Note that if both M1subscriptğ‘€1M_{1}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and M2subscriptğ‘€2M_{2}italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are linear matroids over the same field, then it is easy to construct a tensor product by taking the tensor product of the matrices representing them. Nevertheless, Las Vergnas [25] later showed that the situation is generally not so fortunate, as, for example, the VÃ¡mos matroid and the rank-2 uniform matroid on three elements do not admit a tensor product. One can think of the tensor product of two matroids as the â€œfreestâ€ among their possible products as it provides an unrestricted way to combine two matroids while preserving structure along both dimensions, meaning that the product of independent sets is also independent. However, since a tensor product does not exist for every pair of matroids, Mason [30] raised the problem of whether a freest product exists among the possible products. Las Vergnas [25] answered this question in the negative, and showed that the matroid obtained via Dilworth completion as in [27, 30] is the freest quasi-product satisfying râ¢({x,xâ€²}Ã—{y,yâ€²})â‰¤3ğ‘Ÿğ‘¥superscriptğ‘¥â€²ğ‘¦superscriptğ‘¦â€²3r(\{x,x^{\prime}\}\times\{y,y^{\prime}\})\leq 3italic_r ( { italic_x , italic_x start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT } Ã— { italic_y , italic_y start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT } ) â‰¤ 3 for all x,xâ€²âˆˆS1ğ‘¥superscriptğ‘¥â€²subscriptğ‘†1x,x^{\prime}\in S_{1}italic_x , italic_x start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and y,yâ€²âˆˆS2ğ‘¦superscriptğ‘¦â€²subscriptğ‘†2y,y^{\prime}\in S_{2}italic_y , italic_y start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, where rğ‘Ÿritalic_r denotes the rank function of the product matroid. In summary, while the marginals of both couplings of probability measures and matroid tensor products match the original measures or rank functions up to a constant factor, they differ in key structural aspects. Couplings do not require measures to appear on sets of the form {x}Ã—S2ğ‘¥subscriptğ‘†2\{x\}\times S_{2}{ italic_x } Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT or S1Ã—{y}subscriptğ‘†1ğ‘¦S_{1}\times\{y\}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— { italic_y } called fibers, whereas matroid product constructions enforce this as a strict condition. Additionally, in probability couplings, the measure on the product space equals the product of the original measures, while for matroids, the rank of the product is typically lower than the product of the individual ranks. 1.1 Our results and techniques In this paper, we extend the concept of coupling to matroids and, more broadly, to submodular functions. We prove that, unlike tensor products, couplings always exist, leading to a novel operation on matroids. This result is particularly interesting because it shows that a finite number of matroids can be encoded into a single one, while also taking into account how these matroids interact with each other. As an application, we establish the existence of functions that are universal with respect to some property, meaning that any set function with that property can be obtained as a quotient. This result brings new insights into the developing limit theory of matroids and submodular functions. Let Ï†1:2S1â†’â„:subscriptğœ‘1â†’superscript2subscriptğ‘†1â„\varphi_{1}\colon 2^{S_{1}}\to\mathbb{R}italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â†’ blackboard_R and Ï†2:2S2â†’â„:subscriptğœ‘2â†’superscript2subscriptğ‘†2â„\varphi_{2}\colon 2^{S_{2}}\to\mathbb{R}italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â†’ blackboard_R be set functions defined over finite ground sets S1subscriptğ‘†1S_{1}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and S2subscriptğ‘†2S_{2}italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, respectively. The notion of a tensor product can be naturally extended to set functions by calling a function Ï†:2S1Ã—S2â†’â„:ğœ‘â†’superscript2subscriptğ‘†1subscriptğ‘†2â„\varphi\colon 2^{S_{1}\times S_{2}}\to\mathbb{R}italic_Ï† : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â†’ blackboard_R a tensor product of Ï†1subscriptğœ‘1\varphi_{1}italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Ï†2subscriptğœ‘2\varphi_{2}italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT if Ï†â¢(X1Ã—X2)=Ï†1â¢(X1)â‹…Ï†2â¢(X2)ğœ‘subscriptğ‘‹1subscriptğ‘‹2â‹…subscriptğœ‘1subscriptğ‘‹1subscriptğœ‘2subscriptğ‘‹2\varphi(X_{1}\times X_{2})=\varphi_{1}(X_{1})\cdot\varphi_{2}(X_{2})italic_Ï† ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) â‹… italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) holds for every X1âŠ†S1subscriptğ‘‹1subscriptğ‘†1X_{1}\subseteq S_{1}italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŠ† italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and X2âŠ†S2subscriptğ‘‹2subscriptğ‘†2X_{2}\subseteq S_{2}italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âŠ† italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. As a new concept, we call Ï†ğœ‘\varphiitalic_Ï† a coupling of Ï†1subscriptğœ‘1\varphi_{1}italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Ï†2subscriptğœ‘2\varphi_{2}italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT if Ï†â¢(X1Ã—S2)=Ï†1â¢(X1)â‹…Ï†2â¢(S2)ğœ‘subscriptğ‘‹1subscriptğ‘†2â‹…subscriptğœ‘1subscriptğ‘‹1subscriptğœ‘2subscriptğ‘†2\varphi(X_{1}\times S_{2})=\varphi_{1}(X_{1})\cdot\varphi_{2}(S_{2})italic_Ï† ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) â‹… italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) for every X1âŠ†S1subscriptğ‘‹1subscriptğ‘†1X_{1}\subseteq S_{1}italic_X start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âŠ† italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Ï†â¢(S1Ã—X2)=Ï†1â¢(S1)â‹…Ï†2â¢(X2)ğœ‘subscriptğ‘†1subscriptğ‘‹2â‹…subscriptğœ‘1subscriptğ‘†1subscriptğœ‘2subscriptğ‘‹2\varphi(S_{1}\times X_{2})=\varphi_{1}(S_{1})\cdot\varphi_{2}(X_{2})italic_Ï† ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) = italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) â‹… italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) for every X2âŠ†S2subscriptğ‘‹2subscriptğ‘†2X_{2}\subseteq S_{2}italic_X start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âŠ† italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. In other words, a coupling is a set function on the product set, where the projections onto each coordinate return the corresponding Ï†isubscriptğœ‘ğ‘–\varphi_{i}italic_Ï† start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, up to a constant multiplier. Motivated by the goal of defining the coupling of matroids, Section 3 focuses on submodular functions. First, we show that any two submodular functions admit a submodular coupling (Theorem 3.1). One remarkable feature of the proof is that it provides an explicit formula for the coupling function using two arbitrary modular functions. However, the proof itself does not imply that if both Ï†1subscriptğœ‘1\varphi_{1}italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Ï†2subscriptğœ‘2\varphi_{2}italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are monotonically increasing, then the coupling function Ï†ğœ‘\varphiitalic_Ï† is also monotonically increasing. Since this property is essential for the coupling of two matroids to result in a matroid, next we show that a k1subscriptğ‘˜1k_{1}italic_k start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-polymatroid function and a k2subscriptğ‘˜2k_{2}italic_k start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-polymatroid function have a (k1â‹…k2)â‹…subscriptğ‘˜1subscriptğ‘˜2(k_{1}\cdot k_{2})( italic_k start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â‹… italic_k start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )-polymatroid coupling, which is also integer-valued if the original functions are (Theorem 3.2). The proof follows a similar idea as that of the submodular case, but the modular functions in question need to be chosen to be elements in the base polyhedra of Ï†1subscriptğœ‘1\varphi_{1}italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Ï†2subscriptğœ‘2\varphi_{2}italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, respectively. As a corollary, we get that any two matroids admit a coupling (Corollary 3.6) which in turn implies that there exists a finite matroid that contains every matroid of fixed rank over a ground set of fixed size (Corollary 3.7). We provide several equivalent characterizations of two matroids having a coupling that is also a tensor product (Theorem 3.11), and establish a strong connection between tensor products and Ingletonâ€™s inequality, a fundamental tool in the theory of representable matroids (Theorem 3.14). As a corollary, we get a new proof for the fact that the uniform matroid U2,3subscriptğ‘ˆ23U_{2,3}italic_U start_POSTSUBSCRIPT 2 , 3 end_POSTSUBSCRIPT and the VÃ¡mos matroid do not admit a tensor product. We separately study a subclass of increasing submodular functions with strong structural properties, called â€œcoverage functionsâ€ in combinatorial optimization. These functions were originally introduced by Choquet for analytical studies. He defined them in terms of a sequence of inequalities strengthening submodularity, and proved their equivalence with what is now the combinatorial definition. We prove that a coverage function and an increasing submodular function have an increasing submodular tensor product (Corollary 3.17), and that any two coverage functions have a tensor product that is a coverage function (Corollary 3.19). The proofs rely on the characterization of the extreme rays of the cone of coverage functions, as established by Choquet. Finally, we describe how to extend our results on submodular functions defined on finite ground sets to those with infinite domains (Theorems 3.22 and 3.23). Let Ï†ğœ‘\varphiitalic_Ï† be a set function over some finite ground set Sğ‘†Sitalic_S, and let ğ’¬=(S1,â€¦,Sq)ğ’¬subscriptğ‘†1â€¦subscriptğ‘†ğ‘\mathcal{Q}=(S_{1},\dots,S_{q})caligraphic_Q = ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_S start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ) be a partition of Sğ‘†Sitalic_S into qğ‘qitalic_q possibly empty parts. The quotient of Ï†ğœ‘\varphiitalic_Ï† with respect to ğ’¬ğ’¬\mathcal{Q}caligraphic_Q is a set function Ï†ğ’¬subscriptğœ‘ğ’¬\varphi_{\mathcal{Q}}italic_Ï† start_POSTSUBSCRIPT caligraphic_Q end_POSTSUBSCRIPT over Sğ’¬={s1,â€¦,sq}subscriptğ‘†ğ’¬subscriptğ‘ 1â€¦subscriptğ‘ ğ‘S_{\mathcal{Q}}=\{s_{1},\dots,s_{q}\}italic_S start_POSTSUBSCRIPT caligraphic_Q end_POSTSUBSCRIPT = { italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_s start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT } defined by Ï†ğ’¬â¢(X)=Ï†â¢(â‹ƒsiâˆˆXSi)subscriptğœ‘ğ’¬ğ‘‹ğœ‘subscriptsubscriptğ‘ ğ‘–ğ‘‹subscriptğ‘†ğ‘–\varphi_{\mathcal{Q}}(X)=\varphi(\bigcup_{s_{i}\in X}S_{i})italic_Ï† start_POSTSUBSCRIPT caligraphic_Q end_POSTSUBSCRIPT ( italic_X ) = italic_Ï† ( â‹ƒ start_POSTSUBSCRIPT italic_s start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âˆˆ italic_X end_POSTSUBSCRIPT italic_S start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) for XâŠ†Sğ’¬ğ‘‹subscriptğ‘†ğ’¬X\subseteq S_{\mathcal{Q}}italic_X âŠ† italic_S start_POSTSUBSCRIPT caligraphic_Q end_POSTSUBSCRIPT. In particular, if Ï†:2S1Ã—S2â†’â„:ğœ‘â†’superscript2subscriptğ‘†1subscriptğ‘†2â„\varphi\colon 2^{S_{1}\times S_{2}}\to\mathbb{R}italic_Ï† : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â†’ blackboard_R is a coupling of Ï†1:2S1â†’â„:subscriptğœ‘1â†’superscript2subscriptğ‘†1â„\varphi_{1}\colon 2^{S_{1}}\to\mathbb{R}italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â†’ blackboard_R and Ï†2:2S2â†’â„:subscriptğœ‘2â†’superscript2subscriptğ‘†2â„\varphi_{2}\colon 2^{S_{2}}\to\mathbb{R}italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT : 2 start_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT â†’ blackboard_R and ğ’¬1subscriptğ’¬1\mathcal{Q}_{1}caligraphic_Q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and ğ’¬2subscriptğ’¬2\mathcal{Q}_{2}caligraphic_Q start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are the partitions of S1Ã—S2subscriptğ‘†1subscriptğ‘†2S_{1}\times S_{2}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT into fibers of the form {x}Ã—S2ğ‘¥subscriptğ‘†2\{x\}\times S_{2}{ italic_x } Ã— italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and S1Ã—{y}subscriptğ‘†1ğ‘¦S_{1}\times\{y\}italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— { italic_y }, respectively, then Ï†1=Ï†2â¢(S2)â‹…Ï†ğ’¬1subscriptğœ‘1â‹…subscriptğœ‘2subscriptğ‘†2subscriptğœ‘subscriptğ’¬1\varphi_{1}=\varphi_{2}(S_{2})\cdot\varphi_{\mathcal{Q}_{1}}italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) â‹… italic_Ï† start_POSTSUBSCRIPT caligraphic_Q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT and Ï†2=Ï†1â¢(S1)â‹…Ï†ğ’¬2subscriptğœ‘2â‹…subscriptğœ‘1subscriptğ‘†1subscriptğœ‘subscriptğ’¬2\varphi_{2}=\varphi_{1}(S_{1})\cdot\varphi_{\mathcal{Q}_{2}}italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ( italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) â‹… italic_Ï† start_POSTSUBSCRIPT caligraphic_Q start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT. The positive results of Section 3 motivate the following question: Given a property of set functions, is there a function that is universal with respect to that property, in the sense that every function exhibiting the property can be obtained as its quotient? In Section 4, we examine this problem and show that, under some natural assumptions, the answer is positive (Theorem 4.2). Although the proof is analytical and may therefore be less appealing to those interested in combinatorial optimization, the result has far-reaching implications for functions defined on finite ground sets as well. For example, we obtain that there exists a submodular function Ï†:2â„¤â†’[0,1]:ğœ‘â†’superscript2â„¤01\varphi\colon 2^{\mathbb{Z}}\to[0,1]italic_Ï† : 2 start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT â†’ [ 0 , 1 ] such that any nonnegative normalized submodular function is a quotient of Ï†ğœ‘\varphiitalic_Ï† (Corollary 4.3), and we prove an analogous result for coverage functions as well (Corollary 4.4). We conclude the section by providing an explicit construction for a universal coverage function, being in sharp contrast with the preceding non-constructive universality results; the formula of the function is surprisingly simple (Theorem 4.6). It is worth emphasizing that for functions over finite ground sets, our proofs are algorithmic in the sense that given value oracles for Ï†1subscriptğœ‘1\varphi_{1}italic_Ï† start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and Ï†2subscriptğœ‘2\varphi_{2}italic_Ï† start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, one can construct a value oracle for their coupling Ï†ğœ‘\varphiitalic_Ï† with the desired properties in polynomial time. 1.2 Related work and motivation Understanding how matroids can be combined does not only help in studying properties of larger systems formed from simpler matroid components, but it is closely related to a range of problems and techniques in combinatorial optimization. In what follows, we give a brief overview of related topics. Tropical geometry. Tensor products of matroids have deep connections to tropical geometry. A key consequence of Las Vergnasâ€™s counterexample is that the tensor product of tropical linear spaces does not always yield a tropical linear space, see e.g. [18]. The notion of tensor products can be extended to more than two matroids. If all kğ‘˜kitalic_k matroids in the product are identical to a given matroid M=(S,r)ğ‘€ğ‘†ğ‘ŸM=(S,r)italic_M = ( italic_S , italic_r ), the tensor product defines a matroid structure on the set of ordered kğ‘˜kitalic_k-tuples from Sğ‘†Sitalic_S, known as the kğ‘˜kitalic_k-th power of Mğ‘€Mitalic_M. For unordered kğ‘˜kitalic_k-tuples, we consider symmetric tensors, which remain invariant under any permutation of their variables. The concept of symmetric powers of matroids was first introduced by LovÃ¡sz [27] and Mason [30], who noted that not all matroids admit higher symmetric powers. Draisma and RincÃ³n [13] established a link between tropical ideals and matroid symmetric powers by showing that the Bergman fan of the direct sum of the VÃ¡mos matroid and U2,3subscriptğ‘ˆ23U_{2,3}italic_U start_POSTSUBSCRIPT 2 , 3 end_POSTSUBSCRIPT is not a tropically realizable variety. In [2], Anderson proved an equivalence between valuated matroids with arbitrarily large symmetric powers and tropical linear spaces represented as varieties of tropical ideals. Brakensiek, Dhar, Gao, Gopi, and Larson [7] explored the connection between rigidity matroids of graphs and matroids arising from linear algebraic constructions like tensor products and symmetric products. Matroid tensor products in tropical geometry were also examined in [22, 14]. Linear matroids. A matroid is called linear if its independent sets can be represented by vectors in a vector space over some field ğ”½ğ”½\mathbb{F}blackboard_F. Such matroids are particularly interesting because they allow for a rich connection between linear algebra and combinatorial structures. For deciding if a matroid is regular, i.e. representable over every field, Seymourâ€™s decomposition theorem [35] implies an algorithm, as such decompositions can be found efficiently [36]. However, Truemper [36] showed that many representability questions cannot be efficiently solved. This includes deciding representability over a specific field, over all fields with a given characteristic, and, most importantly, over any field. Since determining representability is oracle-hard in general, the focus of research has shifted toward finding necessary or sufficient conditions. Ingletonâ€™s inequality [21] is one of the most prominent examples, giving a necessary condition for a matroid to be linear. Surprisingly, we show that representability of a matroid is closely related to having a tensor product with U2,3subscriptğ‘ˆ23U_{2,3}italic_U start_POSTSUBSCRIPT 2 , 3 end_POSTSUBSCRIPT. Limits of matroids. The limit theory of graphs provides powerful tools for analyzing sequences of graphs and their structural similarities through analytic methods. By defining convergence in terms of distributions of small subgraphs (left-convergence) and homomorphisms into small graphs (right-convergence), it aids in understanding complex networks and their applications in various fields of mathematics and computer science; we refer the interested reader to [28] for a thorough introduction. In [5], a new form of right-convergence called quotient-convergence was introduced for set functions, which eventually led to a notion of convergence of matroids through their rank functions. The limit object of such a sequence is a submodular function [29]. One of the main research subjects is understanding the structure and properties of these limit objects, which heavily relies on examining their quotients and the coupling of the functions in the sequence. Extended formulations. For a polytope PâŠ†â„dğ‘ƒsuperscriptâ„ğ‘‘P\subseteq\mathbb{R}^{d}italic_P âŠ† blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT, an extension of Pğ‘ƒPitalic_P is a polytope Qâˆˆâ„dâ€²ğ‘„superscriptâ„superscriptğ‘‘â€²Q\in\mathbb{R}^{d^{\prime}}italic_Q âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT such that P=Ï€â¢(Q)ğ‘ƒğœ‹ğ‘„P=\pi(Q)italic_P = italic_Ï€ ( italic_Q ) for some affine map Ï€:â„dâ€²â†’â„d:ğœ‹â†’superscriptâ„superscriptğ‘‘â€²superscriptâ„ğ‘‘\pi\colon\mathbb{R}^{d^{\prime}}\to\mathbb{R}^{d}italic_Ï€ : blackboard_R start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT â†’ blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT. The extension complexity xcâ¡(P)xcğ‘ƒ\operatorname{xc}(P)roman_xc ( italic_P ) of Pğ‘ƒPitalic_P is defined as the minimum number of facets of an extension of Pğ‘ƒPitalic_P. If Qğ‘„Qitalic_Q is given by a linear description Q={yâˆˆâ„dâ€²âˆ£Aâ¢yâ‰¤b}ğ‘„conditional-setğ‘¦superscriptâ„superscriptğ‘‘â€²ğ´ğ‘¦ğ‘Q=\{y\in\mathbb{R}^{d^{\prime}}\mid Ay\leq b\}italic_Q = { italic_y âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT âˆ£ italic_A italic_y â‰¤ italic_b }, then {xâˆˆâ„dâˆ£Aâ¢yâ‰¤b,x=Ï€â¢(y)}conditional-setğ‘¥superscriptâ„ğ‘‘formulae-sequenceğ´ğ‘¦ğ‘ğ‘¥ğœ‹ğ‘¦\{x\in\mathbb{R}^{d}\mid Ay\leq b,x=\pi(y)\}{ italic_x âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT âˆ£ italic_A italic_y â‰¤ italic_b , italic_x = italic_Ï€ ( italic_y ) } is called an extended formulation of Pğ‘ƒPitalic_P. Using this terminology, the extension complexity of a polytope is the minimum number of inequality constraints in an extended formulation. Since the fundamental work of Yannakakis [38], the extension complexity of various families of polytopes that appear naturally in combinatorial and graph optimization problems has been settled, such as the traveling salesman and cut polytopes [15], the stable set polytope [15, 19], the matching polytope [34], and recently the independence polytope of regular matroids [3]. Taking the quotient of a function is similar to projection; however, instead of retaining only certain coordinates of a solution, the coordinates are partitioned and summed within each partition class. Consequently, the coupling of matroids, or more generally, submodular functions leads to a different type of â€œextendedâ€ formulation that is of independent combinatorial interest. 1.3 Organization The rest of the paper is organized as follows. In Section 2, we introduce basic definitions, notation, and relevant results on submodular functions, matroids, and polymatroids. Section 3 is devoted to verifying the existence of couplings for various functions, first focusing on submodular functions in Section 3.1 and then extending these results to polymatroid functions in Section 3.2. In Section 3.3, we show how these observations lead to one of the main results of the paper: the existence of matroidal couplings that are almost tensor products. Section 3.3.1 explores the relation between our construction and matroidal amalgams. To understand the fine line between couplings and tensor products, we establish a necessary and sufficient condition for a coupling to be a tensor product in Section 3.3.2. Finally, in Section 3.3.3, we provide new necessary conditions for matroid representability. As an application, we verify the existence of functions that are universal with respect to certain properties in Section 4. The proof is analytical and hence is not constructive; we encourage first-time readers to skip the technical parts of Sections 4.1 and 4.2. As an application of the abstract existence theorem, we deduce that universal functions exist for several set function properties; these examples can be found in Section 4.3. Finally, we give an explicit construction for a universal coverage function in Section 4.4."
https://arxiv.org/html/2411.02122v1,Centered colorings in minor-closed graph classes,"A vertex coloring Ï†ğœ‘\varphiitalic_Ï† of a graph GğºGitalic_G is pğ‘pitalic_p-centered if for every connected subgraph Hğ»Hitalic_H of GğºGitalic_G, either Ï†ğœ‘\varphiitalic_Ï† uses more than pğ‘pitalic_p colors on Hğ»Hitalic_H, or there is a color that appears exactly once on Hğ»Hitalic_H. We prove that for every fixed positive integer tğ‘¡titalic_t, every Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graph admits a pğ‘pitalic_p-centered coloring using ğ’ªâ¢(ptâˆ’1)ğ’ªsuperscriptğ‘ğ‘¡1\mathcal{O}(p^{t-1})caligraphic_O ( italic_p start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT ) colors.","Let GğºGitalic_G be a graph, pğ‘pitalic_p be a positive integer, and Cğ¶Citalic_C be a set of colors. A coloring Ï†:Vâ¢(G)â†’C:ğœ‘â†’ğ‘‰ğºğ¶\varphi\colon V(G)\to Citalic_Ï† : italic_V ( italic_G ) â†’ italic_C of GğºGitalic_G is pğ‘pitalic_p-centered if for every connected111 In this paper, connected graphs are nonnull, that is, they have at least one vertex. Note that a tree is defined as a connected forest, thus, trees and subtrees are also assumed to be nonnull. subgraph Hğ»Hitalic_H of GğºGitalic_G, either Ï†ğœ‘\varphiitalic_Ï† uses more than pğ‘pitalic_p colors on Hğ»Hitalic_H, or there is a color that appears exactly once on Hğ»Hitalic_H. The pğ‘pitalic_p-centered chromatic number of GğºGitalic_G, denoted by Ï‡pâ¢(G)subscriptğœ’ğ‘ğº\chi_{p}(G)italic_Ï‡ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ), is the least nonnegative integer kğ‘˜kitalic_k such that GğºGitalic_G admits a pğ‘pitalic_p-centered coloring using kğ‘˜kitalic_k colors. The following theorem is the main contribution of this paper. Theorem 1. Let tğ‘¡titalic_t be an integer with tâ©¾2ğ‘¡2t\geqslant 2italic_t â©¾ 2. There exists an integer cğ‘citalic_c such that for every Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graph GğºGitalic_G and for every positive integer pğ‘pitalic_p, Ï‡pâ¢(G)â©½câ‹…ptâˆ’1.subscriptğœ’ğ‘ğºâ‹…ğ‘superscriptğ‘ğ‘¡1\chi_{p}(G)\leqslant c\cdot p^{t-1}.italic_Ï‡ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) â©½ italic_c â‹… italic_p start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT . This improves on the work of Pilipczuk and Siebertz [11] who proved that for every integer tğ‘¡titalic_t with tâ©¾2ğ‘¡2t\geqslant 2italic_t â©¾ 2, Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs have pğ‘pitalic_p-centered chromatic number upper bounded by a polynomial in pğ‘pitalic_p. Contrary to Theorem 1, the degree of their polynomial is not explicitly given and arises from an application of the graph minor structure theorem by Robertson and Seymour [13]. On the other hand, DÄ™bski, Micek, SchrÃ¶der, and Felsner [5] showed that there exist Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs with pğ‘pitalic_p-centered chromatic number in Î©â¢(ptâˆ’2)Î©superscriptğ‘ğ‘¡2\Omega(p^{t-2})roman_Î© ( italic_p start_POSTSUPERSCRIPT italic_t - 2 end_POSTSUPERSCRIPT ). Hence, Theorem 1 is tight, up to an ğ’ªâ¢(p)ğ’ªğ‘\mathcal{O}(p)caligraphic_O ( italic_p ) factor. Let us provide some context for our theorem. One of the driving forces in graph theory continues to be the development of efficient algorithms for computationally hard problems for sparse graph classes. NeÅ¡etÅ™il and Ossona de Mendez [10] introduced the concepts of bounded expansion and nowhere denseness of classes of graphs. These notions cover many well-studied classes of graphs, such as graphs excluding a fixed minor, graphs of bounded book-thickness or graphs that admit drawings with a bounded number of crossings per edge. A key reason why centered colorings have gained significant attention is that they encapsulate the concept of bounded expansion. Indeed, a class of graphs ğ’ğ’\mathcal{C}caligraphic_C has bounded expansion if and only if there is a function f:â„•â†’â„•:ğ‘“â†’â„•â„•f\colon\mathbb{N}\to\mathbb{N}italic_f : blackboard_N â†’ blackboard_N such that for all positive integers pğ‘pitalic_p, we have Ï‡pâ¢(G)â©½fâ¢(p)subscriptğœ’ğ‘ğºğ‘“ğ‘\chi_{p}(G)\leqslant f(p)italic_Ï‡ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) â©½ italic_f ( italic_p ) for every graph GğºGitalic_G in ğ’ğ’\mathcal{C}caligraphic_C, see again [10]. Centered colorings are also a crucial tool in designing parameterized algorithms in classes of graphs of bounded expansion. For example, Pilipczuk and Siebertz [11] showed that if ğ’ğ’\mathcal{C}caligraphic_C is a class of graphs excluding a fixed minor, then it can be decided whether a given pğ‘pitalic_p-vertex graph Hğ»Hitalic_H is a subgraph of a given nğ‘›nitalic_n-vertex graph GğºGitalic_G in ğ’ğ’\mathcal{C}caligraphic_C in time 2ğ’ªâ¢(pâ¢logâ¡p)â‹…nğ’ªâ¢(1)â‹…superscript2ğ’ªğ‘ğ‘superscriptğ‘›ğ’ª12^{\mathcal{O}(p\log p)}\cdot n^{\mathcal{O}(1)}2 start_POSTSUPERSCRIPT caligraphic_O ( italic_p roman_log italic_p ) end_POSTSUPERSCRIPT â‹… italic_n start_POSTSUPERSCRIPT caligraphic_O ( 1 ) end_POSTSUPERSCRIPT and space nğ’ªâ¢(1)superscriptğ‘›ğ’ª1n^{\mathcal{O}(1)}italic_n start_POSTSUPERSCRIPT caligraphic_O ( 1 ) end_POSTSUPERSCRIPT. This algorithm relies on a general fact that the union of any pğ‘pitalic_p color classes in a pğ‘pitalic_p-centered coloring induces a subgraph of treedepth at most pğ‘pitalic_p. Therefore, finding a pğ‘pitalic_p-centered coloring using pğ’ªâ¢(1)superscriptğ‘ğ’ª1p^{\mathcal{O}(1)}italic_p start_POSTSUPERSCRIPT caligraphic_O ( 1 ) end_POSTSUPERSCRIPT colors, allows us to reduce the problem to graphs of bounded treedepth, on which the subgraph isomorphism problem can be solved efficiently. The running times of algorithms based on pğ‘pitalic_p-centered colorings heavily depend on the number of colors used. Another important family of graph parameters capturing sparsity are the weak coloring numbers. Let GğºGitalic_G be a graph, let Ïƒğœ\sigmaitalic_Ïƒ be a vertex ordering of GğºGitalic_G, and let rğ‘Ÿritalic_r be a nonnegative integer. For all uğ‘¢uitalic_u and vğ‘£vitalic_v vertices of GğºGitalic_G, we say that vğ‘£vitalic_v is weakly rğ‘Ÿritalic_r-reachable from uğ‘¢uitalic_u in (G,Ïƒ)ğºğœ(G,\sigma)( italic_G , italic_Ïƒ ), if there exists a path between uğ‘¢uitalic_u and vğ‘£vitalic_v in GğºGitalic_G containing at most rğ‘Ÿritalic_r edges such that for every vertex wğ‘¤witalic_w on the path, vâ©½Ïƒwsubscriptğœğ‘£ğ‘¤v\leqslant_{\sigma}witalic_v â©½ start_POSTSUBSCRIPT italic_Ïƒ end_POSTSUBSCRIPT italic_w. Let WReachrâ¡[G,Ïƒ,u]subscriptWReachğ‘Ÿğºğœğ‘¢\operatorname{WReach}_{r}[G,\sigma,u]roman_WReach start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT [ italic_G , italic_Ïƒ , italic_u ] be the set of all vertices that are weakly rğ‘Ÿritalic_r-reachable from uğ‘¢uitalic_u in (G,Ïƒ)ğºğœ(G,\sigma)( italic_G , italic_Ïƒ ). The rğ‘Ÿritalic_r-th weak coloring number of GğºGitalic_G is defined as wcolrâ¡(G)=minÏƒâ¡maxuâˆˆVâ¢(G)â¡|WReachrâ¡[G,Ïƒ,u]|,subscriptwcolğ‘Ÿğºsubscriptğœsubscriptğ‘¢ğ‘‰ğºsubscriptWReachğ‘Ÿğºğœğ‘¢\operatorname{wcol}_{r}(G)=\min_{\sigma}\max_{u\in V(G)}\ |\operatorname{% WReach}_{r}[G,\sigma,u]|,roman_wcol start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_G ) = roman_min start_POSTSUBSCRIPT italic_Ïƒ end_POSTSUBSCRIPT roman_max start_POSTSUBSCRIPT italic_u âˆˆ italic_V ( italic_G ) end_POSTSUBSCRIPT | roman_WReach start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT [ italic_G , italic_Ïƒ , italic_u ] | , where Ïƒğœ\sigmaitalic_Ïƒ ranges over all vertex orderings of GğºGitalic_G. Van den Heuvel, Ossona de Mendez, Quiroz, Rabinovich, and Siebertz [8] established that for every integer tğ‘¡titalic_t with tâ©¾2ğ‘¡2t\geqslant 2italic_t â©¾ 2, for every Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graph GğºGitalic_G, we have wcolrâ¡(G)=ğ’ªâ¢(rtâˆ’1)subscriptwcolğ‘Ÿğºğ’ªsuperscriptğ‘Ÿğ‘¡1\operatorname{wcol}_{r}(G)=\mathcal{O}(r^{t-1})roman_wcol start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_G ) = caligraphic_O ( italic_r start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT ). Their proof hinges on a carefully designed partition of the vertex set of GğºGitalic_G, inspired by Andreaeâ€™s work [1] on the cops and robber game for Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs. This partition, now commonly referred to as a chordal partition, mimics an elimination ordering of vertices of a chordal graph. Chordal partitions have since become a significant tool in both structural and algorithmic graph theory. In particular, wcolrâ¡(G)=ğ’ªâ¢(rtâˆ’1)subscriptwcolğ‘Ÿğºğ’ªsuperscriptğ‘Ÿğ‘¡1\operatorname{wcol}_{r}(G)=\mathcal{O}(r^{t-1})roman_wcol start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_G ) = caligraphic_O ( italic_r start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT ) is obtained in [8] with a relatively simple and self-contained argument. However, there is currently no known analogous partitioning method that works well with pğ‘pitalic_p-centered colorings. In [11], the bound of Ï‡pâ¢(G)=ğ’ªâ¢(pgâ¢(t))subscriptğœ’ğ‘ğºğ’ªsuperscriptğ‘ğ‘”ğ‘¡\chi_{p}(G)=\mathcal{O}(p^{g(t)})italic_Ï‡ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) = caligraphic_O ( italic_p start_POSTSUPERSCRIPT italic_g ( italic_t ) end_POSTSUPERSCRIPT ) for some function gğ‘”gitalic_g was achieved by first proving the result for graphs of bounded Euler genus, and then lifting the argument using the graph minor structure theorem by Robertson and Seymour [13]. The degree of the polynomial bound in pğ‘pitalic_p they obtain depends on the constants of this structure theorem and is not explicitly given. Consequently, a significant gap exists between the state-of-art upper bounds for weak coloring numbers and the ones for centered chromatic numbers of Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs. In this work, we close this gap. The main novelty of the proof is a replacement of a Helly-type property well-known for graphs of bounded treewidth (see Lemma 4) by a statement on centered colorings that works in the broader class of Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs. See the definition of (p,c)ğ‘ğ‘(p,c)( italic_p , italic_c )-good colorings and Lemma 5. The final centered colorings are constructed in this paper in two steps. First, we prove this Helly-type property for Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-minor-free graphs following a layered variant of Robertson-Seymour decomposition introduced by DujmoviÄ‡, Joret, Micek, Morin, Ueckerdt, and Wood [3]. Second, using this property, we adapt a framework proposed by Illingworth, Scott, and Wood in [9]. This in result allows us to move most of the dependency on tğ‘¡titalic_t from the degree of the final polynomial to a multiplicative constant in front of it. For a more detailed outline of the proof, see Section 2. Graphs with bounded degree have pğ‘pitalic_p-centered chromatic number in ğ’ªâ¢(p)ğ’ªğ‘\mathcal{O}(p)caligraphic_O ( italic_p ) as proved in [5]. This combined with the structure theorem by Grohe and Marx [7] gives a polynomial in pğ‘pitalic_p upper bound on Ï‡pâ¢(G)subscriptğœ’ğ‘ğº\chi_{p}(G)italic_Ï‡ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) for all GğºGitalic_G excluding Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT as a topological minor. Open problem. Let tğ‘¡titalic_t be an integer with tâ©¾2ğ‘¡2t\geqslant 2italic_t â©¾ 2. Does there exist a nonnegative integer cğ‘citalic_c such that for every Ktsubscriptğ¾ğ‘¡K_{t}italic_K start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT-topological-minor-free graph GğºGitalic_G and for every positive integer pğ‘pitalic_p, Ï‡pâ¢(G)â©½câ‹…ptâˆ’1subscriptğœ’ğ‘ğºâ‹…ğ‘superscriptğ‘ğ‘¡1\chi_{p}(G)\leqslant c\cdot p^{t-1}italic_Ï‡ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_G ) â©½ italic_c â‹… italic_p start_POSTSUPERSCRIPT italic_t - 1 end_POSTSUPERSCRIPT?"
https://arxiv.org/html/2411.01630v1,"Optimal Inapproximability of Promise Equationsover Finite Groupsâ€ â€ thanks:This work was supported by UKRI EP/X024431/1. For the purpose of Open Access, the authors have applied a CC BY public copyright licence to any Author Accepted Manuscript version arising from this submission. All data is provided in full in the results section of this paper.","A celebrated result of HÃ¥stad established that, for any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, it is NP-hard to find an assignment satisfying a (1/|ğ’¢|+Îµ)1ğ’¢ğœ€(1/|\mathscr{G}|+\varepsilon)( 1 / | script_G | + italic_Îµ )-fraction of the constraints of a given 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance over an Abelian group ğ’¢ğ’¢\mathscr{G}script_G even if one is promised that an assignment satisfying a (1âˆ’Îµ)1ğœ€(1-\varepsilon)( 1 - italic_Îµ )-fraction of the constraints exists. Engebretsen, Holmerin, and Russell showed the same result for 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instances over any finite (not necessarily Abelian) group. In other words, for almost-satisfiable instances of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN the random assignment achieves an optimal approximation guarantee. We prove that the random assignment algorithm is still best possible under a stronger promise that the 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance is almost satisfiable over an arbitrarily more restrictive group.","The PCP theorem [AS98, ALM+98, Din07] is one of the jewels of computational complexity and theoretical computer science more broadly [AB09]. One of its equivalent statements is as follows: The maximum number of simultaneously satisfiable constraints of a Constraint Satisfaction Problem, or CSP for short, is NP-hard to approximate within some constant factor. That is, while NP-hardness of CSPs means that it is NP-hard to distinguish instances that are satisfiable from those that are unsatisfiable, the PCP theorem shows that there is an absolute constant Î±<1ğ›¼1\alpha<1italic_Î± < 1 such that it is NP-hard to distinguish satisfiable CSP instances from those in which strictly fewer than an Î±ğ›¼\alphaitalic_Î±-fraction of the constraints can be simultaneously satisfied. Thus it is NP-hard to find an assignment that satisfies an Î±ğ›¼\alphaitalic_Î±-fraction of the constraints even if one is promised that a satisfying assignment exists. For some CSPs, as we shall see shortly, the optimal value of Î±ğ›¼\alphaitalic_Î± is known. A classic example of a CSP is 3-SAT, the satisfiability problem of CNF-formulas in which each clause contains 3 literals. The random assignment gives a method to find an assignment that satisfies a 7/8787/87 / 8-fraction of the clauses. HÃ¥stad famously showed that this is optimal in the following sense: For any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, it is NP-hard to find an assignment satisfying a (7/8+Îµ)78ğœ€(7/8+\varepsilon)( 7 / 8 + italic_Îµ )-fraction of the clauses of a 3-SAT instance even if one is promised that a satisfying assignment exists [HÃ¥s01]. Another classic CSP is 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN, the problem of solving linear equations in 3 variables over the Boolean domain {0,1}01\{0,1\}{ 0 , 1 }. If all equations can be satisfied simultaneously then a satisfying assignment can be found in polynomial time by Gaussian elimination. What can be done if no satisfying assignment exists? As for 3-SAT, the random assignment gives a method to find a somewhat satisfying assignment, namely one that satisfies a 1/2121/21 / 2-fraction of the constraints. As it turns out, this is best possible even for instances of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN that are almost satisfiable. In detail, HÃ¥stad showed that for any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, it is NP-hard to find an assignment satisfying a (1/2+Îµ)12ğœ€(1/2+\varepsilon)( 1 / 2 + italic_Îµ )-fraction of the constraints of a 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance even if one is promised that an assignment satisfying a (1âˆ’Îµ)1ğœ€(1-\varepsilon)( 1 - italic_Îµ )-fraction of the constraints exists. In fact, HÃ¥stad established optimal inapproximability results for 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over any finite Abelian group, not just {0,1}01\{0,1\}{ 0 , 1 }. This result was later extended by Engebretsen, Holmerin, and Russell to all finite groups [EHR04]. Since these foundational works, Guruswami and Raghavendra [GR09] showed NP-hardness of finding a barely satisfying assignment for a 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instance over the reals (and thus also over the integers) even if a nearly satisfying assignment is promised to exist over the integers. The same result was later established for 2âˆ’LIN2LIN\operatorname{2-LIN}2 - roman_LIN for large enough cyclic groups [OWZ15]. Khot and Moshkovitz [KM13] studied inapproximability of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over the reals. In this work, we strengthen the optimal inapproximability results for 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over finite groups by establishing NP-hardness of beating the random assignment threshold even if the instance is almost satisfiable in an arbitrarily more restrictive setting. Formally, this is captured by fixing (not one but) two groups and a homomorphism between them, following the framework of promise CSPs [AGH17, BBKO21]. In detail, (decision) promise CSPs [BBKO21] can be seen as a qualitative form of approximation: Each constraint comes in two forms, a strong one and a weak one. The promise is that there is a solution satisfying all constraints in the strong form while the (potentially easier) goal is to find a solution satisfying all constraints in the weak form. An example of a strong vs. weak constraint on the same, say Boolean, domain is 1111-in-3333 vs NAE, where the former is {(0,0,1),(0,1,0),(1,0,0)}001010100\{(0,0,1),(0,1,0),(1,0,0)\}{ ( 0 , 0 , 1 ) , ( 0 , 1 , 0 ) , ( 1 , 0 , 0 ) } and the latter is {(0,0,1),(0,1,0),(1,0,0),(1,1,0),(1,0,1),(0,1,1)}001010100110101011\{(0,0,1),(0,1,0),(1,0,0),(1,1,0),(1,0,1),(0,1,1)\}{ ( 0 , 0 , 1 ) , ( 0 , 1 , 0 ) , ( 1 , 0 , 0 ) , ( 1 , 1 , 0 ) , ( 1 , 0 , 1 ) , ( 0 , 1 , 1 ) }. NAE is weaker as the relation contains more tuples. While these two constraint relations capture the well-known NP-hard problems of 1-in-3-SAT and Not-All-Equal-SAT respectively [Sch78], finding an NAE-assignment turns out to be doable in polynomial time under the promise that a 1-in-3-assignment exists [BG21]! For constraints on different domains, the notion of strong vs. weak constraint is captured by a homomorphism between the (sets of all) constraint relations; in the example above, the homomorphism is just the identity function. The exact solvability of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN in the promise setting was resolved in [LÅ½24]. Recent work of Barto et al. [BBK+24] considered (quantitative) approximation of promise CSPs. In the context of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN, here are two simple examples captured by this framework. First, let ğ’¢ğ’¢\mathscr{G}script_G be a group and â„‹â„‹\mathscr{H}script_H be a subgroup of ğ’¢ğ’¢\mathscr{G}script_G. Given an almost-satisfiable system over the subgroup â„‹â„‹\mathscr{H}script_H, maximise the number of satisfied equations over ğ’¢ğ’¢\mathscr{G}script_G. Our results imply that beating the random assignment over â„‹â„‹\mathscr{H}script_H is NP-hard. In the second example, consider a group ğ’¢ğ’¢\mathscr{G}script_G, a normal subgroup â„‹â„‹\mathscr{H}script_H, and an almost-satisfiable system over ğ’¢ğ’¢\mathscr{G}script_G. The goal this time is to maximise the number of satisfied equations in the system over the quotient ğ’¢/â„‹ğ’¢â„‹\mathscr{G}/\mathscr{H}script_G / script_H. Our results show that doing better than the random assignment over ğ’¢/â„‹ğ’¢â„‹\mathscr{G}/\mathscr{H}script_G / script_H is NP-hard. More generally, going beyond subgroups and quotients of a given group, we fix two groups ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and a group homomorphism Ï†ğœ‘\varphiitalic_Ï† from a subgroup â„‹1subscriptâ„‹1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT of ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to a subgroup â„‹2subscriptâ„‹2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT with the property that Ï†ğœ‘\varphiitalic_Ï† extend to a group homomorphism from ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Given an almost-satisfiable system of equations over ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT with constants in â„‹1subscriptâ„‹1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, the goal is to maximise the number of satisfied equations over ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT where the constants are interpreted in â„‹2subscriptâ„‹2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT via Ï†ğœ‘\varphiitalic_Ï†. Our main result establishes that doing better than the random assignment over â„‹2subscriptâ„‹2\mathscr{H}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is NP-hard, cf. Theorem 1.3. Thus we give an optimal inapproximability result for a natural and fundamental fragment of promise CSPs, systems of linear equations. The general approach for establishing inapproximability of systems of equations, going back to [HÃ¥s01, EHR04], can be seen as a reduction from another CSP that is hard to approximate. In this reduction, one initially transforms an instance of the original CSP to a system of equations of the form xâ¢yâ¢z=1ğ‘¥ğ‘¦ğ‘§1xyz=1italic_x italic_y italic_z = 1. To guarantee the soundness of this reduction, one needs to show that any assignment that beats the random assignment in the target system of equations can be transformed into a â€œgoodâ€ assignment of the original instance. To do this it is necessary to rule out vacuous assignments (e.g., the assignment that sends all variables to the group identity) through a procedure called folding, which introduces constants in the system of equations. Afterwards, the soundness bounds are shown by performing Fourier analysis on certain functions derived from the system. Our proof follows this general approach. The main obstacle to applying the techniques of [EHR04] directly is the fact that in our setting the constants lie in a proper subgroup of the ambient group, which precludes us from applying classical folding over groups. Instead, we use a weaker notion of folding. This, however, implies that in the soundness analysis we have to take care of functions whose Fourier expansion has non-zero value for the trivial term. To tackle this issue, we consider the behaviour of irreducible group representations when they are restricted to the subgroup of constants via Frobenius Reciprocity. Before formal description of our results, we mention other related work. First, extending the work from [HÃ¥s01], Austrin, Brown-Cohen, and HÃ¥stad established optimal inapproximability of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over Abelian groups with a universal factor graph [ABCH23]. Similarly, Bhangale and Stankovic established optimal inapproximability of 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over non-Abelian groups with a universal factor graph [BS23]. Second, unlike over Abelian groups, for 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN over non-Abelian groups finding a satisfying assignment is NP-hard even under the promise that one exists. There is a folklore randomised algorithm for satisfiable 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN instances over non-Abelian groups (whose approximation factor depends on the group ğ’¢ğ’¢\mathscr{G}script_G and is 1/|ğ’¢|1ğ’¢1/|\mathscr{G}|1 / | script_G | if ğ’¢ğ’¢\mathscr{G}script_G is a so-called perfect group but can beat the naive random assignment for non-perfect groups). Bhangale and Khot showed that this algorithm is optimal [BK21]. Third, going beyond 3âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN, building on a long line of work Chan established optimal (up to a constant factor) NP-hardness for CSPs [Cha16]. There are other works on various inapproximability notions for CSPs, e.g., [AH13, KTW14a, KTW14b]. Finally, we mention that Khotâ€™s influential Unique Games Conjecture [Kho02] postulates, in one of its equivalent forms, NP-hardness of finding a barely satisfying solution to a 2âˆ’LIN2LIN\operatorname{2-LIN}2 - roman_LIN instance given that an almost-satisfying assignment exists (for a large enough domain size). 1.1 Preliminaries and notation We use âŸ¦â‹…âŸ§delimited-âŸ¦âŸ§â‹…\llbracket\cdot\rrbracketâŸ¦ â‹… âŸ§ to denote the Iverson bracket; i.e., âŸ¦PâŸ§delimited-âŸ¦âŸ§ğ‘ƒ\llbracket P\rrbracketâŸ¦ italic_P âŸ§ is 1 if Pğ‘ƒPitalic_P is true and 00 otherwise. As usual, [n]delimited-[]ğ‘›[n][ italic_n ] denotes the set {1,2,â€¦,n}12â€¦ğ‘›\{1,2,\ldots,n\}{ 1 , 2 , â€¦ , italic_n }. We consider matrices whose sets of indices are arbitrary finite sets. Given two finite sets Nğ‘Nitalic_N and Mğ‘€Mitalic_M, an NÃ—Mğ‘ğ‘€N\times Mitalic_N Ã— italic_M complex matrix Ağ´Aitalic_A consists of a family of complex numbers Ai,jsubscriptğ´ğ‘–ğ‘—A_{i,j}italic_A start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT indexed by pairs iâˆˆNğ‘–ğ‘i\in Nitalic_i âˆˆ italic_N, jâˆˆMğ‘—ğ‘€j\in Mitalic_j âˆˆ italic_M. Algebraic notions such as matrix product, trace, and transpose are defined in the natural way. Given an N1Ã—N2subscriptğ‘1subscriptğ‘2N_{1}\times N_{2}italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT complex matrix Ağ´Aitalic_A, and an M1Ã—M2subscriptğ‘€1subscriptğ‘€2M_{1}\times M_{2}italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT complex matrix BğµBitalic_B, the tensor product AâŠ—Btensor-productğ´ğµA\otimes Bitalic_A âŠ— italic_B is an (N1Ã—M1)Ã—(N2Ã—M2)subscriptğ‘1subscriptğ‘€1subscriptğ‘2subscriptğ‘€2(N_{1}\times M_{1})\times(N_{2}\times M_{2})( italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) Ã— ( italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT Ã— italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) matrix, where (AâŠ—B)(i,s)â¢(j,t)=Ai,jâ¢Bs,tsubscripttensor-productğ´ğµğ‘–ğ‘ ğ‘—ğ‘¡subscriptğ´ğ‘–ğ‘—subscriptğµğ‘ ğ‘¡(A\otimes B)_{(i,s)(j,t)}=A_{i,j}B_{s,t}( italic_A âŠ— italic_B ) start_POSTSUBSCRIPT ( italic_i , italic_s ) ( italic_j , italic_t ) end_POSTSUBSCRIPT = italic_A start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT italic_B start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT for each iâˆˆN1,jâˆˆN2,sâˆˆM1,tâˆˆM2formulae-sequenceğ‘–subscriptğ‘1formulae-sequenceğ‘—subscriptğ‘2formulae-sequenceğ‘ subscriptğ‘€1ğ‘¡subscriptğ‘€2i\in N_{1},j\in N_{2},s\in M_{1},t\in M_{2}italic_i âˆˆ italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_j âˆˆ italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_s âˆˆ italic_M start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t âˆˆ italic_M start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. The group of invertible NÃ—Nğ‘ğ‘N\times Nitalic_N Ã— italic_N complex matrices (equipped with matrix multiplication and matrix inversion) is denoted by GLâ¢(N)GLğ‘\mathrm{GL}(N)roman_GL ( italic_N ), and the set of NÃ—Mğ‘ğ‘€N\times Mitalic_N Ã— italic_M complex matrices is denoted by â„‚NÃ—Msuperscriptâ„‚ğ‘ğ‘€\mathbb{C}^{N\times M}blackboard_C start_POSTSUPERSCRIPT italic_N Ã— italic_M end_POSTSUPERSCRIPT. A subset â„‹âŠ†ğ’¢â„‹ğ’¢\mathscr{H}\subseteq\mathscr{G}script_H âŠ† script_G of a group ğ’¢ğ’¢\mathscr{G}script_G is called a subgroup of ğ’¢ğ’¢\mathscr{G}script_G, denoted by â„‹â‰¤ğ’¢â„‹ğ’¢\mathscr{H}\leq\mathscr{G}script_H â‰¤ script_G, if â„‹â„‹\mathscr{H}script_H equipped with the group operation of ğ’¢ğ’¢\mathscr{G}script_G forms a group. Given a group ğ’¢ğ’¢\mathscr{G}script_G, a subgroup â„‹â„‹\mathscr{H}script_H of ğ’¢ğ’¢\mathscr{G}script_G, and an element gâˆˆğ’¢ğ‘”ğ’¢g\in\mathscr{G}italic_g âˆˆ script_G, the right coset of â„‹â„‹\mathscr{H}script_H in ğ’¢ğ’¢\mathscr{G}script_G by gğ‘”gitalic_g is the set â„‹â¢g:={hâ¢gâˆ£hâˆˆâ„‹}assignâ„‹ğ‘”conditional-setâ„ğ‘”â„â„‹\mathscr{H}g:=\{hg\mid h\in\mathscr{H}\}script_H italic_g := { italic_h italic_g âˆ£ italic_h âˆˆ script_H }. The set of right cosets of â„‹â„‹\mathscr{H}script_H in ğ’¢ğ’¢\mathscr{G}script_G is denoted by â„‹\ğ’¢\â„‹ğ’¢\mathscr{H}\backslash\mathscr{G}script_H \ script_G. Let Nğ‘Nitalic_N be a finite set. The Nthsuperscriptğ‘thN^{\text{th}}italic_N start_POSTSUPERSCRIPT th end_POSTSUPERSCRIPT direct power of ğ’¢ğ’¢\mathscr{G}script_G, denoted by ğ’¢Nsuperscriptğ’¢ğ‘\mathscr{G}^{N}script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT, is the group whose elements are Nğ‘Nitalic_N-tuples ğ âˆˆğ’¢Nğ superscriptğ’¢ğ‘\mathbf{g}\in\mathscr{G}^{N}bold_g âˆˆ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT of elements from ğ’¢ğ’¢\mathscr{G}script_G, and where the group operation is taken component-wise, i.e., ğ â‹…ğ¡â¢(n)=ğ â¢(n)â‹…ğ¡â¢(n)â‹…ğ ğ¡ğ‘›â‹…ğ ğ‘›ğ¡ğ‘›\mathbf{g}\cdot\mathbf{h}(n)=\mathbf{g}(n)\cdot\mathbf{h}(n)bold_g â‹… bold_h ( italic_n ) = bold_g ( italic_n ) â‹… bold_h ( italic_n ) for each nâˆˆNğ‘›ğ‘n\in Nitalic_n âˆˆ italic_N. If â„‹â‰¤ğ’¢â„‹ğ’¢\mathscr{H}\leq\mathscr{G}script_H â‰¤ script_G, we define (hâ‹…ğ )â¢(n)=hâ‹…ğ â¢(n)â‹…â„ğ ğ‘›â‹…â„ğ ğ‘›(h\cdot\mathbf{g})(n)=h\cdot\mathbf{g}(n)( italic_h â‹… bold_g ) ( italic_n ) = italic_h â‹… bold_g ( italic_n ) for each hâˆˆâ„‹â„â„‹h\in\mathscr{H}italic_h âˆˆ script_H and ğ âˆˆğ’¢Nğ superscriptğ’¢ğ‘\mathbf{g}\in\mathscr{G}^{N}bold_g âˆˆ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. With this notation, the notion of coset extends to include the right cosets of â„‹â„‹\mathscr{H}script_H in ğ’¢Nsuperscriptğ’¢ğ‘\mathscr{G}^{N}script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT in a natural way. A homomorphism from a group ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to a group ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is a map Ï†:ğ’¢1â†’ğ’¢2:ğœ‘â†’subscriptğ’¢1subscriptğ’¢2\varphi:\mathscr{G}_{1}\to\mathscr{G}_{2}italic_Ï† : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT which satisfies that Ï†â¢(gâ‹…h)=Ï†â¢(g)â‹…Ï†â¢(h)ğœ‘â‹…ğ‘”â„â‹…ğœ‘ğ‘”ğœ‘â„\varphi(g\cdot h)=\varphi(g)\cdot\varphi(h)italic_Ï† ( italic_g â‹… italic_h ) = italic_Ï† ( italic_g ) â‹… italic_Ï† ( italic_h ) for every g,hâˆˆğ’¢1ğ‘”â„subscriptğ’¢1g,h\in\mathscr{G}_{1}italic_g , italic_h âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. The domain and image of Ï†ğœ‘\varphiitalic_Ï† are denoted Domâ¢(Ï†)Domğœ‘\textnormal{Dom}(\varphi)Dom ( italic_Ï† ) and Imâ¢(Ï†)Imğœ‘\textnormal{Im}(\varphi)Im ( italic_Ï† ) respectively. Let Nğ‘Nitalic_N be a finite set, ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT groups, iâˆˆ[2]ğ‘–delimited-[]2i\in[2]italic_i âˆˆ [ 2 ], â„‹iâ‰¤ğ’¢isubscriptâ„‹ğ‘–subscriptğ’¢ğ‘–\mathscr{H}_{i}\leq\mathscr{G}_{i}script_H start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‰¤ script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, and Ï†:â„‹1â†’â„‹2:ğœ‘â†’subscriptâ„‹1subscriptâ„‹2\varphi:\mathscr{H}_{1}\to\mathscr{H}_{2}italic_Ï† : script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â†’ script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT be a homomorphism. We say that a function f:ğ’¢1Nâ†’ğ’¢2:ğ‘“â†’superscriptsubscriptğ’¢1ğ‘subscriptğ’¢2f:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is folded over Ï†ğœ‘\varphiitalic_Ï† if fâ¢(hâ¢ğ )=Ï†â¢(h)â¢fâ¢(ğ )ğ‘“â„ğ ğœ‘â„ğ‘“ğ f(h\mathbf{g})=\varphi(h)f(\mathbf{g})italic_f ( italic_h bold_g ) = italic_Ï† ( italic_h ) italic_f ( bold_g ) for all hâˆˆâ„‹1â„subscriptâ„‹1h\in\mathscr{H}_{1}italic_h âˆˆ script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and ğ âˆˆğ’¢1Nğ superscriptsubscriptğ’¢1ğ‘\mathbf{g}\in\mathscr{G}_{1}^{N}bold_g âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. Given an arbitrary function f:ğ’¢1Nâ†’ğ’¢2:ğ‘“â†’superscriptsubscriptğ’¢1ğ‘subscriptğ’¢2f:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and a homomorphism between subgroups, there is a natural way to construct a folded function that resembles fğ‘“fitalic_f. Fix an arbitrary representative from each right coset of â„‹1subscriptâ„‹1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT in ğ’¢1Nsuperscriptsubscriptğ’¢1ğ‘\mathscr{G}_{1}^{N}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT. For each ğ âˆˆğ’¢Nğ superscriptğ’¢ğ‘\mathbf{g}\in\mathscr{G}^{N}bold_g âˆˆ script_G start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT, denote by ğ â€ superscriptğ â€ \mathbf{g}^{\dagger}bold_g start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT the representative of â„‹1â¢ğ subscriptâ„‹1ğ \mathscr{H}_{1}\mathbf{g}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT bold_g, and let hğ âˆˆâ„‹1subscriptâ„ğ subscriptâ„‹1h_{\mathbf{g}}\in\mathscr{H}_{1}italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT âˆˆ script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT be such that ğ â€ =hğ â¢ğ superscriptğ â€ subscriptâ„ğ ğ \mathbf{g}^{\dagger}=h_{\mathbf{g}}\mathbf{g}bold_g start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT = italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT bold_g. Then the folding of fğ‘“fitalic_f over Ï†ğœ‘\varphiitalic_Ï† (with respect to this choice of representatives) is the map fÏ†:ğ’¢1Nâ†’ğ’¢2:subscriptğ‘“ğœ‘â†’superscriptsubscriptğ’¢1ğ‘subscriptğ’¢2f_{\varphi}:\mathscr{G}_{1}^{N}\to\mathscr{G}_{2}italic_f start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT given by fÏ†â¢(ğ )=Ï†â¢(hğ âˆ’1)â¢fâ¢(ğ â€ )subscriptğ‘“ğœ‘ğ ğœ‘superscriptsubscriptâ„ğ 1ğ‘“superscriptğ â€ f_{\varphi}(\mathbf{g})=\varphi(h_{\mathbf{g}}^{-1})f(\mathbf{g}^{\dagger})italic_f start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_g ) = italic_Ï† ( italic_h start_POSTSUBSCRIPT bold_g end_POSTSUBSCRIPT start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) italic_f ( bold_g start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT ). Fix a pair of disjoint finite sets Dğ·Ditalic_D, Eğ¸Eitalic_E, called the label sets, and a subset Î âŠ†EDÎ superscriptğ¸ğ·\Pi\subseteq E^{D}roman_Î  âŠ† italic_E start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT of labeling functions. An instance of the Label Cover problem is a bipartite graph with vertex set UâŠ”Vsquare-unionğ‘ˆğ‘‰U\sqcup Vitalic_U âŠ” italic_V and a labeling function Ï€uâ¢vâˆˆÎ subscriptğœ‹ğ‘¢ğ‘£Î \pi_{uv}\in\Piitalic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT âˆˆ roman_Î  for each edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v } in the graph. The task is to decide whether there is a pair of assignments hD:Uâ†’D:subscriptâ„ğ·â†’ğ‘ˆğ·h_{D}:U\to Ditalic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT : italic_U â†’ italic_D, hE:Vâ†’E:subscriptâ„ğ¸â†’ğ‘‰ğ¸h_{E}:V\to Eitalic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT : italic_V â†’ italic_E that satisfies all the constraints, i.e., such that Ï€uâ¢vâ¢(hDâ¢(u))=hEâ¢(v)subscriptğœ‹ğ‘¢ğ‘£subscriptâ„ğ·ğ‘¢subscriptâ„ğ¸ğ‘£\pi_{uv}(h_{D}(u))=h_{E}(v)italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_u ) ) = italic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT ( italic_v ) for each edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v }. Given additionally a pair of rational constants 0<sâ‰¤câ‰¤10ğ‘ ğ‘10<s\leq c\leq 10 < italic_s â‰¤ italic_c â‰¤ 1, the gap version of this problem, known as the Gap Label Cover problem with completeness cğ‘citalic_c and soundness sğ‘ sitalic_s and denoted GLCD,Eâ¢(c,s)subscriptGLCğ·ğ¸ğ‘ğ‘ \mathrm{GLC}_{D,E}(c,s)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( italic_c , italic_s ), is the problem of distinguishing instances where a cğ‘citalic_c-fraction of the constraints can be satisfied from instances where not even an sğ‘ sitalic_s-fraction of the constraints can be satisfied. The hardness of Gap Label Cover with perfect completeness stated below is a consequence of the PCP theorem [ALM+98, AS98] and the Parallel Repetition Theorem [Raz98]. Theorem 1.1. For every Î±>0ğ›¼0\alpha>0italic_Î± > 0 there exist finite sets Dğ·Ditalic_D, Eğ¸Eitalic_E such that GLCD,Eâ¢(1,Î±)subscriptGLCğ·ğ¸1ğ›¼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_Î± ) is NP-hard. Fourier Analysis We follow closely [Ter99] for our main definitions and preliminary results. A representation of a group ğ’¢ğ’¢\mathscr{G}script_G is a group homomorphism Î³:ğ’¢â†’GLâ¢(NÎ³):ğ›¾â†’ğ’¢GLsubscriptğ‘ğ›¾\gamma:\mathscr{G}\to\mathrm{GL}(N_{\gamma})italic_Î³ : script_G â†’ roman_GL ( italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT ) for some finite set NÎ³subscriptğ‘ğ›¾N_{\gamma}italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT. We call |NÎ³|subscriptğ‘ğ›¾|N_{\gamma}|| italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT | the dimension of Î³ğ›¾\gammaitalic_Î³ and write dimÎ³=|NÎ³|subscriptdimensionğ›¾subscriptğ‘ğ›¾\dim_{\gamma}=|N_{\gamma}|roman_dim start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT = | italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT |. Given a pair of indices i,jâˆˆNÎ³2ğ‘–ğ‘—superscriptsubscriptğ‘ğ›¾2i,j\in N_{\gamma}^{2}italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, Î³i,jsubscriptğ›¾ğ‘–ğ‘—\gamma_{i,j}italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT denotes the (i,j)ğ‘–ğ‘—(i,j)( italic_i , italic_j )-th entry of Î³ğ›¾\gammaitalic_Î³. The character of a representation Î³ğ›¾\gammaitalic_Î³, denoted by Ï‡Î³subscriptğœ’ğ›¾\chi_{\gamma}italic_Ï‡ start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT, is its trace. The trivial representation, denoted 1111, maps all group elements to the number one (i.e., the one-dimensional identity matrix). A representation Î³ğ›¾\gammaitalic_Î³ is said to be unitary if its image contains only unitary matrices. We say that two representations Î±ğ›¼\alphaitalic_Î± and Î²ğ›½\betaitalic_Î² of some group ğ’¢ğ’¢\mathscr{G}script_G are equivalent, written Î±â‰ƒÎ²similar-to-or-equalsğ›¼ğ›½\alpha\simeq\betaitalic_Î± â‰ƒ italic_Î², if there is an invertible NÎ²Ã—NÎ±subscriptğ‘ğ›½subscriptğ‘ğ›¼N_{\beta}\times N_{\alpha}italic_N start_POSTSUBSCRIPT italic_Î² end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT complex matrix Tğ‘‡Titalic_T such that Î±â¢(g)=Tâˆ’1â¢Î²â¢(g)â¢Tğ›¼ğ‘”superscriptğ‘‡1ğ›½ğ‘”ğ‘‡\alpha(g)=T^{-1}\beta(g)Titalic_Î± ( italic_g ) = italic_T start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_Î² ( italic_g ) italic_T for all gâˆˆğ’¢ğ‘”ğ’¢g\in\mathscr{G}italic_g âˆˆ script_G. In particular, dimÎ±=dimÎ²subscriptdimensionğ›¼subscriptdimensionğ›½\dim_{\alpha}=\dim_{\beta}roman_dim start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT = roman_dim start_POSTSUBSCRIPT italic_Î² end_POSTSUBSCRIPT. Similarly, the representation Î²ğ›½\betaitalic_Î² is said to be a sub-representation of Î±ğ›¼\alphaitalic_Î± if there is an invertible matrix Tğ‘‡Titalic_T, such that Tâˆ’1â¢Î±â¢(g)â¢Tsuperscriptğ‘‡1ğ›¼ğ‘”ğ‘‡T^{-1}\alpha(g)Titalic_T start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_Î± ( italic_g ) italic_T can be written as (Î²â¢(g)âˆ—0âˆ—)matrixğ›½ğ‘”0\begin{pmatrix}\beta(g)&*\\ 0&*\end{pmatrix}( start_ARG start_ROW start_CELL italic_Î² ( italic_g ) end_CELL start_CELL âˆ— end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL âˆ— end_CELL end_ROW end_ARG ) for all gâˆˆğ’¢ğ‘”ğ’¢g\in\mathscr{G}italic_g âˆˆ script_G. The representation Î²ğ›½\betaitalic_Î² is said to be irreducible if all its sub-representations are equivalent to itself. If Î²ğ›½\betaitalic_Î² is irreducible, its multiplicity in Î±ğ›¼\alphaitalic_Î± is the non-negative integer nğ‘›nitalic_n satisfying that Î±ğ›¼\alphaitalic_Î± is equivalent to a block diagonal representation with two diagonal blocks Î±1,Î±2subscriptğ›¼1subscriptğ›¼2\alpha_{1},\alpha_{2}italic_Î± start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Î± start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, where (1) Î±1subscriptğ›¼1\alpha_{1}italic_Î± start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT is another block-diagonal representation consisting of nğ‘›nitalic_n diagonal blocks equal to Î²ğ›½\betaitalic_Î², and (2) Î±2subscriptğ›¼2\alpha_{2}italic_Î± start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT does not have Î²ğ›½\betaitalic_Î² as a sub-representation. Given a group ğ’¢ğ’¢\mathscr{G}script_G, we use ğ’¢^^ğ’¢\widehat{\mathscr{G}}over^ start_ARG script_G end_ARG to denote some arbitrary and fixed complete set of inequivalent irreducible unitary representations of ğ’¢ğ’¢\mathscr{G}script_G; such a set exists by, e.g., [Ter99, Proposition 1]. The space â„’2â¢(ğ’¢)superscriptâ„’2ğ’¢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ) is the vector space of complex-valued functions over ğ’¢ğ’¢\mathscr{G}script_G, equipped with the following inner product:111Note the additional normalising factor of 1|ğ’¢|1ğ’¢\frac{1}{|\mathscr{G}|}divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG compared to [Ter99]. âŸ¨F,HâŸ©=1|ğ’¢|â¢âˆ‘gâˆˆğ’¢Fâ¢(g)â¢Hâ¢(g)Â¯.ğ¹ğ»1ğ’¢subscriptğ‘”ğ’¢ğ¹ğ‘”Â¯ğ»ğ‘”\langle F,H\rangle=\frac{1}{|\mathscr{G}|}\sum_{g\in\mathscr{G}}F(g)\overline{% H(g)}.âŸ¨ italic_F , italic_H âŸ© = divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG âˆ‘ start_POSTSUBSCRIPT italic_g âˆˆ script_G end_POSTSUBSCRIPT italic_F ( italic_g ) overÂ¯ start_ARG italic_H ( italic_g ) end_ARG . Let ğ’¢ğ’¢\mathscr{G}script_G be a group, and let F:ğ’¢â†’â„‚:ğ¹â†’ğ’¢â„‚F:\mathscr{G}\rightarrow\mathbb{C}italic_F : script_G â†’ blackboard_C be a complex-valued function. Given Î³âˆˆğ’¢^ğ›¾^ğ’¢\gamma\in\widehat{\mathscr{G}}italic_Î³ âˆˆ over^ start_ARG script_G end_ARG and i,jâˆˆNÎ³ğ‘–ğ‘—subscriptğ‘ğ›¾i,j\in N_{\gamma}italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT, the Fourier coefficient F^â¢(Î³i,j)^ğ¹subscriptğ›¾ğ‘–ğ‘—\widehat{F}(\gamma_{i,j})over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) is defined as the product âŸ¨F,Î³i,jâŸ©ğ¹subscriptğ›¾ğ‘–ğ‘—\langle F,\gamma_{i,j}\rangleâŸ¨ italic_F , italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT âŸ©. The matrix entries of the representations Î³âˆˆğ’¢^ğ›¾^ğ’¢\gamma\in\widehat{\mathscr{G}}italic_Î³ âˆˆ over^ start_ARG script_G end_ARG form an orthogonal basis of â„’2â¢(ğ’¢)superscriptâ„’2ğ’¢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), and allow us to perform Fourier analysis on this space, as stated in the following theorem [Ter99, Theorem 2]. Theorem 1.2. Let ğ’¢ğ’¢\mathscr{G}script_G be a finite group. Then the set {Î³i,jâˆ£Î³âˆˆğ’¢^,i,jâˆˆNÎ³}conditional-setsubscriptğ›¾ğ‘–ğ‘—formulae-sequenceğ›¾^ğ’¢ğ‘–ğ‘—subscriptğ‘ğ›¾\{\gamma_{i,j}\mid\gamma\in\widehat{\mathscr{G}},\ i,j\in N_{\gamma}\}{ italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT âˆ£ italic_Î³ âˆˆ over^ start_ARG script_G end_ARG , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT } is an orthogonal basis of â„’2â¢(ğ’¢)superscriptâ„’2ğ’¢\mathcal{L}^{2}(\mathscr{G})caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), and dimÎ³âˆ¥Î³i,jâˆ¥2=1subscriptdimensionğ›¾superscriptdelimited-âˆ¥âˆ¥subscriptğ›¾ğ‘–ğ‘—21\dim_{\gamma}\lVert\gamma_{i,j}\rVert^{2}=1roman_dim start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT âˆ¥ italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = 1 for all Î³i,jsubscriptğ›¾ğ‘–ğ‘—\gamma_{i,j}italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT. Moreover, the following hold: 1. Plancherelâ€™s Theorem: Given Fâˆˆâ„’2â¢(ğ’¢)ğ¹superscriptâ„’2ğ’¢F\in\mathcal{L}^{2}(\mathscr{G})italic_F âˆˆ caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), âˆ¥Fâˆ¥2=âˆ‘Î³âˆˆğ’¢^,i,jâˆˆNÎ³dimÎ³|F^â¢(Î³i,j)|2.superscriptdelimited-âˆ¥âˆ¥ğ¹2subscriptformulae-sequenceğ›¾^ğ’¢ğ‘–ğ‘—subscriptğ‘ğ›¾subscriptdimensionğ›¾superscript^ğ¹subscriptğ›¾ğ‘–ğ‘—2\lVert F\rVert^{2}=\sum_{\gamma\in\widehat{\mathscr{G}},i,j\in N_{\gamma}}\dim% _{\gamma}|\widehat{F}(\gamma_{i,j})|^{2}.âˆ¥ italic_F âˆ¥ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = âˆ‘ start_POSTSUBSCRIPT italic_Î³ âˆˆ over^ start_ARG script_G end_ARG , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT | over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT . 2. Fourier Inversion: Given Fâˆˆâ„’2â¢(ğ’¢)ğ¹superscriptâ„’2ğ’¢F\in\mathcal{L}^{2}(\mathscr{G})italic_F âˆˆ caligraphic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( script_G ), Fâ¢(g)=âˆ‘Î³âˆˆğ’¢^,i,jâˆˆNÎ³dimÎ³F^â¢(Î³i,j)â¢Î³i,jâ¢(g) for all â¢gâˆˆğ’¢.formulae-sequenceğ¹ğ‘”subscriptformulae-sequenceğ›¾^ğ’¢ğ‘–ğ‘—subscriptğ‘ğ›¾subscriptdimensionğ›¾^ğ¹subscriptğ›¾ğ‘–ğ‘—subscriptğ›¾ğ‘–ğ‘—ğ‘” for all ğ‘”ğ’¢F(g)=\sum_{\gamma\in\widehat{\mathscr{G}},i,j\in N_{\gamma}}\dim_{\gamma}% \widehat{F}(\gamma_{i,j})\gamma_{i,j}(g)\qquad\text{ for all }g\in\mathscr{G}.italic_F ( italic_g ) = âˆ‘ start_POSTSUBSCRIPT italic_Î³ âˆˆ over^ start_ARG script_G end_ARG , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( italic_g ) for all italic_g âˆˆ script_G . We also consider Fourier transforms of matrix-valued functions F:ğ’¢â†’â„‚NFÃ—NF:ğ¹â†’ğ’¢superscriptâ„‚subscriptğ‘ğ¹subscriptğ‘ğ¹F:\mathscr{G}\rightarrow\mathbb{C}^{N_{F}\times N_{F}}italic_F : script_G â†’ blackboard_C start_POSTSUPERSCRIPT italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT end_POSTSUPERSCRIPT. Given Î³âˆˆğ’¢^ğ›¾^ğ’¢\gamma\in\widehat{\mathscr{G}}italic_Î³ âˆˆ over^ start_ARG script_G end_ARG and indices i,jâˆˆNÎ³ğ‘–ğ‘—subscriptğ‘ğ›¾i,j\in N_{\gamma}italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Î³ end_POSTSUBSCRIPT, we define the NFÃ—NFsubscriptğ‘ğ¹subscriptğ‘ğ¹N_{F}\times N_{F}italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT matrix F^â¢(Î³i,j)^ğ¹subscriptğ›¾ğ‘–ğ‘—\widehat{F}(\gamma_{i,j})over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) as the one whose (s,t)ğ‘ ğ‘¡(s,t)( italic_s , italic_t )-th entry is Fs,t^â¢(Î³i,j)^subscriptğ¹ğ‘ ğ‘¡subscriptğ›¾ğ‘–ğ‘—\widehat{F_{s,t}}(\gamma_{i,j})over^ start_ARG italic_F start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) for each s,tâˆˆNFğ‘ ğ‘¡subscriptğ‘ğ¹s,t\in N_{F}italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT. In other words, F^â¢(Î³i,j)=1|ğ’¢|â¢âˆ‘gâˆˆğ’¢Fâ¢(g)â¢Î³i,jâ¢(g)Â¯.^ğ¹subscriptğ›¾ğ‘–ğ‘—1ğ’¢subscriptğ‘”ğ’¢ğ¹ğ‘”Â¯subscriptğ›¾ğ‘–ğ‘—ğ‘”\widehat{F}(\gamma_{i,j})=\frac{1}{|\mathscr{G}|}\sum_{g\in\mathscr{G}}F(g)% \overline{\gamma_{i,j}(g)}.over^ start_ARG italic_F end_ARG ( italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) = divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG âˆ‘ start_POSTSUBSCRIPT italic_g âˆˆ script_G end_POSTSUBSCRIPT italic_F ( italic_g ) overÂ¯ start_ARG italic_Î³ start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( italic_g ) end_ARG . Let Nğ‘Nitalic_N be a finite set. Given a pair of functions function F,H:ğ’¢â†’â„‚NÃ—N:ğ¹ğ»â†’ğ’¢superscriptâ„‚ğ‘ğ‘F,H:\mathscr{G}\to\mathbb{C}^{N\times N}italic_F , italic_H : script_G â†’ blackboard_C start_POSTSUPERSCRIPT italic_N Ã— italic_N end_POSTSUPERSCRIPT, we define their convolution Fâˆ—Hğ¹ğ»F*Hitalic_F âˆ— italic_H by (Fâˆ—H)â¢(g):=1|ğ’¢|â¢âˆ‘hâˆˆğ’¢Fâ¢(h)â¢Hâ¢(hâˆ’1â¢g).assignğ¹ğ»ğ‘”1ğ’¢subscriptâ„ğ’¢ğ¹â„ğ»superscriptâ„1ğ‘”(F*H)(g):=\frac{1}{|\mathscr{G}|}\sum_{h\in\mathscr{G}}F(h)H(h^{-1}g).( italic_F âˆ— italic_H ) ( italic_g ) := divide start_ARG 1 end_ARG start_ARG | script_G | end_ARG âˆ‘ start_POSTSUBSCRIPT italic_h âˆˆ script_G end_POSTSUBSCRIPT italic_F ( italic_h ) italic_H ( italic_h start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_g ) . We will also need to perform Fourier analysis over powers of the form ğ’¢Dsuperscriptğ’¢ğ·\mathscr{G}^{D}script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT for a given group ğ’¢ğ’¢\mathscr{G}script_G and finite set Dğ·Ditalic_D. It is possible to identify ğ’¢D^^superscriptğ’¢ğ·\widehat{\mathscr{G}^{D}}over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG with (ğ’¢^)Dsuperscript^ğ’¢ğ·(\widehat{\mathscr{G}})^{D}( over^ start_ARG script_G end_ARG ) start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT [Ter99]. This way, an element Ïâˆˆğ’¢D^ğœŒ^superscriptğ’¢ğ·\rho\in\widehat{\mathscr{G}^{D}}italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG is given by a tuple (Ïd)dâˆˆDsubscriptsuperscriptğœŒğ‘‘ğ‘‘ğ·(\rho^{d})_{d\in D}( italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ) start_POSTSUBSCRIPT italic_d âˆˆ italic_D end_POSTSUBSCRIPT where Ïdâˆˆğ’¢^superscriptğœŒğ‘‘^ğ’¢\rho^{d}\in\widehat{\mathscr{G}}italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT âˆˆ over^ start_ARG script_G end_ARG for each dâˆˆDğ‘‘ğ·d\in Ditalic_d âˆˆ italic_D in such a way that Ïâ¢(ğ )=â¨‚dâˆˆDÏdâ¢(ğ â¢(d))ğœŒğ subscripttensor-productğ‘‘ğ·superscriptğœŒğ‘‘ğ ğ‘‘\rho(\mathbf{g})=\bigotimes_{d\in D}\rho^{d}(\mathbf{g}(d))italic_Ï ( bold_g ) = â¨‚ start_POSTSUBSCRIPT italic_d âˆˆ italic_D end_POSTSUBSCRIPT italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT ( bold_g ( italic_d ) ) for all ğ âˆˆğ’¢Dğ superscriptğ’¢ğ·\mathbf{g}\in\mathscr{G}^{D}bold_g âˆˆ script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT. Observe we use superscripts for the â€œcomponentsâ€ of the representation ÏğœŒ\rhoitalic_Ï on the power group ğ’¢Dsuperscriptğ’¢ğ·\mathscr{G}^{D}script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT, rather than subscripts, which we utilise to denote matrix entries. The degree of ÏğœŒ\rhoitalic_Ï, written |Ï|ğœŒ|\rho|| italic_Ï |, is the number of indices dâˆˆDğ‘‘ğ·d\in Ditalic_d âˆˆ italic_D for which ÏdsuperscriptğœŒğ‘‘\rho^{d}italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT is non-trivial.222This quantity is called â€œweightâ€ in [EHR04, BS23]. 1.2 Results Let ğ’¢1,ğ’¢2subscriptğ’¢1subscriptğ’¢2\mathscr{G}_{1},\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT be two groups and Ï†ğœ‘\varphiitalic_Ï† a group homomorphism with domain Domâ¢(Ï†)â‰¤ğ’¢1Domğœ‘subscriptğ’¢1\textnormal{Dom}(\varphi)\leq\mathscr{G}_{1}Dom ( italic_Ï† ) â‰¤ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and image Imâ¢(Ï†)â‰¤ğ’¢2Imğœ‘subscriptğ’¢2\textnormal{Im}(\varphi)\leq\mathscr{G}_{2}Im ( italic_Ï† ) â‰¤ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT that extends to a full homomorphism from ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. We shall refer to triples (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) of this kind as templates. Further, let 0<sâ‰¤câ‰¤10ğ‘ ğ‘10<s\leq c\leq 10 < italic_s â‰¤ italic_c â‰¤ 1 be rational constants. We consider the problem 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) which asks, given a weighted system of linear equations with exactly three variables in each equation and constants in Domâ¢(Ï†)Domğœ‘\textnormal{Dom}(\varphi)Dom ( italic_Ï† ) that is cğ‘citalic_c-satisfiable in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, to decide whether there exists an sğ‘ sitalic_s-approximation in ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, where the constants are interpreted through Ï†ğœ‘\varphiitalic_Ï†. To be more precise, an instance to 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) over a set of variables Xğ‘‹Xitalic_X is a weighted systems of linear equations where each equation is of the form xiâ¢yjâ¢zk=gsuperscriptğ‘¥ğ‘–superscriptğ‘¦ğ‘—superscriptğ‘§ğ‘˜ğ‘”x^{i}y^{j}z^{k}=gitalic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_y start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_z start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g for some x,y,zâˆˆXğ‘¥ğ‘¦ğ‘§ğ‘‹x,y,z\in Xitalic_x , italic_y , italic_z âˆˆ italic_X, gâˆˆDomâ¢(Ï†)ğ‘”Domğœ‘g\in\textnormal{Dom}(\varphi)italic_g âˆˆ Dom ( italic_Ï† ), i,j,kâˆˆ{âˆ’1,1}ğ‘–ğ‘—ğ‘˜11i,j,k\in\{-1,1\}italic_i , italic_j , italic_k âˆˆ { - 1 , 1 }, and each equation has a non-negative rational weight. Without loss of generality, we assume that the weights are normalised, i.e., sum up to 1. For tâˆˆ[2]ğ‘¡delimited-[]2t\in[2]italic_t âˆˆ [ 2 ], an assignment f:Xâ†’ğ’¢t:ğ‘“â†’ğ‘‹subscriptğ’¢ğ‘¡f:X\to\mathscr{G}_{t}italic_f : italic_X â†’ script_G start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT satisfies an equation xiâ¢yjâ¢zk=gsuperscriptğ‘¥ğ‘–superscriptğ‘¦ğ‘—superscriptğ‘§ğ‘˜ğ‘”x^{i}y^{j}z^{k}=gitalic_x start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_y start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_z start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g in ğ’¢tsubscriptğ’¢ğ‘¡\mathscr{G}_{t}script_G start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT if fâ¢(x)iâ¢fâ¢(y)jâ¢fâ¢(z)k=gğ‘“superscriptğ‘¥ğ‘–ğ‘“superscriptğ‘¦ğ‘—ğ‘“superscriptğ‘§ğ‘˜ğ‘”f(x)^{i}f(y)^{j}f(z)^{k}=gitalic_f ( italic_x ) start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_f ( italic_y ) start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_f ( italic_z ) start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_g for t=1ğ‘¡1t=1italic_t = 1, and fâ¢(x)iâ¢fâ¢(y)jâ¢fâ¢(z)k=Ï†â¢(g)ğ‘“superscriptğ‘¥ğ‘–ğ‘“superscriptğ‘¦ğ‘—ğ‘“superscriptğ‘§ğ‘˜ğœ‘ğ‘”f(x)^{i}f(y)^{j}f(z)^{k}=\varphi(g)italic_f ( italic_x ) start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT italic_f ( italic_y ) start_POSTSUPERSCRIPT italic_j end_POSTSUPERSCRIPT italic_f ( italic_z ) start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT = italic_Ï† ( italic_g ) for t=2ğ‘¡2t=2italic_t = 2. The task then is to accept if there is an assignment that satisfies a cğ‘citalic_c-fraction (i.e., a fraction of total weight cğ‘citalic_c) of equations in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, and to reject if there is no assignment that satisfies an sğ‘ sitalic_s-fraction of the equations in ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. It is easy to verify that, if (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) is a template and sâ‰¤cğ‘ ğ‘s\leq citalic_s â‰¤ italic_c, then the sets of accept and reject instances are, in fact, disjoint.3333âˆ’LIN3LIN\operatorname{3-LIN}3 - roman_LIN can be alternatively phrased as a promise constraint satisfaction problem, cf. Section 4 for details. 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) is trivially tractable when Imâ¢(Ï†)={1}Imğœ‘1\textnormal{Im}(\varphi)=\{1\}Im ( italic_Ï† ) = { 1 }, so we focus on the case where |Imâ¢(Ï†)|â‰¥2Imğœ‘2|\textnormal{Im}(\varphi)|\geq 2| Im ( italic_Ï† ) | â‰¥ 2. The main result of this paper is that 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,1âˆ’Ïµ,1/|Imâ¢(Ï†)|+Î´)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘1italic-Ïµ1Imğœ‘ğ›¿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , 1 - italic_Ïµ , 1 / | Im ( italic_Ï† ) | + italic_Î´ ) in NP-hard for all Ïµ,Î´>0italic-Ïµğ›¿0\epsilon,\delta>0italic_Ïµ , italic_Î´ > 0 for which the problem is well-defined. This is achieved by a reduction from the Gap Label Cover problem with perfect completeness and soundness Î±=Î´2/(4â¢Îºâ¢|ğ’¢1|Îºâ¢|ğ’¢2|4)ğ›¼superscriptğ›¿24ğœ…superscriptsubscriptğ’¢1ğœ…superscriptsubscriptğ’¢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_Î± = italic_Î´ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_Îº | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_Îº end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ), where Îº=âŒˆ(log2â¡Î´âˆ’2)/(log2â¡(1âˆ’Ïµ))âŒ‰ğœ…subscript2ğ›¿2subscript21italic-Ïµ\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon))\rceilitalic_Îº = âŒˆ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_Î´ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_Ïµ ) ) âŒ‰. Theorem 1.3 (Main). Let Ïµ,Î´italic-Ïµğ›¿\epsilon,\deltaitalic_Ïµ , italic_Î´ be positive constants satisfying 1âˆ’Ïµâ‰¥1/|Imâ¢(Ï†)|+Î´1italic-Ïµ1Imğœ‘ğ›¿1-\epsilon\geq 1/|\textnormal{Im}(\varphi)|+\delta1 - italic_Ïµ â‰¥ 1 / | Im ( italic_Ï† ) | + italic_Î´. Then, 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,1âˆ’Ïµ,1/|Imâ¢(Ï†)|+Î´)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘1italic-Ïµ1Imğœ‘ğ›¿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , 1 - italic_Ïµ , 1 / | Im ( italic_Ï† ) | + italic_Î´ ) is NP-hard. The hardness result in Theorem 1.3 is tight for many, but perhaps surprisingly not all, templates. We call a template (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) cubic if for every hâˆˆImâ¢(Ï†)â„Imğœ‘h\in\textnormal{Im}(\varphi)italic_h âˆˆ Im ( italic_Ï† ) there is an element gâˆˆğ’¢2ğ‘”subscriptğ’¢2g\in\mathscr{G}_{2}italic_g âˆˆ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT satisfying g3=hsuperscriptğ‘”3â„g^{3}=hitalic_g start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT = italic_h. Theorem 1.3 is tight for cubic templates. Indeed, for these templates, the random assignment over Imâ¢(Ï†)Imğœ‘\textnormal{Im}(\varphi)Im ( italic_Ï† ) achieves a 1/|Imâ¢(Ï†)|1Imğœ‘1/|\textnormal{Im}(\varphi)|1 / | Im ( italic_Ï† ) | expected fraction of satisfied equations (and this can be derandomised, e.g., by the method of conditional expectations). Theorem 1.4. Let (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) be a cubic template and 0<sâ‰¤c<10ğ‘ ğ‘10<s\leq c<10 < italic_s â‰¤ italic_c < 1. Then, 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) is tractable if sâ‰¤1/|Imâ¢(Ï†)|ğ‘ 1Imğœ‘s\leq 1/|\textnormal{Im}(\varphi)|italic_s â‰¤ 1 / | Im ( italic_Ï† ) | and NP-hard otherwise. Let us now turn to non-cubic templates. An equation is unsatisfiable if it is of the form x3=hsuperscriptğ‘¥3â„x^{3}=hitalic_x start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT = italic_h or xâˆ’3=hsuperscriptğ‘¥3â„x^{-3}=hitalic_x start_POSTSUPERSCRIPT - 3 end_POSTSUPERSCRIPT = italic_h for some hâˆˆDomâ¢(Ï†)â„Domğœ‘h\in\textnormal{Dom}(\varphi)italic_h âˆˆ Dom ( italic_Ï† ) such that g3â‰ Ï†â¢(h)superscriptğ‘”3ğœ‘â„g^{3}\neq\varphi(h)italic_g start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT â‰  italic_Ï† ( italic_h ) for all gâˆˆğ’¢2ğ‘”subscriptğ’¢2g\in\mathscr{G}_{2}italic_g âˆˆ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Note that a template has unsatisfiable equations if and only if it is non-cubic. Note that the naive random assignment cannot achieve a positive approximation factor in systems of equations over non-cubic templates since the system could consist exclusively of unsatisfiable equations. However, there is a simple algorithm for 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,c/|Imâ¢(Ï†)|)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘Imğœ‘\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,c/|\textnormal{% Im}(\varphi)|)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_c / | Im ( italic_Ï† ) | ) that works even for non-cubic templates, which we describe next. Given a weighted system of equations over (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ), consider its set of unsatisfiable equations. Since Ï†ğœ‘\varphiitalic_Ï† extends to a full homomorphism, if the total weight of the set of unsatisfiable equations is more than 1âˆ’c1ğ‘1-c1 - italic_c, then the instance cannot be cğ‘citalic_c-satisfiable in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT, hence, reject. Otherwise, the random assignment over Imâ¢(Ï†)Imğœ‘\textnormal{Im}(\varphi)Im ( italic_Ï† ) satisfies at least a 1/|Imâ¢(Ï†)|1Imğœ‘1/|\textnormal{Im}(\varphi)|1 / | Im ( italic_Ï† ) |-fraction of the satisfiable equations over ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, which is at least a c/|Imâ¢(Ï†)|ğ‘Imğœ‘c/|\textnormal{Im}(\varphi)|italic_c / | Im ( italic_Ï† ) |-fraction of the entire system. It is a simple corollary of Theorem 1.3 that this algorithm is optimal for non-cubic groups, leading to the following result. Details are deferred to Appendix A. Theorem 1.5. Let (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ) be a non-cubic template and 0<sâ‰¤c<10ğ‘ ğ‘10<s\leq c<10 < italic_s â‰¤ italic_c < 1. Then, 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,c,s)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘ğ‘ğ‘ \operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,c,s)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , italic_c , italic_s ) is tractable if s/câ‰¤1/|Imâ¢(Ï†)|ğ‘ ğ‘1Imğœ‘s/c\leq 1/|\textnormal{Im}(\varphi)|italic_s / italic_c â‰¤ 1 / | Im ( italic_Ï† ) | and NP-hard otherwise. The structure of the paper is as follows. The rest of this section gives a sketch of the main proof: In Section 1.3 we present the reduction from Gap Label Cover to 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,1âˆ’Ïµ,1/|Imâ¢(Ï†)|+Î´)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘1italic-Ïµ1Imğœ‘ğ›¿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , 1 - italic_Ïµ , 1 / | Im ( italic_Ï† ) | + italic_Î´ ), and in Section 1.4 we give an overview of the techniques used in the analysis of this reduction and of the main challenges that arise in extending previous work to the promise setting. The rest of the paper then gives all technical details. In Section 2 we set the notation and present the necessary technical background on Fourier analysis over non-Abelian groups. Section 3 is dedicated to the proof of the main result, with the completeness analysis in Section 3.1 and the soundness analysis in Section 3.2. Finally, in Section 4 we relate our results to a recent theory of Barto et al. [BBK+24], who developed a systematic approach to study (in)approximability of promise CSPs, which includes approximability of promise linear equations, from the viewpoint of universal algebra. In particular, we show that the proof of Theorem 1.3 implies that the collection of symmetries444called the valued minion of plurimorphisms in [BBK+24]. of 3âˆ’LINâ¡(ğ’¢1,ğ’¢2,Ï†,1âˆ’Ïµ,1/|Imâ¢(Ï†)|+Î´)3LINsubscriptğ’¢1subscriptğ’¢2ğœ‘1italic-Ïµ1Imğœ‘ğ›¿\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},\varphi,1-\epsilon,1/|% \textnormal{Im}(\varphi)|+\delta)start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† , 1 - italic_Ïµ , 1 / | Im ( italic_Ï† ) | + italic_Î´ ) can be mapped homomorphically to the collection of symmetries of Gap Label Cover, a condition that, based on the algebraic theory from [BBK+24], is known to guarantee NP-hardness of the former problem. 1.3 Reduction For the rest of the section we outline the proof of our main result, Theorem 1.3. From now on we fix a template (ğ’¢1,ğ’¢2,Ï†)subscriptğ’¢1subscriptğ’¢2ğœ‘(\mathscr{G}_{1},\mathscr{G}_{2},\varphi)( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_Ï† ), and positive constants Î´,Ïµ>0ğ›¿italic-Ïµ0\delta,\epsilon>0italic_Î´ , italic_Ïµ > 0 with 1/|Imâ¢(Ï†)|+Î´â‰¤1âˆ’Ïµ1Imğœ‘ğ›¿1italic-Ïµ1/|\textnormal{Im}(\varphi)|+\delta\leq 1-\epsilon1 / | Im ( italic_Ï† ) | + italic_Î´ â‰¤ 1 - italic_Ïµ. We define â„‹1=Domâ¢(Ï†)â‰¤ğ’¢1subscriptâ„‹1Domğœ‘subscriptğ’¢1\mathscr{H}_{1}=\textnormal{Dom}(\varphi)\leq\mathscr{G}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = Dom ( italic_Ï† ) â‰¤ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and â„‹2=Imâ¢(Ï†)â‰¤ğ’¢2subscriptâ„‹2Imğœ‘subscriptğ’¢2\mathscr{H}_{2}=\textnormal{Im}(\varphi)\leq\mathscr{G}_{2}script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = Im ( italic_Ï† ) â‰¤ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Our proof follows from a reduction from GLCD,Eâ¢(1,Î±)subscriptGLCğ·ğ¸1ğ›¼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_Î± ) where Î±=Î´2/(4â¢Îºâ¢|ğ’¢1|Îºâ¢|ğ’¢2|4)ğ›¼superscriptğ›¿24ğœ…superscriptsubscriptğ’¢1ğœ…superscriptsubscriptğ’¢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_Î± = italic_Î´ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_Îº | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_Îº end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ), Îº=âŒˆ(log2â¡Î´âˆ’2)/(log2â¡(1âˆ’Ïµ))âŒ‰ğœ…subscript2ğ›¿2subscript21italic-Ïµ\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon))\rceilitalic_Îº = âŒˆ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_Î´ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_Ïµ ) ) âŒ‰, and D,Eğ·ğ¸D,Eitalic_D , italic_E are chosen to be large enough so that GLCD,Eâ¢(1,Î±)subscriptGLCğ·ğ¸1ğ›¼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_Î± ) is NP-hard by the PCP theorem [ALM+98, AS98, Raz98] (cf. Theorem 1.1). This reduction constructs an instance Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT of 3âˆ’LIN(ğ’¢1,ğ’¢2,\operatorname{3-LIN}(\mathscr{G}_{1},\mathscr{G}_{2},start_OPFUNCTION 3 - roman_LIN end_OPFUNCTION ( script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , Ï†,1âˆ’Ïµ,1/|â„‹2|+Î´)\varphi,1-\epsilon,1/|\mathscr{H}_{2}|+\delta)italic_Ï† , 1 - italic_Ïµ , 1 / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | + italic_Î´ ) for any given instance Î£Î£\Sigmaroman_Î£ of Gap Label Cover as described below. Let UâŠ”Vsquare-unionğ‘ˆğ‘‰U\sqcup Vitalic_U âŠ” italic_V be the underlying vertex set of Î£Î£\Sigmaroman_Î£, D,Eğ·ğ¸D,Eitalic_D , italic_E be the disjoint sets of labels, and Ï€uâ¢vsubscriptğœ‹ğ‘¢ğ‘£\pi_{uv}italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT be the labeling functions. We fix representatives from each right coset in â„‹1\ğ’¢1D\subscriptâ„‹1superscriptsubscriptğ’¢1ğ·\mathscr{H}_{1}\backslash\mathscr{G}_{1}^{D}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT \ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT and â„‹1\ğ’¢1E\subscriptâ„‹1superscriptsubscriptğ’¢1ğ¸\mathscr{H}_{1}\backslash\mathscr{G}_{1}^{E}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT \ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT. Given a tuple ğ±ğ±{\mathbf{x}}bold_x in either ğ’¢1Dsuperscriptsubscriptğ’¢1ğ·\mathscr{G}_{1}^{D}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT or ğ’¢1Esuperscriptsubscriptğ’¢1ğ¸\mathscr{G}_{1}^{E}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT we write ğ±â€ superscriptğ±â€ \mathbf{x}^{\dagger}bold_x start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT for the representative of the coset â„‹1â¢ğ±subscriptâ„‹1ğ±\mathscr{H}_{1}\mathbf{x}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT bold_x. Let X={uğ›|uâˆˆU,ğ›âˆˆğ’¢1D}âŠ”{vğš|vâˆˆV,ğšâˆˆğ’¢1E}ğ‘‹square-unionconditional-setsubscriptğ‘¢ğ›formulae-sequenceğ‘¢ğ‘ˆğ›superscriptsubscriptğ’¢1ğ·conditional-setsubscriptğ‘£ğšformulae-sequenceğ‘£ğ‘‰ğšsuperscriptsubscriptğ’¢1ğ¸X=\{u_{\mathbf{b}}\,|u\in U,{\mathbf{b}}\in\mathscr{G}_{1}^{D}\}\sqcup\{v_{% \mathbf{a}}\,|v\in V,{\mathbf{a}}\in\mathscr{G}_{1}^{E}\}italic_X = { italic_u start_POSTSUBSCRIPT bold_b end_POSTSUBSCRIPT | italic_u âˆˆ italic_U , bold_b âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT } âŠ” { italic_v start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT | italic_v âˆˆ italic_V , bold_a âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT }. Then Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT is the weighted system of equations over Xğ‘‹Xitalic_X that contains the equation vğšâ€ â¢uğ›s1s1â¢uğœs2s2=gğšsubscriptğ‘£superscriptğšâ€ superscriptsubscriptğ‘¢superscriptğ›subscriptğ‘ 1subscriptğ‘ 1superscriptsubscriptğ‘¢superscriptğœsubscriptğ‘ 2subscriptğ‘ 2subscriptğ‘”ğšv_{{\mathbf{a}}^{\dagger}}u_{{\mathbf{b}}^{s_{1}}}^{s_{1}}u_{{\mathbf{c}}^{s_{% 2}}}^{s_{2}}=g_{{\mathbf{a}}}italic_v start_POSTSUBSCRIPT bold_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT end_POSTSUBSCRIPT italic_u start_POSTSUBSCRIPT bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_u start_POSTSUBSCRIPT bold_c start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT (1) for each edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v } of Î£Î£\Sigmaroman_Î£, ğšâˆˆğ’¢1Eğšsuperscriptsubscriptğ’¢1ğ¸{\mathbf{a}}\in\mathscr{G}_{1}^{E}bold_a âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT, ğ›âˆˆğ’¢1Dğ›superscriptsubscriptğ’¢1ğ·{\mathbf{b}}\in\mathscr{G}_{1}^{D}bold_b âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT, s1,s2âˆˆ{âˆ’1,1}subscriptğ‘ 1subscriptğ‘ 211s_{1},s_{2}\in\{-1,1\}italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âˆˆ { - 1 , 1 }, where ğœğœ{\mathbf{c}}bold_c stands for ğ›âˆ’1â¢(ğšâˆ˜Ï€uâ¢v)âˆ’1â¢ğ‚superscriptğ›1superscriptğšsubscriptğœ‹ğ‘¢ğ‘£1ğ‚{\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu}bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ and ğ‚âˆˆğ’¢1Dğ‚superscriptsubscriptğ’¢1ğ·\bm{\nu}\in\mathscr{G}_{1}^{D}bold_italic_Î½ âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT is a small perturbation factor. The element gğšsubscriptğ‘”ğšg_{\mathbf{a}}italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT is chosen so that ğšâ€ =gğšâ¢ğšsuperscriptğšâ€ subscriptğ‘”ğšğš{\mathbf{a}}^{\dagger}=g_{\mathbf{a}}{\mathbf{a}}bold_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT bold_a. The weight of this equation in Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT is the joint probability of the independent events described in Figure 1. (1)The edge {u,v} is chosen uniformly at random among all edges of Î£.(2)The elements ğš and ğ› are chosen uniformly at random from ğ’¢1E and ğ’¢1D respectively.(3)The element ğ‚âˆˆğ’¢1D is chosen so that for each dâˆˆD, independently, ğ‚â¢(d)=1ğ’¢1 withprobability 1âˆ’Ïµ, and ğ‚â¢(d) is selected uniformly at random from ğ’¢1 with probability Ïµ.(4)The signs s1,s2 are chosen uniformly at random from {âˆ’1,1}.(1)The edge {u,v} is chosen uniformly at random among all edges of Î£.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(2)The elements ğš and ğ› are chosen uniformly at random from ğ’¢1E and ğ’¢1D respectively.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(3)The element ğ‚âˆˆğ’¢1D is chosen so that for each dâˆˆD, independently, ğ‚â¢(d)=1ğ’¢1 withmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpressionprobability 1âˆ’Ïµ, and ğ‚â¢(d) is selected uniformly at random from ğ’¢1 with probability Ïµ.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression(4)The signs s1,s2 are chosen uniformly at random from {âˆ’1,1}.missing-subexpressionmissing-subexpressionmissing-subexpressionmissing-subexpression\displaystyle\boxed{\begin{array}[]{llllll}\mbox{($1$)}&\text{The edge $\{u,v\}$ is chosen uniformly at random among all edges of $\Sigma$.}\\[5% .0pt] \mbox{($2$)}&\text{The elements ${\mathbf{a}}$ and ${\mathbf{b}}$ are chosen % uniformly at random from $\mathscr{G}_{1}^{E}$ and $\mathscr{G}_{1}^{D}$ % respectively.}\\[5.0pt] \mbox{($3$)}&\text{The element $\bm{\nu}\in\mathscr{G}_{1}^{D}$ is chosen so % that for each $d\in D$, independently, $\bm{\nu}(d)=1_{\mathscr{G}_{1}}$ with}\\ &\text{probability $1-\epsilon$, and $\bm{\nu}(d)$ is selected uniformly at % random from $\mathscr{G}_{1}$ with probability $\epsilon$.}\\[5.0pt] \mbox{($4$)}&\text{The signs $s_{1},s_{2}$ are chosen uniformly at random from $\{-1,1\}$.}\end{array}}start_ARRAY start_ROW start_CELL ( 1 ) end_CELL start_CELL The edge { italic_u , italic_v } is chosen uniformly at random among all edges of roman_Î£ . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 2 ) end_CELL start_CELL The elements bold_a and bold_b are chosen uniformly at random from script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT and script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT respectively. end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 3 ) end_CELL start_CELL The element bold_italic_Î½ âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT is chosen so that for each italic_d âˆˆ italic_D , independently, bold_italic_Î½ ( italic_d ) = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT with end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL end_CELL start_CELL probability 1 - italic_Ïµ , and bold_italic_Î½ ( italic_d ) is selected uniformly at random from script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT with probability italic_Ïµ . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW start_ROW start_CELL ( 4 ) end_CELL start_CELL The signs italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are chosen uniformly at random from { - 1 , 1 } . end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL start_CELL end_CELL end_ROW end_ARRAY Figure 1: The sampling procedure for Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT. Let us describe assignments of Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT over ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT for i=1,2ğ‘–12i=1,2italic_i = 1 , 2. Formally, an assignment of Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT over ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is a map h:Xâ†’ğ’¢i:â„â†’ğ‘‹subscriptğ’¢ğ‘–h:X\rightarrow\mathscr{G}_{i}italic_h : italic_X â†’ script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT. Such an assignment can be described by two families of maps A=(Av)vâˆˆVğ´subscriptsubscriptğ´ğ‘£ğ‘£ğ‘‰A=(A_{v})_{v\in V}italic_A = ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_v âˆˆ italic_V end_POSTSUBSCRIPT from ğ’¢1Esubscriptsuperscriptğ’¢ğ¸1\mathscr{G}^{E}_{1}script_G start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT to ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and B=(Bu)uâˆˆUğµsubscriptsubscriptğµğ‘¢ğ‘¢ğ‘ˆB=(B_{u})_{u\in U}italic_B = ( italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_u âˆˆ italic_U end_POSTSUBSCRIPT from ğ’¢1Dsuperscriptsubscriptğ’¢1ğ·\mathscr{G}_{1}^{D}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT to ğ’¢isubscriptğ’¢ğ‘–\mathscr{G}_{i}script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT by letting Avâ¢(ğš)=hâ¢(vğš)subscriptğ´ğ‘£ğšâ„subscriptğ‘£ğšA_{v}({\mathbf{a}})=h(v_{{\mathbf{a}}})italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a ) = italic_h ( italic_v start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT ) for all vâˆˆV,ğšâˆˆğ’¢1Eformulae-sequenceğ‘£ğ‘‰ğšsuperscriptsubscriptğ’¢1ğ¸v\in V,{\mathbf{a}}\in\mathscr{G}_{1}^{E}italic_v âˆˆ italic_V , bold_a âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT, and Buâ¢(ğ›)=hâ¢(uğ›)=subscriptğµğ‘¢ğ›â„subscriptğ‘¢ğ›absentB_{u}({\mathbf{b}})=h(u_{{\mathbf{b}}})=italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b ) = italic_h ( italic_u start_POSTSUBSCRIPT bold_b end_POSTSUBSCRIPT ) = for all uâˆˆU,ğ›âˆˆğ’¢1Dformulae-sequenceğ‘¢ğ‘ˆğ›superscriptsubscriptğ’¢1ğ·u\in U,{\mathbf{b}}\in\mathscr{G}_{1}^{D}italic_u âˆˆ italic_U , bold_b âˆˆ script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT. It will be more convenient to talk about the pair (A,B)ğ´ğµ(A,B)( italic_A , italic_B ) rather than the map hâ„hitalic_h itself, so we will write Î¦Î£ğ’¢iâ¢(A,B)subscriptsuperscriptÎ¦subscriptğ’¢ğ‘–Î£ğ´ğµ\Phi^{\mathscr{G}_{i}}_{\Sigma}(A,B)roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) to refer to the proportion of equations satisfied by the assignment hâ„hitalic_h. Let us give a more useful expression for Î¦Î£ğ’¢iâ¢(A,B)subscriptsuperscriptÎ¦subscriptğ’¢ğ‘–Î£ğ´ğµ\Phi^{\mathscr{G}_{i}}_{\Sigma}(A,B)roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ). When i=1ğ‘–1i=1italic_i = 1, we can write Î¦Î£ğ’¢1(A,B)=ğ”¼uâ¢v,ğš,ğ›,ğ‚,s1,s2[âŸ¦Av(ğšâ€ )Bu(ğ›s1)s1Bu((ğ›âˆ’1(ğšâˆ˜Ï€uâ¢v)âˆ’1ğ‚)s2)s2=gğšâŸ§],\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket A_{v}({\mathbf{a}}^{% \dagger})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{% a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=g_{{\mathbf{a}}}\rrbracket% \right],roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_Î½ , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ âŸ¦ italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT âŸ§ ] , where the expectation is taken over the probabilities described in Figure 1, and we use uâ¢vğ‘¢ğ‘£uvitalic_u italic_v as a shorthand for an edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v }. Folding the assignments Avsubscriptğ´ğ‘£A_{v}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT over the identity on â„‹1subscriptâ„‹1\mathscr{H}_{1}script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and using the fact that (Av)idâ„‹1â¢(ğš)=gğšâˆ’1â¢Avâ¢(ğšâ€ )subscriptsubscriptğ´ğ‘£subscriptidsubscriptâ„‹1ğšsuperscriptsubscriptğ‘”ğš1subscriptğ´ğ‘£superscriptğšâ€ (A_{v})_{\mathrm{id}_{\mathscr{H}_{1}}}({\mathbf{a}})=g_{{\mathbf{a}}}^{-1}A_{% v}({\mathbf{a}}^{\dagger})( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( bold_a ) = italic_g start_POSTSUBSCRIPT bold_a end_POSTSUBSCRIPT start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ( bold_a start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT ), we obtain Î¦Î£ğ’¢1(A,B)=ğ”¼uâ¢v,ğš,ğ›,ğ‚,s1,s2[âŸ¦(Av)idâ„‹1(ğš)Bu(ğ›s1)s1Bu((ğ›âˆ’1(ğšâˆ˜Ï€uâ¢v)âˆ’1ğ‚)s2)s2=1ğ’¢1âŸ§].\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket(A_{v})_{\mathrm{id}_{% \mathscr{H}_{1}}}({\mathbf{a}})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({% \mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=1_{% \mathscr{G}_{1}}\rrbracket\right].roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_Î½ , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ âŸ¦ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT âŸ§ ] . (2) Analogously, when i=2ğ‘–2i=2italic_i = 2 and Av,Busubscriptğ´ğ‘£subscriptğµğ‘¢A_{v},B_{u}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT , italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are families of maps to ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, we obtain a similar expression for Î¦Î£ğ’¢2â¢(A,B)subscriptsuperscriptÎ¦subscriptğ’¢2Î£ğ´ğµ\Phi^{\mathscr{G}_{2}}_{\Sigma}(A,B)roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ): Î¦Î£ğ’¢2(A,B)=ğ”¼uâ¢v,ğš,ğ›,ğ‚,s1,s2[âŸ¦(Av)Ï†(ğš)Bu(ğ›s1)s1Bu((ğ›âˆ’1(ğšâˆ˜Ï€uâ¢v)âˆ’1ğ‚)s2)s2=1ğ’¢2âŸ§].\Phi^{\mathscr{G}_{2}}_{\Sigma}(A,B)=\mathbb{E}_{\begin{subarray}{c}uv,{% \mathbf{a}},{\mathbf{b}},\\ \bm{\nu},s_{1},s_{2}\end{subarray}}\left[\llbracket(A_{v})_{\varphi}({\mathbf{% a}})B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}% \circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_{2}}=1_{\mathscr{G}_{2}}\rrbracket% \right].roman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) = blackboard_E start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_u italic_v , bold_a , bold_b , end_CELL end_ROW start_ROW start_CELL bold_italic_Î½ , italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT [ âŸ¦ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = 1 start_POSTSUBSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT âŸ§ ] . (3) That is, a pair of assignments (A,B)ğ´ğµ(A,B)( italic_A , italic_B ) satisfies an equation in Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT if and only if the corresponding pair of assignments obtained by folding Ağ´Aitalic_A (over idâ„‹1subscriptidsubscriptâ„‹1\mathrm{id}_{\mathscr{H}_{1}}roman_id start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT and Ï†ğœ‘\varphiitalic_Ï† respectively) maps the equation to the group identity (respectively, in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT). Thus, folding allows us to focus exclusively on the identity terms in these expectations, which will be useful in the analysis of the reduction. Theorem 1.3 follows from our completeness and soundness bounds for Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT, stated in the next results, using the fact that by Theorem 1.1, there are finite sets D,Eğ·ğ¸D,Eitalic_D , italic_E such that GLCD,Eâ¢(1,Î±)subscriptGLCğ·ğ¸1ğ›¼\mathrm{GLC}_{D,E}(1,\alpha)roman_GLC start_POSTSUBSCRIPT italic_D , italic_E end_POSTSUBSCRIPT ( 1 , italic_Î± ) is NP-hard for the value of Î±ğ›¼\alphaitalic_Î± chosen in Theorem 1.7 below. The proofs of the completeness and soundness bounds can be found in Section 3.1 and Section 3.2 respectively. Theorem 1.6 (Completeness). Let Î£Î£\Sigmaroman_Î£ be a Gap Label Cover instance and Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT be the system defined in (1). Suppose that Î£Î£\Sigmaroman_Î£ is 1111-satisfiable. Then Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT is (1âˆ’Ïµ)1italic-Ïµ(1-\epsilon)( 1 - italic_Ïµ )-satisfiable in ğ’¢1subscriptğ’¢1\mathscr{G}_{1}script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT. Theorem 1.7 (Soundness). Let Î£Î£\Sigmaroman_Î£ be a Gap Label Cover instance and Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT be the system defined in (1). Suppose that Î¦Î£subscriptÎ¦Î£\Phi_{\Sigma}roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT is (1/|â„‹2|+Î´)1subscriptâ„‹2ğ›¿(1/|\mathscr{H}_{2}|+\delta)( 1 / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | + italic_Î´ )-satisfiable in ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Then Î£Î£\Sigmaroman_Î£ is Î±ğ›¼\alphaitalic_Î±-satisfiable, where Î±=Î´2/(4â¢Îºâ¢|ğ’¢1|Îºâ¢|ğ’¢2|4)ğ›¼superscriptğ›¿24ğœ…superscriptsubscriptğ’¢1ğœ…superscriptsubscriptğ’¢24\alpha=\delta^{2}/(4\kappa|\mathscr{G}_{1}|^{\kappa}|\mathscr{G}_{2}|^{4})italic_Î± = italic_Î´ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / ( 4 italic_Îº | script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_Îº end_POSTSUPERSCRIPT | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) and Îº=âŒˆ(log2Î´âˆ’2)/(log2(1âˆ’Ïµ)âŒ‰\kappa=\lceil(\log_{2}\delta-2)/(\log_{2}(1-\epsilon)\rceilitalic_Îº = âŒˆ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_Î´ - 2 ) / ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_Ïµ ) âŒ‰. 1.4 Proof Outline The main difficulty in proving the correctness of our reduction lies in showing the soundness bound (Theorem 1.7). The completeness result (Theorem 1.6) is relatively straightforward and follows as in [EHR04]. In summary, suppose the Gap Label Cover instance Î£Î£\Sigmaroman_Î£ is satisfied by a pair of assignments hD:Uâ†’D:subscriptâ„ğ·â†’ğ‘ˆğ·h_{D}:U\rightarrow Ditalic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT : italic_U â†’ italic_D, hE:Vâ†’E:subscriptâ„ğ¸â†’ğ‘‰ğ¸h_{E}:V\rightarrow Eitalic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT : italic_V â†’ italic_E. Then we find families A,Bğ´ğµA,Bitalic_A , italic_B such that Î¦Î£ğ’¢1â¢(A,B)â‰¥1âˆ’ÏµsubscriptsuperscriptÎ¦subscriptğ’¢1Î£ğ´ğµ1italic-Ïµ\Phi^{\mathscr{G}_{1}}_{\Sigma}(A,B)\geq 1-\epsilonroman_Î¦ start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT ( italic_A , italic_B ) â‰¥ 1 - italic_Ïµ by letting Avsubscriptğ´ğ‘£A_{v}italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT be the hEâ¢(v)subscriptâ„ğ¸ğ‘£h_{E}(v)italic_h start_POSTSUBSCRIPT italic_E end_POSTSUBSCRIPT ( italic_v )-th projection and Busubscriptğµğ‘¢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT be the hDâ¢(u)subscriptâ„ğ·ğ‘¢h_{D}(u)italic_h start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_u )-th projection for each vâˆˆV,uâˆˆUformulae-sequenceğ‘£ğ‘‰ğ‘¢ğ‘ˆv\in V,u\in Uitalic_v âˆˆ italic_V , italic_u âˆˆ italic_U. As usual, the noise introduced by the perturbation factor ğ‚ğ‚\bm{\nu}bold_italic_Î½ is what forces us to give up perfect completeness. The idea behind our soundness analysis has appeared many times in the literature (e.g., [HÃ¥s01, EHR04, BK21]), but the approach taken in [EHR04] is the most similar to ours. Suppose that there are assignments A,Bğ´ğµA,Bitalic_A , italic_B, satisfying Î¦Î£ğ’¢2â¢(A,B)â‰¥1|â„‹2|+Î´.superscriptsubscriptÎ¦Î£subscriptğ’¢2ğ´ğµ1subscriptâ„‹2ğ›¿\Phi_{\Sigma}^{\mathscr{G}_{2}}(A,B)\geq\frac{1}{|\mathscr{H}_{2}|}+\delta.roman_Î¦ start_POSTSUBSCRIPT roman_Î£ end_POSTSUBSCRIPT start_POSTSUPERSCRIPT script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ( italic_A , italic_B ) â‰¥ divide start_ARG 1 end_ARG start_ARG | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | end_ARG + italic_Î´ . (4) In view of (3), this inequality can be understood as a lower bound for the the success probability of the following 3333-query dictatorship test: Sample all parameters according to the distribution shown in Figure 1, and then query the values (Av)Ï†â¢(ğš)subscriptsubscriptğ´ğ‘£ğœ‘ğš(A_{v})_{\varphi}({\mathbf{a}})( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_a ), Buâ¢(ğ›s1)s1subscriptğµğ‘¢superscriptsuperscriptğ›subscriptğ‘ 1subscriptğ‘ 1B_{u}({\mathbf{b}}^{s_{1}})^{s_{1}}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT, and Buâ¢((ğ›âˆ’1â¢(ğšâˆ˜Ï€uâ¢v)âˆ’1â¢ğ‚)s2)s2subscriptğµğ‘¢superscriptsuperscriptsuperscriptğ›1superscriptğšsubscriptğœ‹ğ‘¢ğ‘£1ğ‚subscriptğ‘ 2subscriptğ‘ 2B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi_{uv})^{-1}\bm{\nu})^{s_{2}})^{s_% {2}}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT. The test is passed if the product of the three values is the group identity, and failed otherwise. The soundness proof consists in showing that (4) implies that the functions (Av)Ï†:ğ’¢1Eâ†’ğ’¢2:subscriptsubscriptğ´ğ‘£ğœ‘â†’superscriptsubscriptğ’¢1ğ¸subscriptğ’¢2(A_{v})_{\varphi}:\mathscr{G}_{1}^{E}\rightarrow\mathscr{G}_{2}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and Bu:ğ’¢1Dâ†’ğ’¢2:subscriptğµğ‘¢â†’superscriptsubscriptğ’¢1ğ·subscriptğ’¢2B_{u}:\mathscr{G}_{1}^{D}\rightarrow\mathscr{G}_{2}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are â€œcloseâ€ to dictators (i.e., projections) for each vâˆˆVğ‘£ğ‘‰v\in Vitalic_v âˆˆ italic_V, uâˆˆUğ‘¢ğ‘ˆu\in Uitalic_u âˆˆ italic_U. Then, this fact allows us to find a good solution to the starting Gap Label Cover instance Î£Î£\Sigmaroman_Î£. Indeed, suppose that for each vâˆˆVğ‘£ğ‘‰v\in Vitalic_v âˆˆ italic_V the map (Av)Ï†subscriptsubscriptğ´ğ‘£ğœ‘(A_{v})_{\varphi}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT is the projection on the evsubscriptğ‘’ğ‘£e_{v}italic_e start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT-th coordinate, and for each uâˆˆUğ‘¢ğ‘ˆu\in Uitalic_u âˆˆ italic_U, the map Busubscriptğµğ‘¢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT is the projection on the dusubscriptğ‘‘ğ‘¢d_{u}italic_d start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT-th coordinate. Then the assignment mapping vğ‘£vitalic_v to evsubscriptğ‘’ğ‘£e_{v}italic_e start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT and uğ‘¢uitalic_u to dusubscriptğ‘‘ğ‘¢d_{u}italic_d start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT for each vâˆˆV,uâˆˆUformulae-sequenceğ‘£ğ‘‰ğ‘¢ğ‘ˆv\in V,u\in Uitalic_v âˆˆ italic_V , italic_u âˆˆ italic_U is a good solution for Î£Î£\Sigmaroman_Î£. However, it is not clear how to extend this simple idea to the case where the maps (Av)Ï†,Busubscriptsubscriptğ´ğ‘£ğœ‘subscriptğµğ‘¢(A_{v})_{\varphi},B_{u}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT , italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are not projections. In order to find a good solution for Î£Î£\Sigmaroman_Î£ in this general case, we first find suitable maps Î³1,Î³2:ğ’¢2â†’â„‚:subscriptğ›¾1subscriptğ›¾2â†’subscriptğ’¢2â„‚\gamma_{1},\gamma_{2}:\mathscr{G}_{2}\rightarrow\mathbb{C}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT : script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT â†’ blackboard_C and analyse Î³1âˆ˜(Av)Ï†subscriptğ›¾1subscriptsubscriptğ´ğ‘£ğœ‘\gamma_{1}\circ(A_{v})_{\varphi}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âˆ˜ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT, Î³2âˆ˜Busubscriptğ›¾2subscriptğµğ‘¢\gamma_{2}\circ B_{u}italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âˆ˜ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT. Now, using the fact that (Av)Ï†subscriptsubscriptğ´ğ‘£ğœ‘(A_{v})_{\varphi}( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT and Busubscriptğµğ‘¢B_{u}italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT are close to projections, we can prove that choosing the labels e,dğ‘’ğ‘‘e,ditalic_e , italic_d for the vertices v,uğ‘£ğ‘¢v,uitalic_v , italic_u according to the â€œlow-degree influenceâ€ of the eğ‘’eitalic_e-th coordinate in Î³1âˆ˜(Av)Ï†subscriptğ›¾1subscriptsubscriptğ´ğ‘£ğœ‘\gamma_{1}\circ(A_{v})_{\varphi}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âˆ˜ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT and the dğ‘‘ditalic_d-th coordinate in Î³2âˆ˜Busubscriptğ›¾2subscriptğµğ‘¢\gamma_{2}\circ B_{u}italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âˆ˜ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT yields a good randomised assignment of Î£Î£\Sigmaroman_Î£. This overview so far also applies to the soundness analysis of [EHR04]. Let us give more detail and highlight the main differences that sets our work apart. The first important difference has to do with the choice of Î³1,Î³2subscriptğ›¾1subscriptğ›¾2\gamma_{1},\gamma_{2}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. We define Î³1=Ï‰x,ysubscriptğ›¾1subscriptğœ”ğ‘¥ğ‘¦\gamma_{1}=\omega_{x,y}italic_Î³ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = italic_Ï‰ start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT, and Î³2=Ï‰y,zsubscriptğ›¾2subscriptğœ”ğ‘¦ğ‘§\gamma_{2}=\omega_{y,z}italic_Î³ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT = italic_Ï‰ start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT, where Ï‰ğœ”\omegaitalic_Ï‰ is some irreducible representation of ğ’¢2subscriptğ’¢2\mathscr{G}_{2}script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, and x,y,zğ‘¥ğ‘¦ğ‘§x,y,zitalic_x , italic_y , italic_z are suitable indices in NÏ‰subscriptğ‘ğœ”N_{\omega}italic_N start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT. In [EHR04], the representation Ï‰ğœ”\omegaitalic_Ï‰ is a non-trivial representation chosen so that |ğ”¼â¢[Ï‡Ï‰â¢((Av)Ï†â¢(ğš)â¢Buâ¢(ğ›s1)s1â¢Buâ¢((ğ›âˆ’1â¢(ğšâˆ˜Ï€)âˆ’1â¢ğ‚)s2)s2)]|â‰¥dimÏ‰Î´.ğ”¼delimited-[]subscriptğœ’ğœ”subscriptsubscriptğ´ğ‘£ğœ‘ğšsubscriptğµğ‘¢superscriptsuperscriptğ›subscriptğ‘ 1subscriptğ‘ 1subscriptğµğ‘¢superscriptsuperscriptsuperscriptğ›1superscriptğšğœ‹1ğ‚subscriptğ‘ 2subscriptğ‘ 2subscriptdimensionğœ”ğ›¿\left|\mathbb{E}\left[\chi_{\omega}\left((A_{v})_{\varphi}({\mathbf{a}})B_{u}(% {\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi)^{-% 1}\bm{\nu})^{s_{2}})^{s_{2}}\right)\right]\right|\geq\dim_{\omega}\delta.| blackboard_E [ italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT ( ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) ] | â‰¥ roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ . Here the expectation is taken over the probability space described in Figure 1, and the dependence of Ï€ğœ‹\piitalic_Ï€ on the edge {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v } is left implicit. In our case, rather than using the Fourier characters for choosing Ï‰ğœ”\omegaitalic_Ï‰, we consider â€œpenalized charactersâ€ Ï‡Ï‰~~subscriptğœ’ğœ”\widetilde{\chi_{\omega}}over~ start_ARG italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT end_ARG. We define Ï‡Ï‰~:ğ’¢2â†’â„‚:~subscriptğœ’ğœ”â†’subscriptğ’¢2â„‚\widetilde{\chi_{\omega}}:\mathscr{G}_{2}\rightarrow\mathbb{C}over~ start_ARG italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT end_ARG : script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT â†’ blackboard_C as the map Ï‡Ï‰âˆ’Î·Ï‰subscriptğœ’ğœ”subscriptğœ‚ğœ”\chi_{\omega}-\eta_{\omega}italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT - italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT, where the penalty Î·Ï‰subscriptğœ‚ğœ”\eta_{\omega}italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT is the multiplicity of the trivial representation in the restriction Ï‰|â„‹2evaluated-atğœ”subscriptâ„‹2\omega|_{\mathscr{H}_{2}}italic_Ï‰ | start_POSTSUBSCRIPT script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT. This way, we pick Ï‰âˆˆğ’¢2^ğœ”^subscriptğ’¢2\omega\in\widehat{\mathscr{G}_{2}}italic_Ï‰ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG so that the previous inequality holds after replacing Ï‡Ï‰subscriptğœ’ğœ”\chi_{\omega}italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT with Ï‡Ï‰~~subscriptğœ’ğœ”\widetilde{\chi_{\omega}}over~ start_ARG italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT end_ARG. Equivalently, we find Ï‰ğœ”\omegaitalic_Ï‰ satisfying |ğ”¼â¢[Ï‡Ï‰â¢((Av)Ï†â¢(ğš)â¢Buâ¢(ğ›s1)s1â¢Buâ¢((ğ›âˆ’1â¢(ğšâˆ˜Ï€)âˆ’1â¢ğ‚)s2)s2)]|â‰¥dimÏ‰Î´+Î·Ï‰.ğ”¼delimited-[]subscriptğœ’ğœ”subscriptsubscriptğ´ğ‘£ğœ‘ğšsubscriptğµğ‘¢superscriptsuperscriptğ›subscriptğ‘ 1subscriptğ‘ 1subscriptğµğ‘¢superscriptsuperscriptsuperscriptğ›1superscriptğšğœ‹1ğ‚subscriptğ‘ 2subscriptğ‘ 2subscriptdimensionğœ”ğ›¿subscriptğœ‚ğœ”\left|\mathbb{E}\left[\chi_{\omega}\left((A_{v})_{\varphi}({\mathbf{a}})B_{u}(% {\mathbf{b}}^{s_{1}})^{s_{1}}B_{u}(({\mathbf{b}}^{-1}({\mathbf{a}}\circ\pi)^{-% 1}\bm{\nu})^{s_{2}})^{s_{2}}\right)\right]\right|\geq\dim_{\omega}\delta+\eta_% {\omega}.| blackboard_E [ italic_Ï‡ start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT ( ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT ( bold_a ) italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( ( bold_b start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) ] | â‰¥ roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ + italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT . (5) The fact that such Ï‰ğœ”\omegaitalic_Ï‰ exists is a consequence of (4) together with âˆ‘Ï‰âˆˆğ’¢2^dimÏ‰Î·Ï‰=|ğ’¢2|/|â„‹2|subscriptğœ”^subscriptğ’¢2subscriptdimensionğœ”subscriptğœ‚ğœ”subscriptğ’¢2subscriptâ„‹2\sum_{\omega\in\widehat{\mathscr{G}_{2}}}\dim_{\omega}\eta_{\omega}=|\mathscr{% G}_{2}|/|\mathscr{H}_{2}|âˆ‘ start_POSTSUBSCRIPT italic_Ï‰ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_ARG end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT = | script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | / | script_H start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT |, which follows from the Frobenius Reciprocity Theorem, as shown in Lemma 2.11. This additional factor of Î·Ï‰subscriptğœ‚ğœ”\eta_{\omega}italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT is crucial to our soundness analysis, as we will see. Define the map ğ’œ=Ï‰âˆ˜(Av)Ï†ğ’œğœ”subscriptsubscriptğ´ğ‘£ğœ‘\mathcal{A}=\omega\circ(A_{v})_{\varphi}caligraphic_A = italic_Ï‰ âˆ˜ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT and the map â„¬:ğ’¢1Dâ†’ğ’¢2:â„¬â†’superscriptsubscriptğ’¢1ğ·subscriptğ’¢2\mathcal{B}:\mathscr{G}_{1}^{D}\rightarrow\mathscr{G}_{2}caligraphic_B : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT given by â„¬â¢(ğ›)=ğ”¼sâˆˆ{âˆ’1,1}â¢Ï‰âˆ˜Buâ¢(ğ›s)sâ„¬ğ›subscriptğ”¼ğ‘ 11ğœ”subscriptğµğ‘¢superscriptsuperscriptğ›ğ‘ ğ‘ \mathcal{B}({\mathbf{b}})=\mathbb{E}_{s\in\{-1,1\}}\omega\circ B_{u}({\mathbf{% b}}^{s})^{s}caligraphic_B ( bold_b ) = blackboard_E start_POSTSUBSCRIPT italic_s âˆˆ { - 1 , 1 } end_POSTSUBSCRIPT italic_Ï‰ âˆ˜ italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( bold_b start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT, where sâˆˆ{âˆ’1,1}ğ‘ 11s\in\{-1,1\}italic_s âˆˆ { - 1 , 1 } is distributed uniformly.555Observe that the maps ğ’œğ’œ\mathcal{A}caligraphic_A and â„¬â„¬\mathcal{B}caligraphic_B depend on the hidden parameters vğ‘£vitalic_v and uğ‘¢uitalic_u respectively. To show the soundness bound we consider the Fourier expansions of ğ’œğ’œ\mathcal{A}caligraphic_A and â„¬âˆ—â„¬â„¬â„¬\mathcal{B}*\mathcal{B}caligraphic_B âˆ— caligraphic_B in the expression |trâ¢ğ”¼â¢[ğ’œâ¢(ğš)â¢(â„¬âˆ—â„¬)â¢((ğšâˆ˜Ï€)âˆ’1â¢ğ‚)]|,trğ”¼delimited-[]ğ’œğšâ„¬â„¬superscriptğšğœ‹1ğ‚\left|\mathrm{tr}\,\mathbb{E}\left[\mathcal{A}({\mathbf{a}})(\mathcal{B}*% \mathcal{B})(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right]\right|,| roman_tr blackboard_E [ caligraphic_A ( bold_a ) ( caligraphic_B âˆ— caligraphic_B ) ( ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) ] | , which is just a rearrangement of the left-hand-side in the previous inequality. More precisely, we look at the equivalent expression |trâ¢ğ”¼â¢[(âˆ‘Ï„âˆˆğ’¢E^,s,tâˆˆNÏ„dimÏ„ğ’œ^â¢(Ï„s,t)â¢Ï„s,tâ¢(ğš))â¢(âˆ‘Ïâˆˆğ’¢D^,i,jâˆˆNÏdimÏ(â„¬âˆ—â„¬)^â¢(Ïi,j)â¢Ïi,jâ¢((ğšâˆ˜Ï€)âˆ’1â¢ğ‚))]|.trğ”¼delimited-[]subscriptformulae-sequenceğœ^superscriptğ’¢ğ¸ğ‘ ğ‘¡subscriptğ‘ğœsubscriptdimensionğœ^ğ’œsubscriptğœğ‘ ğ‘¡subscriptğœğ‘ ğ‘¡ğšsubscriptformulae-sequenceğœŒ^superscriptğ’¢ğ·ğ‘–ğ‘—subscriptğ‘ğœŒsubscriptdimensionğœŒ^â„¬â„¬subscriptğœŒğ‘–ğ‘—subscriptğœŒğ‘–ğ‘—superscriptğšğœ‹1ğ‚\left|\mathrm{tr}\,\mathbb{E}\left[\left(\sum_{\tau\in\widehat{\mathscr{G}^{E}% },s,t\in N_{\tau}}\dim_{\tau}\widehat{\mathcal{A}}(\tau_{s,t})\tau_{s,t}({% \mathbf{a}})\right)\left(\sum_{\rho\in\widehat{\mathscr{G}^{D}},i,j\in N_{\rho% }}\dim_{\rho}\widehat{(\mathcal{B}*\mathcal{B})}(\rho_{i,j})\rho_{i,j}(({% \mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right)\right]\right|.| roman_tr blackboard_E [ ( âˆ‘ start_POSTSUBSCRIPT italic_Ï„ âˆˆ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT over^ start_ARG caligraphic_A end_ARG ( italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ( bold_a ) ) ( âˆ‘ start_POSTSUBSCRIPT italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B âˆ— caligraphic_B ) end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) ) ] | . (6) Our goal is to find a bound Îºğœ…\kappaitalic_Îº, independent of |D|,|E|ğ·ğ¸|D|,|E|| italic_D | , | italic_E |, satisfying that the contribution to this expression of non-trivial representations Ï„,ÏğœğœŒ\tau,\rhoitalic_Ï„ , italic_Ï of degree less than Îºğœ…\kappaitalic_Îº is at least dimÏ‰Î´/2subscriptdimensionğœ”ğ›¿2\dim_{\omega}\delta/2roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ / 2. This is achieved by controlling the contribution of the trivial term and the contribution of high-degree terms, as indicated by Lemma 3.1 and Lemma 3.2 respectively. The second main difference of our soundness analysis compared to [EHR04] is our handling of the trivial term. In Lemma 3.1 we prove that |trâ¢ğ”¼â¢[ğ’œ^â¢(1)â¢(âˆ‘Ïâˆˆğ’¢D^,s,tâˆˆNÏdimÏ(â„¬âˆ—â„¬)^â¢(Ïi,j)â¢Ïi,jâ¢((ğšâˆ˜Ï€)âˆ’1â¢ğ‚))]|â‰¤Î·Ï‰.trğ”¼delimited-[]^ğ’œ1subscriptformulae-sequenceğœŒ^superscriptğ’¢ğ·ğ‘ ğ‘¡subscriptğ‘ğœŒsubscriptdimensionğœŒ^â„¬â„¬subscriptğœŒğ‘–ğ‘—subscriptğœŒğ‘–ğ‘—superscriptğšğœ‹1ğ‚subscriptğœ‚ğœ”\left|\mathrm{tr}\,\mathbb{E}\left[\widehat{\mathcal{A}}(1)\left(\sum_{\rho\in% \widehat{\mathscr{G}^{D}},s,t\in N_{\rho}}\dim_{\rho}\widehat{(\mathcal{B}*% \mathcal{B})}(\rho_{i,j})\rho_{i,j}(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right% )\right]\right|\leq\eta_{\omega}.| roman_tr blackboard_E [ over^ start_ARG caligraphic_A end_ARG ( 1 ) ( âˆ‘ start_POSTSUBSCRIPT italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B âˆ— caligraphic_B ) end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) ) ] | â‰¤ italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT . In the non-promise setting, this bound is not necessary. Roughly, under the stronger notion of folding used in [EHR04], it is possible to show that ğ’œ^â¢(1)^ğ’œ1\widehat{\mathcal{A}}(1)over^ start_ARG caligraphic_A end_ARG ( 1 ) vanishes. Our weaker notion of folding does not allow us to prove the same result, but we are still able to leverage folding to obtain the above bound. This mismatch with [EHR04] is the reason why the extra Î·Ï‰subscriptğœ‚ğœ”\eta_{\omega}italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT term was required in (5). The key insight in the proof of Lemma 3.1 is that if F:ğ’¢1Eâ†’ğ’¢2:ğ¹â†’superscriptsubscriptğ’¢1ğ¸subscriptğ’¢2F:\mathscr{G}_{1}^{E}\rightarrow\mathscr{G}_{2}italic_F : script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT â†’ script_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT is folded over Ï†ğœ‘\varphiitalic_Ï†, then the trace of (Ï‰âˆ˜F)^â¢(1)^ğœ”ğ¹1\widehat{(\omega\circ F)}(1)over^ start_ARG ( italic_Ï‰ âˆ˜ italic_F ) end_ARG ( 1 ) is at most Î·Ï‰subscriptğœ‚ğœ”\eta_{\omega}italic_Î· start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT in absolute value. Our analysis of high-degree terms is in the same spirit as previous works that show hardness of approximation in the imperfect completeness setting. In Lemma 3.2 we prove that |trğ”¼[(âˆ‘Ï„âˆˆğ’¢1E^,Ï„â‰ 1âˆ‘s,tâˆˆNÏ„dimÏ„ğ’œ^(Ï„s,t)Ï„s,t(ğš))Ã—\displaystyle\left|\mathrm{tr}\,\mathbb{E}\left[\left(\sum_{\tau\in\widehat{% \mathscr{G}_{1}^{E}},\tau\neq 1}\sum_{s,t\in N_{\tau}}\dim_{\tau}\widehat{% \mathcal{A}}(\tau_{s,t})\tau_{s,t}({\mathbf{a}})\right)\times\right.\right.| roman_tr blackboard_E [ ( âˆ‘ start_POSTSUBSCRIPT italic_Ï„ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_Ï„ â‰  1 end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT over^ start_ARG caligraphic_A end_ARG ( italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ( bold_a ) ) Ã— (âˆ‘Ïâˆˆğ’¢1D^,|Ï|â‰¥Îºâˆ‘i,jâˆˆNÏdimÏ(â„¬âˆ—â„¬)^(Ïi,j)Ïi,j((ğšâˆ˜Ï€)âˆ’1ğ‚))]|â‰¤(dimÏ‰Î´)/2\displaystyle\left.\left.\left(\sum_{\rho\in\widehat{\mathscr{G}_{1}^{D}},|% \rho|\geq\kappa}\sum_{i,j\in N_{\rho}}\dim_{\rho}\widehat{(\mathcal{B}*% \mathcal{B})}(\rho_{i,j})\rho_{i,j}(({\mathbf{a}}\circ\pi)^{-1}\bm{\nu})\right% )\right]\right|\leq(\dim_{\omega}\delta)/2( âˆ‘ start_POSTSUBSCRIPT italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , | italic_Ï | â‰¥ italic_Îº end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT over^ start_ARG ( caligraphic_B âˆ— caligraphic_B ) end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ( ( bold_a âˆ˜ italic_Ï€ ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT bold_italic_Î½ ) ) ] | â‰¤ ( roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ ) / 2 for all Îºâ‰¥(log2â¡Î´âˆ’2)/log2â¡(1âˆ’Ïµ)ğœ…subscript2ğ›¿2subscript21italic-Ïµ\kappa\geq(\log_{2}\delta-2)/\log_{2}(1-\epsilon)italic_Îº â‰¥ ( roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_Î´ - 2 ) / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( 1 - italic_Ïµ ). The essential idea is that the â€œnoise vectorâ€ ğ‚ğ‚\bm{\nu}bold_italic_Î½ has a smoothing effect that limits the contribution of high-degree terms in (6). Finally, having established that the contribution of non-trivial terms of degree less than Îºğœ…\kappaitalic_Îº in (6) is at least dimÏ‰Î´/2subscriptdimensionğœ”ğ›¿2\dim_{\omega}\delta/2roman_dim start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT italic_Î´ / 2, in Lemma 3.3 we give a good randomised strategy to solve Î£Î£\Sigmaroman_Î£. This strategy assigns the label eâˆˆEğ‘’ğ¸e\in Eitalic_e âˆˆ italic_E to vâˆˆVğ‘£ğ‘‰v\in Vitalic_v âˆˆ italic_V and the label dâˆˆDğ‘‘ğ·d\in Ditalic_d âˆˆ italic_D to uâˆˆUğ‘¢ğ‘ˆu\in Uitalic_u âˆˆ italic_U with probabilities Prâ¡(vâ†¦e)=âˆ‘Ï„âˆˆğ’¢1E^,Ï„eâ‰ 1âˆ‘s,tâˆˆNÏ„dimÏ„|ğ’œx,y^â¢(Ï„s,t)|2|Ï„|Prmaps-toğ‘£ğ‘’subscriptformulae-sequenceğœ^superscriptsubscriptğ’¢1ğ¸superscriptğœğ‘’1subscriptğ‘ ğ‘¡subscriptğ‘ğœsubscriptdimensionğœsuperscript^subscriptğ’œğ‘¥ğ‘¦subscriptğœğ‘ ğ‘¡2ğœ\Pr(v\mapsto e)\ =\sum_{\tau\in\widehat{\mathscr{G}_{1}^{E}},\tau^{e}\neq 1}% \sum_{s,t\in N_{\tau}}\dim_{\tau}\frac{\left|\widehat{\mathcal{A}_{x,y}}(\tau_% {s,t})\right|^{2}}{|\tau|}roman_Pr ( italic_v â†¦ italic_e ) = âˆ‘ start_POSTSUBSCRIPT italic_Ï„ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_Ï„ start_POSTSUPERSCRIPT italic_e end_POSTSUPERSCRIPT â‰  1 end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT divide start_ARG | over^ start_ARG caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT end_ARG ( italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_Ï„ | end_ARG and Prâ¡(uâ†¦d)=âˆ‘Ïâˆˆğ’¢1D^,Ïdâ‰ 1âˆ‘i,jâˆˆNÏdimÏ|â„¬y,z^â¢(Ïi,j)|2|Ï|,Prmaps-toğ‘¢ğ‘‘subscriptformulae-sequenceğœŒ^superscriptsubscriptğ’¢1ğ·superscriptğœŒğ‘‘1subscriptğ‘–ğ‘—subscriptğ‘ğœŒsubscriptdimensionğœŒsuperscript^subscriptâ„¬ğ‘¦ğ‘§subscriptğœŒğ‘–ğ‘—2ğœŒ\Pr(u\mapsto d)\ =\sum_{\rho\in\widehat{\mathscr{G}_{1}^{D}},\rho^{d}\neq 1}% \sum_{i,j\in N_{\rho}}\dim_{\rho}\frac{\left|\widehat{\mathcal{B}_{y,z}}(\rho_% {i,j})\right|^{2}}{|\rho|},roman_Pr ( italic_u â†¦ italic_d ) = âˆ‘ start_POSTSUBSCRIPT italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT â‰  1 end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_POSTSUBSCRIPT roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT divide start_ARG | over^ start_ARG caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_Ï | end_ARG , where x,y,zâˆˆNÏ‰ğ‘¥ğ‘¦ğ‘§subscriptğ‘ğœ”x,y,z\in N_{\omega}italic_x , italic_y , italic_z âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï‰ end_POSTSUBSCRIPT are suitable indices found in Lemma 3.3. These probabilities are supposed to capture the influence of the eğ‘’eitalic_e-th and dğ‘‘ditalic_d-th coordinates on ğ’œx,y=Ï‰x,yâˆ˜(Av)Ï†subscriptğ’œğ‘¥ğ‘¦subscriptğœ”ğ‘¥ğ‘¦subscriptsubscriptğ´ğ‘£ğœ‘\mathcal{A}_{x,y}=\omega_{x,y}\circ(A_{v})_{\varphi}caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT = italic_Ï‰ start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT âˆ˜ ( italic_A start_POSTSUBSCRIPT italic_v end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_Ï† end_POSTSUBSCRIPT and â„¬y,z=Ï‰y,zâˆ˜ğ”¼sâ¢Buâ¢(â‹…s)ssubscriptâ„¬ğ‘¦ğ‘§subscriptğœ”ğ‘¦ğ‘§subscriptğ”¼ğ‘ subscriptğµğ‘¢superscriptsuperscriptâ‹…ğ‘ ğ‘ \mathcal{B}_{y,z}=\omega_{y,z}\circ\mathbb{E}_{s}B_{u}(\ \cdot^{s})^{s}caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT = italic_Ï‰ start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT âˆ˜ blackboard_E start_POSTSUBSCRIPT italic_s end_POSTSUBSCRIPT italic_B start_POSTSUBSCRIPT italic_u end_POSTSUBSCRIPT ( â‹… start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT respectively (compare with the notion of influence in [BK21, AM09]). This turns out to be a good randomised assignment for Î£Î£\Sigmaroman_Î£. That is, ğ”¼uâ¢vâ¢[âˆ‘dâˆˆDPrâ¡(vâ†¦Ï€uâ¢vâ¢(d))â¢Prâ¡(uâ†¦d)]â‰¥Î±,subscriptğ”¼ğ‘¢ğ‘£delimited-[]subscriptğ‘‘ğ·Prmaps-toğ‘£subscriptğœ‹ğ‘¢ğ‘£ğ‘‘Prmaps-toğ‘¢ğ‘‘ğ›¼\mathbb{E}_{uv}\left[\sum_{d\in D}\Pr(v\mapsto\pi_{uv}(d))\Pr(u\mapsto d)% \right]\geq\alpha,blackboard_E start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT [ âˆ‘ start_POSTSUBSCRIPT italic_d âˆˆ italic_D end_POSTSUBSCRIPT roman_Pr ( italic_v â†¦ italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_d ) ) roman_Pr ( italic_u â†¦ italic_d ) ] â‰¥ italic_Î± , (7) where the expectation is taken uniformly over the edges {u,v}ğ‘¢ğ‘£\{u,v\}{ italic_u , italic_v } of Î£Î£\Sigmaroman_Î£, and Î±ğ›¼\alphaitalic_Î± is the soundness constant appearing in Theorem 1.7. We are being informal with the usage of the word â€œprobabilityâ€ here: the quantities Prâ¡(vâ†¦e)Prmaps-toğ‘£ğ‘’\Pr(v\mapsto e)roman_Pr ( italic_v â†¦ italic_e ) and Prâ¡(uâ†¦d)Prmaps-toğ‘¢ğ‘‘\Pr(u\mapsto d)roman_Pr ( italic_u â†¦ italic_d ) may add up to less than 1111, but this is easily fixed by normalising, or by letting our strategy default to the uniform assignment with some positive probability. Let us give some more detail. More precisely, Lemma 3.3 shows that truncating our assignment probabilities to terms of degree less than Îºğœ…\kappaitalic_Îº is enough to satisfy this last inequality. Let â„“â‰¥0â„“0\ell\geq 0roman_â„“ â‰¥ 0. The probabilities Pr<â„“â¡(vâ†¦e)superscriptPrabsentâ„“maps-toğ‘£ğ‘’\Pr^{<\ell}(v\mapsto e)roman_Pr start_POSTSUPERSCRIPT < roman_â„“ end_POSTSUPERSCRIPT ( italic_v â†¦ italic_e ), Pr<â„“â¡(uâ†¦d)superscriptPrabsentâ„“maps-toğ‘¢ğ‘‘\Pr^{<\ell}(u\mapsto d)roman_Pr start_POSTSUPERSCRIPT < roman_â„“ end_POSTSUPERSCRIPT ( italic_u â†¦ italic_d ) are defined the same way as Prâ¡(vâ†¦e)Prmaps-toğ‘£ğ‘’\Pr(v\mapsto e)roman_Pr ( italic_v â†¦ italic_e ) and Prâ¡(uâ†¦d)Prmaps-toğ‘¢ğ‘‘\Pr(u\mapsto d)roman_Pr ( italic_u â†¦ italic_d ) but considering only representations Ï„,ÏğœğœŒ\tau,\rhoitalic_Ï„ , italic_Ï of degree less than â„“â„“\ellroman_â„“. These modified probabilities can be understood as the â€œlow-degree influencesâ€ of each coordinate in ğ’œx,ysubscriptğ’œğ‘¥ğ‘¦\mathcal{A}_{x,y}caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT and â„¬y,zsubscriptâ„¬ğ‘¦ğ‘§\mathcal{B}_{y,z}caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT. With this notation, in Lemma 3.3 we prove that (7) holds after replacing each assignment probability PrPr\Prroman_Pr with its truncated variant Pr<ÎºsuperscriptPrabsentğœ…\Pr^{<\kappa}roman_Pr start_POSTSUPERSCRIPT < italic_Îº end_POSTSUPERSCRIPT. In other words, we prove that ğ”¼uâ¢vâ¢[âˆ‘dâˆˆDâˆ‘Ïâˆˆğ’¢1D^,Ïdâ‰ 1|Ï|<Îº,i,jâˆˆNÏâˆ‘Ï„âˆˆğ’¢1E^,Ï„Ï€uâ¢vâ¢(d)â‰ 1|Ï„|<Îº,s,tâˆˆNÏ„dimÏ„|ğ’œx,y^â¢(Ï„s,t)|2|Ï„|â¢dimÏ|â„¬y,z^â¢(Ïi,j)|2|Ï|]â‰¥Î±.subscriptğ”¼ğ‘¢ğ‘£delimited-[]subscriptğ‘‘ğ·subscriptformulae-sequenceğœŒ^superscriptsubscriptğ’¢1ğ·superscriptğœŒğ‘‘1formulae-sequenceğœŒğœ…ğ‘–ğ‘—subscriptğ‘ğœŒsubscriptformulae-sequenceğœ^superscriptsubscriptğ’¢1ğ¸superscriptğœsubscriptğœ‹ğ‘¢ğ‘£ğ‘‘1formulae-sequenceğœğœ…ğ‘ ğ‘¡subscriptğ‘ğœsubscriptdimensionğœsuperscript^subscriptğ’œğ‘¥ğ‘¦subscriptğœğ‘ ğ‘¡2ğœsubscriptdimensionğœŒsuperscript^subscriptâ„¬ğ‘¦ğ‘§subscriptğœŒğ‘–ğ‘—2ğœŒğ›¼\mathbb{E}_{uv}\left[\sum_{d\in D}\sum_{\begin{subarray}{c}\rho\in\widehat{% \mathscr{G}_{1}^{D}},\rho^{d}\neq 1\\ |\rho|<\kappa,\,i,j\in N_{\rho}\end{subarray}}\sum_{\begin{subarray}{c}\tau\in% \widehat{\mathscr{G}_{1}^{E}},\tau^{\pi_{uv}(d)}\neq 1\\ |\tau|<\kappa,\,s,t\in N_{\tau}\end{subarray}}\frac{\dim_{\tau}\left|\widehat{% \mathcal{A}_{x,y}}(\tau_{s,t})\right|^{2}}{|\tau|}\frac{\dim_{\rho}\left|% \widehat{\mathcal{B}_{y,z}}(\rho_{i,j})\right|^{2}}{|\rho|}\right]\geq\alpha.blackboard_E start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT [ âˆ‘ start_POSTSUBSCRIPT italic_d âˆˆ italic_D end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_Ï âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_D end_POSTSUPERSCRIPT end_ARG , italic_Ï start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT â‰  1 end_CELL end_ROW start_ROW start_CELL | italic_Ï | < italic_Îº , italic_i , italic_j âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT âˆ‘ start_POSTSUBSCRIPT start_ARG start_ROW start_CELL italic_Ï„ âˆˆ over^ start_ARG script_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_E end_POSTSUPERSCRIPT end_ARG , italic_Ï„ start_POSTSUPERSCRIPT italic_Ï€ start_POSTSUBSCRIPT italic_u italic_v end_POSTSUBSCRIPT ( italic_d ) end_POSTSUPERSCRIPT â‰  1 end_CELL end_ROW start_ROW start_CELL | italic_Ï„ | < italic_Îº , italic_s , italic_t âˆˆ italic_N start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT end_CELL end_ROW end_ARG end_POSTSUBSCRIPT divide start_ARG roman_dim start_POSTSUBSCRIPT italic_Ï„ end_POSTSUBSCRIPT | over^ start_ARG caligraphic_A start_POSTSUBSCRIPT italic_x , italic_y end_POSTSUBSCRIPT end_ARG ( italic_Ï„ start_POSTSUBSCRIPT italic_s , italic_t end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_Ï„ | end_ARG divide start_ARG roman_dim start_POSTSUBSCRIPT italic_Ï end_POSTSUBSCRIPT | over^ start_ARG caligraphic_B start_POSTSUBSCRIPT italic_y , italic_z end_POSTSUBSCRIPT end_ARG ( italic_Ï start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT ) | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_ARG start_ARG | italic_Ï | end_ARG ] â‰¥ italic_Î± . This shows that our proposed strategy produces a good randomised assignment for Î£Î£\Sigmaroman_Î£ and completes the soundness proof."
https://arxiv.org/html/2411.01591v1,What Dosinâ¡(x)ğ‘¥\sin(x)roman_sin ( italic_x )andarcsinhâ¡(x)arcsinhğ‘¥\operatorname{arcsinh}(x)roman_arcsinh ( italic_x )Have in Common?,"N. G. de Bruijn (1958) studied the asymptotic expansion of iterates of sinâ¡(x)ğ‘¥\sin(x)roman_sin ( italic_x ) with 0<xâ‰¤Ï€/20ğ‘¥ğœ‹20<x\leq\pi/20 < italic_x â‰¤ italic_Ï€ / 2. Bencherif & Robin (1994) generalized this result to increasing analytic functions fâ¢(x)ğ‘“ğ‘¥f(x)italic_f ( italic_x ) with an attractive fixed point at 00 and x>0ğ‘¥0x>0italic_x > 0 suitably small. Mavecha & Laohakosol (2013) formulated an algorithm for explicitly deriving required parameters. We review their method, testing it initally on the logistic function â„“â¢(x)â„“ğ‘¥\ell(x)roman_â„“ ( italic_x ), a certain radical function râ¢(x)ğ‘Ÿğ‘¥r(x)italic_r ( italic_x ), and later on several transcendental functions. Along the way, we show how â„“â¢(x)â„“ğ‘¥\ell(x)roman_â„“ ( italic_x ) and râ¢(x)ğ‘Ÿğ‘¥r(x)italic_r ( italic_x ) are kindred functions; the same is also true for sinâ¡(x)ğ‘¥\sin(x)roman_sin ( italic_x ) and arcsinhâ¡(x)arcsinhğ‘¥\operatorname{arcsinh}(x)roman_arcsinh ( italic_x ).","1 Basics Consider an analytic function fâ¢(x)ğ‘“ğ‘¥f(x)italic_f ( italic_x ) whose Taylor series at the origin starts as x+âˆ‘m=17amâ¢xmâ¢Ï„+1ğ‘¥superscriptsubscriptğ‘š17subscriptğ‘ğ‘šsuperscriptğ‘¥ğ‘šğœ1x+{\displaystyle\sum\limits_{m=1}^{7}}a_{m}x^{m\,\tau+1}italic_x + âˆ‘ start_POSTSUBSCRIPT italic_m = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 7 end_POSTSUPERSCRIPT italic_a start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT italic_x start_POSTSUPERSCRIPT italic_m italic_Ï„ + 1 end_POSTSUPERSCRIPT where a1<0subscriptğ‘10a_{1}<0italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT < 0 and Ï„â‰¥1ğœ1\tau\geq 1italic_Ï„ â‰¥ 1 is an integer. We choose the upper limit 7777 for the sake of concreteness (the variable kğ‘˜kitalic_k is employed in [6] and leads to some confusion). Note that fâ¢(0)=0ğ‘“00f(0)=0italic_f ( 0 ) = 0 and zeroes of both fğ‘“fitalic_f & fâˆ’idğ‘“idf-\operatorname{id}italic_f - roman_id are isolated, i.e., there is an Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 such that both fâ¢(x)â‰ 0ğ‘“ğ‘¥0f(x)\neq 0italic_f ( italic_x ) â‰  0 & fâ¢(x)â‰ xğ‘“ğ‘¥ğ‘¥f(x)\neq xitalic_f ( italic_x ) â‰  italic_x for all 0<x<Îµ0ğ‘¥ğœ€0<x<\varepsilon0 < italic_x < italic_Îµ. Further, because limxâ†’0+fâ¢(x)x=1>0&limxâ†’0+fâ¢(x)âˆ’xxÏ„+1=a1<0,subscriptâ†’ğ‘¥superscript0ğ‘“ğ‘¥ğ‘¥10missing-subexpression&missing-subexpressionsubscriptâ†’ğ‘¥superscript0ğ‘“ğ‘¥ğ‘¥superscriptğ‘¥ğœ1subscriptğ‘10\begin{array}[c]{ccccc}\lim\limits_{x\rightarrow 0^{+}}\dfrac{f(x)}{x}=1>0&&% \text{\&}&&\lim\limits_{x\rightarrow 0^{+}}\dfrac{f(x)-x}{x^{\tau+1}}=a_{1}<0,% \end{array}start_ARRAY start_ROW start_CELL roman_lim start_POSTSUBSCRIPT italic_x â†’ 0 start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT end_POSTSUBSCRIPT divide start_ARG italic_f ( italic_x ) end_ARG start_ARG italic_x end_ARG = 1 > 0 end_CELL start_CELL end_CELL start_CELL & end_CELL start_CELL end_CELL start_CELL roman_lim start_POSTSUBSCRIPT italic_x â†’ 0 start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT end_POSTSUBSCRIPT divide start_ARG italic_f ( italic_x ) - italic_x end_ARG start_ARG italic_x start_POSTSUPERSCRIPT italic_Ï„ + 1 end_POSTSUPERSCRIPT end_ARG = italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT < 0 , end_CELL end_ROW end_ARRAY we see in fact that 0<fâ¢(x)<x0ğ‘“ğ‘¥ğ‘¥0<f(x)<x0 < italic_f ( italic_x ) < italic_x for all 0<x<Îµ0ğ‘¥ğœ€0<x<\varepsilon0 < italic_x < italic_Îµ. Given an initial value 0<x0<Îµ0subscriptğ‘¥0ğœ€0<x_{0}<\varepsilon0 < italic_x start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT < italic_Îµ, define a sequence xn=fâ¢(xnâˆ’1)subscriptğ‘¥ğ‘›ğ‘“subscriptğ‘¥ğ‘›1x_{n}=f(x_{n-1})italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT = italic_f ( italic_x start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT ) for nâ‰¥1ğ‘›1n\geq 1italic_n â‰¥ 1. We clearly have 0<xn<xnâˆ’10subscriptğ‘¥ğ‘›subscriptğ‘¥ğ‘›10<x_{n}<x_{n-1}0 < italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT < italic_x start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT and thus {xn}subscriptğ‘¥ğ‘›\{x_{n}\}{ italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT } is monotone decreasing & bounded from below. It follows that L=limnâ†’âˆxnğ¿subscriptâ†’ğ‘›subscriptğ‘¥ğ‘›L=\lim_{n\rightarrow\infty}x_{n}italic_L = roman_lim start_POSTSUBSCRIPT italic_n â†’ âˆ end_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT exists and 0â‰¤L<Îµ0ğ¿ğœ€0\leq L<\varepsilon0 â‰¤ italic_L < italic_Îµ. Suppose that L>0ğ¿0L>0italic_L > 0. By definition of xnsubscriptğ‘¥ğ‘›x_{n}italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT, we must have L=fâ¢(L)ğ¿ğ‘“ğ¿L=f(L)italic_L = italic_f ( italic_L ), which contradicts fâ¢(L)â‰ Lğ‘“ğ¿ğ¿f(L)\neq Litalic_f ( italic_L ) â‰  italic_L. Therefore L=0ğ¿0L=0italic_L = 0. Let (âˆ’t)k=(âˆ’t)â¢(âˆ’tâˆ’1)â¢(âˆ’tâˆ’2)â¢â‹¯â¢(âˆ’tâˆ’k+1)subscriptğ‘¡ğ‘˜ğ‘¡ğ‘¡1ğ‘¡2â‹¯ğ‘¡ğ‘˜1(-t)_{k}=(-t)(-t-1)(-t-2)\cdots(-t-k+1)( - italic_t ) start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT = ( - italic_t ) ( - italic_t - 1 ) ( - italic_t - 2 ) â‹¯ ( - italic_t - italic_k + 1 ) for any integer kâ‰¥1ğ‘˜1k\geq 1italic_k â‰¥ 1 and define âˆ‘(k,m,s)subscriptğ‘˜ğ‘šğ‘ {\textstyle\sum\nolimits_{(k,m,s)}}âˆ‘ start_POSTSUBSCRIPT ( italic_k , italic_m , italic_s ) end_POSTSUBSCRIPT to be the sum over all nonnegative integers n1,n2,â€¦,nksubscriptğ‘›1subscriptğ‘›2â€¦subscriptğ‘›ğ‘˜n_{1},n_{2},\ldots,n_{k}italic_n start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_n start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , â€¦ , italic_n start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT such that n1+2â¢n2+3â¢n3+â‹¯+kâ¢nk=mandn1+n2+n3+â‹¯+nk=mâˆ’s.subscriptğ‘›12subscriptğ‘›23subscriptğ‘›3â‹¯ğ‘˜subscriptğ‘›ğ‘˜ğ‘šmissing-subexpressionandmissing-subexpressionsubscriptğ‘›1subscriptğ‘›2subscriptğ‘›3â‹¯subscriptğ‘›ğ‘˜ğ‘šğ‘ \begin{array}[c]{ccccc}n_{1}+2n_{2}+3n_{3}+\cdots+k\,n_{k}=m&&\text{and}&&n_{1% }+n_{2}+n_{3}+\cdots+n_{k}=m-s.\end{array}start_ARRAY start_ROW start_CELL italic_n start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + 2 italic_n start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT + 3 italic_n start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT + â‹¯ + italic_k italic_n start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT = italic_m end_CELL start_CELL end_CELL start_CELL and end_CELL start_CELL end_CELL start_CELL italic_n start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + italic_n start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT + italic_n start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT + â‹¯ + italic_n start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT = italic_m - italic_s . end_CELL end_ROW end_ARRAY This notation will be useful in the following section."
https://arxiv.org/html/2411.01486v1,The Gap Between Greedy Algorithm and Minimum Multiplicative Spanner,"Given any undirected graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) with nğ‘›nitalic_n vertices, if its subgraph HâŠ†Gğ»ğºH\subseteq Gitalic_H âŠ† italic_G satisfies ğ–½ğ—‚ğ—Œğ—Hâ¢(u,v)â‰¤kâ‹…ğ–½ğ—‚ğ—Œğ—Gâ¢(u,v)subscriptğ–½ğ—‚ğ—Œğ—ğ»ğ‘¢ğ‘£â‹…ğ‘˜subscriptğ–½ğ—‚ğ—Œğ—ğºğ‘¢ğ‘£\mathsf{dist}_{H}(u,v)\leq k\cdot\mathsf{dist}_{G}(u,v)sansserif_dist start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_u , italic_v ) â‰¤ italic_k â‹… sansserif_dist start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u , italic_v ) for any two vertices (u,v)âˆˆVÃ—Vğ‘¢ğ‘£ğ‘‰ğ‘‰(u,v)\in V\times V( italic_u , italic_v ) âˆˆ italic_V Ã— italic_V, we call Hğ»Hitalic_H a kğ‘˜kitalic_k-spanner of GğºGitalic_G. The greedy algorithm adapted from Kruskalâ€™s algorithm is an efficient and folklore way to produce a kğ‘˜kitalic_k-spanner with girth at least k+2ğ‘˜2k+2italic_k + 2. The greedy algorithm has shown to be â€˜existentially optimalâ€™, while itâ€™s not â€˜universally optimalâ€™ for any constant kğ‘˜kitalic_k. Here, â€˜universal optimalityâ€™ means an algorithm can produce the smallest kğ‘˜kitalic_k-spanner Hğ»Hitalic_H given any nğ‘›nitalic_n-vertex input graph GğºGitalic_G.However, how well the greedy algorithm works compared to â€˜universal optimalityâ€™ is still unclear for superconstant k:=kâ¢(n)assignğ‘˜ğ‘˜ğ‘›k:=k(n)italic_k := italic_k ( italic_n ). In this paper, we aim to give a new and fine-grained analysis of this problem in undirected unweighted graph setting. Specifically, we show some bounds on this problem including the following twoOn the negative side, when k<13â¢nâˆ’Oâ¢(1)ğ‘˜13ğ‘›ğ‘‚1k<\frac{1}{3}n-O(1)italic_k < divide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n - italic_O ( 1 ), the greedy algorithm is not â€˜universally optimalâ€™.On the positive side, when k>23â¢n+Oâ¢(1)ğ‘˜23ğ‘›ğ‘‚1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ), the greedy algorithm is â€˜universally optimalâ€™.We also introduce an appropriate notion for â€˜approximately universal optimalityâ€™. An algorithm is (Î±,Î²)ğ›¼ğ›½(\alpha,\beta)( italic_Î± , italic_Î² )-universally optimal iff given any nğ‘›nitalic_n-vertex input graph GğºGitalic_G, it can produce a kğ‘˜kitalic_k-spanner Hğ»Hitalic_H of GğºGitalic_G with size |H|â‰¤n+Î±â¢(|Hâˆ—|âˆ’n)+Î²ğ»ğ‘›ğ›¼superscriptğ»ğ‘›ğ›½|H|\leq n+\alpha(|H^{*}|-n)+\beta| italic_H | â‰¤ italic_n + italic_Î± ( | italic_H start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT | - italic_n ) + italic_Î², where Hâˆ—superscriptğ»H^{*}italic_H start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT is the smallest kğ‘˜kitalic_k-spanner of GğºGitalic_G. We show the following positive bounds.When k>47â¢n+Oâ¢(1)ğ‘˜47ğ‘›ğ‘‚1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ), the greedy algorithm is (2,Oâ¢(1))2ğ‘‚1(2,O(1))( 2 , italic_O ( 1 ) )-universally optimal.When k>1223â¢n+Oâ¢(1)ğ‘˜1223ğ‘›ğ‘‚1k>\frac{12}{23}n+O(1)italic_k > divide start_ARG 12 end_ARG start_ARG 23 end_ARG italic_n + italic_O ( 1 ), the greedy algorithm is (18,Oâ¢(1))18ğ‘‚1(18,O(1))( 18 , italic_O ( 1 ) )-universally optimal.When k>12â¢n+Oâ¢(1)ğ‘˜12ğ‘›ğ‘‚1k>\frac{1}{2}n+O(1)italic_k > divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_n + italic_O ( 1 ), the greedy algorithm is (32,Oâ¢(1))32ğ‘‚1(32,O(1))( 32 , italic_O ( 1 ) )-universally optimal.All our proofs are constructive building on new structural analysis on spanners. We give some ideas about how to break small cycles in a spanner to increase the girth. These ideas may help us to understand the relation between girth and spanners.","A spanner of a graph is a subgraph that approximately preserves distances between all vertex pairs in the original graph. This notion was introduced by [PS89] and widely used in many areas such as graph algorithms [CKL+22, DJWW22], distributed networks [Awe85, BCLR86] and chip design [CKR+91, CKR+92]. In most applications, people aim to construct spanners as sparse as possible. The sparsity is measured by the number of edges in the spanner. In this paper, we will focus on multiplicative spanners for undirected unweighted graphs defined below. Unless otherwise stated, all graphs in this paper are undirected unweighted graphs. Definition 1.1. Given k:=kâ¢(n)assignğ‘˜ğ‘˜ğ‘›k:=k(n)italic_k := italic_k ( italic_n ) and an undirected unweighted graph G:=(V,E)assignğºğ‘‰ğ¸G:=(V,E)italic_G := ( italic_V , italic_E ) with nğ‘›nitalic_n vertices, a kğ‘˜kitalic_k-spanner of GğºGitalic_G is a subgraph H=(V,Eâ€²),Eâ€²âŠ†Eformulae-sequenceğ»ğ‘‰superscriptğ¸â€²superscriptğ¸â€²ğ¸H=(V,E^{\prime}),E^{\prime}\subseteq Eitalic_H = ( italic_V , italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) , italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âŠ† italic_E of GğºGitalic_G such that for any vertex pair (u,v)âˆˆVÃ—Vğ‘¢ğ‘£ğ‘‰ğ‘‰(u,v)\in V\times V( italic_u , italic_v ) âˆˆ italic_V Ã— italic_V, there is ğ–½ğ—‚ğ—Œğ—Hâ¢(u,v)â‰¤kâ‹…ğ–½ğ—‚ğ—Œğ—Gâ¢(u,v)subscriptğ–½ğ—‚ğ—Œğ—ğ»ğ‘¢ğ‘£â‹…ğ‘˜subscriptğ–½ğ—‚ğ—Œğ—ğºğ‘¢ğ‘£\mathsf{dist}_{H}(u,v)\leq k\cdot\mathsf{dist}_{G}(u,v)sansserif_dist start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_u , italic_v ) â‰¤ italic_k â‹… sansserif_dist start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u , italic_v ). We call kğ‘˜kitalic_k the stretch of Hğ»Hitalic_H. One of the simplest and most widely-used spanner construction algorithms is the greedy algorithm introduced by [ADD+93]. It is adapted from Kruskalâ€™s algorithm for computing the minimum spanning tree. In undirected unweighted settings, the greedy algorithm runs like this: Given any input graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) and stretch kğ‘˜kitalic_k, we first choose an arbitrary total order Ïƒğœ\sigmaitalic_Ïƒ on its edges, denoted by Ïƒâ¢(E)=(e1<e2<â‹¯<em)ğœğ¸subscriptğ‘’1subscriptğ‘’2â‹¯subscriptğ‘’ğ‘š\sigma(E)=(e_{1}<e_{2}<\dots<e_{m})italic_Ïƒ ( italic_E ) = ( italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT < italic_e start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT < â‹¯ < italic_e start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT ). Then, starting from empty subgraph H=(V,âˆ…)ğ»ğ‘‰H=(V,\varnothing)italic_H = ( italic_V , âˆ… ), we proceed edges {ei}iâˆˆ[m]subscriptsubscriptğ‘’ğ‘–ğ‘–delimited-[]ğ‘š\{e_{i}\}_{i\in[m]}{ italic_e start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_i âˆˆ [ italic_m ] end_POSTSUBSCRIPT one by one. For each edge ei=(u,v)subscriptğ‘’ğ‘–ğ‘¢ğ‘£e_{i}=(u,v)italic_e start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = ( italic_u , italic_v ), if ğ–½ğ—‚ğ—Œğ—Hâ¢(u,v)>ksubscriptğ–½ğ—‚ğ—Œğ—ğ»ğ‘¢ğ‘£ğ‘˜\mathsf{dist}_{H}(u,v)>ksansserif_dist start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_u , italic_v ) > italic_k, we add eisubscriptğ‘’ğ‘–e_{i}italic_e start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT to edgeset of Hğ»Hitalic_H. Otherwise, we do nothing. After checking all mğ‘šmitalic_m edges, we output the latest Hğ»Hitalic_H as the spanner. [ADD+93] proved the following fact about Hğ»Hitalic_H Proposition 1.2. The subgraph Hğ»Hitalic_H outputted by the greedy algorithm with input âŸ¨G,kâŸ©ğºğ‘˜\langle G,k\rangleâŸ¨ italic_G , italic_k âŸ© is a kğ‘˜kitalic_k-spanner of GğºGitalic_G. Moreover, the girth of Hğ»Hitalic_H is at least k+2ğ‘˜2k+2italic_k + 2. Proposition 1.2 shows that for any graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) with nğ‘›nitalic_n vertices and kğ‘˜kitalic_k, we can use the greedy algorithm to compute one of its kğ‘˜kitalic_k-spanners with girth at least k+2ğ‘˜2k+2italic_k + 2. A simple observation is that the backward direction also holds. Concretely, we have the following Proposition 1.3. Given any graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) with nğ‘›nitalic_n vertices, stretch kğ‘˜kitalic_k and any of its kğ‘˜kitalic_k-spanner Hğ»Hitalic_H with girth at least k+2ğ‘˜2k+2italic_k + 2, there exists an edge ordering Ïƒğœ\sigmaitalic_Ïƒ of Eğ¸Eitalic_E such that the greedy algorithm outputs Hğ»Hitalic_H after running on Ïƒğœ\sigmaitalic_Ïƒ, with input âŸ¨G,kâŸ©ğºğ‘˜\langle G,k\rangleâŸ¨ italic_G , italic_k âŸ©. Proof. Let H=(V,Eâ€²âŠ†E)ğ»ğ‘‰superscriptğ¸â€²ğ¸H=(V,E^{\prime}\subseteq E)italic_H = ( italic_V , italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âŠ† italic_E ). Consider the edge ordering Ïƒğœ\sigmaitalic_Ïƒ on Eğ¸Eitalic_E such that all edges in Eâ€²superscriptğ¸â€²E^{\prime}italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT appear earlier in Ïƒğœ\sigmaitalic_Ïƒ than any edge in E\Eâ€²\ğ¸superscriptğ¸â€²E\backslash E^{\prime}italic_E \ italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. Let Hâ€²superscriptğ»â€²H^{\prime}italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT be the spanner outputted by the greedy algorithm running on Ïƒğœ\sigmaitalic_Ïƒ. Since we first proceed with edges in Eâ€²superscriptğ¸â€²E^{\prime}italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, all edges in Eâ€²superscriptğ¸â€²E^{\prime}italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT will be in Hâ€²superscriptğ»â€²H^{\prime}italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT by the girth assumption. For any edge e=(u,v)âˆˆE\Eâ€²ğ‘’ğ‘¢ğ‘£\ğ¸superscriptğ¸â€²e=(u,v)\in E\backslash E^{\prime}italic_e = ( italic_u , italic_v ) âˆˆ italic_E \ italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, since Hğ»Hitalic_H is a kğ‘˜kitalic_k-spanner of GğºGitalic_G, there must be ğ–½ğ—‚ğ—Œğ—Hâ¢(u,v)â‰¤ksubscriptğ–½ğ—‚ğ—Œğ—ğ»ğ‘¢ğ‘£ğ‘˜\mathsf{dist}_{H}(u,v)\leq ksansserif_dist start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_u , italic_v ) â‰¤ italic_k, and therefore eğ‘’eitalic_e wonâ€™t be added in Hâ€²superscriptğ»â€²H^{\prime}italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT after all edges in Eâ€²superscriptğ¸â€²E^{\prime}italic_E start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT have been added. We conclude Hâ€²=Hsuperscriptğ»â€²ğ»H^{\prime}=Hitalic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT = italic_H. âˆ Proposition 1.3 shows that: Given âŸ¨G=(V,E),kâŸ©delimited-âŸ¨âŸ©ğºğ‘‰ğ¸ğ‘˜\langle G=(V,E),k\rangleâŸ¨ italic_G = ( italic_V , italic_E ) , italic_k âŸ©, the set of subgraphs the greedy algorithm can output (by choosing arbitrary edge ordering) is exactly the set of kğ‘˜kitalic_k-spanners with girth at least k+2ğ‘˜2k+2italic_k + 2. By the Moore bound [AHL02], all graphs Hğ»Hitalic_H with girth at least k+2ğ‘˜2k+2italic_k + 2 and nğ‘›nitalic_n vertices have at most m=Oâ¢(n1+2/k)ğ‘šğ‘‚superscriptğ‘›12ğ‘˜m=O(n^{1+2/k})italic_m = italic_O ( italic_n start_POSTSUPERSCRIPT 1 + 2 / italic_k end_POSTSUPERSCRIPT ) edges. Therefore, we can get a size upper bound of kğ‘˜kitalic_k-spanners possibly outputted by the greedy algorithm. There are also papers studying this upper bound on weighted graph setting [ADD+93, CDNS95, ENS14, Bod24]. Then, a natural question arises: How large is the gap between the minimum (optimal) spanners and spanners outputted by the greedy algorithm? Here, the minimum kğ‘˜kitalic_k-spanner of a graph GğºGitalic_G is its kğ‘˜kitalic_k-spanner with the fewest edges. In a seminal work [FS20], it is shown that the greedy algorithm is existentially optimal. Namely, for any n,kğ‘›ğ‘˜n,kitalic_n , italic_k, they show that there exists an nğ‘›nitalic_n-vertex graph GğºGitalic_G and its minimum kğ‘˜kitalic_k-spanner Hâˆ—superscriptğ»H^{*}italic_H start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT such that any kğ‘˜kitalic_k-spanner Hğ»Hitalic_H outputted by the greedy algorithm running on any nğ‘›nitalic_n-vertex input graph is no larger than Hâˆ—superscriptğ»H^{*}italic_H start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT. A more classical and difficult notion is universally optimal. It requires the greedy algorithm to output a minimum kğ‘˜kitalic_k-spanner for any nğ‘›nitalic_n-vertex graph. However, [FS20] also shows that for many parameter settings (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ), the greedy algorithm for weighted graphs is â€˜far fromâ€™ universally optimal on stretch kğ‘˜kitalic_k and nğ‘›nitalic_n-vertex graphs. It means that the greedy algorithm cannot be universally optimal on general parameters. On the other hand, there is still hope that the greedy algorithm is universally optimal on some specific parameters (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ). In fact, a simple observation is that when we set k=nâˆ’1ğ‘˜ğ‘›1k=n-1italic_k = italic_n - 1, the kğ‘˜kitalic_k-spanners of nğ‘›nitalic_n-vertex graphs are actually equivalent to their reachability preservers, and we can assert that the greedy algorithm is universally optimal on parameters (n,k=nâˆ’1)ğ‘›ğ‘˜ğ‘›1(n,k=n-1)( italic_n , italic_k = italic_n - 1 ) since reachability preservers are just spanning trees, which can be outputted by the greedy algorithm. It is natural to ask: for what parameters (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ), the greedy algorithm is universally optimal? That is, it outputs a minimum kğ‘˜kitalic_k-spanner for any nğ‘›nitalic_n-vertex graphs. In this paper, we will try to partially answer this question. 1.1 Our Results We first define some terms, which is closely related to the performance of the greedy algorithm. Definition 1.4. For any pair (n,k)âˆˆâ„•Ã—â„•ğ‘›ğ‘˜â„•â„•(n,k)\in\mathbb{N}\times\mathbb{N}( italic_n , italic_k ) âˆˆ blackboard_N Ã— blackboard_N, we define: (a) If for any nğ‘›nitalic_n-vertex graph, all of its minimum kğ‘˜kitalic_k-spanners have girth at least k+2ğ‘˜2k+2italic_k + 2, we call (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) an extremely good pair. (b) If for any nğ‘›nitalic_n-vertex graph, at least one of its minimum kğ‘˜kitalic_k-spanners has girth at least k+2ğ‘˜2k+2italic_k + 2, we call (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) a good pair. (c) If for any nğ‘›nitalic_n-vertex graph GğºGitalic_G, all of its minimum kğ‘˜kitalic_k-spanners can be outputted by the greedy algorithm on some edge ordering Ïƒğœ\sigmaitalic_Ïƒ, we say the greedy algorithm is completely universally optimal on (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ). (d) If for any nğ‘›nitalic_n-vertex graph GğºGitalic_G, there exists one of its minimum kğ‘˜kitalic_k-spanners that can be outputted by the greedy algorithm on some edge ordering Ïƒğœ\sigmaitalic_Ïƒ, we say the greedy algorithm is universally optimal on (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ). From Proposition 1.3, we can connect the above notions Corollary 1.5. For any pair (n,k)âˆˆâ„•Ã—â„•ğ‘›ğ‘˜â„•â„•(n,k)\in\mathbb{N}\times\mathbb{N}( italic_n , italic_k ) âˆˆ blackboard_N Ã— blackboard_N, we have: If (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is extremely good, then the greedy algorithm is completely universal optimal on (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ). If (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is good, then the greedy algorithm is universally optimal on (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ). By Corollary 1.5, if we want to argue (completely) universal optimality on specific (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ), it suffices to identify the category of (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ): extremely good, good or â€˜not even goodâ€™. Lower Bound First, we give a lower (negative) bound. It asserts that if kğ‘˜kitalic_k is too small compared to nğ‘›nitalic_n, then (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is not even a good pair. Theorem 1.6. For every sufficiently large nğ‘›nitalic_n and Oâ¢(1)<k<13â¢nâˆ’Oâ¢(1)ğ‘‚1ğ‘˜13ğ‘›ğ‘‚1O(1)<k<\frac{1}{3}n-O(1)italic_O ( 1 ) < italic_k < divide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n - italic_O ( 1 ), (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is not a good pair. In fact, the proof of Theorem 1.6 is constructive: We can construct a graph GğºGitalic_G with nğ‘›nitalic_n vertices such that all of its minimum kğ‘˜kitalic_k-spanners have girth at most k+1ğ‘˜1k+1italic_k + 1. Upper Bound Extremely good (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is the strongest definition, so we first find an upper (positive) bound about it. Our proof is algorithmic. Concretely, if kğ‘˜kitalic_k is large enough compared to nğ‘›nitalic_n, for any kğ‘˜kitalic_k-spanner Hğ»Hitalic_H of nğ‘›nitalic_n-vertex graph GğºGitalic_G with girth at most k+1ğ‘˜1k+1italic_k + 1, we can algorithmically remove some edges of Hğ»Hitalic_H such that Hğ»Hitalic_H is still a kğ‘˜kitalic_k-spanner after removal. Theorem 1.7. There is a deterministic polynomial time algorithm Ağ´Aitalic_A such that for all sufficiently large nğ‘›nitalic_n and any k>34â¢n+Oâ¢(1)ğ‘˜34ğ‘›ğ‘‚1k>\frac{3}{4}n+O(1)italic_k > divide start_ARG 3 end_ARG start_ARG 4 end_ARG italic_n + italic_O ( 1 ), given any nğ‘›nitalic_n-vertex graph GğºGitalic_G and its kğ‘˜kitalic_k-spanner HâŠ†Gğ»ğºH\subseteq Gitalic_H âŠ† italic_G, Aâ¢(G,H,k)ğ´ğºğ»ğ‘˜A(G,H,k)italic_A ( italic_G , italic_H , italic_k ) outputs a subgraph RâŠ†Hğ‘…ğ»R\subseteq Hitalic_R âŠ† italic_H of Hğ»Hitalic_H such that Rğ‘…Ritalic_R is a kğ‘˜kitalic_k-spanner of GğºGitalic_G and Rğ‘…Ritalic_R has girth at least k+2ğ‘˜2k+2italic_k + 2. This immediately gives us an upper bound for extremely good (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ). Corollary 1.8. For all sufficiently large nğ‘›nitalic_n and any k>34â¢n+Oâ¢(1)ğ‘˜34ğ‘›ğ‘‚1k>\frac{3}{4}n+O(1)italic_k > divide start_ARG 3 end_ARG start_ARG 4 end_ARG italic_n + italic_O ( 1 ), (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is extremely good. Proof. Suppose by contradiction that for some nğ‘›nitalic_n-vertex GğºGitalic_G, it has some minimum kğ‘˜kitalic_k-spanner Hğ»Hitalic_H with girth at most k+1ğ‘˜1k+1italic_k + 1. Then by Theorem 1.7 we can construct its subgraph RâŠ†Hğ‘…ğ»R\subseteq Hitalic_R âŠ† italic_H such that Rğ‘…Ritalic_R is also a kğ‘˜kitalic_k-spanner of GğºGitalic_G. Since Rğ‘…Ritalic_R has strictly larger girth than Hğ»Hitalic_H, Rğ‘…Ritalic_R must be a strictly smaller kğ‘˜kitalic_k-spanner of GğºGitalic_G than Hğ»Hitalic_H, which contradicts the assumption that Hğ»Hitalic_H is the minimum kğ‘˜kitalic_k-spanner. âˆ We can also give an upper bound using a similar but more complicated algorithm for the weaker notion, good pair (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ). Theorem 1.9. There is a deterministic polynomial time algorithm Ağ´Aitalic_A such that for all sufficiently large nğ‘›nitalic_n and any k>23â¢n+Oâ¢(1)ğ‘˜23ğ‘›ğ‘‚1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ), given any nğ‘›nitalic_n-vertex graph GğºGitalic_G and its kğ‘˜kitalic_k-spanner H=(V,EH)âŠ†Gğ»ğ‘‰subscriptğ¸ğ»ğºH=(V,E_{H})\subseteq Gitalic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) âŠ† italic_G, Aâ¢(G,H,k)ğ´ğºğ»ğ‘˜A(G,H,k)italic_A ( italic_G , italic_H , italic_k ) outputs R=(V,ER)âŠ†Gğ‘…ğ‘‰subscriptğ¸ğ‘…ğºR=(V,E_{R})\subseteq Gitalic_R = ( italic_V , italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT ) âŠ† italic_G such that Rğ‘…Ritalic_R is a kğ‘˜kitalic_k-spanner of GğºGitalic_G with girth at least k+2ğ‘˜2k+2italic_k + 2. Moreover, the size of Rğ‘…Ritalic_R satisfies |ER|â‰¤|EH|subscriptğ¸ğ‘…subscriptğ¸ğ»|E_{R}|\leq|E_{H}|| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | â‰¤ | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT |. Similarly, this immediately gives us an upper bound for good pairs Corollary 1.10. For all sufficiently large nğ‘›nitalic_n and any k>23â¢n+Oâ¢(1)ğ‘˜23ğ‘›ğ‘‚1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ), (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is good. Approximately Universally Optimal By the previous results, we have known whether the greedy algorithm is universally optimal when k<13â¢nâˆ’Oâ¢(1)ğ‘˜13ğ‘›ğ‘‚1k<\frac{1}{3}n-O(1)italic_k < divide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n - italic_O ( 1 ) or k>23â¢n+Oâ¢(1)ğ‘˜23ğ‘›ğ‘‚1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ). It remains open when 13â¢n<k<23â¢n13ğ‘›ğ‘˜23ğ‘›\frac{1}{3}n<k<\frac{2}{3}ndivide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n < italic_k < divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n. To understand the gap between the greedy algorithm and minimum spanners in this range, we need to introduce a notion called â€˜approximately universally optimalâ€™. Since we actually have a polynomial time algorithm in Theorem 1.9, we can consider slacking the size requirement of outputted spanner Rğ‘…Ritalic_R. Concretely, rather than requiring |ER|â‰¤|EH|subscriptğ¸ğ‘…subscriptğ¸ğ»|E_{R}|\leq|E_{H}|| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | â‰¤ | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT |, we can output a kğ‘˜kitalic_k-spanner Rğ‘…Ritalic_R with girth at least k+2ğ‘˜2k+2italic_k + 2 that is just â€˜slightlyâ€™ larger than Hğ»Hitalic_H. In the classical approximation algorithm setting, we use a multiplicative slack factor. Formally, Suppose Hğ»Hitalic_H is the minimum kğ‘˜kitalic_k-spanner, if our outputted large-girth kğ‘˜kitalic_k-spanner Rğ‘…Ritalic_R has size |ER|â‰¤Î±â¢|EH|subscriptğ¸ğ‘…ğ›¼subscriptğ¸ğ»|E_{R}|\leq\alpha|E_{H}|| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | â‰¤ italic_Î± | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT |, we can call it Î±ğ›¼\alphaitalic_Î±-optimal. However, there is a critical issue about the multiplicative approximation factor in our setting. Since we are considering the case when k>Î©â¢(n)ğ‘˜Î©ğ‘›k>\Omega(n)italic_k > roman_Î© ( italic_n ), by Moore bound [AHL02] the classical greedy algorithm will always give a kğ‘˜kitalic_k-spanner with girth at least k+2ğ‘˜2k+2italic_k + 2 and size at most n1+Oâ¢(1/n)=n+Oâ¢(logâ¡n)superscriptğ‘›1ğ‘‚1ğ‘›ğ‘›ğ‘‚ğ‘›n^{1+O(1/n)}=n+O(\log{n})italic_n start_POSTSUPERSCRIPT 1 + italic_O ( 1 / italic_n ) end_POSTSUPERSCRIPT = italic_n + italic_O ( roman_log italic_n ). Since a trivial lower bound on the size of minimum kğ‘˜kitalic_k-spanner H=(V,EH)ğ»ğ‘‰subscriptğ¸ğ»H=(V,E_{H})italic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) of a connected graph is |EH|â‰¥nâˆ’1subscriptğ¸ğ»ğ‘›1|E_{H}|\geq n-1| italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | â‰¥ italic_n - 1, any constant multiplicative approximation factor Î±=1+Î©â¢(1)ğ›¼1Î©1\alpha=1+\Omega(1)italic_Î± = 1 + roman_Î© ( 1 ) will become trivial since the well-known greedy algorithm always outputs a kğ‘˜kitalic_k-spanner with size n+oâ¢(n)â‰¤(1+oâ¢(1))â¢|EH|â‰¤Î±â¢|EH|ğ‘›ğ‘œğ‘›1ğ‘œ1subscriptğ¸ğ»ğ›¼subscriptğ¸ğ»n+o(n)\leq(1+o(1))|E_{H}|\leq\alpha|E_{H}|italic_n + italic_o ( italic_n ) â‰¤ ( 1 + italic_o ( 1 ) ) | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | â‰¤ italic_Î± | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT |. These spanners are usually called ultrasparse spanners [Pet08, BEG+22]. Therefore, we must introduce a more refined notion of â€˜approximationâ€™. The first observation is that since different connected components are isolated when considering spanners, we can only focus on connected graphs without loss of generality. For any connected nğ‘›nitalic_n-vertex graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) and its minimum kğ‘˜kitalic_k-spanner H=(V,EH)ğ»ğ‘‰subscriptğ¸ğ»H=(V,E_{H})italic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ), since |EH|â‰¥nâˆ’1subscriptğ¸ğ»ğ‘›1|E_{H}|\geq n-1| italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | â‰¥ italic_n - 1 is a trivial lower bound, we can use Î±=|ER|âˆ’n|EH|âˆ’nğ›¼subscriptğ¸ğ‘…ğ‘›subscriptğ¸ğ»ğ‘›\alpha=\frac{|E_{R}|-n}{|E_{H}|-n}italic_Î± = divide start_ARG | italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | - italic_n end_ARG start_ARG | italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | - italic_n end_ARG as a new definition for the approximation factor, where R=(V,ER)ğ‘…ğ‘‰subscriptğ¸ğ‘…R=(V,E_{R})italic_R = ( italic_V , italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT ) denotes the kğ‘˜kitalic_k-spanner of GğºGitalic_G outputted by some approximation algorithm. Definition 1.11. For any pair (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) and constants Î±>1,Î²â‰¥0formulae-sequenceğ›¼1ğ›½0\alpha>1,\beta\geq 0italic_Î± > 1 , italic_Î² â‰¥ 0, if any nğ‘›nitalic_n-vertex connected graph G=(V,E)ğºğ‘‰ğ¸G=(V,E)italic_G = ( italic_V , italic_E ) has a kğ‘˜kitalic_k-spanner H=(V,EH)ğ»ğ‘‰subscriptğ¸ğ»H=(V,E_{H})italic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) with girth at least k+2ğ‘˜2k+2italic_k + 2 such that |EH|âˆ’nâ‰¤Î±â¢(ğ–®ğ–¯ğ–³âˆ’n)+Î²subscriptğ¸ğ»ğ‘›ğ›¼ğ–®ğ–¯ğ–³ğ‘›ğ›½|E_{H}|-n\leq\alpha(\mathsf{OPT}-n)+\beta| italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT | - italic_n â‰¤ italic_Î± ( sansserif_OPT - italic_n ) + italic_Î², we call (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) an (Î±,Î²)ğ›¼ğ›½(\alpha,\beta)( italic_Î± , italic_Î² )-approx good pair. Here ğ–®ğ–¯ğ–³ğ–®ğ–¯ğ–³\mathsf{OPT}sansserif_OPT denotes the number of edges in any minimum kğ‘˜kitalic_k-spanner of GğºGitalic_G. We can observe that the fact (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is (Î±,Î²)ğ›¼ğ›½(\alpha,\beta)( italic_Î± , italic_Î² )-approx good is equivalent to â€˜(Î±,Î²)ğ›¼ğ›½(\alpha,\beta)( italic_Î± , italic_Î² )-approximately universal optimalityâ€™ of the greedy algorithm. Namely, the greedy algorithm is â€˜(Î±,Î²)ğ›¼ğ›½(\alpha,\beta)( italic_Î± , italic_Î² )-approximately universally optimalâ€™ on (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) iff for any nğ‘›nitalic_n-vertex graph GğºGitalic_G, the greedy algorithm can output a (Î±,Î²)ğ›¼ğ›½(\alpha,\beta)( italic_Î± , italic_Î² )-approximately minimum kğ‘˜kitalic_k-spanner of GğºGitalic_G on some edge ordering Ïƒğœ\sigmaitalic_Ïƒ. Using the above definitions, we can try to understand the power of the greedy algorithm when 13â¢nâ‰¤kâ‰¤23â¢n13ğ‘›ğ‘˜23ğ‘›\frac{1}{3}n\leq k\leq\frac{2}{3}ndivide start_ARG 1 end_ARG start_ARG 3 end_ARG italic_n â‰¤ italic_k â‰¤ divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n. The first bound is the following Theorem 1.12. There is a deterministic polynomial time algorithm Ağ´Aitalic_A such that for all sufficiently large nğ‘›nitalic_n and any k>47â¢n+Oâ¢(1)ğ‘˜47ğ‘›ğ‘‚1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ), given any nğ‘›nitalic_n-vertex graph GğºGitalic_G and its kğ‘˜kitalic_k-spanner H=(V,EH)âŠ†Gğ»ğ‘‰subscriptğ¸ğ»ğºH=(V,E_{H})\subseteq Gitalic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) âŠ† italic_G, Aâ¢(G,H,k)ğ´ğºğ»ğ‘˜A(G,H,k)italic_A ( italic_G , italic_H , italic_k ) outputs a kğ‘˜kitalic_k-spanner R=(V,ER)ğ‘…ğ‘‰subscriptğ¸ğ‘…R=(V,E_{R})italic_R = ( italic_V , italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT ) of GğºGitalic_G with girth at least k+2ğ‘˜2k+2italic_k + 2. Moreover, the size of Rğ‘…Ritalic_R satisfies |ER|âˆ’nâ‰¤2â¢(Eâ¢(H)âˆ’n)+1subscriptğ¸ğ‘…ğ‘›2ğ¸ğ»ğ‘›1|E_{R}|-n\leq 2(E(H)-n)+1| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | - italic_n â‰¤ 2 ( italic_E ( italic_H ) - italic_n ) + 1. As Corollaries 1.5 and 1.8, we can use Theorem 1.12 to derive the following Corollary 1.13. For all sufficiently large nğ‘›nitalic_n and every k>47â¢n+Oâ¢(1)ğ‘˜47ğ‘›ğ‘‚1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ), (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is (2,Oâ¢(1))2ğ‘‚1(2,O(1))( 2 , italic_O ( 1 ) )-approx good. We also generalize Theorem 1.12 (but use a less fine-grained way to analyze it) to smaller kğ‘˜kitalic_k but with a larger approximation factor as follows: Theorem 1.14. For tâˆˆ{1,2,3,4}ğ‘¡1234t\in\{1,2,3,4\}italic_t âˆˆ { 1 , 2 , 3 , 4 }, there is a deterministic polynomial time algorithm Ağ´Aitalic_A such that for all sufficiently large nğ‘›nitalic_n and any k>4â¢t9â¢tâˆ’4â¢n+Oâ¢(1)ğ‘˜4ğ‘¡9ğ‘¡4ğ‘›ğ‘‚1k>\frac{4t}{9t-4}n+O(1)italic_k > divide start_ARG 4 italic_t end_ARG start_ARG 9 italic_t - 4 end_ARG italic_n + italic_O ( 1 ), given any nğ‘›nitalic_n-vertex graph GğºGitalic_G and its kğ‘˜kitalic_k-spanner H=(V,EH)âŠ†Gğ»ğ‘‰subscriptğ¸ğ»ğºH=(V,E_{H})\subseteq Gitalic_H = ( italic_V , italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ) âŠ† italic_G, Aâ¢(G,H,k)ğ´ğºğ»ğ‘˜A(G,H,k)italic_A ( italic_G , italic_H , italic_k ) outputs a kğ‘˜kitalic_k-spanner R=(V,ER)ğ‘…ğ‘‰subscriptğ¸ğ‘…R=(V,E_{R})italic_R = ( italic_V , italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT ) of GğºGitalic_G with girth at least k+2ğ‘˜2k+2italic_k + 2. Moreover, the size of Rğ‘…Ritalic_R satisfies |ER|âˆ’nâ‰¤2â¢t2â¢(Eâ¢(H)âˆ’n)+2â¢t2subscriptğ¸ğ‘…ğ‘›2superscriptğ‘¡2ğ¸ğ»ğ‘›2superscriptğ‘¡2|E_{R}|-n\leq 2t^{2}(E(H)-n)+2t^{2}| italic_E start_POSTSUBSCRIPT italic_R end_POSTSUBSCRIPT | - italic_n â‰¤ 2 italic_t start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_E ( italic_H ) - italic_n ) + 2 italic_t start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. When t=2ğ‘¡2t=2italic_t = 2, the requirement for kğ‘˜kitalic_k is just k>47â¢n+Oâ¢(1)ğ‘˜47ğ‘›ğ‘‚1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ) which is the same as Theorem 1.12, but the approximation factor 2â¢t2=82superscriptğ‘¡282t^{2}=82 italic_t start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT = 8 is worse. Theorem 1.14 is useful when t={3,4}ğ‘¡34t=\{3,4\}italic_t = { 3 , 4 }, which gives us k>1223â¢n+Oâ¢(1)ğ‘˜1223ğ‘›ğ‘‚1k>\frac{12}{23}n+O(1)italic_k > divide start_ARG 12 end_ARG start_ARG 23 end_ARG italic_n + italic_O ( 1 ) and k>12â¢n+Oâ¢(1)ğ‘˜12ğ‘›ğ‘‚1k>\frac{1}{2}n+O(1)italic_k > divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_n + italic_O ( 1 ) bounds respectively. In fact, Theorem 1.14 is a â€˜bucket-decompositionâ€™ generalized version of Theorem 1.12, and tğ‘¡titalic_t is a decomposition parameter that can be set to any positive integer. However, setting tâ‰¥5ğ‘¡5t\geq 5italic_t â‰¥ 5 cannot derive new approximation bounds so larger tğ‘¡titalic_t is useless in the current technique. We give a detailed explanation in Remark 4.8. Corollary 1.15. For tâˆˆ{1,2,3,4}ğ‘¡1234t\in\{1,2,3,4\}italic_t âˆˆ { 1 , 2 , 3 , 4 }, for all sufficiently large nğ‘›nitalic_n and any k>4â¢t9â¢tâˆ’4â¢n+Oâ¢(1)ğ‘˜4ğ‘¡9ğ‘¡4ğ‘›ğ‘‚1k>\frac{4t}{9t-4}n+O(1)italic_k > divide start_ARG 4 italic_t end_ARG start_ARG 9 italic_t - 4 end_ARG italic_n + italic_O ( 1 ), (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) is (2â¢t2,Oâ¢(1))2superscriptğ‘¡2ğ‘‚1(2t^{2},O(1))( 2 italic_t start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , italic_O ( 1 ) )-approx good. Remark 1.16. All proofs of our upper (positive) bounds are â€˜partially constructiveâ€™. Informally, Theorems 1.7, 1.9, 1.12 and 1.14 all provide algorithms to enlarge the girth of an input kğ‘˜kitalic_k-spanner Hğ»Hitalic_H to at least k+2ğ‘˜2k+2italic_k + 2, and guarantee the outputted graph is still a kğ‘˜kitalic_k-spanner whose size wonâ€™t become too large compared to the size of Hğ»Hitalic_H. These algorithms can be appended behind some other good algorithms that donâ€™t care about girth as â€˜girth enlargerâ€™. For example, suppose there is an algorithm BğµBitalic_B that constructs very sparse spanners but doesnâ€™t guarantee the girth of the outputted spanner, we can feed its output spanner into our algorithms Ağ´Aitalic_A such that the final spanner outputted by Ağ´Aitalic_A has large girth, and at the same time it is only â€˜slightlyâ€™ larger than BğµBitalic_Bâ€™s original output. Figure 1: Different Bounds To the best of our knowledge, our proofs are built upon new ideas of analyzing the structure of spanners using the girth information. We hope these ideas could help us to understand the relation between girth and sparse spanners. Figure 1 is a summary of our main results. 1.2 Notations For any nâˆˆâ„•ğ‘›â„•n\in\mathbb{N}italic_n âˆˆ blackboard_N, let [n]={1,â€¦,n}delimited-[]ğ‘›1â€¦ğ‘›[n]=\{1,\dots,n\}[ italic_n ] = { 1 , â€¦ , italic_n }. For any undirected graph GğºGitalic_G, we use VGsubscriptğ‘‰ğºV_{G}italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT and EGsubscriptğ¸ğºE_{G}italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT to denote its vertex-set and edge-set unless otherwise stated. For any (u,v)âˆˆVGÃ—VGğ‘¢ğ‘£subscriptğ‘‰ğºsubscriptğ‘‰ğº(u,v)\in V_{G}\times V_{G}( italic_u , italic_v ) âˆˆ italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT Ã— italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT, we use ğ–½ğ—‚ğ—Œğ—Gâ¢(u,v)subscriptğ–½ğ—‚ğ—Œğ—ğºğ‘¢ğ‘£\mathsf{dist}_{G}(u,v)sansserif_dist start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u , italic_v ) to denote the length of the shortest path between u,vğ‘¢ğ‘£u,vitalic_u , italic_v in GğºGitalic_G. For any vertex-subset UâŠ†VGğ‘ˆsubscriptğ‘‰ğºU\subseteq V_{G}italic_U âŠ† italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT, we use Gâ¢[U]ğºdelimited-[]ğ‘ˆG[U]italic_G [ italic_U ] to denote the induced subgraph of GğºGitalic_G on Uğ‘ˆUitalic_U. For any two graphs G,Hğºğ»G,Hitalic_G , italic_H, we use G\H\ğºğ»G\backslash Hitalic_G \ italic_H to denote the graph (VG\VH,EG\EH)\subscriptğ‘‰ğºsubscriptğ‘‰ğ»\subscriptğ¸ğºsubscriptğ¸ğ»(V_{G}\backslash V_{H},E_{G}\backslash E_{H})( italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT \ italic_V start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT , italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT \ italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ). We can similarly define G\VH:=(VG\VH,EG)assign\ğºsubscriptğ‘‰ğ»\subscriptğ‘‰ğºsubscriptğ‘‰ğ»subscriptğ¸ğºG\backslash V_{H}:=(V_{G}\backslash V_{H},E_{G})italic_G \ italic_V start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT := ( italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT \ italic_V start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT , italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) and G\EH:=(VG,EG\EH)assign\ğºsubscriptğ¸ğ»subscriptğ‘‰ğº\subscriptğ¸ğºsubscriptğ¸ğ»G\backslash E_{H}:=(V_{G},E_{G}\backslash E_{H})italic_G \ italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT := ( italic_V start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT \ italic_E start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ). For a simple path pğ‘pitalic_p and any two vertices s,tâˆˆVpğ‘ ğ‘¡subscriptğ‘‰ğ‘s,t\in V_{p}italic_s , italic_t âˆˆ italic_V start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT, we use pâ¢[s,t]ğ‘ğ‘ ğ‘¡p[s,t]italic_p [ italic_s , italic_t ] to denote the sub-path between sğ‘ sitalic_s and tğ‘¡titalic_t. pâ¢[s,t),pâ¢(s,t],pâ¢(s,t)ğ‘ğ‘ ğ‘¡ğ‘ğ‘ ğ‘¡ğ‘ğ‘ ğ‘¡p[s,t),p(s,t],p(s,t)italic_p [ italic_s , italic_t ) , italic_p ( italic_s , italic_t ] , italic_p ( italic_s , italic_t ) are similarly defined. We use Sâ¢CGğ‘†subscriptğ¶ğºSC_{G}italic_S italic_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT to denote an arbitrary smallest cycle of GğºGitalic_G, and LG:=|VSâ¢CG|assignsubscriptğ¿ğºsubscriptğ‘‰ğ‘†subscriptğ¶ğºL_{G}:=|V_{SC_{G}}|italic_L start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT := | italic_V start_POSTSUBSCRIPT italic_S italic_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT end_POSTSUBSCRIPT |. 1.3 Paper Organization and Overview In Section 2, we give a brief illustration of the negative lower bound regarding the greedy algorithm as stated in Theorem 1.6. Then, in Section 3 we give detailed proofs of positive upper bounds Theorem 1.7 and Theorem 1.9. Finally, we will prove Theorem 1.12 and Theorem 1.14 in Section 4. Letâ€™s give an overview of our proof strategy used in establishing positive upper bounds. Let Hğ»Hitalic_H be a minimum (in fact arbitrary) kğ‘˜kitalic_k-spanner of GğºGitalic_G and Sâ¢CHğ‘†subscriptğ¶ğ»SC_{H}italic_S italic_C start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT denote its smallest cycle. Let LH=|VSâ¢CH|subscriptğ¿ğ»subscriptğ‘‰ğ‘†subscriptğ¶ğ»L_{H}=|V_{SC_{H}}|italic_L start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT = | italic_V start_POSTSUBSCRIPT italic_S italic_C start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUBSCRIPT |. If LHâ‰¥k+2subscriptğ¿ğ»ğ‘˜2L_{H}\geq k+2italic_L start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT â‰¥ italic_k + 2, our girth lower bound has been satisfied and we are done. Otherwise, we want to find a cycle-edge eâˆˆESâ¢CHğ‘’subscriptğ¸ğ‘†subscriptğ¶ğ»e\in E_{SC_{H}}italic_e âˆˆ italic_E start_POSTSUBSCRIPT italic_S italic_C start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUBSCRIPT and at most mğ‘šmitalic_m edges e1,â€¦,emâˆˆEGsubscriptğ‘’1â€¦subscriptğ‘’ğ‘šsubscriptğ¸ğºe_{1},\dots,e_{m}\in E_{G}italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_e start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT âˆˆ italic_E start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT, such that we can break the smallest cycle Sâ¢CHğ‘†subscriptğ¶ğ»SC_{H}italic_S italic_C start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT by removing eğ‘’eitalic_e, and then preserve the property of kğ‘˜kitalic_k-spanner by adding these mğ‘šmitalic_m edges. Formally, let Hâ€²superscriptğ»â€²H^{\prime}italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT denote (H\{e})âˆª{e1,â€¦,em}\ğ»ğ‘’subscriptğ‘’1â€¦subscriptğ‘’ğ‘š\left(H\backslash\{e\}\right)\cup\{e_{1},\dots,e_{m}\}( italic_H \ { italic_e } ) âˆª { italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_e start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT }, we want â€¢ Hâ€²superscriptğ»â€²H^{\prime}italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT is a kğ‘˜kitalic_k-spanner. â€¢ e1,â€¦,emsubscriptğ‘’1â€¦subscriptğ‘’ğ‘še_{1},\dots,e_{m}italic_e start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_e start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT donâ€™t create any new cycle with length at most k+1ğ‘˜1k+1italic_k + 1 in Hâ€²superscriptğ»â€²H^{\prime}italic_H start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT compared to Hğ»Hitalic_H. If for some pair (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ), the above condition can be met, then the greedy algorithm is (m,Oâ¢(m))ğ‘šğ‘‚ğ‘š(m,O(m))( italic_m , italic_O ( italic_m ) )-Approximately universally optimal on (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ). (See the proof of Theorem 4.4 for details.) Therefore, our goal is to prove the above statement in different mğ‘šmitalic_m and (n,k)ğ‘›ğ‘˜(n,k)( italic_n , italic_k ) settings. First, in Section 3.1 we will show that as long as LH>2â¢(nâˆ’k)subscriptğ¿ğ»2ğ‘›ğ‘˜L_{H}>2(n-k)italic_L start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT > 2 ( italic_n - italic_k ), we can achieve m=0ğ‘š0m=0italic_m = 0 regardless. It suffices to consider the case when LHâ‰¤2â¢(nâˆ’k)subscriptğ¿ğ»2ğ‘›ğ‘˜L_{H}\leq 2(n-k)italic_L start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT â‰¤ 2 ( italic_n - italic_k ): In Section 3.2, we give a common structural framework required in all following proofs. Then, we work on different parameter settings as follows â€¢ In Section 3.3, we will prove when k>34â¢n+Oâ¢(1)ğ‘˜34ğ‘›ğ‘‚1k>\frac{3}{4}n+O(1)italic_k > divide start_ARG 3 end_ARG start_ARG 4 end_ARG italic_n + italic_O ( 1 ), we can achieve m=0ğ‘š0m=0italic_m = 0, and derive Theorem 1.7. â€¢ In Section 3.4, we will prove when k>23â¢n+Oâ¢(1)ğ‘˜23ğ‘›ğ‘‚1k>\frac{2}{3}n+O(1)italic_k > divide start_ARG 2 end_ARG start_ARG 3 end_ARG italic_n + italic_O ( 1 ), we can achieve m=1ğ‘š1m=1italic_m = 1, which confirms Theorem 1.9. â€¢ In Section 4.1, we will prove when k>47â¢n+Oâ¢(1)ğ‘˜47ğ‘›ğ‘‚1k>\frac{4}{7}n+O(1)italic_k > divide start_ARG 4 end_ARG start_ARG 7 end_ARG italic_n + italic_O ( 1 ), we can achieve m=2ğ‘š2m=2italic_m = 2 and derive Theorem 1.12. The proof strategy is a generalization of Section 3.4 â€¢ In Section 4.2, we will prove when k>1223â¢n+Oâ¢(1)ğ‘˜1223ğ‘›ğ‘‚1k>\frac{12}{23}n+O(1)italic_k > divide start_ARG 12 end_ARG start_ARG 23 end_ARG italic_n + italic_O ( 1 ), we can achieve m=18ğ‘š18m=18italic_m = 18, and when k>12â¢n+Oâ¢(1)ğ‘˜12ğ‘›ğ‘‚1k>\frac{1}{2}n+O(1)italic_k > divide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_n + italic_O ( 1 ), we can achieve m=32ğ‘š32m=32italic_m = 32. These two results follow from a â€˜bucket-decompositionâ€™ generalized version of Theorem 1.12."
https://arxiv.org/html/2411.01407v1,Reducing Data Fragmentation in Data Deduplication Systems via Partial Repetition and Coding,"Data deduplication, one of the key features of modern Big Data storage devices, is the process of removing replicas of data chunks stored by different users. Despite the importance of deduplication, several drawbacks of the method, such as storage robustness and file fragmentation, have not been previously analyzed from a theoretical point of view. Storage robustness pertains to ensuring that deduplicated data can be used to reconstruct the original files without service disruptions and data loss. Fragmentation pertains to the problems of placing deduplicated data chunks of different user files in a proximity-preserving linear order, since neighboring chunks of the same file may be stored in sectors far apart on the server. This work proposes a new theoretical model for data fragmentation and introduces novel graph- and coding-theoretic approaches for reducing fragmentation via limited duplication (repetition coding) and coded deduplication (e.g., linear coding). In addition to alleviating issues with fragmentation, limited duplication and coded deduplication can also serve the dual purpose of increasing the robusteness of the system design. The contributions of our work are three-fold. First, we describe a new model for file structures in the form of self-avoiding (simple) paths in specialized graphs. Second, we introduce several new metrics for measuring the fragmentation level in deduplication systems on graph-structured files, including the stretch metric that captures the worst-case â€œspreadâ€ of adjacent data chunks within a file when deduplicated and placed on the server; and, the jump metric that captures the worst-case number of times during the reconstruction process of a file that one has to change the readout location on the server. For the stretch metric, we establish a connection between the level of fragmentation and the bandwidth of the file-graph. In particular, we derive lower and upper bounds on degree of fragmentation and describe instances of the problem where repetition and coding reduce fragmentation. The key ideas behind our approach are graph folding and information-theoretic arguments coupled with graph algorithms such as matching. For the jump metric, we provide a new algorithm for computing the jump number of hierarchical data structures captured by trees. Third, we describe how controlled repetition and coded redundancy added after deduplication can ensure valuable trade-offs between the storage volume and the degree of fragmentation.","Data deduplication is a data management technique employed in modern large-scale data storage systems to increase storage efficiency by removing content replicas of different users [1, 2, 3, 4]. For example, cloud storage providers such as Microsoft and Dropbox, as well as intelligent data infrastructure companies such as NetApp, actively support deduplication schemes in their storage systems. A typical deduplication algorithm first splits the input files into smaller data subunits, referred to as â€œchunksâ€ [5, 6, 7], then removes duplicate data chunks and proceeds to place the chunks on servers. For duplicate chunk identification, one typically uses hash values [5, 6, 7]. The chunk placement is based either on some predetermined protocol or the order of arrival of new chunks. After deduplication, each file is stored in â€˜compressedâ€™ form, involving a set of pointers explaining how to assemble it (e.g., a set of hash values pointing to the actual locations of the data chunks and labels indicating their order). During the file restoration phase, the server uses the compressed description to recreate files by retrieving chunks guided by the pointers. The trade-off between the chunk size and the length of the assembly instruction under various chunking strategies is an important practical system compression feature, addressed in [5]. Since the volume of the assembly instruction data is usually negligible compared to the actual user data, this consideration is irrelevant for protocol-level analyses of deduplication. Although deduplication algorithms provide significant storage savings, they introduce a number of readout issues, including data fragmentation [8] and data instability [9, 10]. Data fragmentation arises due to storing information chunks of a single file at multiple potentially distal locations, which slows down data retrieval and potentially creates problems with accessing large volumes of secondary, unwanted interspersing data. Deduplication instability, on the other hand, refers to the vulnerability to data loss (i.e., lack of robustness) of the file system when only one replica of each chunk is maintained. These problems are partly mitigated in practice by using caches and specialized chunk placements [11], as well as â€˜incomplete deduplicationâ€™ protocols, where not all redundant chunks are removed but only a portion of them, dictated by their popularity [1, 2]. Despite the widespread use of deduplication and the many practical implementations of the method, little is known about the theoretical performance limits of such systems with regards to data fragmentation. Prior work [4] provided a mathematical analysis of the influence of deduplication on distributed storage codes, while [5] initiated an information-theoretic study of deduplication as a form of compression. Some other works [7, 6] focused on examining the influence of errors on chunking and deduplication. None of these contributions considered fragmentation problems or issues associated with partial deduplication and file retrieval robustness. Here, we initiate the first analytical study of the trade-off between storage redundancy and file fragmentation. The key features supporting our analysis are: a) A new model for files that share chunks in terms of self-avoiding (simple) paths/walks in what we call a chunk or file graph. In particular, we model the data as being either generated by a sparse Hamiltonian-path graph in which nodes represent chunks and nodes on connected paths correspond to files to be stored; or, as hierarchical structures whose chunks are organized on a tree. The Hamiltonian path requirement is used to both model a natural linear ordering of concatenated files and to simplify challenging analyses. Similarly, tree models are used to capture chunk organizations in omnipresent hierarchical data; b) Several new metrics for measuring the level of fragmentation, including a worst-case metric which examines the maximum stretch of allotted locations of adjacent data chunks (i.e., the stretch metric) and a metric that captures the worst-case number of times the location on a server needs to be changed to retrieve a file (i.e., the jump metric). Average-case metrics, although formally defined in this work will be examined elsewhere. Our main contributions are bounds on the worst-case fragmentation metrics and algorithms for chunk placements that produce provably good fragmentation results. Most importantly, we examine these key features of deduplication systems for the case of completely deduplicated files (for which the solution involves optimization over permutations, i.e., over the symmetric group), partially deduplicated files with data chunk repetitions (repetition-coded deduplication) and coded deduplication, in which the stored chunks may represent linear (or, in general nonlinear) combinations of systematic user chunks. The outlined analysis involves information-theoretic arguments but also strongly relies on results in graph theory pertaining to the graph bandwith and related concepts [12], as well as matchings in graphs. In the former context, we introduce graph folding which allows one to transfer the domain of the problem from graphs to functions. Additional ideas used in this context include graph factorization and concatenation of different permutations of the chunks, and results already established in the context of the related problem of graph bandwidth analysis [13]. We also describe a number of examples pertaining to deduplication systems in which one is either allowed to retain multiple copies of the same chunk or use coded chunks. In these settings, it is a priori clear that redundant chunks can help reduce fragmentation, since concatenating all files (e.g., not performing deduplication) results in no fragmentation. What is at this point completely unknown is how much redundancy is needed to reduce fragmentation to practically acceptable levels. Furthermore, repeated and/or coded chunks both increase the robustness of the system, which is desirable, but at the cost of increasing the storage overhead of the system. The work closest to our new study is the work that established ultimate performance limits of information retrieval with and without redundancy [14]. There, the questions were posed in a probabilistic context that does not include deduplication nor fragmentation models. Furthermore, information is modelled as arising from a Markovian grid or torus, by traversing a path whose length increases in an unbounded manner. The main objective of the work was to explore the expansion of the average walk lengths of 1-D retrieval versus 2-D retrieval approaches. The work also included an analysis of coding approaches that can aid in reducing the gap introduced by lowering the dimension of the data space. A more detailed description of this work, which is of independent interest, is provided in Section VII. The paper is organized as follows. Section II provides a review of deduplication approaches and introduces terms needed for our analysis and the problem formulations that follow. Section III describes the problem formulation(s), based on the description of the file and chunk store model and the metrics used to measure the fragmentation level. Results pertaining to fragmentation bounds and limits for uncoded, repetition- and linearly encoded chunk stores under the stretch metrics are discussed in Section V. This section also contains the description of our graph folding approach and pertinent bounds based on it. Similar results for the jump fragmentation metric are presented in Section VI. A collection of open problems is discussed in Section VIII."
https://arxiv.org/html/2411.01061v1,Cyclic ordering of split matroids,"There is a long list of open questions rooted in the same underlying problem: understanding the structure of bases or common bases of matroids. These conjectures suggest that matroids may possess much stronger structural properties than are currently known. One example is related to cyclic orderings of matroids. A rank-rğ‘Ÿritalic_r matroid is called cyclically orderable if its ground set admits a cyclic ordering such that any interval of rğ‘Ÿritalic_r consecutive elements forms a basis. In this paper, we show that if the ground set of a split matroid decomposes into pairwise disjoint bases, then it is cyclically orderable. This result answers a conjecture of Kajitani, Ueno, and Miyano in a special case, and also strengthens Gabowâ€™s conjecture for this class of matroids. Our proof is algorithmic, hence it provides a procedure for determining a cyclic ordering in question using a polynomial number of independence oracle calls.Keywords: Cyclic ordering, Paving matroids, Sequential symmetric basis exchanges, Split matroids","Throughout the paper, we denote a matroid by M=(S,â„¬)ğ‘€ğ‘†â„¬M=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ), where Sğ‘†Sitalic_S is a finite ground set and â„¬â„¬\mathcal{B}caligraphic_B is the family of bases, satisfying the so-called basis axioms: (B1) âˆ…âˆˆâ„¬â„¬\emptyset\in\mathcal{B}âˆ… âˆˆ caligraphic_B, and (B2) for any B1,B2âˆˆâ„¬subscriptğµ1subscriptğµ2â„¬B_{1},B_{2}\in\mathcal{B}italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âˆˆ caligraphic_B and eâˆˆB1âˆ’B2ğ‘’subscriptğµ1subscriptğµ2e\in B_{1}-B_{2}italic_e âˆˆ italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT - italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, there exists fâˆˆB2âˆ’B1ğ‘“subscriptğµ2subscriptğµ1f\in B_{2}-B_{1}italic_f âˆˆ italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT - italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT such that B1âˆ’e+fâˆˆâ„¬subscriptğµ1ğ‘’ğ‘“â„¬B_{1}-e+f\in\mathcal{B}italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT - italic_e + italic_f âˆˆ caligraphic_B. The latter property, called the basis exchange axiom, is one of the most fundamental tools in matroid theory. Nevertheless, it only provides a local characterization of the relationship between bases, which presents a significant stumbling block to further progress. A rank-rğ‘Ÿritalic_r matroid M=(S,â„¬)ğ‘€ğ‘†â„¬M=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) with |S|=nğ‘†ğ‘›|S|=n| italic_S | = italic_n is cyclically orderable if there exists an ordering S=s1,â€¦,snğ‘†subscriptğ‘ 1â€¦subscriptğ‘ ğ‘›S={s_{1},\dots,s_{n}}italic_S = italic_s start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_s start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT such that si,si+1,â€¦,si+râˆ’1âˆˆâ„¬subscriptğ‘ ğ‘–subscriptğ‘ ğ‘–1â€¦subscriptğ‘ ğ‘–ğ‘Ÿ1â„¬{s_{i},s_{i+1},\dots,s_{i+r-1}}\in\mathcal{B}italic_s start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_s start_POSTSUBSCRIPT italic_i + 1 end_POSTSUBSCRIPT , â€¦ , italic_s start_POSTSUBSCRIPT italic_i + italic_r - 1 end_POSTSUBSCRIPT âˆˆ caligraphic_B for every iâˆˆ[n]ğ‘–delimited-[]ğ‘›i\in[n]italic_i âˆˆ [ italic_n ], where indices are understood in a cyclic order. While studying the structure of symmetric exchanges in matroids, Gabow [12] formulated a beautiful conjecture, stating that every matroid whose ground set decomposes into two disjoint bases is cyclically orderable. This question was raised independently by Wiedemann [21] and by Cordovil and Moreira [6]. The conjecture makes a stronger claim: for a fixed partition, the cyclic ordering can be chosen such that the elements of the two bases in the partition form contiguous intervals. Conjecture 1 (Gabow). Let M=(S,â„¬)ğ‘€ğ‘†â„¬M=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) be a matroid and S=B1âˆªB2ğ‘†subscriptğµ1subscriptğµ2S=B_{1}\cup B_{2}italic_S = italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âˆª italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT be a partition of the ground set into two disjoint bases. Then, Mğ‘€Mitalic_M has a cyclic ordering in which the elements of B1subscriptğµ1B_{1}italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and B2subscriptğµ2B_{2}italic_B start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT form intervals. It is not difficult to see that the statement holds for strongly base orderable matroids. The conjecture was settled for graphic matroids [14, 6, 21], sparse paving matroids [5], matroids of rank at most 4444 [16] and 5555 [15], split matroids [4], and regular matroids [2]. However, the existence of a cyclic ordering remains open in general, even without the constraint of the bases forming intervals. In [14], Kajitani, Ueno, and Miyano proposed a conjecture that would provide a full characterization of cyclically orderable matroids. A matroid M=(S,â„¬)ğ‘€ğ‘†â„¬M=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) with rank function rMsubscriptğ‘Ÿğ‘€r_{M}italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT is called uniformly dense if |S|â‹…rMâ¢(X)â‰¥rMâ¢(S)â‹…|X|â‹…ğ‘†subscriptğ‘Ÿğ‘€ğ‘‹â‹…subscriptğ‘Ÿğ‘€ğ‘†ğ‘‹|S|\cdot r_{M}(X)\geq r_{M}(S)\cdot|X|| italic_S | â‹… italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_X ) â‰¥ italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_S ) â‹… | italic_X | holds for every XâŠ†Sğ‘‹ğ‘†X\subseteq Sitalic_X âŠ† italic_S. It is not difficult to see that a cyclically orderable matroid is necessarily uniformly dense as well, and the conjecture states that this condition is also sufficient. Conjecture 2 (Kajitani, Ueno, and Miyano). A matroid is cyclically orderable if and only if it is uniformly dense. Despite the fact that the conjecture would provide entirely new insights into the structure of matroids, very little progress has been made so far. Van den Heuvel and ThomassÃ© [19] showed that the conjecture is true if |S|ğ‘†|S|| italic_S | and râ¢(S)ğ‘Ÿğ‘†r(S)italic_r ( italic_S ) are coprimes, and Boninâ€™s result [5] for sparse paving matroids remains true also in this more general setting. Recently, McGuinness [17] made a significant progress by verifying the conjecture for paving matroids. It is worth taking a moment to consider the interpretation of the uniformly dense property. By the matroid union theorem of Edmonds and Fulkerson [7], the ground set of a matroid M=(S,â„¬)ğ‘€ğ‘†â„¬M=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) can be covered by kğ‘˜kitalic_k bases if and only if kâ‹…rMâ¢(X)â‰¥|X|â‹…ğ‘˜subscriptğ‘Ÿğ‘€ğ‘‹ğ‘‹k\cdot r_{M}(X)\geq|X|italic_k â‹… italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_X ) â‰¥ | italic_X | holds for every XâŠ†Sğ‘‹ğ‘†X\subseteq Sitalic_X âŠ† italic_S. Using this, a matroid is uniformly dense if and only if its ground set can be covered by âŒˆ|S|/rMâ¢(S)âŒ‰ğ‘†subscriptğ‘Ÿğ‘€ğ‘†\lceil|S|/r_{M}(S)\rceilâŒˆ | italic_S | / italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_S ) âŒ‰ bases. In other words, the ground set can be decomposed in â€˜almostâ€™ disjoint bases, where almost means that the total overlapping between distinct bases is bounded by rMâ¢(S)âˆ’1subscriptğ‘Ÿğ‘€ğ‘†1r_{M}(S)-1italic_r start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ( italic_S ) - 1. In particular, any matroid whose ground set decomposes into pairwise disjoint bases is uniformly dense. This observation motivates the following strengthening of Gabowâ€™s conjecture. Conjecture 3. Let M=(S,â„¬)ğ‘€ğ‘†â„¬M=(S,\mathcal{B})italic_M = ( italic_S , caligraphic_B ) be a matroid and S=B1âˆªâ‹¯âˆªBkğ‘†subscriptğµ1â‹¯subscriptğµğ‘˜S=B_{1}\cup\dots\cup B_{k}italic_S = italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT âˆª â‹¯ âˆª italic_B start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT be a partition of the ground set into kğ‘˜kitalic_k pairwise disjoint bases. Then, Mğ‘€Mitalic_M has a cyclic ordering in which the elements of Bisubscriptğµğ‘–B_{i}italic_B start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT form an interval for each iâˆˆ[k]ğ‘–delimited-[]ğ‘˜i\in[k]italic_i âˆˆ [ italic_k ]. To the best of our knowledge, Conjecture 3 has not been previously considered and remains open even for very restricted classes of matroids, such as strongly base orderable matroids. Our main contribution is proving the conjecture for the class of split matroids. Split matroids were first introduced by Joswig and SchrÃ¶ter [13] while studying matroid polytopes from a geometric point of view. Since then, this class of matroids has gained importance in many contexts, primarily due to the work of Ferroni and SchrÃ¶ter [8, 9, 10, 11]. Theorem 1. Conjecture 3 is true for split matroids. It is worth emphasizing that our proof is algorithmic, hence it provides a procedure for determining a cyclic ordering in question using a polynomial number of independence oracle calls. Remark 2. In fact, we prove a slightly stronger statement: in the cyclic ordering obtained, the bases B1,â€¦,Bksubscriptğµ1â€¦subscriptğµğ‘˜B_{1},\dots,B_{k}italic_B start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_B start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT form intervals that follow each other in this order. The rest of the paper is organized as follows. Basic definitions and notation are introduced in Section 2. We prove Conjecture 3 for split matroids in Section 3. Finally, in Section 4, we give a list of related open questions and conjectures that are subject of future research."
https://arxiv.org/html/2411.00819v1,A Bellman-Ford algorithm for the path-length-weighted distance in graphs,"Consider a finite directed graph without cycles in which the arrows are weighted. We present an algorithm for the computation of a new distance, called path-length-weighted distance, which has proven useful for graph analysis in the context of fraud detection. The idea is that the new distance explicitly takes into account the size of the paths in the calculations. Thus, although our algorithm is based on arguments similar to those at work for the Bellman-Ford and Dijkstra methods, it is in fact essentially different. We lay out the appropriate framework for its computation, showing the constraints and requirements for its use, along with some illustrative examples.","Algorithms for calculating the (weighted) path-distance between vertices in a graph appeared in the middle of the 20th century, motivated by the growing interest of the time in the applications of mathematical analysis of graphs. The Bellman-Ford algorithm is the main reference of these early studies [2]. Dijkstraâ€™s algorithm for solving the same problem appeared at about the same time [11], and differs from the other, being more efficient depending on the particular problem. After these original works, the growing interest in the subject (due to the numerous applications that graph theory has found in many fields) has given rise to a great deal of research on graph analysis, which often includes the study of these structures when considered as metric spaces. The idea of considering a graph also as a metric space goes back to the beginnings of the theory of graphs. Metric notions begin to appear explicitly in mathematical works in the second half of the last century. The main metric that was considered (and in a sense the only one until the latter part of the century) was the so-called path distance ([12, 15, 18]): for undirected and connected graphs, this metric evaluated between two vertices (nodes) is defined as the length of the shortest path between them (see for example [4, Â§.2.2.2]). One of the first advances in the metric analysis of graphs was the introduction of weights in the definition of the path distance, assigning weights to the individual paths connecting two consecutive nodes and calculating the infimum of the sum of these weights. Some recent papers on the subject using weighted distances that have inspired this paper are [8, 14]. As in the case of other notions of fundamental graph theory, the relevant theoretical ideas appeared together with research topics from other scientific fields, such as sociology [1, 16, 22]. The definition of different metrics and algorithms to compute them increased greatly in the last decade of the last century, often proposed by problems from other disciplines such as chemistry or crystallography (see [18, 19] and references therein). In this sense, there is a particular case that deserves attention, that is the resistance distance [9, 23]. Coming from some ideas in theoretical chemistry [19] and social network analysis [22], this definition turned out to be a useful tool in the study of molecular configurations in chemistry, although it has also been used in network analysis and other fields [24, 5, 3]. In general, metrics could play a relevant role when studying properties such as robustness (see for example the survey [21]; see also [20]). The interested reader can find more information on applications of metric graphs in the books [6, 4, 13]. In the same direction, in this paper we provide an algorithm to compute a new distance that also appeared in an applied context, in connection with the automatic analysis of fraud in economic networks (see [7]). In this paper, we show that this metric allows to consider vertices that are far away when the distance is measured using the path-distance, becoming close with respect to this metric. It is especially useful in the economic analysis of fraud in networks of companies, since very often the strategy used to hide such fraud is to use the path-distance. Technically, it is defined as a weighted metric, but by dividing the sums of weights appearing in the infimum that provides the value of the metric by a new term that depends on the number of steps involved in the summation. We will show that this change in the weighting process forces to radically change the algorithm to calculate it, since in this new case, longer paths could give shorter distances. However, in the present work we consider the case of acyclic directed graphs, in order to avoid restrictions that make it impossible to define a weighted path metric, since continuous passage through a cycle could always give a null value to the metric (which would mean that it is not a metric). There are other ways to avoid this (see for example Proposition 4.1 in [7]), but in our case we decided to compute the distance between vertices by restricting the set of possible paths in the infimum that gives it. The way to do this is to avoid cycles, and to consider directed graphs. As a result, what we compute is not a metric on the whole graph, but only a distance between two vertices chosen in it. Let us give now some basic definitions about graphs and metric spaces. Let us explain some concepts related to the general definition of what a metric is, which will adapted later to the graph theoretic framework. Let â„+superscriptâ„\mathbb{R}^{+}blackboard_R start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT be the non-negative real numbers. An (extended) quasi-metric on a set Î©Î©\Omegaroman_Î© is a function d:Î©Ã—Î©â†’â„+âˆª{âˆ}:ğ‘‘â†’Î©Î©superscriptâ„d:\Omega\times\Omega\to\mathbb{R}^{+}\cup\{\infty\}italic_d : roman_Î© Ã— roman_Î© â†’ blackboard_R start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT âˆª { âˆ } such that for all a,b,câˆˆÎ©ğ‘ğ‘ğ‘Î©a,b,c\in\Omegaitalic_a , italic_b , italic_c âˆˆ roman_Î©, the axioms (1) dâ¢(a,b)=0=dâ¢(b,a)ğ‘‘ğ‘ğ‘0ğ‘‘ğ‘ğ‘d(a,b)=0=d(b,a)italic_d ( italic_a , italic_b ) = 0 = italic_d ( italic_b , italic_a ) if and only if a=b,ğ‘ğ‘a=b,italic_a = italic_b , and (2) dâ¢(a,b)â‰¤dâ¢(a,c)+dâ¢(c,b)ğ‘‘ğ‘ğ‘ğ‘‘ğ‘ğ‘ğ‘‘ğ‘ğ‘d(a,b)\leq d(a,c)+d(c,b)italic_d ( italic_a , italic_b ) â‰¤ italic_d ( italic_a , italic_c ) + italic_d ( italic_c , italic_b ) hold. The resulting quasi-metric structure (Î©,d)Î©ğ‘‘(\Omega,d)( roman_Î© , italic_d ) is called a quasi-metric space. For the specific framework of this paper, a useful summary of the notions of distance in graphs, with sufficient explanation and many examples, is given in Chapter 15 in [10]. In this paper we will deal with the so called path-length-weighted distance, that was introduced in [7, Â§.4]. It should be noted that the version defined there is given for non-directed graphs, and so the definition we will use is slightly different. However, we will define an extended quasi-metric also in this case by giving the value dâ¢(a,b)=âˆğ‘‘ğ‘ğ‘d(a,b)=\inftyitalic_d ( italic_a , italic_b ) = âˆ when there is no path for going from ağ‘aitalic_a to b,ğ‘b,italic_b , and considering only allowed paths between vertices. Since we are interested in how to compute the distance, and not in theoretical questions about its metric space structure, we will focus attention on the computational algorithm. All the notions on graph theory that are needed can be found in books on this subject, as for example [4]. We will introduce some of them in the next section."
https://arxiv.org/html/2411.00721v1,New classes of reversible cellular automata,"A Boolean function fğ‘“fitalic_f on kğ‘˜kitalic_k bits induces a shift-invariant vectorial Boolean function Fğ¹Fitalic_F from nğ‘›nitalic_n bits to nğ‘›nitalic_n bits for every nâ‰¥kğ‘›ğ‘˜n\geq kitalic_n â‰¥ italic_k. If Fğ¹Fitalic_F is bijective for every nğ‘›nitalic_n, we say that fğ‘“fitalic_f is a proper lifting, and it is known that proper liftings are exactly those functions that arise as local rules of reversible cellular automata. We construct new families of such liftings for arbitrary large kğ‘˜kitalic_k and discuss whether all have been identified for kâ‰¤6ğ‘˜6k\leq 6italic_k â‰¤ 6.","Shift-invariant functions are integral to symmetric cryptography, especially for lightweight cryptography, particularly in designing substitution boxes (S-boxes) for block ciphers and hash functions. These functions, and also connections to their associated cellular automata, which have a broad range of applications, have been studied by several authors, see e.g., [4] for a survey. Any shift-invariant function on nğ‘›nitalic_n-bits is derived by a local rule, that is, a Boolean function on kğ‘˜kitalic_k-bits for some kâ‰¤nğ‘˜ğ‘›k\leq nitalic_k â‰¤ italic_n. Conversely, every Boolean function f:ğ”½2kâ†’ğ”½2:ğ‘“â†’superscriptsubscriptğ”½2ğ‘˜subscriptğ”½2f\colon\mathbb{F}_{2}^{k}\to\mathbb{F}_{2}italic_f : blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT â†’ blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT induces a shift-invariant function F:ğ”½2nâ†’ğ”½2n:ğ¹â†’superscriptsubscriptğ”½2ğ‘›superscriptsubscriptğ”½2ğ‘›F\colon\mathbb{F}_{2}^{n}\to\mathbb{F}_{2}^{n}italic_F : blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT for every nâ‰¥kğ‘›ğ‘˜n\geq kitalic_n â‰¥ italic_k. If for every such nğ‘›nitalic_n the induced map Fğ¹Fitalic_F is bijective, then fğ‘“fitalic_f is called a proper lifting, and the corresponding cellular automaton is reversible. This work constructs and classifies new families of proper liftings, thus advancing the understanding of reversible cellular automata, and evaluate their resistance to differential cryptanalysis. In Section 1, we describe a new way of produce proper liftings through composition of landscape functions, generalizing existing constructions coming from sets of landscapes, see e.g., [1]. In Section 2, we study in detail the case k=6ğ‘˜6k=6italic_k = 6, and analyze whether these families are exhaustive. Finally, in Section 4, we present a few other constructions of families of proper liftings."
https://arxiv.org/html/2411.00708v2,Simplifying and Characterizing DAGs and Phylogenetic Networks via Least Common Ancestor Constraints,"Rooted phylogenetic networks, or more generally, directed acyclic graphs (DAGs), are widely used to model species or gene relationships that traditional rooted trees cannot fully capture, especially in the presence of reticulate processes or horizontal gene transfers. Such networks or DAGs are typically inferred from genomic data of extant taxa, providing only an estimate of the true evolutionary history. However, these inferred DAGs are often complex and difficult to interpret. In particular, many contain vertices that do not serve as least common ancestors (LCAs) for any subset of the underlying genes or species, thus lacking direct support from the observed data. In contrast, LCA vertices represent ancestral states substantiated by the data, offering important insights into evolutionary relationships among subsets of taxa. To reduce unnecessary complexity and eliminate unsupported vertices, we aim to simplify a DAG to retain only LCA vertices while preserving essential evolutionary information.In this paper, we characterize LCALCA\mathrm{LCA}roman_LCA-relevant and lcalca\mathrm{lca}roman_lca-relevant DAGs, defined as those in which every vertex serves as an LCA (or unique LCA) for some subset of taxa. We introduce methods to identify LCAs in DAGs and efficiently transform any DAG into an LCALCA\mathrm{LCA}roman_LCA-relevant or lcalca\mathrm{lca}roman_lca-relevant one while preserving key structural properties of the original DAG or network. This transformation is achieved using a simple operator â€œâŠ–symmetric-difference\ominusâŠ–â€ that mimics vertex suppression.","Rooted networks and, more generally, directed acyclic graphs (DAGs), are essential in mathematical phylogenetics for modeling complex evolutionary relationships that traditional rooted trees cannot fully represent [22, 25, 24]. In a DAG GğºGitalic_G, the leaf set Lâ¢(G)ğ¿ğºL(G)italic_L ( italic_G ) represents extant taxa, such as genes or species, while internal vertices vâˆˆVâ¢(G)âˆ–Lâ¢(G)ğ‘£ğ‘‰ğºğ¿ğºv\in V(G)\setminus L(G)italic_v âˆˆ italic_V ( italic_G ) âˆ– italic_L ( italic_G ) correspond to ancestral states and are associated with sets ğ™²Gâ¡(v)subscriptğ™²ğºğ‘£\operatorname{\mathtt{C}}_{G}(v)typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) of descendant leaves known as â€œhardwired clustersâ€ [24, 26, 23], or clusters [20] for short. Typically, only the leaf set Lâ¢(G)ğ¿ğºL(G)italic_L ( italic_G ) is available and a primary task is to reconstruct the evolutionary history - i.e., phylogenetic networks or DAGs - using information provided solely by the taxa in Lâ¢(G)ğ¿ğºL(G)italic_L ( italic_G ). This information, often derived from genomic sequence data and sequence similarities, can reveal clusters within the unknown DAG GğºGitalic_G that are used to reconstruct GğºGitalic_G [26, 23, 24, 13]. However, DAGs and networks inferred from genomic data can be highly complex and tangled, often containing redundant information [9, 12]. In particular, unlike phylogenetic trees, the number of vertices in a DAG GğºGitalic_G is not generally bounded by the number of leaves. As a result, various methods have been developed to simplify DAGs while preserving their most significant features [17, 12, 21]. Our research builds on this line of work and focuses on eliminating vertices from a DAG GğºGitalic_G that are â€œless relevantâ€ in the sense that they are not least common ancestors of certain subsets of Lâ¢(G)ğ¿ğºL(G)italic_L ( italic_G ). A least common ancestor (LCA) of a subset AâŠ†Lâ¢(G)ğ´ğ¿ğºA\subseteq L(G)italic_A âŠ† italic_L ( italic_G ) is a vertex vğ‘£vitalic_v that is an ancestor of all xâˆˆAğ‘¥ğ´x\in Aitalic_x âˆˆ italic_A and has no descendant that also satisfies this property. LCAs are essential for understanding and interpreting evolutionary relationships in phylogenetics [39, 19, 30, 36]. In evolutionary biology, there is a general consensus that inferred networks and DAGs should be phylogenetic, that is, they should not contain vertices with in- and out-degree one. The reason is simple: such vertices cannot be observed from any biological data since there is no historical trace left justifying their existence [18]. By similar reasoning, LCA vertices should represent ancestral relationships evidenced by a clear phylogenetic signal in the data. Vertices that are not LCAs of any subset of taxa of the underlying data, i.e., the leaves in GğºGitalic_G, lack direct relevance to the observed ancestral relationships; see, for example, vertex uğ‘¢uitalic_u or uâ€²superscriptğ‘¢â€²u^{\prime}italic_u start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT in the network Nğ‘Nitalic_N in Figure 1. Consequently, non-LCA vertices may lack clear interpretation and could be considered less significant or redundant in an evolutionary context. Therefore, simplifying a DAG by â€œremovalâ€ of non-LCA vertices resulting in a DAG in which each vertex is a (unique) LCA of at least some leaves is a natural next step. We demonstrate that this transformation can be performed efficiently while preserving the structural integrity of the original DAG. The central questions considered here are as follows: 1. Is a given vertex a (unique) LCA of a specific, known subset AâŠ†Lâ¢(G)ğ´ğ¿ğºA\subseteq L(G)italic_A âŠ† italic_L ( italic_G )? 2. Is a given vertex a (unique) LCA of some unknown subset AâŠ†Lâ¢(G)ğ´ğ¿ğºA\subseteq L(G)italic_A âŠ† italic_L ( italic_G ), possibly with a prescribed size |A|ğ´|A|| italic_A |? 3. Can one characterize and recognize DAGs GğºGitalic_G in which every vertex is a (unique) LCA of some subset of Lâ¢(G)ğ¿ğºL(G)italic_L ( italic_G )? 4. Is it possible to efficiently remove all vertices from a DAG GğºGitalic_G that do not satisfy (1) or (2) and thus, to simplify GğºGitalic_G to a DAG in which each vertex is a (unique) LCA of some subset of Lâ¢(G)ğ¿ğºL(G)italic_L ( italic_G ) while preserving as many structural features of GğºGitalic_G as possible? We will address these problems from different perspectives. Numerous results have been established for Question 1 and 2 for the case |A|=2ğ´2|A|=2| italic_A | = 2 [29, 37, 4, 34, 8, 15, 5, 3, 28, 16], or when assuming that A=ğ™²Gâ¡(v)ğ´subscriptğ™²ğºğ‘£A=\operatorname{\mathtt{C}}_{G}(v)italic_A = typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) for a given vertex vğ‘£vitalic_v [35]. Figure 1: Shown are three networks Nğ‘Nitalic_N, Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT and Tğ‘‡Titalic_T. All have the same clustering system â„­={{x},{y},{z},{x,y},{x,y,z}}â„­ğ‘¥ğ‘¦ğ‘§ğ‘¥ğ‘¦ğ‘¥ğ‘¦ğ‘§\mathfrak{C}=\{\{x\},\{y\},\{z\},\{x,y\},\{x,y,z\}\}fraktur_C = { { italic_x } , { italic_y } , { italic_z } , { italic_x , italic_y } , { italic_x , italic_y , italic_z } } and leaf set X={x,y,z}ğ‘‹ğ‘¥ğ‘¦ğ‘§X=\{x,y,z\}italic_X = { italic_x , italic_y , italic_z }. Here, only Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT and Tğ‘‡Titalic_T are phylogenetic. The network Nğ‘Nitalic_N is not phylogenetic, since Nğ‘Nitalic_N contains the vertex uâ€²superscriptğ‘¢â€²u^{\prime}italic_u start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT with in- and out-degree one. Moreover, vertices uğ‘¢uitalic_u and uâ€²superscriptğ‘¢â€²u^{\prime}italic_u start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT in Nğ‘Nitalic_N are not LCAs of any subset of leaves. â€œRemovingâ€ uğ‘¢uitalic_u and uâ€²superscriptğ‘¢â€²u^{\prime}italic_u start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT from Nğ‘Nitalic_N â€“ as explained in detail in Section 6 â€“ yields the simplified network Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT in which all vertices are LCAs of some subset of Xğ‘‹Xitalic_X. Hence, Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT is LCALCA\operatorname{LCA}roman_LCA-Rel but not lcalca\operatorname{lca}roman_lca-Rel as the vertices vğ‘£vitalic_v and wğ‘¤witalic_w are not unique LCAs in Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT for any subset of Xğ‘‹Xitalic_X. If desired, Nâ€²superscriptğ‘â€²N^{\prime}italic_N start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT can now be further simplified by â€œremovingâ€ one of vğ‘£vitalic_v or wğ‘¤witalic_w resulting in the phylogenetic and lcalca\operatorname{lca}roman_lca-Rel tree Tğ‘‡Titalic_T. This paper is organized as follows. We start with introducing the basic definitions needed in Section 2. In Section 3, we define the notions of lcalca\operatorname{lca}roman_lca-Rel and LCALCA\operatorname{LCA}roman_LCA-Rel DAGs, as well as kğ‘˜kitalic_k-lcalca\operatorname{lca}roman_lca and kğ‘˜kitalic_k-LCALCA\operatorname{LCA}roman_LCA vertices. In short, a vertex vğ‘£vitalic_v is a kğ‘˜kitalic_k-LCALCA\operatorname{LCA}roman_LCA (resp., kğ‘˜kitalic_k-lcalca\operatorname{lca}roman_lca) in GğºGitalic_G if there exists a subset AâŠ†Lâ¢(G)ğ´ğ¿ğºA\subseteq L(G)italic_A âŠ† italic_L ( italic_G ) of size |A|=kğ´ğ‘˜|A|=k| italic_A | = italic_k such that vğ‘£vitalic_v is a LCA (resp., unique LCA) of the vertices in Ağ´Aitalic_A. As we will see, a vertex vğ‘£vitalic_v is a kğ‘˜kitalic_k-LCALCA\operatorname{LCA}roman_LCA vertex (resp., kğ‘˜kitalic_k-lcalca\operatorname{lca}roman_lca vertex) for some kğ‘˜kitalic_k precisely if vğ‘£vitalic_v is a LCA (resp., unique LCA) of the vertices in ğ™²Gâ¡(v)subscriptğ™²ğºğ‘£\operatorname{\mathtt{C}}_{G}(v)typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) (cf. Corollary 3.6). A DAG is LCALCA\operatorname{LCA}roman_LCA-Rel (resp., lcalca\operatorname{lca}roman_lca-Rel) if each of its vertices is a LCA (resp., unique LCA) for some subset Ağ´Aitalic_A. We then show that the set of least common ancestors of a set AâŠ†Lâ¢(G)ğ´ğ¿ğºA\subseteq L(G)italic_A âŠ† italic_L ( italic_G ) can be determined in linear time when |A|âˆˆOâ¢(1)ğ´ğ‘‚1|A|\in O(1)| italic_A | âˆˆ italic_O ( 1 ) is constant. Additionally, we demonstrate that recognizing lcalca\operatorname{lca}roman_lca-Rel and LCALCA\operatorname{LCA}roman_LCA-Rel DAGs can be done in polynomial time. In Section 4, we continue by characterizing lcalca\operatorname{lca}roman_lca-Rel and LCALCA\operatorname{LCA}roman_LCA-Rel DAGs. As shown in Theorem 4.4, LCALCA\operatorname{LCA}roman_LCA-Rel DAGs are precisely those DAGs that do not contain adjacent vertices uğ‘¢uitalic_u and vğ‘£vitalic_v with the same cluster, i.e., ğ™²Gâ¡(v)=ğ™²Gâ¡(u)subscriptğ™²ğºğ‘£subscriptğ™²ğºğ‘¢\operatorname{\mathtt{C}}_{G}(v)=\operatorname{\mathtt{C}}_{G}(u)typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) = typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u ). We then provide several characterizations of lcalca\operatorname{lca}roman_lca-Rel DAGs in Theorem 4.5. Among other results, lcalca\operatorname{lca}roman_lca-Rel DAGs are exactly those LCALCA\operatorname{LCA}roman_LCA-Rel DAGs with (PCC) property, meaning ğ™²Gâ¡(u)âŠ†ğ™²Gâ¡(v)subscriptğ™²ğºğ‘¢subscriptğ™²ğºğ‘£\operatorname{\mathtt{C}}_{G}(u)\subseteq\operatorname{\mathtt{C}}_{G}(v)typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_u ) âŠ† typewriter_C start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_v ) if and only if uğ‘¢uitalic_u is an ancestor of vğ‘£vitalic_v or vice versa. Moreover, we show a close connection between lcalca\operatorname{lca}roman_lca-Rel DAGs and so-called regular DAGs where the latter, loosely speaking, are DAGs that are completely determined by their set of clusters. In particular, lcalca\operatorname{lca}roman_lca-Rel DAGs with all shortcuts removed are regular (cf. Corollary 4.9). Novel characterizations of regular DAGs are presented in Theorem 4.10. Similar to phylogenetic trees, the number of vertices in lcalca\operatorname{lca}roman_lca-Rel DAGs GğºGitalic_G is bounded above by the number of leaves, see Lemma 4.12. Not all DAGs are lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel. Hence, the question arises whether one can transform a given DAG GğºGitalic_G into an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel DAG Hğ»Hitalic_H while preserving as much of the structure of GğºGitalic_G as possible. In Section 5, we provide an axiomatic framework for the phrase â€œpreserving as much structure of GğºGitalic_G as possibleâ€ resulting in five axioms (S1) â€“ (S5). These include, among other conditions, that the vertex set of Hğ»Hitalic_H is a subset of the vertex set of GğºGitalic_G, that the leaf-set Lâ¢(G)ğ¿ğºL(G)italic_L ( italic_G ) remains the set of leaves in Hğ»Hitalic_H and that the ancestor-relationship between the vertices in Hğ»Hitalic_H are consistent with those in GğºGitalic_G. This in turn implies an additional Condition (S0): no new clusters in Hğ»Hitalic_H are introduced. To transform a given DAG into an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel one, we introduce a simple operator âŠ–symmetric-difference\ominusâŠ– that acts on the vertices and edges of GğºGitalic_G [41]. Specifically, we denote with GâŠ–vsymmetric-differenceğºğ‘£G\ominus vitalic_G âŠ– italic_v the DAG obtained from GğºGitalic_G by removing vertex vğ‘£vitalic_v and its incident edges and connecting each parent of vğ‘£vitalic_v with each child of vğ‘£vitalic_v. Using this method, vertices vğ‘£vitalic_v can be removed stepwise from GğºGitalic_G, resulting in an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel DAG Hğ»Hitalic_H that satisfies the axioms (S1) â€“ (S5). In particular, we provide conditions under which the set Wğ‘ŠWitalic_W of vertices such that GâŠ–Wsymmetric-differenceğºğ‘ŠG\ominus Witalic_G âŠ– italic_W is lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel is uniquely determined and of minimum size. Furthermore, polynomial-time algorithms are given to transform any DAG into an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel one. The established algorithms are implemented in Python and hosted at GitHub [31]. Following [17], we discuss in Section 6 a general framework for any transformation Ï†â¢(G)ğœ‘ğº\varphi(G)italic_Ï† ( italic_G ) that â€œsimplifiesâ€ a DAG GğºGitalic_G, formalized through three axioms (P1) â€“ (P3). Given a suitable notion of restriction of DAGs, we show that the âŠ–symmetric-difference\ominusâŠ–-operator can be used to derive simplifications Ï†â¢(G)ğœ‘ğº\varphi(G)italic_Ï† ( italic_G ) that satisfy axioms (P1) â€“ (P3). We exemplify different types of simplification steps on a biological network with reticulation events that is based on a study of the Viola genus from Marcussen et al. [33]. While we have provided polynomial-time algorithms to verify whether a given DAG GğºGitalic_G is lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel and to transform GğºGitalic_G into an lcalca\operatorname{lca}roman_lca-Rel or LCALCA\operatorname{LCA}roman_LCA-Rel DAG if it is not, an open question remains: can it be decided in polynomial-time if a vertex vğ‘£vitalic_v is a kğ‘˜kitalic_k-lcalca\operatorname{lca}roman_lca or kğ‘˜kitalic_k-LCALCA\operatorname{LCA}roman_LCA vertex for a given kğ‘˜kitalic_k? In Section 7, we show that this problem is NP-complete in general. However, it becomes polynomial-time solvable for DAGs with the (N3O) property, i.e., DAGs that do not contain three pairwise overlapping clusters. Such DAGs are of particular interest, as they include important subclasses of phylogenetic networks, such as rooted phylogenetic trees and galled-trees. We close this paper with Section 8, where we summarize the main results and provide open problems for future work."
https://arxiv.org/html/2411.00343v1,Treewidth 2 in thePlanar Graph Product Structure Theorem,"We prove that every planar graph is contained in H_â¢1âŠ H_â¢2âŠ K_â¢2âŠ âŠ subscriptğ»_1subscriptğ»_2subscriptğ¾_2H_{\_}1\boxtimes H_{\_}2\boxtimes K_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 âŠ  italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 âŠ  italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 for some graphs H_â¢1subscriptğ»_1H_{\_}1italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 and H_â¢2subscriptğ»_2H_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 both with treewidth 2. This resolves a question of Liu, Norin and Wood [arXiv:2410.20333]. We also show this result is best possible in the following sense: for any câˆˆâ„•ğ‘â„•c\in\mathbb{N}italic_c âˆˆ blackboard_N, there is a planar graph GğºGitalic_G such that for any tree Tğ‘‡Titalic_T and graph Hğ»Hitalic_H with twâ¡(H)â©½2twğ»2\operatorname{tw}(H)\leqslant 2roman_tw ( italic_H ) â©½ 2, GğºGitalic_G is not contained in HâŠ TâŠ K_â¢câŠ ğ»ğ‘‡subscriptğ¾_ğ‘H\boxtimes T\boxtimes K_{\_}citalic_H âŠ  italic_T âŠ  italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT italic_c.","Graph product structure theory describes graphs in complicated graph classes as subgraphs of products of graphs in simpler graph classes, typically with bounded treewidth or bounded pathwidth. As defined in Section 2, the treewidth of a graph GğºGitalic_G, denoted by twâ¡(G)twğº\operatorname{tw}(G)roman_tw ( italic_G ), is the standard measure of how similar GğºGitalic_G is to a tree. As illustrated in Figure 1, the strong product AâŠ BâŠ ğ´ğµA\mathbin{\boxtimes}Bitalic_A âŠ  italic_B of graphs Ağ´Aitalic_A and BğµBitalic_B has vertex-set Vâ¢(A)Ã—Vâ¢(B)ğ‘‰ğ´ğ‘‰ğµV(A)\times V(B)italic_V ( italic_A ) Ã— italic_V ( italic_B ), where distinct vertices (v,x),(w,y)ğ‘£ğ‘¥ğ‘¤ğ‘¦(v,x),(w,y)( italic_v , italic_x ) , ( italic_w , italic_y ) are adjacent if: â€¢ v=wğ‘£ğ‘¤v=witalic_v = italic_w and xâ¢yâˆˆEâ¢(B)ğ‘¥ğ‘¦ğ¸ğµxy\in E(B)italic_x italic_y âˆˆ italic_E ( italic_B ), or â€¢ x=yğ‘¥ğ‘¦x=yitalic_x = italic_y and vâ¢wâˆˆEâ¢(A)ğ‘£ğ‘¤ğ¸ğ´vw\in E(A)italic_v italic_w âˆˆ italic_E ( italic_A ), or â€¢ vâ¢wâˆˆEâ¢(A)ğ‘£ğ‘¤ğ¸ğ´vw\in E(A)italic_v italic_w âˆˆ italic_E ( italic_A ) and xâ¢yâˆˆEâ¢(B)ğ‘¥ğ‘¦ğ¸ğµxy\in E(B)italic_x italic_y âˆˆ italic_E ( italic_B ). Figure 1: Strong product of two paths. The following Planar Graph Product Structure Theorem is the classical example of a graph product structure theorem. Here, a graph Hğ»Hitalic_H is contained in a graph GğºGitalic_G if Hğ»Hitalic_H is isomorphic to a subgraph of GğºGitalic_G, written HâŠ‚âˆ¼Gsimilar-toğ»ğºH\mathrel{\begin{subarray}{c}\textstyle\subset\\[-2.58334pt] \textstyle\sim\\[-1.72218pt] \end{subarray}}Gitalic_H start_RELOP start_ARG start_ROW start_CELL âŠ‚ end_CELL end_ROW start_ROW start_CELL âˆ¼ end_CELL end_ROW end_ARG end_RELOP italic_G. Theorem 1. For every planar graph GğºGitalic_G: (a) GâŠ‚âˆ¼HâŠ Psimilar-toğºâŠ ğ»ğ‘ƒG\mathrel{\begin{subarray}{c}\textstyle\subset\\[-2.58334pt] \textstyle\sim\\[-1.72218pt] \end{subarray}}H\mathbin{\boxtimes}Pitalic_G start_RELOP start_ARG start_ROW start_CELL âŠ‚ end_CELL end_ROW start_ROW start_CELL âˆ¼ end_CELL end_ROW end_ARG end_RELOP italic_H âŠ  italic_P for some graph Hğ»Hitalic_H with twâ¡(H)â©½6twğ»6\operatorname{tw}(H)\leqslant 6roman_tw ( italic_H ) â©½ 6 and path Pğ‘ƒPitalic_P [20], (b) GâŠ‚âˆ¼HâŠ PâŠ K_â¢2similar-toğºâŠ ğ»ğ‘ƒsubscriptğ¾_2G\mathrel{\begin{subarray}{c}\textstyle\subset\\[-2.58334pt] \textstyle\sim\\[-1.72218pt] \end{subarray}}H\mathbin{\boxtimes}P\mathbin{\boxtimes}K_{\_}2italic_G start_RELOP start_ARG start_ROW start_CELL âŠ‚ end_CELL end_ROW start_ROW start_CELL âˆ¼ end_CELL end_ROW end_ARG end_RELOP italic_H âŠ  italic_P âŠ  italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 for some graph Hğ»Hitalic_H with twâ¡(H)â©½4twğ»4\operatorname{tw}(H)\leqslant 4roman_tw ( italic_H ) â©½ 4 and path Pğ‘ƒPitalic_P [20], (c) GâŠ‚âˆ¼HâŠ PâŠ K_â¢3similar-toğºâŠ ğ»ğ‘ƒsubscriptğ¾_3G\mathrel{\begin{subarray}{c}\textstyle\subset\\[-2.58334pt] \textstyle\sim\\[-1.72218pt] \end{subarray}}H\mathbin{\boxtimes}P\mathbin{\boxtimes}K_{\_}3italic_G start_RELOP start_ARG start_ROW start_CELL âŠ‚ end_CELL end_ROW start_ROW start_CELL âˆ¼ end_CELL end_ROW end_ARG end_RELOP italic_H âŠ  italic_P âŠ  italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 3 for some graph Hğ»Hitalic_H with twâ¡(H)â©½3twğ»3\operatorname{tw}(H)\leqslant 3roman_tw ( italic_H ) â©½ 3 and path Pğ‘ƒPitalic_P [8]. DujmoviÄ‡ et al. [8] first proved Theorem 1(a) with twâ¡(H)â©½8twğ»8\operatorname{tw}(H)\leqslant 8roman_tw ( italic_H ) â©½ 8. In follow-up work, Ueckerdt et al. [20] improved the bound to twâ¡(H)â©½6twğ»6\operatorname{tw}(H)\leqslant 6roman_tw ( italic_H ) â©½ 6. Part (b) is due to DujmoviÄ‡, and is presented in [20]. Part (c) is in the original paper of DujmoviÄ‡ et al. [8]. Illingworth et al. [14] gave a new proof of part (c). Theorem 1 provides a powerful tool for studying questions about planar graphs, by reducing to graphs of bounded treewidth. Indeed, this result has been the key for resolving several open problems regarding queue layouts [8], nonrepetitive colourings [7], centred colourings [5], adjacency labelling schemes [11, 2, 10, 6], twin-width [3, 15], infinite graphs [13], and comparable box dimension [9]. In several of these applications, because the dependence on twâ¡(H)twğ»\operatorname{tw}(H)roman_tw ( italic_H ) is often exponential, the best bounds are obtained by applying the 3-term product in Theorem 1(c). The twâ¡(H)â©½3twğ»3\operatorname{tw}(H)\leqslant 3roman_tw ( italic_H ) â©½ 3 bound in Theorem 1(c) is best possible in any result saying that every planar graph is contained HâŠ PâŠ K_â¢câŠ ğ»ğ‘ƒsubscriptğ¾_ğ‘H\mathbin{\boxtimes}P\mathbin{\boxtimes}K_{\_}citalic_H âŠ  italic_P âŠ  italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT italic_c where Pğ‘ƒPitalic_P is a path (see [8]). Liu et al. [17] relaxed the assumption that Pğ‘ƒPitalic_P is a path, and studied products of two graphs of bounded treewidth. They asked whether every planar graph is contained in H_â¢1âŠ H_â¢2âŠ K_â¢câŠ âŠ subscriptğ»_1subscriptğ»_2subscriptğ¾_ğ‘H_{\_}1\mathbin{\boxtimes}H_{\_}2\mathbin{\boxtimes}K_{\_}citalic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 âŠ  italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 âŠ  italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT italic_c for some graphs H_â¢1subscriptğ»_1H_{\_}1italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 and H_â¢2subscriptğ»_2H_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 with twâ¡(H_â¢1)â©½2twsubscriptğ»_12\operatorname{tw}(H_{\_}1)\leqslant 2roman_tw ( italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 ) â©½ 2 and twâ¡(H_â¢2)â©½2twsubscriptğ»_22\operatorname{tw}(H_{\_}2)\leqslant 2roman_tw ( italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 ) â©½ 2. We answer this question in the affirmative. Theorem 2. Every planar graph GğºGitalic_G is contained in H_â¢1âŠ H_â¢2âŠ K_â¢2âŠ âŠ subscriptğ»_1subscriptğ»_2subscriptğ¾_2H_{\_}1\mathbin{\boxtimes}H_{\_}2\mathbin{\boxtimes}K_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 âŠ  italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 âŠ  italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 for some graphs H_â¢1subscriptğ»_1H_{\_}1italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 and H_â¢2subscriptğ»_2H_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 with twâ¡(H_â¢1)â©½2twsubscriptğ»_12\operatorname{tw}(H_{\_}1)\leqslant 2roman_tw ( italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 ) â©½ 2 and twâ¡(H_â¢2)â©½2twsubscriptğ»_22\operatorname{tw}(H_{\_}2)\leqslant 2roman_tw ( italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2 ) â©½ 2. We actually prove a strengthening of Theorem 2 that holds for a more general class of graphs GğºGitalic_G, and with a more precise statement about the structure of H_â¢1subscriptğ»_1H_{\_}1italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 1 and H_â¢2subscriptğ»_2H_{\_}2italic_H start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT 2; see Theorem 8 below. We also show that Theorem 2 is best possible in the following sense. Theorem 3. For any integer câ©¾1ğ‘1c\geqslant 1italic_c â©¾ 1 there is a planar graph GğºGitalic_G such that for any tree Tğ‘‡Titalic_T and graph Hğ»Hitalic_H with twâ¡(H)â©½2twğ»2\operatorname{tw}(H)\leqslant 2roman_tw ( italic_H ) â©½ 2, GğºGitalic_G is not contained in HâŠ TâŠ K_â¢câŠ ğ»ğ‘‡subscriptğ¾_ğ‘H\mathbin{\boxtimes}T\mathbin{\boxtimes}K_{\_}citalic_H âŠ  italic_T âŠ  italic_K start_POSTSUBSCRIPT _ end_POSTSUBSCRIPT italic_c."
