URL,Title,Abstract,Introduction
https://arxiv.org/html/2411.04949v1,Global Optimal Closed-Form Solutions forIntelligent Surfaces With Mutual Coupling:Is Mutual Coupling Detrimental or Beneficial?,"Reconfigurable Intelligent Surface (RIS) is a breakthrough technology enabling the dynamic control of the propagation environment in wireless communications through programmable surfaces. To improve the flexibility of conventional diagonal RIS (D-RIS), beyond diagonal RIS (BD-RIS) has emerged as a family of more general RIS architectures. However, D-RIS and BD-RIS have been commonly explored neglecting mutual coupling effects, while the global optimization of RIS with mutual coupling, its performance limits, and scaling laws remain unexplored. This study addresses these gaps by deriving global optimal closed-form solutions for BD-RIS with mutual coupling to maximize the channel gain, specifically fully- and tree-connected RISs. Besides, we provide the expression of the maximum channel gain achievable in the presence of mutual coupling and its scaling law in closed form. By using the derived scaling laws, we analytically prove that mutual coupling increases the channel gain on average under Rayleigh fading channels. Our theoretical analysis, confirmed by numerical simulations, shows that both fully- and tree-connected RISs with mutual coupling achieve the same channel gain upper bound when optimized with the proposed global optimal solutions. Furthermore, we observe that a mutual coupling-unaware optimization of RIS can cause a channel gain degradation of up to 5 dB.","Reconfigurable intelligent surface (RIS) is a breakthrough technology that allows dynamic control over the wireless channel in wireless systems [1]. A RIS is a surface made of numerous elements with reconfigurable scattering properties, able to steer the impinging electromagnetic (EM) signal toward the intended receiver. In a conventional RIS architecture, the RIS elements are not interconnected to each other, resulting in RIS being characterized by a diagonal phase shift matrix. To overcome this limitation of conventional RIS, also denoted as diagonal RIS (D-RIS), novel and more general RIS architectures have emerged under the name of beyond diagonal RIS (BD-RIS) [2]. The novelty introduced in BD-RIS is the presence of interconnections between the RIS elements, allowing the impinging waves to flow through the surface and the RIS to have a scattering matrix not constrained to be diagonal. Multiple BD-RIS architectures have been developed to offer advanced flexibility and performance over D-RIS [3, 4]. Among them, the fully-connected RIS offers the highest flexibility and performance since each RIS element is connected to all others via tunable impedance components [3]. To maintain high performance while decreasing the RIS circuit complexity, the tree-connected RIS has been proposed [4], which reduces the required number of tunable impedance components. Optimal BD-RIS architectures that effectively balance performance and circuit complexity have been investigated in [5], where the Pareto frontier of this trade-off has been characterized. Additionally, BD-RIS has been studied not only for performance enhancement but also to enable full-space coverage, leveraging architectures working in hybrid transmissive and reflective mode [6] and multi-sector mode [7]. Recent studies show the potential of BD-RIS in enabling novel applications, such as channel reciprocity attacks [8, 9], and prove the superiority of BD-RIS over D-RIS in single- and multi-user systems [10, 11]. Although the benefits of BD-RIS have been shown from multiple aspects [2, 3, 4, 5, 6, 7, 8, 9, 10, 11], previous works are based on idealized assumptions neglecting the impact of EM mutual coupling between the RIS elements. Mutual coupling refers to the EM interaction between the RIS elements. When a RIS element is excited with a current, it generates an EM field that can induce currents in neighboring elements, thereby altering their excitation. These mutual coupling effects at the RIS complicate the expression of the RIS-aided channel [12, 13, 14]. For this reason, mutual coupling is commonly neglected in the literature on D-RIS and BD-RIS. Nevertheless, mutual coupling is an intrinsic phenomenon depending on the geometry of the RIS, which can affect the RIS behavior. More importantly, not properly capturing it in the RIS-aided channel model during the RIS optimization can lead to performance degradation. Therefore, modeling and managing mutual coupling between the RIS elements is essential for maximizing the benefits of RIS. Recent works have modeled and optimized RIS-aided systems accounting for mutual coupling. Most literature focused on optimizing D-RIS with mutual coupling, in single-user systems [15, 16] as well as in multi-user systems [17, 18, 19, 20]. The impact of mutual coupling on the channel state information (CSI) acquisition has been investigated in [21, 22], while RIS optimization in the presence of mutual coupling and imperfect CSI has been considered in [23]. In [24], decoupling networks at the RIS array have been proposed as a potential solution for handling mutual coupling. Furthermore, in [25, 26], RIS-aided channels have been modeled accounting for the mutual coupling between the RIS elements and also the coupling induced by the presence of scattering objects. These channel models have been validated through EM simulations and experiments in [27] and [28], respectively. While the works [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28] focused on the modeling and optimization of D-RIS, [29] analyzed the impact of mutual coupling on BD-RIS architectures. Despite recent efforts in studying RIS with mutual coupling, two open challenges can be identified. First, existing mutual coupling-aware optimization algorithms suffer from a high computational complexity caused by the high number of iterations required to converge, which becomes prohibitive when the number of RIS elements increases. Second, given their iterative nature, their convergence is guaranteed only to a local optimum. Thus, an expression of the achievable channel gain of a RIS-aided system with mutual coupling remains unknown. To solve these two challenges, in this study, we derive global optimal closed-form solutions to maximize the channel gain of BD-RIS-aided systems with mutual coupling, applicable to the fully- and tree-connected RIS architectures. In addition, we characterize and compare the scaling laws of the channel gain in the presence and in the absence of mutual coupling. The contributions of this study can be summarized as follows. First, we globally optimize in closed-form fully-connected RISs to maximize the channel gain in the presence of mutual coupling. In addition, we provide the expression of the tight channel gain upper bound which is achievable by the proposed solution. Numerical results are presented to verify the global optimality of the proposed solution. Second, we show that it is also possible to optimize tree-connected RISs through a different global optimal closed-form solution and provide the expression of the achievable channel gain. We observe that tree-connected RISs achieve the same channel gain upper bound as fully-connected RISs in the presence of mutual coupling, while having a highly reduced circuit complexity. Numerical results confirm that fully- and tree-connected RISs can be globally optimized in closed-form in the presence of mutual coupling, to exactly achieve the same channel gain upper bound. Third, we derive the scaling laws of the average channel gain obtained by a fully- or tree-connected RIS in the presence and in the absence of mutual coupling, under Rayleigh fading channels. In the presence of mutual coupling, the scaling law is given as a closed-form function of the mutual coupling, while in the absence of mutual coupling, the scaling law is a function of the RIS antenna self-impedance and the number of RIS elements. Numerical results show the accuracy of the derived scaling laws even for practical values of the number of RIS elements. Fourth, we assess whether mutual coupling is detrimental or beneficial in improving the channel gain of a RIS-aided system. To this end, we prove that the derived scaling law of the channel gain under Rayleigh fading channels with mutual coupling is always higher than with no mutual coupling, for any value of the mutual coupling. Accordingly, we observe that stronger mutual coupling effects enable higher channel gains when they are accounted for by the proposed solutions. Organization: In Section II, we model a RIS-aided system with multiport network theory. In Section III, we derive a global optimal closed-form solution to optimize fully-connected RISs with mutual coupling. In Section IV, we provide a global optimal closed-form solution for tree-connected RISs with mutual coupling, achieving the same performance as fully-connected RISs. In Section V, we derive the scaling laws of the average channel gains achievable with fully- and tree-connected RISs, in the presence and in the absence of mutual coupling. In Section VI, we analytically assess the impact of mutual coupling on the average channel gain. In Section VII, we provide numerical results to evaluate the channel gain of a BD-RIS-aided system with mutual coupling. Finally, Section VIII concludes this work. Notation: Vectors and matrices are denoted with bold lower and bold upper letters, respectively. Scalars are represented with letters not in bold font. â„œâ¡{a}ğ‘\Re\{a\}roman_â„œ { italic_a }, â„‘â¡{a}ğ‘\Im\{a\}roman_â„‘ { italic_a }, |a|ğ‘|a|| italic_a |, argâ¡(a)ğ‘\arg(a)roman_arg ( italic_a ), and aâˆ—superscriptğ‘a^{*}italic_a start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT refer to the real part, imaginary part, modulus, phase, and conjugate of a complex scalar ağ‘aitalic_a, respectively. [ğš]isubscriptdelimited-[]ğšğ‘–[\mathbf{a}]_{i}[ bold_a ] start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and â€–ğšâ€–2subscriptnormğš2\|\mathbf{a}\|_{2}âˆ¥ bold_a âˆ¥ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT refer to the iğ‘–iitalic_ith element and l2subscriptğ‘™2l_{2}italic_l start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-norm of a vector ğšğš\mathbf{a}bold_a, respectively. ğ€âˆ—superscriptğ€\mathbf{A}^{*}bold_A start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT, ğ€Tsuperscriptğ€ğ‘‡\mathbf{A}^{T}bold_A start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT, ğ€Hsuperscriptğ€ğ»\mathbf{A}^{H}bold_A start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT, and [ğ€]i,jsubscriptdelimited-[]ğ€ğ‘–ğ‘—[\mathbf{A}]_{i,j}[ bold_A ] start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT refer to the conjugate, transpose, conjugate transpose, and (i,j)ğ‘–ğ‘—(i,j)( italic_i , italic_j )th element of a matrix ğ€ğ€\mathbf{A}bold_A, respectively. â„â„\mathbb{R}blackboard_R and â„‚â„‚\mathbb{C}blackboard_C denote the real and complex number sets, respectively. j=âˆ’1ğ‘—1j=\sqrt{-1}italic_j = square-root start_ARG - 1 end_ARG denotes the imaginary unit. ğŸ0\mathbf{0}bold_0 and ğˆğˆ\mathbf{I}bold_I denote an all-zero matrix and an identity matrix, respectively, with appropriate dimensions. ğ’â¢ğ’©â¢(0,Ïƒ2)ğ’ğ’©0superscriptğœ2\mathcal{CN}(0,\sigma^{2})caligraphic_C caligraphic_N ( 0 , italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) denotes the distribution of a circularly-symmetric complex Gaussian (CSCG) random variable whose real and imaginary parts are independent and Gaussian distributed with mean zero and variance Ïƒ2/2superscriptğœ22\sigma^{2}/2italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / 2. ğ’â¢ğ’©â¢(ğŸ,ğ‚)ğ’ğ’©0ğ‚\mathcal{CN}(\mathbf{0},\mathbf{C})caligraphic_C caligraphic_N ( bold_0 , bold_C ) denotes the distribution of a CSCG random vector with mean vector ğŸ0\mathbf{0}bold_0 and covariance matrix ğ‚ğ‚\mathbf{C}bold_C. diag(a1,â€¦,aN)subscriptğ‘1â€¦subscriptğ‘ğ‘(a_{1},\ldots,a_{N})( italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_a start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT ) refers to a diagonal matrix with diagonal elements being a1,â€¦,aNsubscriptğ‘1â€¦subscriptğ‘ğ‘a_{1},\ldots,a_{N}italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_a start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT."
https://arxiv.org/html/2411.04574v1,RIS-Assisted Space Shift Keying with Non-Ideal Transceivers and Greedy Detection,"Reconfigurable intelligent surfaces (RIS) and index modulation (IM) represent key technologies for enabling reliable wireless communication with high energy efficiency. However, to fully take advantage of these technologies in practical deployments, comprehending the impact of the non-ideal nature of the underlying transceivers is paramount. In this context, this paper introduces two RIS-assisted IM communication models, in which the RIS is part of the transmitter and space-shift keying (SSK) is employed for IM, and assesses their performance in the presence of hardware impairments. In the first model, the RIS acts as a passive reflector only, reflecting the oncoming SSK modulated signal intelligently towards the desired receive diversity branch/antenna. The second model employs RIS as a transmitter, employing Mğ‘€Mitalic_M-ary phase-shift keying for reflection phase modulation (RPM), and as a reflector for the incoming SSK modulated signal. Considering transmissions subjected to Nakagami-mğ‘šmitalic_m fading, and a greedy detection rule at the receiver, the performance of both the system configurations is evaluated. Specifically, the pairwise probability of erroneous index detection and the probability of erroneous index detection are adopted as performance metrics, and their closed-form expressions are derived for the RIS-assisted SSK and RIS-assisted SSK-RPM system models. Monte-Carlo simulation studies are carried out to verify the analytical framework, and numerical results are presented to study the dependency of the error performance on the system parameters. The findings highlight the effect of hardware impairment on the performance of the communication system under study. More specifically, minimal to no impact is observed on the system performance for low average SNR, while the effect is prominent for higher average SNR. The study emphasizes using such greedy detectors, which are robust to such practical system impairments.","The fifth-generation (5G) of wireless communication has brought about a fresh perspective on mobile communications, broadly addressing three use cases: enhanced mobile broadband, ultra-reliable and low-latency communications, and massive machine-type communications [1]. However, meeting the diverse requirements of these use cases with a single technology has proven to be quite challenging. This has inspired researchers to explore new techniques to prepare communication systems for such practical and futuristic applications. While the sixth-generation (6G) appears to build upon its 5G predecessor, the introduction of new user requirements, applications, use cases, and networking trends, are expected to present new challenges that necessitate the development of new communication paradigms, particularly at the physical layer [2, 3]. To address this, unconventional paradigms are gaining interest, aiming to intelligently control the properties of the propagation medium, such as scattering, reflection, and refraction. Recently, this has been supported by the swift progress in radio frequency micro-electro-mechanical systems that has led to the development of reconfigurable intelligent surfaces (RISs) consisting of programmable and reconfigurable meta-surfaces [4, 5]. The distinctive characteristic of RISs lies in their ability to modify the propagation medium between the transmitter(s) and the receiver(s). The unique nature of RISs, coupled with their ease of deployment in real-world scenarios, render them highly practical and suitable to integrate into future communication systems [6, 7, 8, 9]. The uniqueness of RISs also resides in their passive nature, which aids in achieving channel hardening similar to traditional multiple-input multiple-output (MIMO) techniques. Additionally, RIS-assisted systems exhibit lower implementation costs and complexity compared to MIMO communication systems [10, 11]. Moreover, the reflective properties of these surfaces can be manipulated through software, leading to their conceptualization as software-defined surfaces [12]. Some studies have also highlighted the complementary use of RISs and relays to exploit the advantages of both in beyond-5G network architectures [13]. The use of multiple or cascaded RISs to extend coverage and achieve quality-of-service was highlighted in [5, 14]. Furthermore, the authors in [15] suggested enhancements to RIS-based systems through the implementation of several modulation schemes in symbiotic communications. The authors in [16] delved into the examination of the ergodic capacity of a RIS-assisted multi-user multiple-input single-output communication system, considering practical statistical channel state information (CSI). Moreover, the paper [17] demonstrated the integration of RIS in terahertz communication by applying a deep reinforcement learning method. More recently, researchers explored using RIS as a part of the transmitter and showed significant merits as highlighted in [18, 19, 20]. Considering the merits of index modulation (IM) techniques, including the favorable trade-offs between spectral efficiency and energy efficiency that the systems can achieve, researchers have recently explored different RIS-aided IM communication models. IM refers to a family of modulation techniques that incorporates activation states to embed information in various domains including space, time, frequency, or a combination thereof [21]. The fundamental principle of IM consists in the partitioning of the information bits into index bits and constellation bits, with the index bits ascertaining the active radio resources (antennas and sub-carriers), while the constellation bits are utilized for mapping the constellation symbols to be carried by the active radio resources. Within this category, spatial modulation (SM), and space-shift keying (SSK) as a special case of SM, leverage the spatial-constellation diagram for the data modulation, providing low-complexity solutions for MIMO systems that surpass conventional modulation schemes [22]. While SM and SSK both operate on the same fundamental idea, SM-based systems are more complex due to the additional requirement of an amplitude/phase modulation technique. In SSK, the transmitter structure is simpler due to the non-requirement of additional modulation schemes, making it suitable for meeting the low-power and low-complexity requirements of IoT applications [23]. Furthermore, the study in [24] demonstrates an improved system efficiency and performance of an RIS-assisted SSK system as compared to an SSK system without using RIS. The RIS intelligently reflects the incoming SSK modulated signal, by optimizing the phase introduced by the RIS with the help of real-time CSI, thereby improving the quality of the received signal. Recently, a RIS-assisted SSK communication model has been proposed in [19], where the RIS acts as a transmitter in addition to reflecting the incoming signal from the source. This design reduces the information load on the transmitter compared to generic SM modulation systems by eliminating the need for complex oscillators and phase shifters. The sensor-embedded RIS controller collects environmental data, such as temperature and humidity, which is then modulated using discrete Mğ‘€Mitalic_M-ary phase-shift keying (PSK) symbols. These symbols are appended to the impinging SSK-modulated signals and transmitted as discrete phase shifts, known as reflection phase modulation (RPM), thus resulting in a RIS-assisted SSK-RPM scheme. Though RIS-assisted SSK and RIS-assisted SSK-RPM communication systems hold a great potential [9, 18], their true capabilities can only be understood by analyzing their performance in real-world conditions, particularly when the system transceivers are non-ideal [25], e.g., due to distortion noise [26]. Motivated by this, we consider a RIS-aided receive diversity IM system, where the transceiver pair is affected by practical hardware impairments. Two system models are accounted for in this study. In the first model, the transmitter uses SSK modulation to encode data with the RIS functioning only as a passive reflector. For the second model, the RIS acts as a transmitter for Mğ‘€Mitalic_M-PSK modulated symbols in addition to functioning as a reflector for the impinging SSK-modulated signal from the transmitter. The performance of these systems is evaluated for the symbols being transmitted via Nakagami-mğ‘šmitalic_m fading channels and the receiver employing a greedy rule for detecting the index of the receive diversity branch with the highest instantaneous received energy. Using the probability of erroneous index detection (PED) as a reliability metric, where we consider the erroneous selection of a receive diversity branch at the receiver over the other receive diversity branches, by utilizing the optimum RIS phase shifts for the considered receive diversity branch. The ensuing contributions consist in: â€¢ Finding the exact closed-form expressions for the PED reliability metric, by using a characteristic function (CF) based approach. â€¢ Deriving closed-form expressions for the bit error rate (BER) in both communication systems, based on the union bound technique and the obtained reliability metric. â€¢ Studying the effects of the impairments and other key parameters on the PED, via numerical results, and providing insights into the performance of both systems in practice. Next, section II introduces the communication model of the RIS-assisted SSK and RIS-assisted SSK-RPM with a sub-optimal greedy detector. In section III, we derive the closed-form expressions for the PED of the RIS-assisted SSK and the RIS-assisted SSK-RPM systems. The numerical results are presented in section IV, and section V concludes the paper. Notations ğ’â¢ğ’©â¢(Î¼,Ïƒ2)ğ’ğ’©ğœ‡superscriptğœ2{\mathcal{CN}}\left(\mu,\sigma^{2}\right)caligraphic_C caligraphic_N ( italic_Î¼ , italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) and ğ’©â¢(Î¼,Ïƒ2)ğ’©ğœ‡superscriptğœ2{\mathcal{N}}\left(\mu,\sigma^{2}\right)caligraphic_N ( italic_Î¼ , italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) respectively represent the distribution of a complex Gaussian and a real Gaussian random variable, with mean Î¼ğœ‡\muitalic_Î¼ and variance Ïƒ2superscriptğœ2\sigma^{2}italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. The notation |â‹…|\left|\cdot\right|| â‹… | indicates the modulus operator, Eâ¢[â‹…]Edelimited-[]â‹…\mbox{\bf{E}}\left[\cdot\right]E [ â‹… ] outputs the statistical expectation, â„œâ¡{â‹…}â‹…\Re\left\{\cdot\right\}roman_â„œ { â‹… } and â„‘â¡{â‹…}â‹…\Im\left\{\cdot\right\}roman_â„‘ { â‹… } denote the real-part and imaginary-part operators, respectively, Î“â¢(â‹…)Î“â‹…\Gamma(\cdot)roman_Î“ ( â‹… ) denotes the Gamma function, and È·=âˆ’1italic-È·1\jmath=\sqrt{-1}italic_È· = square-root start_ARG - 1 end_ARG."
https://arxiv.org/html/2411.04447v1,Self-orthogonal codes from plateaued functions,"Self-orthogonal codes are of interest as they have important applications in quantum codes, lattices and many areas. In this paper, based on the weakly regular plateaued functions or plateaued Boolean functions, we construct a family of linear codes with four nonzero weights. This family of linear codes is proved to be not only self-orthogonal but also optimally or almost optimally extendable. Besides, we derive binary and ternary linearly complementary dual codes (LCD codes for short) with new parameters from this family of codes. Some families of self-dual codes are also obtained as byproducts.","Let ğ”½qsubscriptğ”½ğ‘{\mathbb{F}}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT be the finite field with qğ‘qitalic_q elements, where qğ‘qitalic_q is a power of a prime pğ‘pitalic_p. Let ğ”½qâˆ—:=ğ”½q\{0}assignsuperscriptsubscriptğ”½ğ‘\subscriptğ”½ğ‘0{\mathbb{F}}_{q}^{*}:={\mathbb{F}}_{q}\backslash\{0\}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT := blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT \ { 0 }. 1.1 Linear codes and self-orthogonal codes Let n,k,dğ‘›ğ‘˜ğ‘‘n,k,ditalic_n , italic_k , italic_d be three positive integers. For a nonempty set ğ’âŠ†ğ”½qnğ’superscriptsubscriptğ”½ğ‘ğ‘›{\mathcal{C}}\subseteq{\mathbb{F}}_{q}^{n}caligraphic_C âŠ† blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, if ğ’ğ’{\mathcal{C}}caligraphic_C is a kğ‘˜kitalic_k-dimensional linear subspace of ğ”½qnsuperscriptsubscriptğ”½ğ‘ğ‘›{\mathbb{F}}_{q}^{n}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, then it is called an [n,k,d]ğ‘›ğ‘˜ğ‘‘[n,k,d][ italic_n , italic_k , italic_d ] linear code over ğ”½qsubscriptğ”½ğ‘\mathbb{F}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT, where dğ‘‘ditalic_d denotes its minimum distance. Let Aisubscriptğ´ğ‘–A_{i}italic_A start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT be the number of codewords with weight iğ‘–iitalic_i in a linear code ğ’ğ’{\mathcal{C}}caligraphic_C of length nğ‘›nitalic_n, where 0â‰¤iâ‰¤n0ğ‘–ğ‘›0\leq i\leq n0 â‰¤ italic_i â‰¤ italic_n. The sequence (1,A1,A2,â‹¯,An)1subscriptğ´1subscriptğ´2â‹¯subscriptğ´ğ‘›(1,A_{1},A_{2},\cdots,A_{n})( 1 , italic_A start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_A start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , â‹¯ , italic_A start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) is called the weight distribution of ğ’ğ’{\mathcal{C}}caligraphic_C and the polynomial Aâ¢(z)=1+A1â¢z+A2â¢z2+â‹¯+Anâ¢znğ´ğ‘§1subscriptğ´1ğ‘§subscriptğ´2superscriptğ‘§2â‹¯subscriptğ´ğ‘›superscriptğ‘§ğ‘›A(z)=1+A_{1}z+A_{2}z^{2}+\cdots+A_{n}{z^{n}}italic_A ( italic_z ) = 1 + italic_A start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT italic_z + italic_A start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_z start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + â‹¯ + italic_A start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT italic_z start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is referred to as the weight enumerator of ğ’ğ’{\mathcal{C}}caligraphic_C. Weight distribution is a significant research subject as it not only describes the error detection and error correction abilities of the code, but also can be used to calculate the error probabilities of error detection and correction of the code. The weight distributions of some linear codes were studied in the literature [11, 20, 32, 33]. Optimal linear codes play an important role in both theory and practice. An [n,k,d]ğ‘›ğ‘˜ğ‘‘[n,k,d][ italic_n , italic_k , italic_d ] linear code ğ’ğ’{\mathcal{C}}caligraphic_C over ğ”½qsubscriptğ”½ğ‘{\mathbb{F}}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT is said to be optimal if there does not exist [n,k,d+1]ğ‘›ğ‘˜ğ‘‘1[n,k,d+1][ italic_n , italic_k , italic_d + 1 ] linear code over ğ”½qsubscriptğ”½ğ‘{\mathbb{F}}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT and almost optimal if there exists an [n,k,d+1]ğ‘›ğ‘˜ğ‘‘1[n,k,d+1][ italic_n , italic_k , italic_d + 1 ] optimal code over ğ”½qsubscriptğ”½ğ‘{\mathbb{F}}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT. The following is the well-known sphere-packing bound on the parameters of codes. Lemma 1. [18, Sphere-packing bound] Let Mğ‘€Mitalic_M be the maximum number of codewords in a code over ğ”½qsubscriptğ”½ğ‘{\mathbb{F}}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT of length nğ‘›nitalic_n and minimum distance dğ‘‘ditalic_d. Then Mâ‰¤qmâˆ‘i=0t(mi)â¢(qâˆ’1)i,ğ‘€superscriptğ‘ğ‘šsuperscriptsubscriptğ‘–0ğ‘¡binomialğ‘šğ‘–superscriptğ‘1ğ‘–\displaystyle M\leq\frac{q^{m}}{\sum\limits_{i=0}^{t}\tbinom{m}{i}(q-1)^{i}},italic_M â‰¤ divide start_ARG italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT end_ARG start_ARG âˆ‘ start_POSTSUBSCRIPT italic_i = 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT ( FRACOP start_ARG italic_m end_ARG start_ARG italic_i end_ARG ) ( italic_q - 1 ) start_POSTSUPERSCRIPT italic_i end_POSTSUPERSCRIPT end_ARG , where t=âŒŠ(dâˆ’1)/2âŒ‹ğ‘¡ğ‘‘12t=\lfloor(d-1)/2\rflooritalic_t = âŒŠ ( italic_d - 1 ) / 2 âŒ‹ and âŒŠâ‹…âŒ‹â‹…\lfloor\cdot\rfloorâŒŠ â‹… âŒ‹ denotes the floor function. Define the dual code of an [n,k]ğ‘›ğ‘˜[n,k][ italic_n , italic_k ] linear code ğ’ğ’{\mathcal{C}}caligraphic_C by ğ’âŸ‚={ğ®âˆˆğ”½qn:âŸ¨ğ®,ğ¯âŸ©=ğŸâ¢ for all â¢ğ¯âˆˆğ’},superscriptğ’perpendicular-toconditional-setğ®superscriptsubscriptğ”½ğ‘ğ‘›ğ®ğ¯0 for all ğ¯ğ’\mathcal{C}^{\perp}=\left\{\mathbf{u}\in\mathbb{F}_{q}^{n}:\langle\mathbf{u},% \mathbf{v}\rangle=\mathbf{0}\mbox{ for all }\mathbf{v}\in\mathcal{C}\right\},caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT = { bold_u âˆˆ blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT : âŸ¨ bold_u , bold_v âŸ© = bold_0 for all bold_v âˆˆ caligraphic_C } , where âŸ¨â‹…âŸ©delimited-âŸ¨âŸ©â‹…\langle\cdot\rangleâŸ¨ â‹… âŸ© denotes the standard inner product. Then ğ’âŸ‚superscriptğ’perpendicular-to{\mathcal{C}}^{\perp}caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT is a linear code with length nğ‘›nitalic_n and dimension nâˆ’kğ‘›ğ‘˜n-kitalic_n - italic_k. If ğ’âŠ†ğ’âŸ‚ğ’superscriptğ’perpendicular-to{\mathcal{C}}\subseteq{\mathcal{C}}^{\perp}caligraphic_C âŠ† caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT, then ğ’ğ’{\mathcal{C}}caligraphic_C is called a self-orthogonal code. In particular, if ğ’=ğ’âŸ‚ğ’superscriptğ’perpendicular-to{\mathcal{C}}={\mathcal{C}}^{\perp}caligraphic_C = caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT, then ğ’ğ’{\mathcal{C}}caligraphic_C is said to be self-dual. Self-orthogonal codes have nice applications in lattices [37], linear complementary dual codes (LCD codes for short) [26], quantum codes [6] and so on. For a given qğ‘qitalic_q-ary linear code ğ’ğ’{\mathcal{C}}caligraphic_C, it is natural to study whether it is self-orthogonal or not. If q=2,3ğ‘23q=2,3italic_q = 2 , 3, the following provides simple conditions for a linear code to be self-orthogonal by the divisibility of its weights. Lemma 2. [18, Theorems 1.4.8 and 1.4.10 ] Let ğ’ğ’{\mathcal{C}}caligraphic_C be a linear code over ğ”½psubscriptğ”½ğ‘{\mathbb{F}}_{p}blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT. For p=2ğ‘2p=2italic_p = 2, if every codeword of ğ’ğ’{\mathcal{C}}caligraphic_C has weight divisible by four, then ğ’ğ’{\mathcal{C}}caligraphic_C is self-orthogonal. For p=3ğ‘3p=3italic_p = 3, ğ’ğ’{\mathcal{C}}caligraphic_C is self-orthogonal if and only if every codeword of ğ’ğ’{\mathcal{C}}caligraphic_C has weight divisible by three. Recently, Li and Heng established a sufficient condition for a qğ‘qitalic_q-ary linear code containing the all-1 vector to be self-orthogonal if qğ‘qitalic_q is a power of an odd prime [19]. Lemma 3. [19] Let qğ‘qitalic_q be a power of pğ‘pitalic_p. where pğ‘pitalic_p is an odd prime. Let ğ’ğ’\mathcal{C}caligraphic_C be an [n,k,d]ğ‘›ğ‘˜ğ‘‘[n,k,d][ italic_n , italic_k , italic_d ] linear code over ğ”½qsubscriptğ”½ğ‘{\mathbb{F}}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT with ğŸâˆˆğ’,1ğ’\mathbf{1}\in{\mathcal{C}},bold_1 âˆˆ caligraphic_C , where ğŸ1\mathbf{1}bold_1 is all-1 vector of length nğ‘›nitalic_n. If ğ’ğ’{\mathcal{C}}caligraphic_C is pğ‘pitalic_p-divisible, then ğ’ğ’{\mathcal{C}}caligraphic_C is self-orthogonal. The following lemmas show that we can derive self-dual codes from self-orthogonal codes. These self-dual codes are the subcodes of the duals of the self-orthogonal codes. Lemma 4. [4, Proposition 4.5] Let qğ‘qitalic_q be a power of 2222. A linear code ğ’âŠ†ğ”½qnğ’superscriptsubscriptğ”½ğ‘ğ‘›{\mathcal{C}}\subseteq\mathbb{F}_{q}^{n}caligraphic_C âŠ† blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT of dimension kâ‰¥n2ğ‘˜ğ‘›2k\geq\frac{n}{2}italic_k â‰¥ divide start_ARG italic_n end_ARG start_ARG 2 end_ARG contains a self-dual subcode if and only if nğ‘›nitalic_n is even and ğ’âŸ‚superscriptğ’perpendicular-to{\mathcal{C}}^{\perp}caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT is self-orthogonal, that is, ğ’âŸ‚âŠ†ğ’.superscriptğ’perpendicular-toğ’{\mathcal{C}}^{\perp}\subseteq{\mathcal{C}}.caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT âŠ† caligraphic_C . Lemma 5. [4, Proposition 4.6] Let ğ’âŠ†ğ”½qnğ’superscriptsubscriptğ”½ğ‘ğ‘›{\mathcal{C}}\subseteq\mathbb{F}_{q}^{n}caligraphic_C âŠ† blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT be a linear code of dimension kâ‰¥n2ğ‘˜ğ‘›2k\geq\frac{n}{2}italic_k â‰¥ divide start_ARG italic_n end_ARG start_ARG 2 end_ARG. (1) If qâ‰¡1(mod4)ğ‘annotated1pmod4q\equiv 1\pmod{4}italic_q â‰¡ 1 start_MODIFIER ( roman_mod start_ARG 4 end_ARG ) end_MODIFIER, then ğ’ğ’{\mathcal{C}}caligraphic_C contains a self-dual subcode if and only if nğ‘›nitalic_n is even and ğ’âŸ‚superscriptğ’perpendicular-to{\mathcal{C}}^{\perp}caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT is self-orthogonal. (2) If qâ‰¡3(mod4)ğ‘annotated3pmod4q\equiv 3\pmod{4}italic_q â‰¡ 3 start_MODIFIER ( roman_mod start_ARG 4 end_ARG ) end_MODIFIER, then ğ’ğ’{\mathcal{C}}caligraphic_C contains a self-dual subcode if and only if nâ‰¡0(mod4)ğ‘›annotated0pmod4n\equiv 0\pmod{4}italic_n â‰¡ 0 start_MODIFIER ( roman_mod start_ARG 4 end_ARG ) end_MODIFIER and ğ’âŸ‚superscriptğ’perpendicular-to{\mathcal{C}}^{\perp}caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT is self-orthogonal. 1.2 LCD codes An [n,k,d]ğ‘›ğ‘˜ğ‘‘[n,k,d][ italic_n , italic_k , italic_d ] linear code ğ’ğ’{\mathcal{C}}caligraphic_C is called an Euclidean LCD code if ğ’âˆ©ğ’âŸ‚={ğŸ}ğ’superscriptğ’perpendicular-to0{\mathcal{C}}\cap{\mathcal{C}}^{\perp}=\{\mathbf{0}\}caligraphic_C âˆ© caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT = { bold_0 }, where ğŸ0\mathbf{0}bold_0 denotes the zero vector of length nğ‘›nitalic_n. In [24], Massey introduced the definition and gave the algebraic characterization of LCD codes. He also proved the existence of asymptotically good LCD codes and provided an optimum linear coding solution for the two-user binary adder channel. In [31], Sendrier showed that LCD codes satisfy the asymptotic Gilbert-Varshamov bound. LCD codes have nice applications in lattices, network coding, and multisecret-sharing schemes [1, 3, 13]. Besides, LCD codes also have application in counter-measures to passive and active side channel analyses on embedded cryptosystems. Many families of LCD codes have been constructed in [34, 23]. The existence of qğ‘qitalic_q-ary (q>3)ğ‘3(q>3)( italic_q > 3 ) Euclidean LCD codes has been studied in [8]. However, the existence of binary and ternary Euclidean LCD codes has not been totally investigated. Self-orthogonal codes can be used to construct LCD codes. It is known that a generator matrix GğºGitalic_G of an [n,k,d]ğ‘›ğ‘˜ğ‘‘[n,k,d][ italic_n , italic_k , italic_d ] self-orthogonal code satisfies Gâ¢GT=ğŸk,kğºsuperscriptğºğ‘‡subscript0ğ‘˜ğ‘˜GG^{T}=\mathbf{0}_{k,k}italic_G italic_G start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT = bold_0 start_POSTSUBSCRIPT italic_k , italic_k end_POSTSUBSCRIPT, where ğŸk,ksubscript0ğ‘˜ğ‘˜\mathbf{0}_{k,k}bold_0 start_POSTSUBSCRIPT italic_k , italic_k end_POSTSUBSCRIPT denotes the zero matrix of size kÃ—kğ‘˜ğ‘˜k\times kitalic_k Ã— italic_k. In other words, GğºGitalic_G is row-self-orthogonal. The following lemma shows how to construct leading-systematic codes from a row-self-orthogonal matrix, where a linear code is said to be leading-systematic if and only if it has a generator matrix of the form G=[I:P]G=[I:P]italic_G = [ italic_I : italic_P ] for an identity matrix Iğ¼Iitalic_I. Lemma 6. [26] A leading-systematic linear code ğ’ğ’{\mathcal{C}}caligraphic_C with systematic generator matrix G:=[I:P]G:=[I:P]italic_G := [ italic_I : italic_P ] is an LCD code if (but not only if) the matrix Pğ‘ƒPitalic_P is row-self-orthogonal, where Iğ¼Iitalic_I denotes an identity matrix. Note that a self-orthogonal code has many different generator matrices. If P1subscriptğ‘ƒ1P_{1}italic_P start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and P2subscriptğ‘ƒ2P_{2}italic_P start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT are two different generator matrices of a self-orthogonal code ğ’ğ’{\mathcal{C}}caligraphic_C, then G1:=[I:P1]G_{1}:=[I:P_{1}]italic_G start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT := [ italic_I : italic_P start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ] and G2:=[I:P2]G_{2}:=[I:P_{2}]italic_G start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT := [ italic_I : italic_P start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ] may generate two inequivalent LCD codes. Finding a suitable generator matrix Pğ‘ƒPitalic_P such that G=[I:P]G=[I:P]italic_G = [ italic_I : italic_P ] generate an LCD code with large minimum distance, whose dual also have large minimum distance, is important. 1.3 Optimally and almost optimally extendable codes In [2], Bringer et al. introduced a direct sum masking (DSM) countermeasure to oppose side channel attack (SCA) and fault injection attack (FIA) which have brought great threats to the implementation of block cipher. It needs two linear codes ğ’ğ’{\mathcal{C}}caligraphic_C and ğ’Ÿğ’Ÿ{\mathcal{D}}caligraphic_D satisfying ğ’â¢â¨ğ’Ÿ=ğ”½qnğ’direct-sumğ’Ÿsuperscriptsubscriptğ”½ğ‘ğ‘›{\mathcal{C}}\bigoplus{\mathcal{D}}={\mathbb{F}}_{q}^{n}caligraphic_C â¨ caligraphic_D = blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, where ğ’ğ’{\mathcal{C}}caligraphic_C and ğ’Ÿğ’Ÿ{\mathcal{D}}caligraphic_D are used to encode the sensitive data and encode random data, respectively. In particular, if ğ’Ÿ=ğ’âŸ‚ğ’Ÿsuperscriptğ’perpendicular-to{\mathcal{D}}={\mathcal{C}}^{\perp}caligraphic_D = caligraphic_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT, then ğ’ğ’{\mathcal{C}}caligraphic_C is an LCD code. For a general pair (ğ’,ğ’Ÿ)ğ’ğ’Ÿ({\mathcal{C}},{\mathcal{D}})( caligraphic_C , caligraphic_D ) satisfying ğ’â¢â¨ğ’Ÿ=ğ”½qnğ’direct-sumğ’Ÿsuperscriptsubscriptğ”½ğ‘ğ‘›{\mathcal{C}}\bigoplus{\mathcal{D}}={\mathbb{F}}_{q}^{n}caligraphic_C â¨ caligraphic_D = blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, it is desirable to change ğ’ğ’{\mathcal{C}}caligraphic_C and ğ’Ÿğ’Ÿ{\mathcal{D}}caligraphic_D into ğ’â€²superscriptğ’â€²{\mathcal{C}}^{\prime}caligraphic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT and ğ’Ÿâ€²superscriptğ’Ÿâ€²{\mathcal{D}}^{\prime}caligraphic_D start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT to protect the sensitive data stored in the register from SCA and FIA, where ğ’â€²superscriptğ’â€²{\mathcal{C}}^{\prime}caligraphic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT is obtained by adding kğ‘˜kitalic_k bits of zeros to the end of each codeword in ğ’ğ’{\mathcal{C}}caligraphic_C and ğ’Ÿâ€²superscriptğ’Ÿâ€²{\mathcal{D}}^{\prime}caligraphic_D start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT is derived by appending the identity matrix at the end of the generator matrix of ğ’Ÿâ€²superscriptğ’Ÿâ€²{\mathcal{D}}^{\prime}caligraphic_D start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT. If dâ¢(ğ’Ÿâ€²âŸ‚)=dâ¢(ğ’ŸâŸ‚)ğ‘‘superscriptsuperscriptğ’Ÿâ€²perpendicular-toğ‘‘superscriptğ’Ÿperpendicular-tod({{\mathcal{D}}^{\prime}}^{\perp})=d({\mathcal{D}}^{\perp})italic_d ( caligraphic_D start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT ) = italic_d ( caligraphic_D start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT ), then ğ’Ÿğ’Ÿ{\mathcal{D}}caligraphic_D is said to be optimally extendable. ğ’Ÿğ’Ÿ{\mathcal{D}}caligraphic_D is said to be almost optimally extendable if dâ¢(ğ’Ÿâ€²â£âŸ‚)=dâ¢(ğ’ŸâŸ‚)âˆ’1ğ‘‘superscriptğ’Ÿâ€²perpendicular-toğ‘‘superscriptğ’Ÿperpendicular-to1d({\mathcal{D}}^{\prime\perp})=d({\mathcal{D}}^{\perp})-1italic_d ( caligraphic_D start_POSTSUPERSCRIPT â€² âŸ‚ end_POSTSUPERSCRIPT ) = italic_d ( caligraphic_D start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT ) - 1. In the literature, there are only a few known constructions of optimally or almost optimally extendable codes. Carlet, Li and Mesnager gave two families of optimally extendable linear codes and two families of almost optimally extendable linear codes from the first-order Reed-Muller codes and irreducible cyclic codes of dimension two [7]. Quan, Yue and Hu studied (almost) optimally extendable linear codes from irreducible cyclic codes, MDS codes and NMDS codes [29]. In [36], Wang, Heng, Li and Yue constructed some families of almost optimally extendable codes from self-orthogonal codes. In [12], Heng, Li, Wu and Wang constructed two families of optimally or almost optimally extendable codes from some functions over finite fields. 1.4 The purpose of this paper The purpose of this paper is to construct linear codes from weakly regular plateaued functions over finite fields. Let pğ‘pitalic_p be an odd prime and fâ¢(x)ğ‘“ğ‘¥f(x)italic_f ( italic_x ) be a function from ğ”½qsubscriptğ”½ğ‘{\mathbb{F}}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT to ğ”½psubscriptğ”½ğ‘{\mathbb{F}}_{p}blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT with fâ¢(0)=0ğ‘“00f(0)=0italic_f ( 0 ) = 0. We define a pğ‘pitalic_p-ary linear code as ğ’fÂ¯={ğœ(a,b,c)=(aâ¢fâ¢(x)+Trq/pâ¢(bâ¢x)+c)xâˆˆğ”½q:aâˆˆğ”½p,bâˆˆğ”½q,câˆˆğ”½p}.Â¯subscriptğ’ğ‘“conditional-setsubscriptğœğ‘ğ‘ğ‘subscriptğ‘ğ‘“ğ‘¥subscriptTrğ‘ğ‘ğ‘ğ‘¥ğ‘ğ‘¥subscriptğ”½ğ‘formulae-sequenceğ‘subscriptğ”½ğ‘formulae-sequenceğ‘subscriptğ”½ğ‘ğ‘subscriptğ”½ğ‘\displaystyle{\overline{{\mathcal{C}}_{f}}}=\left\{{\mathbf{c}}_{{(a,b,c)}}=(% af(x)+{\mathrm{Tr}}_{q/p}(bx)+c)_{x\in{\mathbb{F}}_{q}}:a\in{\mathbb{F}}_{p},b% \in{\mathbb{F}}_{q},c\in{\mathbb{F}}_{p}\right\}.overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG = { bold_c start_POSTSUBSCRIPT ( italic_a , italic_b , italic_c ) end_POSTSUBSCRIPT = ( italic_a italic_f ( italic_x ) + roman_Tr start_POSTSUBSCRIPT italic_q / italic_p end_POSTSUBSCRIPT ( italic_b italic_x ) + italic_c ) start_POSTSUBSCRIPT italic_x âˆˆ blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT end_POSTSUBSCRIPT : italic_a âˆˆ blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT , italic_b âˆˆ blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT , italic_c âˆˆ blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT } . (1) We remark that ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG is the augmented code of the extended code of ğ’fâˆ—={ğœ(a,b)=(aâ¢fâ¢(x)+Trq/pâ¢(bâ¢x))xâˆˆğ”½qâˆ—:aâˆˆğ”½p,bâˆˆğ”½q}.superscriptsubscriptğ’ğ‘“conditional-setsubscriptğœğ‘ğ‘subscriptğ‘ğ‘“ğ‘¥subscriptTrğ‘ğ‘ğ‘ğ‘¥ğ‘¥superscriptsubscriptğ”½ğ‘formulae-sequenceğ‘subscriptğ”½ğ‘ğ‘subscriptğ”½ğ‘\displaystyle{\mathcal{C}}_{f}^{*}=\left\{{\mathbf{c}}_{(a,b)}=(af(x)+{\mathrm% {Tr}}_{q/p}(bx))_{x\in{\mathbb{F}}_{q}^{*}}:a\in{\mathbb{F}}_{p},b\in{\mathbb{% F}}_{q}\right\}.caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT = { bold_c start_POSTSUBSCRIPT ( italic_a , italic_b ) end_POSTSUBSCRIPT = ( italic_a italic_f ( italic_x ) + roman_Tr start_POSTSUBSCRIPT italic_q / italic_p end_POSTSUBSCRIPT ( italic_b italic_x ) ) start_POSTSUBSCRIPT italic_x âˆˆ blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT end_POSTSUBSCRIPT : italic_a âˆˆ blackboard_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT , italic_b âˆˆ blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT } . (2) When fğ‘“fitalic_f is a weakly regular bent function, the code ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG was studied in [12]. In this paper, we mainly study the parameters and weight distribution of ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG and prove the following if fğ‘“fitalic_f is a weakly regular plateaued function: âˆ™âˆ™\bulletâˆ™ ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG is self-orthogonal; âˆ™âˆ™\bulletâˆ™ ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG is optimally or almost optimally extendable if we select a suitable generator matrix of ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG. Besides, we also derive ternary LCD codes from ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG. Moreover, if fğ‘“fitalic_f is a plateaued Boolean function, we also prove that ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG is self-orthogonal and determine their parameters and weight distribution. The binary code ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG is proved to be almost optimally extendable. We also use the binary code ğ’fÂ¯Â¯subscriptğ’ğ‘“\overline{{\mathcal{C}}_{f}}overÂ¯ start_ARG caligraphic_C start_POSTSUBSCRIPT italic_f end_POSTSUBSCRIPT end_ARG to construct a family of binary LCD codes. Finally, we obtain some families of self-dual codes from the duals of the self-orthogonal codes in this paper."
https://arxiv.org/html/2411.04445v1,"Large Sets of Asymptotically Optimal and Near-Optimal Quasi-ComplementarySequencesâ€ â€ thanks:Z. Hengâ€™s research was supported in part by the National Natural Science Foundation of China under Grant 12271059, in part by the Shaanxi Fundamental
Science Research Project for Mathematics and Physics (Grant No. 23JSZ008), in part by the open research fund of National Mobile Communications
Research Laboratory of Southeast University under Grant 2024D10 and in part by the Research Funds for the Interdisciplinary Projects, CHU, under Grant 300104240922. C. Xieâ€™s research was supported by the Shaanxi Provincial Key Research and Development Program under Grant 2023-YBGY-042. H. Zhouâ€™s research was supported by the National Natural Science Foundation of China under Grant 12471493.","Perfect complementary sequence sets (PCSSs) are widely used in multi-carrier code-division multiple-access (MC-CDMA) communication system. However, the set size of a PCSS is upper bounded by the number of row sequences of each two-dimensional matrix in PCSS. Then quasi-complementary sequence set (QCSS) was proposed to support more users in MC-CDMA communications. For practical applications, it is desirable to construct an (M,K,N,Ï‘mâ¢aâ¢x)ğ‘€ğ¾ğ‘subscriptitalic-Ï‘ğ‘šğ‘ğ‘¥(M,K,N,\vartheta_{max})( italic_M , italic_K , italic_N , italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT )-QCSS with Mğ‘€Mitalic_M as large as possible and Ï‘mâ¢aâ¢xsubscriptitalic-Ï‘ğ‘šğ‘ğ‘¥\vartheta_{max}italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT as small as possible, where Mğ‘€Mitalic_M is the number of matrices with Kğ¾Kitalic_K rows and Nğ‘Nitalic_N columns in the set and Ï‘mâ¢aâ¢xsubscriptitalic-Ï‘ğ‘šğ‘ğ‘¥\vartheta_{max}italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT denotes its periodic tolerance. There exists a tradoff among these parameters and constructing QCSSs achieving or nearly achieving the known correlation lower bound has been an interesting research topic. Up to now, only a few constructions of asymptotically optimal or near-optimal periodic QCSSs were reported in the literature. In this paper, we construct five families of asymptotically optimal or near-optimal periodic QCSSs with large set sizes and low periodic tolerances. These families of QCSSs have set size Î˜â¢(q2)Î˜superscriptğ‘2\Theta(q^{2})roman_Î˜ ( italic_q start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) or Î˜â¢(q3)Î˜superscriptğ‘3\Theta(q^{3})roman_Î˜ ( italic_q start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) and flock size Î˜â¢(q)Î˜ğ‘\Theta(q)roman_Î˜ ( italic_q ), where qğ‘qitalic_q is a power of a prime. To the best of our knowledge, only three known families of periodic QCSSs with set size Î˜â¢(q2)Î˜superscriptğ‘2\Theta(q^{2})roman_Î˜ ( italic_q start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) and flock size Î˜â¢(q)Î˜ğ‘\Theta(q)roman_Î˜ ( italic_q ) were constructed and all other known periodic QCSSs have set sizes much smaller than Î˜â¢(q2)Î˜superscriptğ‘2\Theta(q^{2})roman_Î˜ ( italic_q start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ). Our new constructed periodic QCSSs with set size Î˜â¢(q2)Î˜superscriptğ‘2\Theta(q^{2})roman_Î˜ ( italic_q start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) and flock size Î˜â¢(q)Î˜ğ‘\Theta(q)roman_Î˜ ( italic_q ) have better parameters than known ones. They have larger set sizes or lower periodic tolerances. The periodic QCSSs with set size Î˜â¢(q3)Î˜superscriptğ‘3\Theta(q^{3})roman_Î˜ ( italic_q start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT ) and flock size Î˜â¢(q)Î˜ğ‘\Theta(q)roman_Î˜ ( italic_q ) constructed in this paper have the largest set size among all known families of asymptotically optimal or near-optimal periodic QCSSs.","A perfect complementary sequence set (PCSS), which is also called mutually orthogonal complementary sequence set, consists of a number of two-dimensional matrices. The nontrivial auto-correlation and cross-correlation sums of the row sequences of the matrices are zero for any nonzero time-shift [21]. PCSSs have been found many nice applications including peak-to-average power ration reduction [4], inter-symbol interference channel estimation [20], radar waveform design [18] and multi-carrier code-division multiple-access (MC-CDMA) communication system [2]. The application of PCSSs has been viewed as a very promising technology for the next generation CDMA [3]. In MC-CDMA communication system, each user is assigned a two-dimensional matrix whose all row sequences are transmitted over separate sub-carrier channels simultaneously [2]. Then the number of the row sequences of a matrix in PCSS and that of sub-carrier channels are equal. However, the set size of a PCSS can not be larger than the number of row sequences of each two-dimensional matrix in it by the correlation lower bound. In order to support more users in MC-CDMA communication systems, some researchers proposed two new kinds of complementary sequence sets which are zero-correlation zone complementary sequence sets (ZCZ-CSSs) [5, 8] and low-correlation zone complementary sequence sets (LCZ-CSS) [13]. An LCZ-CSS (resp. ZCZ-CSS) has low (resp. zero) correlation magnitudes within a zone around the zero-shift. In recent years, many researches have been done on constructing LCZ-CSSs and ZCZ-CSSs. In 2013, Liu et al. proposed another type of complementary sequence set called quasi-complementary sequence set (QCSS) which could have larger set size than that of PCSS [14]. In the literature, there are two kinds of QCSSs including periodic QCSSs and aperiodic QCSSs [14, 15]. In this paper, we mainly study periodic QCSSs. A periodic (M,K,N,Ï‘mâ¢aâ¢x)ğ‘€ğ¾ğ‘subscriptitalic-Ï‘ğ‘šğ‘ğ‘¥(M,K,N,\vartheta_{max})( italic_M , italic_K , italic_N , italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT )-QCSS over an alphabet Ağ´Aitalic_A is a set consisting of Mğ‘€Mitalic_M two-dimensional KÃ—Nğ¾ğ‘K\times Nitalic_K Ã— italic_N matrices such that the maximum value Ï‘mâ¢aâ¢xsubscriptitalic-Ï‘ğ‘šğ‘ğ‘¥\vartheta_{max}italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT of nontrivial periodic correlation sums of the row sequences is a small positive number. Each row of the two-dimensional matrices is called a constituent sequence of length Nğ‘Nitalic_N and Kğ¾Kitalic_K denotes the flock size. The maximum non-trivial periodic correlation sum Ï‘mâ¢aâ¢xsubscriptitalic-Ï‘ğ‘šğ‘ğ‘¥\vartheta_{max}italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT measures the maximum possible amount of multipath interference and multiuser interference. For the application of a periodic QCSSs in MC-CDMA communications, it is required that its set size Mğ‘€Mitalic_M is as large as possible and Ï‘mâ¢aâ¢xsubscriptitalic-Ï‘ğ‘šğ‘ğ‘¥\vartheta_{max}italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT is as small as possible. However, there exists a tradeoff among the parameters M,K,Nğ‘€ğ¾ğ‘M,K,Nitalic_M , italic_K , italic_N and Ï‘mâ¢aâ¢xsubscriptitalic-Ï‘ğ‘šğ‘ğ‘¥\vartheta_{max}italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT. In [14], Liu et al. presented a lower bound for the maximum periodic correlation sum of a periodic (M,K,N,Ï‘mâ¢aâ¢x)ğ‘€ğ¾ğ‘subscriptitalic-Ï‘ğ‘šğ‘ğ‘¥(M,K,N,\vartheta_{max})( italic_M , italic_K , italic_N , italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT )-QCSS as follows: Ï‘mâ¢aâ¢xâ‰¥Ï‘oâ¢pâ¢t=Kâ¢Nâ¢M/Kâˆ’1Mâ¢Nâˆ’1.subscriptitalic-Ï‘ğ‘šğ‘ğ‘¥subscriptitalic-Ï‘ğ‘œğ‘ğ‘¡ğ¾ğ‘ğ‘€ğ¾1ğ‘€ğ‘1\displaystyle\vartheta_{max}\geq\vartheta_{opt}=KN\sqrt{\frac{M/K-1}{MN-1}}.italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT â‰¥ italic_Ï‘ start_POSTSUBSCRIPT italic_o italic_p italic_t end_POSTSUBSCRIPT = italic_K italic_N square-root start_ARG divide start_ARG italic_M / italic_K - 1 end_ARG start_ARG italic_M italic_N - 1 end_ARG end_ARG . (1) It is easy to verify that Mâ‰¤Kğ‘€ğ¾M\leq Kitalic_M â‰¤ italic_K, which is the upper bound of the size of a periodic PCSS, provided that Ï‘mâ¢aâ¢x=0subscriptitalic-Ï‘ğ‘šğ‘ğ‘¥0\vartheta_{max}=0italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT = 0. The tightness factor of the above correlation lower bound for periodic QCSS is defined by Ï=Ï‘mâ¢aâ¢x/Ï‘oâ¢pâ¢tğœŒsubscriptitalic-Ï‘ğ‘šğ‘ğ‘¥subscriptitalic-Ï‘ğ‘œğ‘ğ‘¡\rho=\vartheta_{max}/\vartheta_{opt}italic_Ï = italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT / italic_Ï‘ start_POSTSUBSCRIPT italic_o italic_p italic_t end_POSTSUBSCRIPT. Note that Ïâ‰¥1ğœŒ1\rho\geq 1italic_Ï â‰¥ 1. A QCSS is said to be optimal if Ï=1ğœŒ1\rho=1italic_Ï = 1 and near-optimal if 1<Ïâ‰¤21ğœŒ21<\rho\leq 21 < italic_Ï â‰¤ 2 [14]. Constructing optimal or near-optimal periodic QCSSs has been an interesting research topic in recent years. However, up to now, no infinite family of optimal QCSSs achieving the lower bound in (1) was reported. Only a few families of asymptotically optimal or near-optimal QCSSs were constructed. In [14], Liu et al. constructed the first family of asymptotically optimal and the first family of asymptotically near-optimal periodic QCSSs from the Single difference sets and the existing optimal quaternary sequence sets. Using a similar idea, Li et al. constructed a family of asymptotically optimal periodic QCSSs from almost difference sets in [12]. In [9], Li et al. generalized the constructions in [14] and derived new asymptotically optimal periodic QCSSs. In [10, 11], Li et al. presented several constructions of asymptotically optimal QCSSs from additive and multiplicative characters over finite fields. Later, Luo et al. gave three new constructions of asymptotically optimal QCSSs with samll alphabet sizes by additive characters over finite fields [16]. Recently, Xiao et al. used additive characters of finite fields to construct two more constructions of asymptotically optimal periodic QCSSs [22]. The parameters of these known families of periodic QCSSs are summarized in Table I. It is shown that only three known families of periodic QCSSs with set size Î˜â¢(q2)Î˜superscriptğ‘2\Theta(q^{2})roman_Î˜ ( italic_q start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) and flock size Î˜â¢(q)Î˜ğ‘\Theta(q)roman_Î˜ ( italic_q ) were constructed and all other known periodic QCSSs have set sizes much smaller than Î˜â¢(q2)Î˜superscriptğ‘2\Theta(q^{2})roman_Î˜ ( italic_q start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ), where qğ‘qitalic_q is a power of a prime. The purpose of this paper is to use new approaches to construct five new families of asymptotically optimal or near optimal QCSSs with better parameters. The main contents of this paper are as follows: 1. Using a family of quadratic polynomials over finite fields, we construct a family of (q2,q,qâˆ’1,q)superscriptğ‘2ğ‘ğ‘1ğ‘(q^{2},q,q-1,q)( italic_q start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , italic_q , italic_q - 1 , italic_q )-QCSSs with alphabet size pğ‘pitalic_p and a family of (22â¢n,2n,22â¢nâˆ’1,2n)superscript22ğ‘›superscript2ğ‘›superscript22ğ‘›1superscript2ğ‘›(2^{2n},2^{n},2^{2n}-1,2^{n})( 2 start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT , 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT , 2 start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT - 1 , 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT )-QCSSs with alphabet size 2222, where q=pnğ‘superscriptğ‘ğ‘›q=p^{n}italic_q = italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT with pğ‘pitalic_p an odd prime and nğ‘›nitalic_n a positive integer. These two families of QCSSs are asymptotically optimal with respect to the correlation lower bound and have larger set sizes than those in [10, 22] by Table I. 2. A family of (23â¢n,2n,2nâˆ’1,2n+1)superscript23ğ‘›superscript2ğ‘›superscript2ğ‘›1superscript2ğ‘›1(2^{3n},2^{n},2^{n}-1,2^{n+1})( 2 start_POSTSUPERSCRIPT 3 italic_n end_POSTSUPERSCRIPT , 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT , 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 , 2 start_POSTSUPERSCRIPT italic_n + 1 end_POSTSUPERSCRIPT )-QCSSs with alphabet size 2222 is constructed from a special quadrinomial over finite fields with characteristic 2. A family of (p3â¢n,pn,pnâˆ’1,â‰¤2pn)(p^{3n},p^{n},p^{n}-1,\leq 2p^{n})( italic_p start_POSTSUPERSCRIPT 3 italic_n end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT , italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 , â‰¤ 2 italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT )-QCSSs with alphabet size pğ‘pitalic_p is also constructed from a cubic quadrinomial over finite fields with characteristic pğ‘pitalic_p for an odd prime pğ‘pitalic_p. These two families of QCSSs are asymptotically near-optimal with respect to the correlation lower bound. Note that the set size of each family of QCSSs is the cube of the flock size. In this sense, these two families of QCSSs have the largest set sizes among all known families of asymptotically optimal or near-optimal periodic QCSSs. 3. By Gaussian sums, we construct a family of (pnâ¢(pnâˆ’1),pnâˆ’1,pnâˆ’1,pn)superscriptğ‘ğ‘›superscriptğ‘ğ‘›1superscriptğ‘ğ‘›1superscriptğ‘ğ‘›1superscriptğ‘ğ‘›(p^{n}(p^{n}-1),p^{n}-1,p^{n}-1,p^{n})( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) , italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 , italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 , italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT )-QCSSs which have lower periodic tolerance than the known (pnâ¢(pnâˆ’1),pnâˆ’1,pnâˆ’1,pn+1)superscriptğ‘ğ‘›superscriptğ‘ğ‘›1superscriptğ‘ğ‘›1superscriptğ‘ğ‘›1superscriptğ‘ğ‘›1(p^{n}(p^{n}-1),p^{n}-1,p^{n}-1,p^{n}+1)( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) , italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 , italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 , italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + 1 )-QCSSs in [22], though our QCSSs have larger alphabet size. According to the parameters of all known periodic QCSSs listed in Table I, our QCSSs have new parameters and very large set sizes. Most of them have very small alphabet size. These new QCSSs may be used in MC-CDMA communication systems to support a large number of users. TABLE I: The parameter of known periodic QCSSs. Set size Mğ‘€Mitalic_M Flock size Kğ¾Kitalic_K Length Nğ‘Nitalic_N Ï‘mâ¢aâ¢xsubscriptitalic-Ï‘ğ‘šğ‘ğ‘¥\vartheta_{max}italic_Ï‘ start_POSTSUBSCRIPT italic_m italic_a italic_x end_POSTSUBSCRIPT Alphabet Size Constraint References 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT 2nâˆ’1âˆ’1superscript2ğ‘›112^{n-1}-12 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT - 1 2nâˆ’1superscript2ğ‘›12^{n}-12 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 2n+2n22superscript2ğ‘›superscript2ğ‘›22\frac{2^{n}+2^{\frac{n}{2}}}{2}divide start_ARG 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + 2 start_POSTSUPERSCRIPT divide start_ARG italic_n end_ARG start_ARG 2 end_ARG end_POSTSUPERSCRIPT end_ARG start_ARG 2 end_ARG 4â¢(2nâˆ’1)4superscript2ğ‘›14(2^{n}-1)4 ( 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) n>1ğ‘›1n>1italic_n > 1 [14] 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT 2nâˆ’1âˆ’1superscript2ğ‘›112^{n-1}-12 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT - 1 2â¢(2nâˆ’1)2superscript2ğ‘›12(2^{n}-1)2 ( 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) 2n+2n/2superscript2ğ‘›superscript2ğ‘›22^{n}+2^{n/2}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + 2 start_POSTSUPERSCRIPT italic_n / 2 end_POSTSUPERSCRIPT 4â¢(2nâˆ’1)4superscript2ğ‘›14(2^{n}-1)4 ( 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) n>1ğ‘›1n>1italic_n > 1 [14] 22â¢nsuperscript22ğ‘›2^{2n}2 start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT 2nâˆ’1âˆ’2n/2superscript2ğ‘›1superscript2ğ‘›22^{n-1}-2^{n/2}2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT - 2 start_POSTSUPERSCRIPT italic_n / 2 end_POSTSUPERSCRIPT 22â¢nâˆ’1superscript22ğ‘›12^{2n}-12 start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT - 1 â‰¤wabsentğ‘¤\leq wâ‰¤ italic_w 4â¢(2nâˆ’1)4superscript2ğ‘›14(2^{n}-1)4 ( 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) nâ‰¥3ğ‘›3n\geq 3italic_n â‰¥ 3 [12] pğ‘pitalic_p pâˆ’12ğ‘12\frac{p-1}{2}divide start_ARG italic_p - 1 end_ARG start_ARG 2 end_ARG pğ‘pitalic_p â‰¤p+p2absentğ‘ğ‘2\leq\frac{p+\sqrt{p}}{2}â‰¤ divide start_ARG italic_p + square-root start_ARG italic_p end_ARG end_ARG start_ARG 2 end_ARG pğ‘pitalic_p pâ‰¡1(mod4)ğ‘annotated1pmod4p\equiv 1\pmod{4}italic_p â‰¡ 1 start_MODIFIER ( roman_mod start_ARG 4 end_ARG ) end_MODIFIER is a prime [9] pnâˆ’2superscriptğ‘ğ‘›2p^{n}-2italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 2 pnâˆ’12superscriptğ‘ğ‘›12\frac{p^{n}-1}{2}divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 end_ARG start_ARG 2 end_ARG pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 â‰¤pn+4â¢pn+32absentsuperscriptğ‘ğ‘›4superscriptğ‘ğ‘›32\leq\frac{p^{n}+4\sqrt{p^{n}}+3}{2}â‰¤ divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + 4 square-root start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG + 3 end_ARG start_ARG 2 end_ARG pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pğ‘pitalic_p is an odd prime [10] p2â¢nâˆ’2superscriptğ‘2ğ‘›2p^{2n}-2italic_p start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT - 2 pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT p2â¢nâˆ’1superscriptğ‘2ğ‘›1p^{2n}-1italic_p start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT - 1 pnâ¢(p2â¢n+3)superscriptğ‘ğ‘›superscriptğ‘2ğ‘›3p^{n}(p^{2n}+3)italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT + 3 ) p2â¢nâˆ’1superscriptğ‘2ğ‘›1p^{2n}-1italic_p start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT - 1 pğ‘pitalic_p is a prime [10] pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pnâˆ’12superscriptğ‘ğ‘›12\frac{p^{n}-1}{2}divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 end_ARG start_ARG 2 end_ARG pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 â‰¤pn+pn2absentsuperscriptğ‘ğ‘›superscriptğ‘ğ‘›2\leq\frac{p^{n}+\sqrt{p^{n}}}{2}â‰¤ divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + square-root start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG end_ARG start_ARG 2 end_ARG pâ¢(pnâˆ’1)ğ‘superscriptğ‘ğ‘›1p(p^{n}-1)italic_p ( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) pğ‘pitalic_p is an odd prime [11] pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pnâˆ’1superscriptğ‘ğ‘›1p^{n-1}italic_p start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 â‰¤pnâˆ’12absentsuperscriptğ‘ğ‘›12\leq p^{n-\frac{1}{2}}â‰¤ italic_p start_POSTSUPERSCRIPT italic_n - divide start_ARG 1 end_ARG start_ARG 2 end_ARG end_POSTSUPERSCRIPT pâ¢(pnâˆ’1)ğ‘superscriptğ‘ğ‘›1p(p^{n}-1)italic_p ( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) pğ‘pitalic_p is a prime and n>1ğ‘›1n>1italic_n > 1 [11] p2â¢nâˆ’1superscriptğ‘2ğ‘›1p^{2n}-1italic_p start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT - 1 pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT p2â¢nâˆ’1superscriptğ‘2ğ‘›1p^{2n}-1italic_p start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT - 1 p3â¢n/2superscriptğ‘3ğ‘›2p^{3n/2}italic_p start_POSTSUPERSCRIPT 3 italic_n / 2 end_POSTSUPERSCRIPT pâ¢(p2â¢nâˆ’1)ğ‘superscriptğ‘2ğ‘›1p(p^{2n}-1)italic_p ( italic_p start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT - 1 ) pğ‘pitalic_p is a prime [11] 2nâˆ’1superscript2ğ‘›12^{n}-12 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 2nâˆ’1âˆ’1superscript2ğ‘›112^{n-1}-12 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT - 1 2nâˆ’1superscript2ğ‘›12^{n}-12 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 2nâˆ’1superscript2ğ‘›12^{n-1}2 start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT 2â¢(2nâˆ’1)2superscript2ğ‘›12(2^{n}-1)2 ( 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) n>1ğ‘›1n>1italic_n > 1 [11] 2nâˆ’1superscript2ğ‘›12^{n}-12 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 2nâˆ’2superscript2ğ‘›22^{n-2}2 start_POSTSUPERSCRIPT italic_n - 2 end_POSTSUPERSCRIPT 2nâˆ’1superscript2ğ‘›12^{n}-12 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 â‰¤3â‹…2nâˆ’2absentâ‹…3superscript2ğ‘›2\leq 3\cdot 2^{n-2}â‰¤ 3 â‹… 2 start_POSTSUPERSCRIPT italic_n - 2 end_POSTSUPERSCRIPT 2â¢(2nâˆ’1)2superscript2ğ‘›12(2^{n}-1)2 ( 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) n>1ğ‘›1n>1italic_n > 1 [11] pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pnâˆ’12superscriptğ‘ğ‘›12\frac{p^{n}-1}{2}divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 end_ARG start_ARG 2 end_ARG pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pn+12superscriptğ‘ğ‘›12\frac{p^{n}+1}{2}divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + 1 end_ARG start_ARG 2 end_ARG pğ‘pitalic_p pğ‘pitalic_p is an odd prime, pn>3superscriptğ‘ğ‘›3p^{n}>3italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT > 3 [16] pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pnâˆ’pnâˆ’12superscriptğ‘ğ‘›superscriptğ‘ğ‘›12\frac{p^{n}-p^{n-1}}{2}divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - italic_p start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT end_ARG start_ARG 2 end_ARG pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pn+pnâˆ’12superscriptğ‘ğ‘›superscriptğ‘ğ‘›12\frac{p^{n}+p^{n-1}}{2}divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + italic_p start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT end_ARG start_ARG 2 end_ARG pğ‘pitalic_p pğ‘pitalic_p is an odd prime, pn>3superscriptğ‘ğ‘›3p^{n}>3italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT > 3 [16] pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT uğ‘¢uitalic_u pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 vğ‘£vitalic_v pğ‘pitalic_p pğ‘pitalic_p is an odd prime, n>1ğ‘›1n>1italic_n > 1 is odd [16] pnâ¢(pnâˆ’1)superscriptğ‘ğ‘›superscriptğ‘ğ‘›1p^{n}(p^{n}-1)italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pğ‘pitalic_p pğ‘pitalic_p is a prime, n>1ğ‘›1n>1italic_n > 1 [22] pnâ¢(pnâˆ’1)superscriptğ‘ğ‘›superscriptğ‘ğ‘›1p^{n}(p^{n}-1)italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pn+1superscriptğ‘ğ‘›1p^{n}+1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + 1 pğ‘pitalic_p pğ‘pitalic_p is a prime, n>1ğ‘›1n>1italic_n > 1 [22] p2â¢nsuperscriptğ‘2ğ‘›p^{2n}italic_p start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pğ‘pitalic_p pğ‘pitalic_p is an odd prime, nâ‰¥1ğ‘›1n\geq 1italic_n â‰¥ 1 Theorem III.1 22â¢nsuperscript22ğ‘›2^{2n}2 start_POSTSUPERSCRIPT 2 italic_n end_POSTSUPERSCRIPT 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT 2nâˆ’1superscript2ğ‘›12^{n}-12 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT 2222 nâ‰¥1ğ‘›1n\geq 1italic_n â‰¥ 1 Theorem III.2 23â¢nsuperscript23ğ‘›2^{3n}2 start_POSTSUPERSCRIPT 3 italic_n end_POSTSUPERSCRIPT 2nsuperscript2ğ‘›2^{n}2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT 2nâˆ’1superscript2ğ‘›12^{n}-12 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 2n+1superscript2ğ‘›12^{n+1}2 start_POSTSUPERSCRIPT italic_n + 1 end_POSTSUPERSCRIPT 2222 nâ‰¥3ğ‘›3n\geq 3italic_n â‰¥ 3 Theorem III.3 p3â¢nsuperscriptğ‘3ğ‘›p^{3n}italic_p start_POSTSUPERSCRIPT 3 italic_n end_POSTSUPERSCRIPT pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 2â¢pn2superscriptğ‘ğ‘›2p^{n}2 italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pğ‘pitalic_p pğ‘pitalic_p is an odd prime, nâ‰¥1ğ‘›1n\geq 1italic_n â‰¥ 1 Theorem III.4 pnâ¢(pnâˆ’1)superscriptğ‘ğ‘›superscriptğ‘ğ‘›1p^{n}(p^{n}-1)italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pnâˆ’1superscriptğ‘ğ‘›1p^{n}-1italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 pnsuperscriptğ‘ğ‘›p^{n}italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT pâ¢(pnâˆ’1)ğ‘superscriptğ‘ğ‘›1p(p^{n}-1)italic_p ( italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) pğ‘pitalic_p is a prime Theorem III.5 u=pnâˆ’pnâˆ’1+(âˆ’1)(pâˆ’1)â¢(n+3)/4â¢(pâˆ’1)â¢p(nâˆ’1)/22ğ‘¢superscriptğ‘ğ‘›superscriptğ‘ğ‘›1superscript1ğ‘1ğ‘›34ğ‘1superscriptğ‘ğ‘›122u=\frac{p^{n}-p^{n-1}+(-1)^{(p-1)(n+3)/4}(p-1)p^{(n-1)/2}}{2}italic_u = divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - italic_p start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT + ( - 1 ) start_POSTSUPERSCRIPT ( italic_p - 1 ) ( italic_n + 3 ) / 4 end_POSTSUPERSCRIPT ( italic_p - 1 ) italic_p start_POSTSUPERSCRIPT ( italic_n - 1 ) / 2 end_POSTSUPERSCRIPT end_ARG start_ARG 2 end_ARG,v=pn+pnâˆ’1âˆ’(âˆ’1)(pâˆ’1)â¢(n+3)/4â¢(pâˆ’1)â¢p(nâˆ’1)/22ğ‘£superscriptğ‘ğ‘›superscriptğ‘ğ‘›1superscript1ğ‘1ğ‘›34ğ‘1superscriptğ‘ğ‘›122v=\frac{p^{n}+p^{n-1}-(-1)^{(p-1)(n+3)/4}(p-1)p^{(n-1)/2}}{2}italic_v = divide start_ARG italic_p start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + italic_p start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT - ( - 1 ) start_POSTSUPERSCRIPT ( italic_p - 1 ) ( italic_n + 3 ) / 4 end_POSTSUPERSCRIPT ( italic_p - 1 ) italic_p start_POSTSUPERSCRIPT ( italic_n - 1 ) / 2 end_POSTSUPERSCRIPT end_ARG start_ARG 2 end_ARG,w=(1+2n)â¢2n+2nâˆ’2âˆ’2n/2ğ‘¤1superscript2ğ‘›superscript2ğ‘›superscript2ğ‘›2superscript2ğ‘›2w=(1+2^{n})\sqrt{2^{n}+2^{n-2}-2^{n/2}}italic_w = ( 1 + 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT ) square-root start_ARG 2 start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT + 2 start_POSTSUPERSCRIPT italic_n - 2 end_POSTSUPERSCRIPT - 2 start_POSTSUPERSCRIPT italic_n / 2 end_POSTSUPERSCRIPT end_ARG"
https://arxiv.org/html/2411.04992v1,Which bits went where? Past and future transfer entropy decomposition with the information bottleneck,"Whether the system under study is a shoal of fish, a collection of neurons, or a set of interacting atmospheric and oceanic processes, transfer entropy measures the flow of information between time series and can detect possible causal relationships. Much like mutual information, transfer entropy is generally reported as a single value summarizing an amount of shared variation, yet a more fine-grained accounting might illuminate much about the processes under study. Here we propose to decompose transfer entropy and localize the bits of variation on both sides of information flow: that of the originating processâ€™s past and that of the receiving processâ€™s future. We employ the information bottleneck (IB) to compress the time series and identify the transferred entropy. We apply our method to decompose the transfer entropy in several synthetic recurrent processes and an experimental mouse dataset of concurrent behavioral and neural activity. Our approach highlights the nuanced dynamics within information flow, laying a foundation for future explorations into the intricate interplay of temporal processes in complex systems.","Causality forms the backbone of explanations in science. Detecting cause and effect from observational data alone is generally impossible, as there can always be unobserved shared causes. However, certain signatures have been identified that can indicate possible causality, such as Granger causality [1], transfer entropy [2], and directed information [3]. Measuring such signatures can be a powerful step toward understanding a complex system, with applications as broad as groups of fish [4], neural signals [5, 6], and Earth-scale climate processes [7]. Transfer entropy quantifies the additional information a source process shares with a target process after accounting for the information contained in the target processâ€™s history [2, 8]. As a conditional mutual information, transfer entropy is nonparametric and generalizes to arbitrary probability distributions and relationships between variables, in contrast to Granger causality; transfer entropy and Granger causality are equivalent for Gaussian variables [9]. On the other hand, conditional mutual information can be challenging to estimate from limited data samples [10, 6]. Consider modeling the movement of the blue fish in Fig. 1a so as to forecast its future given its past. If the red fish causes the blue fish to alter its behavior, then the accuracy of the forecast will improve when information about the past of the red fish is incorporated into the model. The converse is not necessarily trueâ€”that an improvement in accuracy implies a causal relationshipâ€”but quantifying information flow in this way is often the closest to causality one can get with observational data alone (i.e., without having the ability to intervene in the data collection process) [11, 9]. While the above framing in terms of forecasting with and without the sourceâ€™s past is the common way to present transfer entropy, there is an equivalent alternative that we will leverage in this work. Again employing the fish of Fig. 1a, consider the task of inferring the red fishâ€™s movement given the blue fishâ€™s movement over the same time frame. If the accuracy of the model improves when incorporating the future of the blue fish, there is information flow from the past of the red fish to the future of the blue fish. With these two equivalent expressions for transfer entropy, we can focus on the effect of incorporating either the past of the red fish or the future of the blue fish into a predictive model. The net information change in either case must be equal to the transfer entropy, but the originating and terminating variation can look different on either side of the information flow. Our goal in this work is to identify the variation on either side by using the information bottleneck. The information bottleneck (IB) is a method to isolate targeted variation in a learned compression scheme [12, 13], allowing for control over learned representations [14] and fine-grained inspection of what the information is [15]. Here we propose an IB scheme to encapsulate the transfer entropy from either side of an information flow into a learned compression space. The encapsulated information can then be decomposed in terms of multiple sources via the distributed IB [15, 16], inspected as a local quantity varying in time [17], and used as a targeted representation for downstream tasks [18]."
https://arxiv.org/html/2411.04803v1,Unbounded Error Correcting Codes,"We introduce a variant of Error Correcting Codes with no predetermined length. An Unbounded ECC with rate Rğ‘…Ritalic_R and distance Îµğœ€\varepsilonitalic_Îµ is an encoding of a possibly infinite message into a possibly infinite codeword, such that for every large enough kğ‘˜kitalic_k we may recover the first Râ¢kğ‘…ğ‘˜Rkitalic_R italic_k symbols of the message from the first kğ‘˜kitalic_k symbols of the codeword â€” even when up to 12â¢Îµâ¢k12ğœ€ğ‘˜\frac{1}{2}\varepsilon kdivide start_ARG 1 end_ARG start_ARG 2 end_ARG italic_Îµ italic_k of these codeword symbols are adversarially corrupted. We study unbounded codes over a binary alphabet in the regime of small distance Îµğœ€\varepsilonitalic_Îµ, and obtain nearly-tight upper and lower bounds in several natural settings. We show that the optimal rate of such a code is between R<1âˆ’Î©â¢(Îµ)ğ‘…1Î©ğœ€R<1-\Omega(\sqrt{\varepsilon})italic_R < 1 - roman_Î© ( square-root start_ARG italic_Îµ end_ARG ) and R>1âˆ’Oâ¢(Îµâ¢logâ¡logâ¡(1/Îµ))ğ‘…1ğ‘‚ğœ€1ğœ€R>1-O\left(\sqrt{\varepsilon\log\log\left(1/\varepsilon\right)}\right)italic_R > 1 - italic_O ( square-root start_ARG italic_Îµ roman_log roman_log ( 1 / italic_Îµ ) end_ARG ). Surprisingly, our construction is non-linear, and we show that the optimal rate of a linear unbounded code is the asymptotically worse R=1âˆ’Î˜â¢(Îµâ¢logâ¡(1/Îµ))ğ‘…1Î˜ğœ€1ğœ€R=1-\Theta\left(\sqrt{\varepsilon\log\left(1/\varepsilon\right)}\right)italic_R = 1 - roman_Î˜ ( square-root start_ARG italic_Îµ roman_log ( 1 / italic_Îµ ) end_ARG ). In the setting of random noise, the optimal rate of unbounded codes improves and matches the rate of standard codes at R=1âˆ’Î˜â¢(Îµâ¢logâ¡(1/Îµ))ğ‘…1Î˜ğœ€1ğœ€R=1-\Theta({\varepsilon\log{\left(1/\varepsilon\right)}})italic_R = 1 - roman_Î˜ ( italic_Îµ roman_log ( 1 / italic_Îµ ) ).","Error Correcting Codes (ECCs) are the means to compensate for errors in the transmission of messages. An ECC encodes a message into a slightly larger codeword, such that even if a certain fraction of the codeword is corrupted the message can still be recovered. ECCs are extensively studied and it is long known that good ECCs can be constructed, even over a binary alphabet. [Ham50, Gil52, Var57, Jus72, SS96]. We define a natural generalization of ECCs, in which the length of the message (and hence also of the codeword) is not fixed. We call those Unbounded ECCs. We would require that for any kğ‘˜kitalic_k, the first kğ‘˜kitalic_k symbols of the message can be decoded from the first Oâ¢(k)ğ‘‚ğ‘˜O(k)italic_O ( italic_k ) symbols of the codeword, even if a small fraction of those codeword symbols are corrupted. This allows, for example, robust transmission of a long message in a connection that would abruptly halt at an unknown point in time. Recently, Zamir [Zam24] raised the same question in the specified model of noiseless feedback â€” as a part of a work on Large Language Models watermarking. We study this question in the more general setting. Definition (Unbounded codes). A code C:Î£â‹†â†’Î“â‹†:ğ¶â†’superscriptÎ£â‹†superscriptÎ“â‹†C:\Sigma^{\star}\rightarrow\Gamma^{\star}italic_C : roman_Î£ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT â†’ roman_Î“ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT is called an unbounded code with rate Rğ‘…Ritalic_R and distance Îµğœ€\varepsilonitalic_Îµ, or a (R,Îµ)ğ‘…ğœ€(R,\varepsilon)( italic_R , italic_Îµ )-unbounded code, if there exists some k0âˆˆâ„•subscriptğ‘˜0â„•k_{0}\in\mathbb{N}italic_k start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT âˆˆ blackboard_N such that the following holds. Let x,yâˆˆÎ£â‹†ğ‘¥ğ‘¦superscriptÎ£â‹†x,y\in\Sigma^{\star}italic_x , italic_y âˆˆ roman_Î£ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT, iâ‰¥k0ğ‘–subscriptğ‘˜0i\geq k_{0}italic_i â‰¥ italic_k start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT, and jâ‰¥iRğ‘—ğ‘–ğ‘…j\geq\frac{i}{R}italic_j â‰¥ divide start_ARG italic_i end_ARG start_ARG italic_R end_ARG. If x[:i]â‰ y[:i]x[:i]\neq y[:i]italic_x [ : italic_i ] â‰  italic_y [ : italic_i ] then dH(C(x)[:j],C(y)[:j])â‰¥Îµj.d_{H}(C(x)[:j],C(y)[:j])\geq\varepsilon j.italic_d start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT ( italic_C ( italic_x ) [ : italic_j ] , italic_C ( italic_y ) [ : italic_j ] ) â‰¥ italic_Îµ italic_j . An unbounded ECC can be viewed as a family of standard ECCs that extend each other. For any large enough kğ‘˜kitalic_k, an (R,Îµ)ğ‘…ğœ€(R,\varepsilon)( italic_R , italic_Îµ )-unbounded code indeed induces a standard ECC for messages of length kğ‘˜kitalic_k with rate Rğ‘…Ritalic_R and distance Îµğœ€\varepsilonitalic_Îµ, which can be constructed by taking the prefix of length k/Rğ‘˜ğ‘…k/Ritalic_k / italic_R of the code words of Cğ¶Citalic_C. This object can be motivated by various natural scenarios, for example, streaming a large file such that at any point in time the receiver can sustain a certain fraction of errors. In this paper, we study unbounded codes with binary alphabet Î£=Î“=ğ”½2Î£Î“subscriptğ”½2\Sigma=\Gamma=\mathbb{F}_{2}roman_Î£ = roman_Î“ = blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, in the regime of small distance Îµâ†’0â†’ğœ€0\varepsilon\rightarrow 0italic_Îµ â†’ 0. We obtain upper and lower bounds for their optimal rates in several natural settings. Our main results are the following nearly-tight bounds on the optimal rate of unbounded ECCs. Theorem. For every small enough Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 there exists a (R,Îµ)ğ‘…ğœ€(R,\varepsilon)( italic_R , italic_Îµ )-unbounded code with R>1âˆ’Oâ¢(Îµâ¢logâ¡logâ¡(1/Îµ))ğ‘…1ğ‘‚ğœ€1ğœ€R>1-O\left(\sqrt{\varepsilon\log\log\left(1/\varepsilon\right)}\right)italic_R > 1 - italic_O ( square-root start_ARG italic_Îµ roman_log roman_log ( 1 / italic_Îµ ) end_ARG ). Furthermore, for every (R,Îµ)ğ‘…ğœ€(R,\varepsilon)( italic_R , italic_Îµ )-unbounded code it holds that R<1âˆ’Î©â¢(Îµ)ğ‘…1Î©ğœ€R<1-\Omega\left(\sqrt{\varepsilon}\right)italic_R < 1 - roman_Î© ( square-root start_ARG italic_Îµ end_ARG ). The construction we present to achieve this bound is non-linear, which is surprising as in standard ECCs optimal (or nearly-optimal) bounds are achieved using linear constructions. We prove that this is inherent, and in fact, the optimal rate for linear unbounded ECCs is strictly worse. Theorem. For every small enough Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 there exists a linear (R,Îµ)ğ‘…ğœ€(R,\varepsilon)( italic_R , italic_Îµ )-unbounded code with R>1âˆ’Oâ¢(Îµâ¢logâ¡(1/Îµ))ğ‘…1ğ‘‚ğœ€1ğœ€R>1-O\left(\sqrt{\varepsilon\log\left(1/\varepsilon\right)}\right)italic_R > 1 - italic_O ( square-root start_ARG italic_Îµ roman_log ( 1 / italic_Îµ ) end_ARG ). Furthermore, for every linear (R,Îµ)ğ‘…ğœ€(R,\varepsilon)( italic_R , italic_Îµ )-unbounded code it holds that R<1âˆ’Î©â¢(Îµâ¢logâ¡(1/Îµ))ğ‘…1Î©ğœ€1ğœ€R<1-\Omega\left(\sqrt{\varepsilon\log\left(1/\varepsilon\right)}\right)italic_R < 1 - roman_Î© ( square-root start_ARG italic_Îµ roman_log ( 1 / italic_Îµ ) end_ARG ). Another divergence from standard ECCs is that for unbounded ECCs, random and adversarial errors lead to significantly different optimal rates. We show that if the errors are random bit-flips happening with probability Îµğœ€\varepsilonitalic_Îµ instead of an adversarial Îµğœ€\varepsilonitalic_Îµ-fraction of errors, then an unbounded ECC with a rate similar to that of standard codes is possible. Theorem. For every small enough Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0 there exists a (R,Îµ)ğ‘…ğœ€(R,\varepsilon)( italic_R , italic_Îµ )-unbounded code resilient to BSC(Îµ)ğœ€(\varepsilon)( italic_Îµ ) with R>1âˆ’Oâ¢(Îµâ¢logâ¡(1/Îµ))ğ‘…1ğ‘‚ğœ€1ğœ€R>1-O\left({\varepsilon\log\left(1/\varepsilon\right)}\right)italic_R > 1 - italic_O ( italic_Îµ roman_log ( 1 / italic_Îµ ) ). In a model where the encoder receives an immediate and noiseless feedback as to whether the previous symbol was received with or without errors, [Zam24] shows that a rate of 1âˆ’Î˜â¢(Îµ)1Î˜ğœ€1-\Theta(\varepsilon)1 - roman_Î˜ ( italic_Îµ ) is possible for unbounded ECCs â€” the same optimal rate in this setting as standard ECCs. See Table 1 for a summary of the comparison between the optimal rates of standard and unbounded ECCs in the various regimes. As part of our proof, we study another variant of ECCs we call subset codes. A standard error correcting code can be viewed as a set of vectors such that the distance between every pair of them is large. A subset code is a collection of (possibly large) subsets of ğ”½2nsuperscriptsubscriptğ”½2ğ‘›\mathbb{F}_{2}^{n}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT such that the distance between every two such subsets is large (but on the other hand, vectors within the same subset might be close to each other). In Section 6 we study these codes and derive optimal asymptotic bounds, this can be of independent interest. Table 1: Optimal rate Rğ‘…Ritalic_R for error Îµâ†’0â†’ğœ€0\varepsilon\rightarrow 0italic_Îµ â†’ 0. Standard ECCs Unbounded ECCs Adversarial errors 1âˆ’Î˜â¢(Îµâ¢logâ¡(1/Îµ))1Î˜ğœ€1ğœ€1-\Theta(\varepsilon\log(1/\varepsilon))1 - roman_Î˜ ( italic_Îµ roman_log ( 1 / italic_Îµ ) ) 1âˆ’Î˜~â¢(Îµ)1~Î˜ğœ€1-\tilde{\Theta}(\sqrt{\varepsilon})1 - over~ start_ARG roman_Î˜ end_ARG ( square-root start_ARG italic_Îµ end_ARG ) Random errors 1âˆ’Î˜â¢(Îµâ¢logâ¡(1/Îµ))1Î˜ğœ€1ğœ€1-\Theta(\varepsilon\log(1/\varepsilon))1 - roman_Î˜ ( italic_Îµ roman_log ( 1 / italic_Îµ ) ) 1âˆ’Î˜â¢(Îµâ¢logâ¡(1/Îµ))1Î˜ğœ€1ğœ€1-\Theta(\varepsilon\log(1/\varepsilon))1 - roman_Î˜ ( italic_Îµ roman_log ( 1 / italic_Îµ ) ) Noiseless feedback 1âˆ’Î˜â¢(Îµ)1Î˜ğœ€1-\Theta(\varepsilon)1 - roman_Î˜ ( italic_Îµ ) 1âˆ’Î˜â¢(Îµ)1Î˜ğœ€1-\Theta(\varepsilon)1 - roman_Î˜ ( italic_Îµ ) 1.1 Connections to Prior Works This definition we consider is somewhat reminiscent of Tree Codes [Sch93, Sch96], but the definitions are qualitatively different: In a tree code, every symbol of the code-word directly corresponds to a single symbol of the message â€” in an unbounded code, there is no such direct correspondence and code symbols may depend on both previous and following message symbols. Furthermore, while in a tree code the distance property is defined with respect to only the part of the code-word succeeding the first disagreement between messages â€” in an unbounded code the distance property is always defined with respect to the entire codeword prefix. Tree codes and other types of codes were considered in the context of error correction of interactive protocols [BR11, GHS14, G+17, EKS20]. Contrary to the setting of interactive codes and also to that of noiseless feedback studied in [Zam24], in our settings there is no interaction whatsoever â€” that is, the receiver is not communicating anything and, in particular, no information about what symbols were corrupted is ever learned by the sender. While the optimal rates of unbounded codes are similar to those of interactive codes with small noise [KR13, Hae14] we are not aware of any formal connection. A somewhat related notion of anytime capacity [SM06] was studied in the context of control theory. Here, the sender does not have the whole message in advance but receives it online, and the model assumes stochastic (random) noise. The goal is that the probability of making a mistake on a bitâ€™s decoding will decrease exponentially with the time passed since the sender received this bit. 1.2 Alphabet Size In the vast majority of this paper we focus on the binary alphabet Î£=Î“=ğ”½2Î£Î“subscriptğ”½2\Sigma=\Gamma=\mathbb{F}_{2}roman_Î£ = roman_Î“ = blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT, which is equivalent to the case of an alphabet of any arbitrary constant size |Î£|,|Î“|=Oâ¢(1)Î£Î“ğ‘‚1|\Sigma|,|\Gamma|=O(1)| roman_Î£ | , | roman_Î“ | = italic_O ( 1 ). Nonetheless, the same questions we present may also be asked for an alphabet size that is related to Îµğœ€\varepsilonitalic_Îµ. In standard Error Correcting Codes, the optimal rate of 1âˆ’R=Î˜â¢(Îµâ¢logâ¡(1/Îµ))1ğ‘…Î˜ğœ€1ğœ€1-R=\Theta(\varepsilon\log(1/\varepsilon))1 - italic_R = roman_Î˜ ( italic_Îµ roman_log ( 1 / italic_Îµ ) ) as Îµâ†’0â†’ğœ€0\varepsilon\rightarrow 0italic_Îµ â†’ 0 is refined to 1âˆ’R=Î˜â¢(Îµâ¢(logqâ¡(1/Îµ)+1))1ğ‘…Î˜ğœ€subscriptğ‘1ğœ€11-R=\Theta\left(\varepsilon\left(\log_{q}\left(1/\varepsilon\right)+1\right)\right)1 - italic_R = roman_Î˜ ( italic_Îµ ( roman_log start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( 1 / italic_Îµ ) + 1 ) ) when the alphabet size q:=|Î£|assignğ‘Î£q:=|\Sigma|italic_q := | roman_Î£ | is taken into account. In our construction of the linear code of Section 4, the bound is similarly refined to 1âˆ’R=Oâ¢(Îµâ¢(logqâ¡(1/Îµ)+1))1ğ‘…ğ‘‚ğœ€subscriptğ‘1ğœ€11-R=O\left(\sqrt{\varepsilon\left(\log_{q}\left(1/\varepsilon\right)+1\right)}\right)1 - italic_R = italic_O ( square-root start_ARG italic_Îµ ( roman_log start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT ( 1 / italic_Îµ ) + 1 ) end_ARG ) when the dependence on qğ‘qitalic_q is considered. In particular, when q=Î©â¢(1Îµ)ğ‘Î©1ğœ€q=\Omega\left(\frac{1}{\varepsilon}\right)italic_q = roman_Î© ( divide start_ARG 1 end_ARG start_ARG italic_Îµ end_ARG ) we obtain a linear code with rate 1âˆ’R=Oâ¢(Îµ)1ğ‘…ğ‘‚ğœ€1-R=O\left(\sqrt{\varepsilon}\right)1 - italic_R = italic_O ( square-root start_ARG italic_Îµ end_ARG ). On the other hand, the rate upper bound for linear codes in Section 5 is independent of the alphabet size and thus shows 1âˆ’Râ‰¥Îµ1ğ‘…ğœ€1-R\geq\sqrt{\varepsilon}1 - italic_R â‰¥ square-root start_ARG italic_Îµ end_ARG for any qğ‘qitalic_q, which is tight for q=Î©â¢(1Îµ)ğ‘Î©1ğœ€q=\Omega\left(\frac{1}{\varepsilon}\right)italic_q = roman_Î© ( divide start_ARG 1 end_ARG start_ARG italic_Îµ end_ARG ). 1.3 Organization of the Paper In Section 2 we give a high-level overview of the constructions and proofs in the paper. In Section 4 we construct linear unbounded codes and also show that their rate improves when the errors are random. In Section 5 we derive a simple rate upper bound for linear unbounded codes. In Section 6 we introduce and study subset codes, which we use in the consecutive sections. In Section 7 we present a rate upper bound for general unbounded codes as well as improve the bound for linear codes. In Section 8 we improve our construction using non-linear subset codes. Finally, we conclude and present open problems in Section 9."
https://arxiv.org/html/2411.04753v1,Efficient Channel Estimation With Shorter Pilots in RIS-Aided Communications: Using Array Geometries and Interference Statistics,"Accurate estimation of the cascaded channel from a user equipment (UE) to a base station (BS) via each reconfigurable intelligent surface (RIS) element is critical to realizing the full potential of the RISâ€™s ability to control the overall channel. The number of parameters to be estimated is equal to the number of RIS elements, requiring an equal number of pilots unless an underlying structure can be identified. In this paper, we show how the spatial correlation inherent in the different RIS channels provides this desired structure. We first optimize the RIS phase-shift pattern using a much-reduced pilot length (determined by the rank of the spatial correlation matrices) to minimize the mean square error (MSE) in the channel estimation under electromagnetic interference. In addition to considering the linear minimum MSE (LMMSE) channel estimator, we propose a novel channel estimator that requires only knowledge of the array geometry while not requiring any user-specific statistical information. We call this the reduced-subspace least squares (RS-LS) estimator and optimize the RIS phase-shift pattern for it. This novel estimator significantly outperforms the conventional LS estimator. For both the LMMSE and RS-LS estimators, the proposed optimized RIS configurations result in significant channel estimation improvements over the benchmarks.","Reconfigurable intelligent surface (RIS)-aided communication is a pivotal area of investigation for next-generation wireless systems [2, 3, 4]. An RIS is a planar array of Nğ‘Nitalic_N reflecting elements (meta-atoms) with sub-wavelength spacing. Each element can be configured by adjusting its impedance to induce a controllable phase-shift of the incident wave prior to reflection. By optimizing the phase-shift pattern across the RIS, the reflected wavefront can be shaped (e.g., as a near-field/far-field beam toward the intended receiver) [5]. Estimating the channel coefficients associated with each element is a key challenge, as RISs are envisioned to consist of hundreds of elements [6]. In a basic RIS-aided communication setup with a single-antenna base station (BS), a single-antenna user equipment (UE), and Nğ‘Nitalic_N RIS elements, the channel is described by N+1ğ‘1N+1italic_N + 1 coefficients. These coefficients represent the controllable channels via the respective elements plus the uncontrolled direct BS-UE channel. Classical channel estimators (e.g., the least squares (LS) estimator) require a pilot length of at least N+1ğ‘1N+1italic_N + 1 to function properly. The works on passive RIS-aided channel estimation can be broadly classified into two branches [7, Tab. 2]. The first branch employs ON/OFF techniques [8, 9, 10, 11], which require a large pilot overhead. Conversely, low pilot overhead is achievable when the RIS channel is sparse [12, 13, 14, 15, 16]. However, reducing pilot overhead remains a challenge when the channel lacks a sparse structure. Various methods that exploit sparsity, spatial channel correlation, and/or other specific characteristics of the channel can be employed to improve channel estimation beyond classical estimators [17]. One such technique involves exploiting spatial correlation among the channel coefficients. In [18, 3, 19], the authors minimize either the mean square error (MSE) or the effective noise variance of the linear minimum MSE (LMMSE) estimator. However, these methods are only applicable when the pilot length is at least N+1ğ‘1N+1italic_N + 1. Additionally, sparsity inherent in mmWave and THz channels can be leveraged to design parametric channel estimation methods with low overhead [20, 21, 22, 23]. For example, in [20], the authors develop a channel estimation method to obtain sparse multipath components such as angles, distances, and path gains of the near-field THz channel. Similarly, [21] uses a sequential estimation approach for angle parameters, angle differences, and products of propagation path gains. The authors of [22] propose a message-passing-based channel estimation algorithm by exploiting the slow-varying channel components and hidden channel sparsity. In [23], the sparsity and correlation of multi-user mmWave channels are exploited to design low-overhead channel estimation. In [24], a parametric maximum likelihood estimation framework is presented for estimating the line-of-sight channel between UE and RIS. Recently, it has been shown that reducing the pilot length is possible by equipping the RIS with a radio frequency (RF) chain to empower it with a transmission capability [25]. However, for a fully passive RIS, the challenge of low pilot overhead still exists in a rich scattering environment. None of the above parametric approaches consider a rich scattering environment. To the best of our knowledge, this paper is the first to optimize the RIS phase-shift configuration during channel estimation by exploiting the spatial channel correlation to reduce the MSE for a given pilot length, while simultaneously exploiting the reduced-rank properties caused by the array geometry to enable shorter pilot lengths than N+1ğ‘1N+1italic_N + 1. In contrast to earlier studies primarily leveraging array geometry for the development of low-overhead channel estimation schemes, our research delves into a more comprehensive exploration. We not only exploit the array geometry but also address the detrimental impact of electromagnetic interference (EMI) on the RIS during pilot transmission. This EMI, resulting from directional or isotropic interference from other UEs [26], has been identified as a significant factor affecting communication performance, especially as the RIS size increases [27]. EMI can occur accidentally due to various uncontrolled electromagnetic sources, including natural pollution/radiation and human-made devices or intentionally [27, 28, 29]. Since the RIS also reflects EMI, its effect should be analyzed rigorously. While the authors of [28, 30, 31] focus on the performance of RIS-based communications under EMI, [32] proposes an EMI cancellation method that accounts for slowly changing EMI. It is important to note that the majority of prior works, except for [26, 31], do not specifically address channel estimation. In [26], the method presented in the conference version of this paper (i.e., [1]) is employed in a two-stage training framework. In the first stage, the BS exclusively estimates EMI, assuming it remains constant during the pilot phase. Although our analysis shares this assumption, it offers a suboptimal solution in scenarios where EMI changes dynamically during pilot transmission. We thoroughly evaluate this performance in our numerical results. In [31], both LMMSE-based channel estimation and MMSE-based data detection under the influence of EMI are considered. The authors propose alternating optimization algorithms to optimize the RIS phase-shift pattern, ensuring local optimality. In our research, we extend this by providing the global optimal structure of the RIS phase-shift, omitting unit-modulus constraints. This extension yields a lower bound on the achievable mean-square error (MSE). Our contributions can be outlined as follows. We consider the spatial correlation seen at both the BS and the RIS and provide the corresponding LMMSE channel estimator. Inspired by our recent work without RIS [33], we propose a novel channel estimator that exploits the reduced-rank subspace created by the array geometry to improve the estimation quality without requiring UE-specific spatial correlation informationâ€”which is difficult to obtain in cases with a large number of BS antennas and RIS elements. The proposed reduced-subspace least squares (RS-LS) estimator outperforms the conventional LS estimator and enables reduced pilot training time. For both the LMMSE and RS-LS estimators, we derive the ideal RIS configuration that minimizes the respective MSE. We then demonstrate by simulation that projecting to the closest unit modulus RIS responses provides significantly better performance than the benchmarks. Furthermore, as a superior alternative, we propose a majorization-minimization (MM) algorithm for designing the RIS phase-shift matrix to minimize the MSE of the RS-LS estimator, offering a more effective approach to configuring the RIS for improved system performance. Unlike the conference version [1], which focuses solely on RS-LS without EMI, this work provides a comprehensive analysis of both the LMMSE and RS-LS estimators under EMI through extensive mathematical analysis, demonstrating the robustness and applicability of our methods in practical EMI conditions. Paper Outline Section II presents the channel and system modeling for RIS-aided communications. The pilot transmission under EMI and the proposed LMMSE- and RS-LS-based channel estimators are described in Section III. The optimal structure of the phase-shift configuration with and without EMI is derived in Section IV for the LMMSE estimator. The same is done with the RS-LS channel estimator later in Section V, where a suboptimal structure is obtained under EMI. Section VI presents a number of interesting numerical results, and Section VII offers final thoughts to wrap up the work. Reproducible research: All the simulation results can be reproduced using the Matlab code available at: https://github.com/ozlemtugfedemir/RIS-shorter-pilots"
https://arxiv.org/html/2411.04728v1,Neuromorphic Wireless Split Computing with Multi-Level Spikes,"Inspired by biological processes, neuromorphic computing utilizes spiking neural networks (SNNs) to perform inference tasks, offering significant efficiency gains for workloads involving sequential data. Recent advances in hardware and software have demonstrated that embedding a few bits of payload in each spike exchanged between the spiking neurons can further enhance inference accuracy. In a split computing architecture, where the SNN is divided across two separate devices, the device storing the first layers must share information about the spikes generated by the local output neurons with the other device. Consequently, the advantages of multi-level spikes must be balanced against the challenges of transmitting additional bits between the two devices.This paper addresses these challenges by investigating a wireless neuromorphic split computing architecture employing multi-level SNNs. For this system, we present the design of digital and analog modulation schemes optimized for an orthogonal frequency division multiplexing (OFDM) radio interface. Simulation and experimental results using software-defined radios provide insights into the performance gains of multi-level SNN models and the optimal payload size as a function of the quality of the connection between a transmitter and receiver.","I-A Context and Motivation Current learning algorithms, computing primitives, and hardware platforms such as GPUs are widely expected to soon fall short in supporting scalable, energy-efficient artificial intelligence (AI) models, especially for edge deployments [1]. This motivates the ongoing exploration of alternative computing paradigms, including in-memory computing [2], neuromorphic computing [3, 4], and quantum computing [5, 6]. Advances in computing technologies are bound to affect a range of fields from the sciences [7] to engineering [8]. This work studies some of the implications of the emergence of neurormorphic computing for telecommunications engineering [9, 10, 11, 12, 13, 14, 15, 16]. As communication networks become increasingly softwarized [17], spiking neural networks (SNNs) present a promising option as co-processors for wireless transmitters and receivers, as explored in [15, 13]. Neuromorphic computing, therefore, can play an important role in enabling advanced communication functionalities. Conversely, communication networks can support the development of distributed computing architectures grounded in neuromorphic principles. In these architectures, communication protocols must be tailored to the unique nature of information exchanged between SNN neurons. Unlike conventional multi-bit clocked messages, spiking neurons encode and transmit information through the timing of individual spikes. As a result, partitioning an SNN across multiple devices requires these devices to share timing information to maintain the integrity of the neural computations [9, 18, 10, 12, 19, 16, 20]. Figure 1: (a) Neuromorphic wireless split computing architecture based on multi-level SNNs: Spikes exchanged between a transmitter and a receiver over a wireless channel include a payload of mğ‘šmitalic_m bits. (b) While the accuracy of a centralized implementation increases monotonically with the spike payload mğ‘šmitalic_m [21, 22], in the presence of communication constraints there is generally an optimized value of mğ‘šmitalic_m that balances the informativeness of each spike with the reduced accuracy of higher-rate transmission. As shown in Fig. 1(a), in this paper, we focus on a basic distributed computing architecture [23] consisting of an SNN split between two devices, which are connected over a wireless channel. The transmitter-side SNN processes sequential data captured by a neuromorphic sensor, such as an event-driven camera [24, 25, 26, 27]. SNNs can natively process event-driven data via spiking neurons. The receiver-side SNN uses the received radio signal to produce a final inference decision. For example, in the set-up shown in Fig. 1, the transmitterâ€™s sensor observes hand gestures, which are estimated at the receiver side. Conventional SNNs represent information solely in the timing of spikes. However, digital neuromorphic chips, such as Intelâ€™s Loihi 2 supports multi-level, or graded, spikes with minimal additional energy cost [21, 22]. Multi-level spikes encode information both in the timing of the spikes and in their amplitude. There is evidence that biological brains may also leverage spike amplitude variability to encode additional information [28]. As illustrated in Fig. 1(a), multi-level spikes are assigned a payload of mğ‘šmitalic_m bits, while conventional spike carry m=0ğ‘š0m=0italic_m = 0 additional bits of information. SNNs with multi-level spikes have been shown to improve the accuracy of conventional SNN deployments, particularly when the number of timesteps available for inference is limited [29, 30, 31]. In a split computing architecture, the introduction of multi-level spikes creates the challenge of transmitting a larger amount of information per spike on the wireless interface. As illustrated in Fig. 1(b), while in a centralized implementation, larger values of payload size mğ‘šmitalic_m are generally beneficial in terms of inference accuracy, in a split computing system, an excessively large payload size can cause a performance degradation due to the lower fidelity of higher-rate transmissions on wireless channels. This work addresses this challenge by investigating the design of both analog and digital transmission schemes for neuromorphic wireless split computing systems with multi-level spikes. I-B Related Work Neuromorphic wireless split computing: Neuromorphic wireless split computing was first studied in [9], in which single-link neuromorphic sensing and computing were integrated with ultra-wideband (UWB) transmission to enable edge-based remote inference. This work was then extended in [10] to a multi-device scenario with frequency-selective channels, demonstrating IR transmissionâ€™s compatibility in multi-device environments. In [12], wake-up radios were incorporated into the system to further reduce the overall energy consumption of the system. The work reported in [19] analyzed how spike losses affect the inference accuracy and total neural activity when considering a distributed wireless SNN implementation. Another reference [14] studied a distributed system of edge nodes, each containing a subset of spiking neurons, that communicate with an access point via wireless channels using frequency division multiple access (FDMA) by allocating different frequency bands to different nodes. A neuromorphic integrated sensing and communications system was studied in [11], in which an SNN was deployed at the receiver to decode the transmitted information and detect the possible presence of a target simultaneously. There have been also several reported prototypes for neuromorphic split computing. The transmission model in [32] utilized neuromorphic principles, implemented on Intelâ€™s Loihi chip combined with software-defined radio (SDR) hardware, to build a full-stack neuromorphic wireless communication system that considers both orthogonal frequency division multiplexing (OFDM) and UWB transmission. Another work [33] experimentally demonstrated a communication approach for large-scale wireless asynchronous microsensor networks, enabling the transmission of binary events from thousands of local nodes with high spectral efficiency and low error rates. Multi-level SNNs: A few studies have contributed to advances in multi-level SNNs in centralized implementations. For example, reference [31] proposed a multi-bit transmission mechanism that expands spike representation from a single bit to multiple bits, enriching the information content per spike. In [34], a ternary spiking neuron was introduced to increase information capacity while retaining event-driven, addition-only processing advantages. Additionally, reference [35] designed a spiking neuron that activates integer values during training and maintains spike-driven behavior by extending virtual time-steps during inference for object detection tasks. I-C Main Contributions This paper investigates for the first time neuromorphic wireless split computing with multi-level SNNs. Previous works [12, 9, 10, 11], which focused on conventional SNNs, adopted a UWB interface due to its low power consumption and compatibility with spike-based transmission. In contrast, in this paper we adopt the standard OFDM interface, which provides a more flexible modulation scheme to accommodate multi-level spikes and is more widely applicable and available. In particular, OFDM facilitates prototyping using conventional SDR platforms, such as the Universal Software Radio Peripheral (USRP) [36]. We design and evaluate both digital and analog modulation schemes, which are tested via simulation and via an experimental platform. Overall, the main contributions of this paper are summarized as follows. â€¢ We study for the first time a neuromorphic wireless split computing architecture based on multi-level SNNs. Unlike conventional SNNs with binary spikes, multi-level SNNs are able to process richer information by assigning a multi-bit payload to each spike. â€¢ We detail a digital modulation scheme based on the address-event representation (AER) of multi-level spikes [21, 22]. According to this implementation, spike addresses and payloads are channel-encoded and modulated on OFDM symbols. If the number of information bits exceeds the available capacity â€“ which is more likely to occur for a larger value of the payload size mğ‘šmitalic_m â€“ spikes are dropped, causing a potential decrease in accuracy. Upon channel decoding, the transmitted spikes are reconstructed at the receiver and fed to the receiver-side SNN to produce the final inference decision. â€¢ We also detail an analog implementation whereby each output neuron of the transmitter-side SNN is assigned to a fixed subset of OFDM subcarriers and the spikes payloads are transmitted via pulse-amplitude modulation (PAM) on all the assigned subcarriers. This way, the addresses are implicitly transmitted via the location of the PAM symbols across the subcarrier indices. While no spikes are dropped as long as the number of subcarriers is large enough, analog transmission may degrade the quality of the reconstructed spikes due to the reliance of repetition coding. â€¢ We evaluate the performance of the proposed neuromorphic wireless split computing architecture based on multi-level SNNs both via simulations and via a basic prototype using a neuromorphic camera [37] and USRP boards. I-D Organization The remainder of the paper is organized as follows. Section II presents background information about multi-level SNN. Section III describes the neuromorphic wireless split computing system with multi-level spikes under study, while the proposed digital and analog transmission schemes are described in Section IV. Section V explains neuromorphic receiver processing, including channel estimation, equalization, and decoding SNN processing. Experimental setting and results are described in Section VI. Finally, Section VII concludes the paper."
https://arxiv.org/html/2411.04727v1,Quantum Speedup for Polar Maximum Likelihood Decoding,"Conventional decoding algorithms for polar codes strive to balance achievable performance and computational complexity in classical computing. While maximum likelihood (ML) decoding guarantees optimal performance, its NP-hard nature makes it impractical for real-world systems. In this letter, we propose a novel ML decoding architecture for polar codes based on the Grover adaptive search, a quantum exhaustive search algorithm. Unlike conventional studies, our approach, enabled by a newly formulated objective function, uniquely supports Gray-coded multi-level modulation without expanding the search space size compared to the classical ML decoding. Simulation results demonstrate that our proposed quantum decoding achieves ML performance while providing a pure quadratic speedup in query complexity.","Polar codes, introduced by Arikan [1], are the first class of error-correcting codes capable of achieving Shannon capacity over binary input discrete memoryless symmetric channels with low encoding complexity, which is adopted in the 5G standard for uplink control channels. The original decoding algorithm for polar codes, the successive cancellation (SC) algorithm, operates with Oâ¢(Nâ¢logâ¡N)ğ‘‚ğ‘ğ‘O(N\log N)italic_O ( italic_N roman_log italic_N ) time and space complexity, where Nğ‘Nitalic_N is the code length. However, the SC decoding suffers from suboptimal error-correction performances, especially for short to moderate code lengths, and cannot compete with turbo and low-density parity check (LDPC) codes. To address this limitation, the successive cancellation list (SCL) decoding algorithm was developed [2], retaining the Lğ¿Litalic_L most likely codewords at each step to enhance error-correction capability. Integrating cyclic redundancy check codes with SCL decoding further improves the performance [2], often surpassing turbo and LDPC codes for short to moderate code lengths. However, this approach increases complexity to Oâ¢(Lâ¢Nâ¢logâ¡N)ğ‘‚ğ¿ğ‘ğ‘O(LN\log N)italic_O ( italic_L italic_N roman_log italic_N ). When L=2Kğ¿superscript2ğ¾L=2^{K}italic_L = 2 start_POSTSUPERSCRIPT italic_K end_POSTSUPERSCRIPT, covering all possible polar codewords, it achieves optimal maximum likelihood (ML) decoding, but with exponential complexity. In quantum computing, Groverâ€™s algorithm [3] can locate an exact solution in an unsorted database of size 2Nsuperscript2ğ‘2^{N}2 start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT with Oâ¢(2N)ğ‘‚superscript2ğ‘O(\sqrt{2^{N}})italic_O ( square-root start_ARG 2 start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT end_ARG ) query complexity, offering a quadratic speedup over the Oâ¢(2N)ğ‘‚superscript2ğ‘O(2^{N})italic_O ( 2 start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT ) complexity of classical exhaustive search. This framework has been extended to binary optimization problems while retaining the quadratic speedup. Recent studies have explored Grover adaptive search (GAS) [4], a variant of Groverâ€™s algorithm, to reduce complexity in solving NP-hard problems like codebook design [5] and ML decoding for multi-input multi-output systems [6].111Note that such speedup can only be realized through future fault-tolerant quantum computing. Several studies have explored decoding algorithms for classical polar codes relying on quantum computing. A pioneering approach of [7] uses a quantum gate model with amplitude amplification, a generalization of Groverâ€™s algorithm, to achieve ML decoding under ideal conditions with binary phase shift keying (BPSK) modulation. However, this approach does not consider practical multi-level modulation schemes and evaluates all possible 2Nsuperscript2ğ‘2^{N}2 start_POSTSUPERSCRIPT italic_N end_POSTSUPERSCRIPT binary vectors, including non-polar codewords, whereas the classical ML decoding only searches 2Ksuperscript2ğ¾2^{K}2 start_POSTSUPERSCRIPT italic_K end_POSTSUPERSCRIPT polar codewords. Another approach of [8] combines quantum annealing with classical computation, where the classical part computes log-likelihood ratios at the upper-level of the SC decoder, and the quantum part decodes lower-level sub-blocks. The study in [9] shows this annealing approach without upper-level classical computation can achieve near-ML performance for short polar codes. However, it requires redundant ancillae, expanding the search space to 2Nâ¢(logâ¡N+1)superscript2ğ‘ğ‘12^{N(\log N+1)}2 start_POSTSUPERSCRIPT italic_N ( roman_log italic_N + 1 ) end_POSTSUPERSCRIPT. Additionally, quantum annealing often produces sub-optimal solutions, and achieving quantum speedup over classical computing is generally considered unlikely [10]. Against this background, we consider achieving a pure quantum speedup for polar ML decoding. This letter has two major contributions. 1) We propose an ML decoding architecture for classical polar codes using GAS, achieving a pure quadratic speedup in computational complexity over a classical ML counterpart. Specifically, the classical ML decoding requires Oâ¢(2K)ğ‘‚superscript2ğ¾O(2^{K})italic_O ( 2 start_POSTSUPERSCRIPT italic_K end_POSTSUPERSCRIPT ) complexity, while our approach requires only Oâ¢(2K)ğ‘‚superscript2ğ¾O(\sqrt{2^{K}})italic_O ( square-root start_ARG 2 start_POSTSUPERSCRIPT italic_K end_POSTSUPERSCRIPT end_ARG ). This speedup relies on an initial state preparation exploiting the unique structure of polar codes, which prepares a superposition of quantum states corresponding to only valid polar codewords. 2) Additionally, we introduce the first approach for ML decoding of classical polar codes with a multi-level Gray-coded 2Msuperscript2ğ‘€2^{M}2 start_POSTSUPERSCRIPT italic_M end_POSTSUPERSCRIPT-pulse amplitude modulation (PAM). This approach features a tailored objective function for ML decoding of multi-level Gray-coded symbols, which is also applicable to general ML detection schemes, while the conventional studies [8, 7, 9] only support BPSK."
https://arxiv.org/html/2411.04702v1,Large Intelligent Surfaces with Low-End Receivers: From Scaling to Antenna and Panel Selection,"We analyze the performance of large intelligent surface (LIS) with hardware distortion at its RX-chains. In particular, we consider the memory-less polynomial model for non-ideal hardware and derive analytical expressions for the signal to noise plus distortion ratio after applying maximum ratio combining (MRC) at the LIS. We also study the effect of back-off and automatic gain control on the RX-chains. The derived expressions enable us to evaluate the scalability of LIS when hardware impairments are present. We also study the cost of assuming ideal hardware by analyzing the minimum scaling required to achieve the same performance with a non-ideal hardware. Then, we exploit the analytical expressions to propose optimized antenna selection schemes for LIS and we show that such schemes can improve the performance significantly. In particular, the antenna selection schemes allow the LIS to have lower number of non-ideal RX-chains for signal reception while maintaining a good performance. We also consider a more practical case where the LIS is deployed as a grid of multi-antenna panels, and we propose panel selection schemes to optimize the complexity-performance trade-offs and improve the system overall efficiency.","Large Intelligent Surfaces (LISs) have emerged as one of the next major steps in the future development of multiple-input multiple-output (MIMO) communication systems [1, 2, 3]. While LISs are sometimes considered to be a scaled up version of the widely known massive MIMO systems, they have some unique properties which distinguishes them from the massive MIMO systems. For instance, their physical size can be compared to the user-equipment (UE) distance to the LIS, which introduces near-field effects in the wireless channel. As a result, the common assumptions about the massive MIMO channels are no longer valid and new effects emerge. This requires different channel models, and more investigation into the already known facts about the transmit and receive schemes in massive MIMO systems [4]. More importantly, the deployment of LISs is envisioned to be much more challenging because of the enormous leap in the number of transceiver chains, and the associated processing complexities. One important challenge is the cost efficiency of the whole system, where hundreds to thousands of transceiver chains are to be deployed, which may force systems designers to consider the use of inexpensive hardware components in each of these transceiver chains [5]. Therefore, it is of high importance to study and mitigate the effects of hardware distortion in transceiver chains when scaling up LIS to allow the use of cost-efficient transceiver chains. The vision for future antenna arrays in the next generation of wireless communication systems highly depends on deploying arbitrarily large arrays due to the compelling gains in terms of multiplexing and beamforming performance through increasing spatial resolution [6]. With traditional design approaches, implementing such a huge array may not be economically favored for operators and vendors, since each antenna is typically equipped with an analog and a digital front-end (AFE and DFE) [7]. The requirements for each transceiver chain may lead to unreasonable implementation costs [8]. On the other hand, the power consumption of each transceiver can also become a bottleneck, especially if there are tight requirements on the non-linearity of amplifiers and the out-of-band emissions. AFEs are considered to be one of the main sources of hardware distortion in receivers [9, 10, 11]. Not only the non-linearity effect of AFEs are important to consider, but also the limitations in the total power consumption of the receiver chain is of great importance. Linearity requirements in the RX-chains can result in a huge leap in power consumption of the whole system [12], which is not favorable neither in terms of cost nor energy efficiency. To deal with these challenges, we need to make the receiver design as efficient as possible, from a system perspective. In general, the path to follow is to optimize the signal processing schemes and system designs while maintaining the hardware quality at a minimum level. In other words, we want to get the most gain from each transceiver chain while limiting the implementation costs, e.g., by using inexpensive hardware components. In [13] and [14], we have proposed approaches to address such challenges in massive MIMO systems, mainly by optimizing the per-antenna digital pre-distortion (DPD) resources. Another approach is to perform antenna selection methods and only use a portion of the array for transmission and reception. By doing so, we only use antennas which have a significant contribution to the performance and thereby increase energy efficiency. In this paper, we focus on optimizing the performance of LIS with non-ideal RX-chains. We first analyze the signal to distortion-plus-noise ratio (SNDR) with the purpose of studying the scaling behavior and asymptotic limits of LIS with hardware distortion. Then, we propose receive antenna selection schemes for a LIS with non-ideal AFEs. Optimization problems are defined and solved to illustrate the importance of performing antenna selection when scaling up LIS. We show that selecting antennas with the strongest channels is not always the optimal solution. We then focus on more practical cases where the LIS is implemented as a grid of panels, and transform the antenna selection problem into a panel selection problem. Low-complexity closed-form sub-optimal solutions are proposed for the panel selection. We also show that, by adopting such antenna selection and panel selection schemes, we can improve the system performance significantly for a fixed receive-chain hardware quality. I-A Contributions The contributions of this paper are listed as follows. â€¢ We provide a framework to study the hardware distortion effect on LIS performance while considering high-complexity non-linear polynomial model at RX-chains. â€¢ We derive close-form expressions for the SNDR of the LIS under polynomial hardware distortion model to enable scaling and asymptotic analysis. â€¢ We introduce antenna selection problems in LIS with hardware distortion and illustrate the achievable gains of adopting optimal antenna selection. We also consider the the more practical case with a panel-based LIS and propose closed-form solutions for panel selection with hardware distortion effects. I-B Paper Outline The rest of this paper is organized as follows. In Section II, the system model is introduced, which includes the LIS deployment configurations, channel model, and hardware distortion model. In Section III, we characterize the SNDR and propose closed-form expressions to evaluate the LIS performance, which is exploited for asymptotic and scaling analysis. Sections IV and V introduce the antenna and panel selection problems, respectively, and some proposed solutions are presented for the corresponding LIS scenarios. In Section VI, numerical results are used to further illustrate the results from previous sections. Finally, Section VII concludes the paper results. I-C Notation Matrices, vectors, and scalars are denoted by boldface uppercase, boldface lowercase, and italic letters, respectively. For a vector ğ’‚ğ’‚\bm{a}bold_italic_a, conjugate transpose, transpose, Euclidean norm, and the iğ‘–iitalic_iâ€™th element of ğ’‚ğ’‚\bm{a}bold_italic_a are represented by ğ’‚Hsuperscriptğ’‚ğ»\bm{a}^{H}bold_italic_a start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT, ğ’‚Tsuperscriptğ’‚ğ‘‡\bm{a}^{T}bold_italic_a start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT, â€–ğ’‚~â€–norm~ğ’‚\|\tilde{\bm{a}}\|âˆ¥ over~ start_ARG bold_italic_a end_ARG âˆ¥, and aisubscriptğ‘ğ‘–a_{i}italic_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, respectively. For a scalar ağ‘aitalic_a, the complex conjugate is denoted by aÂ¯Â¯ğ‘\bar{a}overÂ¯ start_ARG italic_a end_ARG. We indicate zero-mean circularly-symmetric complex Gaussian random vectors with covariance matrix ğ‘ªğ‘ª\bm{C}bold_italic_C as ğ’‚âˆ¼ğ’â¢ğ’©â¢(ğŸ,ğ‘ª)similar-toğ’‚ğ’ğ’©0ğ‘ª\bm{a}\sim\mathcal{CN}(\bm{0},\bm{C})bold_italic_a âˆ¼ caligraphic_C caligraphic_N ( bold_0 , bold_italic_C ) and the expectation of a random variable by ğ”¼â¢{â‹…}ğ”¼â‹…\mathbb{E}\{\cdot\}blackboard_E { â‹… }. We denote a diagonal matrix with elements a1,â€¦,aNsubscriptğ‘1â€¦subscriptğ‘ğ‘{a_{1},...,a_{N}}italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_a start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT on the main diagonal by diagâ¢(a1,â€¦,aN)diagsubscriptğ‘1â€¦subscriptğ‘ğ‘\textnormal{diag}\left({a_{1},...,a_{N}}\right)diag ( italic_a start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_a start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT ) and the NÃ—Nğ‘ğ‘N\times Nitalic_N Ã— italic_N identity matrix by ğ‘°Nsubscriptğ‘°ğ‘\bm{I}_{N}bold_italic_I start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT."
https://arxiv.org/html/2411.04689v1,Over-the-Air DPD and Reciprocity Calibration in Massive MIMO and Beyond,"In this paper we study an over-the-air (OTA) approach for digital pre-distortion (DPD) and reciprocity calibration in massive multiple-input-multiple-output systems. In particular, we consider a memory-less non-linearity model for the base station (BS) transmitters and propose a methodology to linearize the transmitters and perform the calibration by using mutual coupling OTA measurements between BS antennas. We show that by only using the OTA-based data, we can linearize the transmitters and design the calibration to compensate for both the non-linearity and non-reciprocity of BS transceivers effectively. This allows to alleviate the requirement to have dedicated hardware modules for transceiver characterization. Moreover, exploiting the results of the DPD linearization step, our calibration method may be formulated in terms of closed-form transformations, achieving a significant complexity reduction over state-of-the-art methods, which usually rely on costly iterative computations. Simulation results showcase the potential of our approach in terms of the calibration matrix estimation error and downlink data-rates when applying zero-forcing precoding after using our OTA-based DPD and calibration method.","Massive multiple-input multiple-output (MIMO) has been one of the main technologies in the development of the fifth-generation (5G) of wireless networks, by enabling significant improvement in network capacity and reliability [1, 2]. In the early stages of massive MIMO development, several proposals motivated the adoption of frequency-division duplexing (FDD) in massive MIMO deployments. While some advantages may arise from considering FDD [3], the over-head in downlink channel estimation is an important drawback which limits the system scalability. Therefore, time-division duplexing (TDD) is selected as the more viable approach for the deployment of massive MIMO in 5G and beyond, since it enables downlink channel estimation based on uplink channel state information (CSI) and channel reciprocity [4]. In ideal TDD systems, perfect channel reciprocity allows the base station (BS) to use the uplink (UL) CSI also for downlink (DL) precoding. However, in practical deployments, the difference in transmit (TX) and receive (RX) hardware may compromise this assumption [5]. To tackle this issue, reciprocity calibration methods are employed to compensate the difference in TX and RX hardware in DL precoding. There are several approaches for reciprocity calibration in massive MIMO systems. \AcOTA-based reciprocity calibration methods relying on mutual-coupling measurements are specially promising since they do not require dedicated hardware for reciprocity calibration [6, 7]. Another challenge in implementing massive MIMO systems is the non-linear response of the transceivers. There are several methods to compensate the non-linearity effects, with per-antenna digital pre-distortion (DPD) being the most favorable option because of its effectiveness [8]. To perform the DPD, many approaches rely on input-output measurements of the amplifiers and analogue front-ends to design an inverse function for cancelling the non-linearity effects [8, 9, 10]. over-the-air (OTA)-based DPD approaches such as the methods based on wireless links with near-field or far-field probes have emerged as an efficient alternative to linearize the amplifiers by exploiting the OTA data [11]. In this paper, we propose a method exploiting OTA measurements of inter-antenna mutual couplings at the BS to perform both the DPD and reciprocity calibration. The reciprocity methods in the literature mostly rely on linear transceivers, i.e., modelled by a complex number [6, 5]. This assumption is not accurate in practical cases, especially when scaling up massive MIMO systems, which necessitates deploying less expensive non-linear components and low-end DPD modules. Therefore, we assume that the TX-chains in the BS are non-linear and we propose a method to linearize them based on mutual coupling measurements. Our approach relies on the same hardware available for OTA-based reciprocity calibration, which eliminates the need for excessive hardware resources to perform per-antenna DPD. We show that, once the transmitters are linearized through the OTA-based method, reciprocity calibration becomes even simpler than previous approaches, allowing for a significant complexity reduction over the methods in [6, 5]. Numerical results show that, although we consider non-linear TX-chains, the calibration matrix estimation error is fairly close to the Cramer-Rao Lower Bound (CRLB) for the method from [6]. We also evaluate the system performance in downlink data transmission using zero-forzing (ZF) precoding and show that the proposed calibration method can approach the optimal calibration performance for moderate values of signal to noise ratio (SNR)."
https://arxiv.org/html/2411.04675v1,"Advancing Multi-Connectivity in Satellite-Terrestrial Integrated Networks: Architectures, Challenges, and Applications","Multi-connectivity (MC) in satellite-terrestrial integrated networks (STINs), included in 3GPP standards, is regarded as a promising technology for future networks. The significant advantages of MC in improving coverage, communication, and sensing through satellite-terrestrial collaboration have sparked widespread interest. In this article, we first introduce three fundamental deployment architectures of MC systems in STINs, including multi-satellite, single-satellite single-base-station, and multi-satellite multi-base-station configurations. Considering the emerging but still evolving satellite networking, we explore system design challenges such as satellite networking schemes, e.g., cell-free and multi-tier satellite networks. Then, key technical challenges that severely influence the quality of mutual communications, including beamforming, channel estimation, and synchronization, are discussed subsequently. Furthermore, typical applications such as coverage enhancement, traffic offloading, collaborative sensing, and low-altitude communication are demonstrated, followed by a case study comparing coverage performance in MC and single-connectivity (SC) configurations. Several essential future research directions for MC in STINs are presented to facilitate further exploration.","Fueled by the increasing demand for high-quality seamless connectivity and the rapid proliferation of data-intensive applications such as video streaming, cloud services, and the Internet of Things (IoT), the evolution of network architectures continues to advance inexorably. Conventional terrestrial networks (TNs) can often be restricted by insufficient infrastructure, particularly in remote and underserved areas. This gives rise to the emergence of multi-connectivity (MC), a solution that enables a devicesâ€™ simultaneous connections to multiple networks to enhance communication robustness, performance, and resilience [1]. Recently, the next generation of wireless communication systems, that is, the sixth generation (6G), has embarked on the extension of the capabilities and scenarios of the fifth generation (5G) such as network coverage, traffic offloading, integrated sensing and communication, low-altitude economy, etc., to global IoT. By allowing devices to connect to multiple network nodes concurrently, increased coverage, higher data throughput, and improved reliability can be ensured for connections between transmitters and user equipments (UEs). To satisfy this growing demand in wider areas, it is essential to understand the developments in potential architectures, technical challenges, and potential real-world applications of MC from a system-level perspective. In recent years, satellite communication (SatCom) is envisioned to be a perfect supplement for TNs in the context of its extensive coverage and efficient multi-cast and broadcast capabilities. However, challenges such as weather sensitivity, the high cost of deployment and maintenance, and deep fading at higher frequencies make it difficult for SatCom systems to independently support global services. Considering the non-negligible role of TNs, satellite-terrestrial integrated networks (STINs) have attracted the attention of standardization institutes, network operators, research fraternities, and related industries [2]. By reaping the benefits of the wide coverage provided by satellites and the high data rates of both networks, STINs act as a prospective paradigm for future networks in providing global coverage and ubiquitous wireless access. Note that if certain satellites or base stations (BSs) become overloaded due to a large number of UEs, their resources are strained, while other satellites or BSs may remain underutilized. This imbalance leads to inefficient use of available network resources. One promising solution to tackle such a problem is to redistribute the load by incorporating MC in STINs to switch or add UEs to less congested satellites and/or BSs. In this case, while no additional bandwidth is provided, UEs experience greater flexibility in connecting to multiple serving entities in the TN and/or non-terrestrial network (NTN). Obviously, by exploiting MC in STINs, the excess available resources could be utilized more efficiently. Moreover, the interoperability of satellites and TNs can support seamless handover and reduce the probability of handover failure, which will improve the reliability of the connection. In addition, the information interaction among satellites and BSs can be made more efficient so that more dynamic and adaptive space-air-ground resource coordination and optimization can be realized. It is worth mentioning that MC in terrestrial mobile networks was once studied in terms of protocols, data and control in the transport layer and the network layer [3]. The authors in [4] also presented the concept of MC in NTNs, but did not take into account the inherent TNs. An overview of the activities and goals of an ongoing STIN project was provided in [5], without leveraging the advantages offered by MC. It is worth mentioning that none of the above works considered the capabilities and application scenarios in future generation networks. Therefore, in this article we seek to address this gap in existing research. Although MC in STINs is expected to offer potential benefits, several questions remain to be answered. â€¢ Q1: What will be the basic architectures for deployment when the MC is integrated into current networks? â€¢ Q2: What will be the challenges to the system design of MC in STINs from a system-level perspective? â€¢ Q3: What will be the real-world applications that MC will have in STINs for future communication systems? This article first provides an overview of MC in STINs in Fig. 1. The main contributions are summarized as follows. FIGURE 1: An overview of MC in STINs. â€¢ We present three deployment architectures for MC when integrating satellite networks into current TNs. Importantly, we provide a comprehensive introduction to these architectures, detailing their characteristics and differences in user pairing and scheduling in each architecture. â€¢ We investigate critical challenges in designing the MC system in STINs from a wireless networking perspective. Specifically, we elaborate on the challenges in the establishment of satellite networks, the use of transmission strategies, the application of channel estimation techniques, and the execution of synchronization operations. â€¢ We propose four typical applications of MC in current and future networks, including coverage enhancement, traffic offloading, collaborative sensing, and low-altitude communication. Then, a case study is conducted to show the improvement in coverage when applying MC compared to single-connectivity networks. Finally, the article concludes with a discussion on future research directions for exploring additional technical opportunities of MC in STINs."
https://arxiv.org/html/2411.04464v1,"Decoding Quasi-Cyclic Quantum LDPC Codesâ€ â€ thanks:Research supported in part by a ONR grant N00014-24-1-2491, a UC Noyce initiative award, and a Simons Investigator award. L.Â Golowich is supported by a National Science Foundation Graduate Research Fellowship under Grant No.Â DGE 2146752.","Quantum low-density parity-check (qLDPC) codes are an important component in the quest for quantum fault tolerance. Dramatic recent progress on qLDPC codes has led to constructions which are asymptotically good, and which admit linear-time decoders to correct errors affecting a constant fraction of codeword qubits [PK22a, LZ23, DHLV23, GPT23]. These constructions, while theoretically explicit, rely on inner codes with strong properties only shown to exist by probabilistic arguments, resulting in lengths that are too large to be practically relevant. In practice, the surface/toric codes, which are the product of two repetition codes, are still often the qLDPC codes of choice.A construction preceding [PK22a] based on the lifted product of an expander-based classical LDPC code with a repetition code [PK22b] achieved a near-linear distance (of Î©â¢(N/logâ¡N)Î©ğ‘ğ‘\Omega(N/\log N)roman_Î© ( italic_N / roman_log italic_N ) where Nğ‘Nitalic_N is the number of codeword qubits), and avoids the need for such intractable inner codes. Our main result is an efficient decoding algorithm for these codes that corrects Î˜â¢(N/logâ¡N)Î˜ğ‘ğ‘\Theta(N/\log N)roman_Î˜ ( italic_N / roman_log italic_N ) adversarial errors. En route, we give such an algorithm for the hypergraph product version these codes, which have weaker Î˜â¢(N)Î˜ğ‘\Theta(\sqrt{N})roman_Î˜ ( square-root start_ARG italic_N end_ARG ) distance (but are simpler). Our decoding algorithms leverage the fact that the codes we consider are quasi-cyclic, meaning that they respect a cyclic group symmetry.Since the repetition code is not based on expanders, previous approaches to decoding expander-based qLDPC codes, which typically worked by greedily flipping code bits to reduce some potential function, do not apply in our setting. Instead, we reduce our decoding problem (in a black-box manner) to that of decoding classical expander-based LDPC codes under noisy parity-check syndromes. For completeness, we also include a treatment of such classical noisy-syndrome decoding that is sufficient for our application to the quantum setting.","Quantum low-density parity-check (qLDPC) codes provide a particularly promising avenue for achieving low-overhead quantum error correction. Alongside code design, one of the most important challenges associated with qLDPC codes is the design of efficient decoding algorithms, which are needed to correct errors more quickly than they occur in quantum devices. In this paper, we present new efficient algorithms to decode qLDPC codes arising from a product of a classical LDPC code and a repetition code against a number of adversarial errors growing linearly in the code distance. As described below, the problem of decoding such quantum codes arise in various settings of interest, and even permits a purely classical interpretation. To the best of our knowledge, our results provide the first known polynomial-time decoding algorithms for these codes. A qLDPC code is a quantum code for which errors on code states can be corrected by first performing some constant-weight quantum stabilizer (i.e. parity-check) measurements, and then running a classical decoding procedure that processes these measurement outcomes to identify an appropriate correction that will revert the effect of the error. The stabilizer measurements are typically efficient111Assuming an architecture permitting arbitrary qubit connectivity., at least in theory, as they by definition each only involve a constant number of qubits. Therefore a key challenge in decoding qLDPC codes is to define a classical decoding algorithm, which receives as input the stabilizer measurement outcomes, called the syndrome. This algorithm must output a Pauli correction that can be applied to revert the effect of the physical error on the code qubits. We typically want to design efficient decoding algorithms for qLDPC codes with large distance and dimension relative to the length, or number of physical qubits. The distance of a code measures the maximum number of corruptions from which the original code state can be recovered information-theoretically (but possibly inefficiently). In particular, codes of distance Dğ·Ditalic_D permit information-theoretic error-correction from adversarial errors acting on up to (Dâˆ’1)/2ğ·12(D-1)/2( italic_D - 1 ) / 2 physical code qubits. Meanwhile, the dimension of a code equals the number of logical qubits that can be encoded in the code. For over two decades, there were no known qLDPC codes of length Nğ‘Nitalic_N and distance above O~â¢(N)~ğ‘‚ğ‘\tilde{O}(\sqrt{N})over~ start_ARG italic_O end_ARG ( square-root start_ARG italic_N end_ARG ), which up to poly-logarithmic factors is the distance achieved by Kitaevâ€™s Toric code [Kit03]. However, a recent breakthrough line of work achieved the first qLDPC codes of distance N1/2+Î©â¢(1)superscriptğ‘12Î©1N^{1/2+\Omega(1)}italic_N start_POSTSUPERSCRIPT 1 / 2 + roman_Î© ( 1 ) end_POSTSUPERSCRIPT [HHO21, BE21, Has23], culminating first in qLDPC codes of nearly linear distance D=Î˜â¢(N/logâ¡N)ğ·Î˜ğ‘ğ‘D=\Theta(N/\log N)italic_D = roman_Î˜ ( italic_N / roman_log italic_N ) with dimension K=Î˜â¢(logâ¡N)ğ¾Î˜ğ‘K=\Theta(\log N)italic_K = roman_Î˜ ( roman_log italic_N ) [PK22b], and then finally of linear distance D=Î˜â¢(N)ğ·Î˜ğ‘D=\Theta(N)italic_D = roman_Î˜ ( italic_N ) and dimension K=Î˜â¢(N)ğ¾Î˜ğ‘K=\Theta(N)italic_K = roman_Î˜ ( italic_N ) (i.e. asymptotically good) [PK22a]. The construction of [PK22a], along with some spinoff constructions [LZ22, DHLV23], remain the only known linear-distance qLDPC codes. Meanwhile, the codes of [PK22b] remain the only other known construction of qLDPC codes with almost linear distance Dâ‰¥N1âˆ’oâ¢(1)ğ·superscriptğ‘1ğ‘œ1D\geq N^{1-o(1)}italic_D â‰¥ italic_N start_POSTSUPERSCRIPT 1 - italic_o ( 1 ) end_POSTSUPERSCRIPT. The codes of [PK22a, LZ22, DHLV23], though asymptotically good in theory, are constructed using inner codes for which the only known constructions are randomized and prohibitively large in practice. In contrast, the nearly-linear-distance codes of [PK22b] are constructed as a product of an expander-based classical LDPC code with a repetition code, and thereby avoid the need for such intractable inner code properties. These codes of [PK22b] are said to be quasi-cyclic, as they respect the action of a large cyclic group, in part due to the cyclic symmetry of the repetition code. The asymptotically good codes of [PK22a, LZ22, DHLV23] have been shown to have linear-time decoders [GPT23, LZ23, DHLV23], which can be parallelized to run in logarithmic time [LZ23]. However, to the best of our knowledge, there were no known polynomial-time decoding algorithms for the nearly-linear distance quasi-cyclic codes of [PK22b]. Such a decoder is our principal contribution: Theorem 1 (Informal statement of Theorem 32 with Proposition 24). There exists an explicit family of qLDPC codes ğ’ğ’\mathcal{C}caligraphic_C of length Nâ†’âˆâ†’ğ‘N\rightarrow\inftyitalic_N â†’ âˆ, dimension K=Î˜â¢(logâ¡N)ğ¾Î˜ğ‘K=\Theta(\log N)italic_K = roman_Î˜ ( roman_log italic_N ), and distance D=Î˜â¢(N/logâ¡N)ğ·Î˜ğ‘ğ‘D=\Theta(N/\log N)italic_D = roman_Î˜ ( italic_N / roman_log italic_N ) obtained by instantiating the construction of [PK22b], such that the following holds. Fix any constants 0<Ïµâ‰¤1/20italic-Ïµ120<\epsilon\leq 1/20 < italic_Ïµ â‰¤ 1 / 2 and Ïµâ€²>0superscriptitalic-Ïµâ€²0\epsilon^{\prime}>0italic_Ïµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT > 0. Then there is a Oâ¢(N2+Oâ¢(Ïµ+Ïµâ€²))ğ‘‚superscriptğ‘2ğ‘‚italic-Ïµsuperscriptitalic-Ïµâ€²O(N^{2+O(\epsilon+\epsilon^{\prime})})italic_O ( italic_N start_POSTSUPERSCRIPT 2 + italic_O ( italic_Ïµ + italic_Ïµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) end_POSTSUPERSCRIPT )-time randomized decoding algorithm for ğ’ğ’\mathcal{C}caligraphic_C that successfully decodes against Î˜â¢(Ïµâ¢D)Î˜italic-Ïµğ·\Theta(\epsilon D)roman_Î˜ ( italic_Ïµ italic_D ) adversarial errors with probability â‰¥1âˆ’2âˆ’NÏµâ€²absent1superscript2superscriptğ‘superscriptitalic-Ïµâ€²\geq 1-2^{-N^{\epsilon^{\prime}}}â‰¥ 1 - 2 start_POSTSUPERSCRIPT - italic_N start_POSTSUPERSCRIPT italic_Ïµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT. In words, Theorem 1 provides a close-to-quadratic time randomized algorithm that decodes the codes of [PK22b] from a linear number of errors with respect to the code distance, with just an exponentially small probability of a decoding failure. At a very high level, our algorithm works by making appropriate black-box calls to a classical LDPC code decoder that can handle errors on both code bits and parity-check bits. We emphasize that Theorem 1 provides a decoding algorithm that corrects against arbitrary adversarial errors, not simply randomized errors. The randomization and exponentially small failure probability in Theorem 1 instead arise from a randomized component of the decoding algorithm. As shown in Section 6, we depress the failure probability to be exponentially small using standard amplification techniques; we can similarly detect decoding failures when they do occur. 1.1 Overview of QLDPC Code Constructions The nearly linear-distance quasi-cyclic qLDPC codes of [PK22b] in Theorem 1 are constructed as the lifted product (see Section 2.7) of a classical Tanner code (on an expander graph) with a repetition code. Lifted products provide a general means for constructing a quantum code from two classical codes that respect a group symmetry. The asymptotically good qLDPC codes of [PK22a, LZ22, DHLV23] are also constructed using a lifted product, but of two classical Tanner codes on expander graphs (see also [TZ14]). Meanwhile, the Toric code [Kit03] is constructed as a product of two repetition codes. We remark that the Toric code, along with the closely related surface code [BK98], has dimension K=Î˜â¢(1)ğ¾Î˜1K=\Theta(1)italic_K = roman_Î˜ ( 1 ), distance Î˜â¢(N)Î˜ğ‘\Theta(\sqrt{N})roman_Î˜ ( square-root start_ARG italic_N end_ARG ), was essentially the state-of-the-art qLDPC code for many years, and remains integral to practical quantum error correction efforts. To summarize, many qLDPC codes of interest in the literature are constructed either as a product of two expander-based classical LDPC codes, or as a product of two repetition codes. The quasi-cyclic codes of [PK22b] interpolate between these two constructions by taking a product of an expander-based classical LDPC code with a repetition code. Our work initiates the study of efficiently decoding such products of an expander-based code with a repetition code. Our techniques are applicable beyond the decoder in Theorem 1 for the codes of [PK22b]. For instance, we show that a similar, but less involved, decoding algorithm applies to another class of quasi-cyclic codes, obtained as a related (but different) product, namely the hypergraph product, of an expander-based classical LDPC code with a repetition code (see Section 5). The reader is referred to Section 1.3 for comparisons to prior decoders for related codes. Such hypergraph products of expander-based codes with repetition codes arise naturally in various settings. For instance, similar such codes are used to teleport logical qubits between a product of two expander-based codes and a surface code; see for instance [XAP+23]. Perhaps more fundamentally, the hypergraph product of some code ğ’œğ’œ\mathcal{A}caligraphic_A with a repetition code â„¬â„¬\mathcal{B}caligraphic_B can be viewed as a description of how the code ğ’œğ’œ\mathcal{A}caligraphic_A handles errors occuring on different code components at different points in time. At a high level, here the code ğ’œğ’œ\mathcal{A}caligraphic_A describes the available storage space, while the repetition code â„¬â„¬\mathcal{B}caligraphic_B serves as the time axis. This viewpoint is often used in quantum error correction to design decoding algorithms, such as for the surface code, that are robust against syndrome errors (see e.g. [DKLP02]). Appendix A applies this viewpoint to give a fully classical interpretation of our decoding algorithm for quantum hypergraph product codes. 1.2 Overview of Decoding Techniques Our decoding algorithm for the codes ğ’ğ’\mathcal{C}caligraphic_C in Theorem 1 leverages the group symmetry that ğ’ğ’\mathcal{C}caligraphic_C respects due to its quasi-cyclic nature. If we arrange the bits of a length-â„“â„“\ellroman_â„“ repetition code in a circle, then the code is preserved under the cyclic group action of â„¤/â„“â¢â„¤â„¤â„“â„¤\mathbb{Z}/\ell\mathbb{Z}blackboard_Z / roman_â„“ blackboard_Z, where iâˆˆâ„¤/â„“â¢â„¤ğ‘–â„¤â„“â„¤i\in\mathbb{Z}/\ell\mathbb{Z}italic_i âˆˆ blackboard_Z / roman_â„“ blackboard_Z simply shifts all bits by iğ‘–iitalic_i positions clockwise. As ğ’ğ’\mathcal{C}caligraphic_C is obtained as a product of an expander-based code (also respecting a cyclic group action) with a length-â„“â„“\ellroman_â„“ repetition code, ğ’ğ’\mathcal{C}caligraphic_C inherits this action of â„¤/â„“â¢â„¤â„¤â„“â„¤\mathbb{Z}/\ell\mathbb{Z}blackboard_Z / roman_â„“ blackboard_Z. Therefore the code space of ğ’ğ’\mathcal{C}caligraphic_C is preserved under permutations of the qubits by actions of the group â„¤/â„“â¢â„¤â„¤â„“â„¤\mathbb{Z}/\ell\mathbb{Z}blackboard_Z / roman_â„“ blackboard_Z, so ğ’ğ’\mathcal{C}caligraphic_C is indeed a quasi-cyclic quantum code. At a high level, our decoder in Theorem 1 repeatedly adds together different cyclic shifts of the received syndrome, and then passes this sum through a classical Tanner code decoder to gain information about the original error. Our algorithm can use, in a black-box manner, any such classical decoder that corrects against errors on the code bits in the presence of errors on the parity-check syndrome bits. The main idea is that we isolate the effects of certain errors by summing together different cyclic shifts of the syndrome; we can then identify, and ultimately correct, these errors. [PK22b] used a related idea to prove the distance bound in these codes. However, our actual algorithm is rather delicate, and requires an iterative aspect that is absent from the distance proof of [PK22b]. Specifically, our algorithm consists of Î˜â¢(logâ¡â„“)Î˜â„“\Theta(\log\ell)roman_Î˜ ( roman_log roman_â„“ ) iterations, where the Ï„ğœ\tauitalic_Ï„th iteration adds together 2Ï„superscript2ğœ2^{\tau}2 start_POSTSUPERSCRIPT italic_Ï„ end_POSTSUPERSCRIPT cyclic shifts of the syndrome, and uses a classical Tanner code decoder to perform some analysis with a constant probability of failure. With probability 2âˆ’Î˜â¢(logâ¡â„“)=1/polyâ¡(â„“)superscript2Î˜â„“1polyâ„“2^{-\Theta(\log\ell)}=1/\operatorname{poly}(\ell)2 start_POSTSUPERSCRIPT - roman_Î˜ ( roman_log roman_â„“ ) end_POSTSUPERSCRIPT = 1 / roman_poly ( roman_â„“ ), all iterations succeed, and we decode successfully. We then amplify the success probability by repeating this procedure polyâ¡(â„“)polyâ„“\operatorname{poly}(\ell)roman_poly ( roman_â„“ ) times. 1.3 Comparison to Prior Decoders Our techniques described above differ from those used in decoders of [GPT23, LZ23, DHLV23] for asymptotically good qLDPC codes [PK22a, LZ22, DHLV23]. At a high level, given a syndrome, these decoders recover the error by greedily flipping code bits to reduce some potential function related to the syndrome weight. Such greedy â€œflipâ€-style decoders are often applied for expander-based classical and quantum LDPC codes (e.g. [SS96, Zem01, LTZ15, FGL18]). However, beacuse the quasi-cyclic codes of [PK22b] that we consider in Theorem 1 are constructed with products involving repetition codes, which are not based on expanders, the resulting codes ğ’ğ’\mathcal{C}caligraphic_C do not seem to be â€œsufficiently expandingâ€ to permit such a greedy flip-style decoder. All previously known decoders [GPT23, LZ23, DHLV23] for linear (or almost linear) distance qLDPC codes [PK22a, LZ22, DHLV23] require the code to be constructed from a constant-sized pair of â€œinner codesâ€ satisfying a property called (two-way) product-expansion (also known as robust testability; see e.g. [KP23, DHLV23]). Such constant-sized objects have been shown to exist via probabilistic arguments. However, the constants are prohibitively large to the point where no specific instances of such two-way product-expanding codes have been constructed, to the best of our knowledge. In contrast, the codes of [PK22b] do not need product-expanding inner codes, and hence may be more relevant for practical implementations. Furthermore, as mentioned in Section 1.2, our decoding algorithm in Theorem 1 is based on the black-box application of classical LDPC code decoders in the quantum setting, which may be helpful for implementation purposes. In contrast, the flip-style decoders of [GPT23, LZ23, DHLV23] are more inherently quantum, as they do not naturally reduce to decoding a good classical code. For hypergraph products of arbitrary classical codes, the ReShape decoder of [QC22] can also correct a linear number adversarial errors with respect to the code distance, and also is based on a black-box application of classical decoders. While we restrict attention to products of expander-based codes with repetition codes, we are able to decode lifted products of nearly linear distance, whereas [QC22] only consider hypergraph products (which have distance at most Oâ¢(N)ğ‘‚ğ‘O(\sqrt{N})italic_O ( square-root start_ARG italic_N end_ARG ) for codes of length Nğ‘Nitalic_N). Furthermore, for hypergraph products, we present a decoding algorithm that runs in almost linear time with respect to the block length (see Section 3.1), whereas ReShape requires quadratic running time [QC22]. One downside of the codes of [PK22b] that we consider is their logarithmic dimension K=Î˜â¢(logâ¡N)ğ¾Î˜ğ‘K=\Theta(\log N)italic_K = roman_Î˜ ( roman_log italic_N ), which is much worse than the optimal K=Î˜â¢(N)ğ¾Î˜ğ‘K=\Theta(N)italic_K = roman_Î˜ ( italic_N ). We can boost the dimension at the cost of degrading the distance by simply breaking the message into equal-sized blocks, and encoding each block into a smaller instance of the codes of [PK22b]. Indeed, for any 0<Î±<10ğ›¼10<\alpha<10 < italic_Î± < 1, we can obtain length-Nğ‘Nitalic_N qLDPC codes of dimension K=Î˜â¢(NÎ±â¢logâ¡N)ğ¾Î˜superscriptğ‘ğ›¼ğ‘K=\Theta(N^{\alpha}\log N)italic_K = roman_Î˜ ( italic_N start_POSTSUPERSCRIPT italic_Î± end_POSTSUPERSCRIPT roman_log italic_N ) and distance D=Î˜â¢(N1âˆ’Î±/logâ¡N)ğ·Î˜superscriptğ‘1ğ›¼ğ‘D=\Theta(N^{1-\alpha}/\log N)italic_D = roman_Î˜ ( italic_N start_POSTSUPERSCRIPT 1 - italic_Î± end_POSTSUPERSCRIPT / roman_log italic_N ) by simply using NÎ±superscriptğ‘ğ›¼N^{\alpha}italic_N start_POSTSUPERSCRIPT italic_Î± end_POSTSUPERSCRIPT copies of the length-N1âˆ’Î±superscriptğ‘1ğ›¼N^{1-\alpha}italic_N start_POSTSUPERSCRIPT 1 - italic_Î± end_POSTSUPERSCRIPT code of [PK22b]. Our decoder in Theorem 1 by definition still applies to such codes. [PK22b] showed how to improve these parameters to K=Î˜â¢(NÎ±â¢logâ¡N)ğ¾Î˜superscriptğ‘ğ›¼ğ‘K=\Theta(N^{\alpha}\log N)italic_K = roman_Î˜ ( italic_N start_POSTSUPERSCRIPT italic_Î± end_POSTSUPERSCRIPT roman_log italic_N ) and D=Î˜â¢(N1âˆ’Î±/2/logâ¡N)ğ·Î˜superscriptğ‘1ğ›¼2ğ‘D=\Theta(N^{1-\alpha/2}/\log N)italic_D = roman_Î˜ ( italic_N start_POSTSUPERSCRIPT 1 - italic_Î± / 2 end_POSTSUPERSCRIPT / roman_log italic_N ) using an additional product construction, though we have not analyzed the decoding problem for these codes. It is an interesting question whether the dimension of such constructions could be further increased, while preserving the distance and efficient decodability, and without requiring a stronger ingredient such as product-expansion. 1.4 Open Problems Our work raises a number of open problems, such as those listed below: â€¢ Can our decoding algorithms be adapted to correct a number of random errors growing linearly in the block length? â€¢ Can our decoding algorithms be made to accomodate syndrome measurement errors? Note that our algorithms use as an ingredient classical codes robust to syndrome errors, which is distinct from considering errors on the syndrome of the quantum code. â€¢ Can our decoding algorithms be parallelized? We see no impediment to parallelization, but for simplicity in the presentation we did not pursue this direction. â€¢ Can our techniques be used to improve decoder performance in practical implementations? Our black-box use of classical LDPC decoders may be useful in this regard. â€¢ Can our techniques be extended to more general classes of codes, or to codes with improved paramters? See for instance the discussion in Section 1.3. 1.5 Roadmap The remainder of this paper is organized as follows. Section 2 provides necessary preliminary notions on classical and quantum codes. For completeness Section 2 is fairly detailed, but readers familiar with quantum LDPC codes and the language of chain complexes may skip most of this background and head directly to Section 3, which provides a technical overview of our decoding algorithms. Section 4 describes the classical LDPC codes that we use in a black-box manner for the quantum codes we consider. Section 5 presents our decoder for the hypergraph product of an expander-based classical LDPC code with a repetition code. This hypergraph product decoder provides a helpful introduction to some of the basic techniques involved in the proof of our main result (Theorem 1) on decoding lifted products of such classical codes. We prove Theorem 1 in Section 6. Appendix A provides a purely classical interpretation of our hypergraph product decoder. This perspective may be particularly helpful for those more familiar with classical error correction. Appendix B provides the formal construction of the expander-based classical LDPC codes we describe in Section 4, and proves the necessary properties. In particular, Appendix B provides a self-contained presentation of efficient decoding of classical LDPC codes, along with their â€œtransposeâ€ codes, under errors on both the code bits and syndrome bits."
https://arxiv.org/html/2411.04114v1,Age of Gossip With Time-Varying Topologies,"We consider a gossiping network, where a source node sends updates to a network of nğ‘›nitalic_n gossiping nodes. Meanwhile, the connectivity topology of the gossiping network changes over time, among a finite number of connectivity â€œstates,â€ such as the fully connected graph, the ring graph, the grid graph, etc. The transition of the connectivity graph among the possible options is governed by a finite state continuous time Markov chain (CTMC). When the CTMC is in a particular state, the associated graph topology of the gossiping network is in the way indicated by that state. We evaluate the impact of time-varying graph topologies on the freshness of information for nodes in the network. We use the version age of information metric to quantify the freshness of information at the nodes. Using a method similar to the first passage percolation method, we show that, if one of the states of the CTMC is the fully connected graph and the transition rates of the CTMC are constant, then the version age of a typical node in the network scales logarithmically with the number of nodes, as in the case if the network was always fully connected. That is, there is no loss in the age scaling, even if the network topology deviates from full connectivity, in this setting. We perform numerical simulations and analyze more generally how having different topologies and different CTMC rates (that might depend on the number of nodes) affect the average version age scaling of a node in the gossiping network.","Recent advances in wireless communication have led to significant improvements in information rate and reliability. The roll-out of 5G has made users more connected than ever before. These new technologies enable easy addition of and massive connectivity for new devices to the network. The enhancement in connectivity has lead to the exploration of new use cases, such as drone networks, sensor networks in remote areas, and self-driving car networks. These are usually dense networks, or may be far away from base stations. Hence, gossiping, i.e., peer-to-peer message dissipation, has emerged as one way of disseminating information fast in such networks. Gossiping protocols are simple algorithms which involve spreading information across the entire network by communication between neighbors. Some of these applications may not have a fixed structure due to mobility or channel unreliability. Hence, there is a need to analyze how dynamic changes in graph connectivity structure impacts such networks. This analysis also helps us in the design of adaptive protocols for networks that fall under this paradigm. Quantification of freshness of information necessitates going beyond the commonly used metrics such as latency and throughput [1]. Age of information was introduced as a metric to capture the freshness of information [2, 3, 4]. Networks have been analyzed and designed with the age of information metric in mind [5, 6]. Several other metrics have been proposed to quantify the freshness of information in application-specific settings, including the age of incorrect information [7], the age of synchronization [8], binary freshness metric [9], and the version age of information [10, 11, 12]. Figure 1: A description of the time evolution of the connectivity of the gossip network. The CTMC represents the connectivity graph (topology) of the gossip network. In this example, the CTMC has four states, representing the fully connected (FC) topology, the ring topology, the grid topology and the disconnected (DC) topology. The current topology is represented using a red dashed circle. In this example, the network starts in the fully connected topology, moving to the ring topology, the disconnected topology and back to the ring topology. Since the rates of the CTMC are different, the time spent in a state will be random, which is also shown in the figure. In this paper, we use the version age of information in a gossiping setting (age of gossip) to quantify the freshness of information. The version age of information can be defined for a node in the gossiping network as the number of versions behind the node is compared to the source node that generates the updates. These updates are typically generated by a random process. Yates [10] was the first to use the stochastic hybrid system (SHS) framework to analyze gossip networks and provide a set of recursive equations to find the version age of a subset of nodes. In particular, the version age of any subset depends on the version age of subsets containing exactly one more neighboring node. Yates showed that the long term average version age of a node in the fully connected network scales as Î˜â¢(logâ¡n)Î˜ğ‘›\Theta(\log{n})roman_Î˜ ( roman_log italic_n ), where nğ‘›nitalic_n is the number of nodes. Following Yatesâ€™ work, many works have used the SHS framework to analyze gossiping networks under various settings, including community structures [13], adversarial settings [14] and distributed computation [15, 16]. The survey [17] discusses works in this area. Recently, [18] showed that for any gossip network, the age of a vertex (i.e., node) is equal in distribution to the first passage time from that vertex to the source. Similarly, [19] investigates how version age is affected by non-Poisson connections between nodes of the gossiping network. Many of these works have analyzed how version age scales with the number of nodes for specific topologies of the gossiping network. [13] shows that the version age under the ring topology scales as Î˜â¢(n)Î˜ğ‘›\Theta(\sqrt{n})roman_Î˜ ( square-root start_ARG italic_n end_ARG ). [20] shows that the version age scales as Oâ¢(n13)ğ‘‚superscriptğ‘›13O(n^{\frac{1}{3}})italic_O ( italic_n start_POSTSUPERSCRIPT divide start_ARG 1 end_ARG start_ARG 3 end_ARG end_POSTSUPERSCRIPT ) in the square grid topology, and as Oâ¢(logâ¡nâ¢logâ¡logâ¡n)ğ‘‚ğ‘›ğ‘›O(\log{n}\log{\log{n}})italic_O ( roman_log italic_n roman_log roman_log italic_n ) in the unit hypercube topology. [21] analyzes complete bipartite graphs, shows that dğ‘‘ditalic_d-regular graphs have logarithmic version age scaling and analyzes Erdos-Renyi random graphs as well. [18] further analyzes new graphs and gives tight upper and lower bounds for the expected version age of any vertex using a new combinatorial quantity. Gossiping networks with mobility have been analyzed using the spatial mean field regime methodology in [22] and SHS framework in [23]. However, no paper has analyzed networks where the gossip links have time-varying rates while the source updates the gossiping network at constant rate. In this work, we use a new method inspired by the first passage percolation methods to analyze how varying gossiping network topologies influence the version age of nodes in the network. In the system we consider, the gossiping network changes topologies according to a continuous time Markov chain (CTMC) process. These topologies are arbitrary fixed graphs, which could be a fully connected network, a ring network, a grid network or some other network. It is possible to write SHS equations for this framework in a similar way to [5]. However, it is not clear if the system of equations obtained are stable and if the limiting version age exists. As an example, assume that we have two possible topologies, the fully connected topology and the ring topology, and we switch between these two states with linear rates (in the number of nodes). Then, we can show that the version age of a node moves from Î˜â¢(logâ¡n)Î˜ğ‘›\Theta(\log{n})roman_Î˜ ( roman_log italic_n ) to Î˜â¢(n)Î˜ğ‘›\Theta(\sqrt{n})roman_Î˜ ( square-root start_ARG italic_n end_ARG ) depending on the current state. Hence, instead of analyzing the limiting average version age, we analyze how the version age of a node depends on the current topology, and if the existence of certain topologies in the network ensure low or high version age for the node. In particular, we analyze a network which has constant CTMC rates, where one of the topologies is the fully connected topology. For this case, we show that the version age of a node scales as Î˜â¢(logâ¡n)Î˜ğ‘›\Theta(\log{n})roman_Î˜ ( roman_log italic_n ), which is the same if the network was always in a fully connected mode. That is, we show that, in this setting, there is no loss in the age scaling, even if the network topology deviates from full connectivity."
https://arxiv.org/html/2411.04083v1,"Learned codes for broadcast channels with feedbackâ€ â€ thanks:The work of N. Devroye and Y. Zhou was partially supported by NSF under awards 2217023, 2240532, and 1900911. The contents of this article are solely the responsibility of the authors and do not necessarily represent the official views of the NSF.","We focus on designing error-correcting codes for the symmetric Gaussian broadcast channel with feedback. Feedback not only expands the capacity region of the broadcast channel but also enhances transmission reliability. In this work, we study the construction of learned finite blocklength codes for broadcast channels with feedback. Learned error-correcting codes, in which both the encoder and decoder are jointly trained, have shown impressive performance in point-to-point channels, particularly with noisy feedback. However, few learned schemes exist for multi-user channels. Here, we develop a lightweight code for the broadcast channel with feedback that outperforms existing schemes and operates effectively at short blocklengths.","We study the transmission of independent messages over a two-user static Gaussian broadcast channel with either noiseless or noisy feedback, where both the forward and feedback links are corrupted by independent Gaussian noises. While feedback does not increase the capacity of a memoryless point-to-point (P2P) channel [1], it can expand the capacity region of a broadcast channel even when the receiver noises are independent [2], or with only one userâ€™s feedback [3]. For the point-to-point additive white Gaussian noise (AWGN) channel with feedback, several well-known schemes exist: Schalkwijk-Kailath [4] introduced the â€œSKâ€ scheme, a capacity-achieving linear coding scheme for noiseless feedback that achieves doubly exponential probability of error decay. For noisy feedback, Chance and Love proposed the CL scheme, a concatenated coding approach that uses passive feedback [5], while the Modulo-SK scheme introduced in [6] uses active feedback, achieving superior performance. For the two-user Gaussian broadcast channel with feedback (GBCF), Ozarow extended the SK scheme to the â€œOLâ€ scheme, which also achieves doubly exponential error decay [2]. Additionally, the work in [7] enhanced the OL scheme by adopting estimators with memory, i.e. that use the last two channel outputs yiâˆ’1,yisubscriptğ‘¦ğ‘–1subscriptğ‘¦ğ‘–y_{i-1},y_{i}italic_y start_POSTSUBSCRIPT italic_i - 1 end_POSTSUBSCRIPT , italic_y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT rather than simply the current channel output yisubscriptğ‘¦ğ‘–y_{i}italic_y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, resulting in the â€œEOLâ€ scheme. This enhancement not only improves the achievable rates of the OL scheme but also increases transmission reliability. In addition to these SK-type coding schemes, control-theory-based codes have been developed in for example [8], where LQG codes for the K-user GBCF, generalizing the schemes in [9] were proposed. For the GBCF with noisy feedback, a linear concatenated coding scheme, referred to as the â€œGBCF-CLâ€ scheme, for the K-user GBCF is proposed in [10]. The focus of this paper is not on achievable rates or error exponents, but rather on constructing practical codes at finite blocklength, evaluating them based on their probability of error for a fixed rate. To achieve low bit or block error rates for finite block lengths, deep learning has successfully been used to design encoder/decoder for P2P error-correcting codes with feedback (DL-ECFCs). These DL-ECFCs [11, 12, 13, 14, 15, 16, 17] outperform traditional analytically constructed codes in most cases, especially in noisy feedback. DL-ECFCs can be categorized into two types: bit-by-bit, where one bit of information is transmitted at a time, and symbol-by-symbol, where message bits of length Kğ¾Kitalic_K are mapped to a symbol for transmission, similar to SK-type codes. Bit-by-bit schemes [11, 12, 13, 14] use a two-phase encoding process with a fixed rate of 1313\frac{1}{3}divide start_ARG 1 end_ARG start_ARG 3 end_ARG, as first introduced in Deepcode [11]. Symbol-by-symbol schemes [15, 16, 17] achieve variable rates by adjusting the number of channel uses. The lightweight symbol-by-symbol code in [17] achieves state-of-the-art performance for AWGN channels with feedback. However, few deep learning strategies have been applied to multi-user channels; [18] extends Deepcode to fading Gaussian broadcast channels with feedback, while [19] focuses on the multiple-access channel (MAC) with feedback. Contribution: We generalize Lightcode [17] to the symmetric GBCF with independent feedback links111Our code is available at https://github.com/zyy-cc/GBCF.git, achieving superior performance over existing coding schemes in the short blocklength regime, even with noisy feedback. Additionally, we provide an initial interpretation of our learned codes, revealing an approximately linear relationship between the encoder output and the received feedback. Notation: Random variables are denoted by capital letters and specific instances by lowercase letters. Vectors are represented in bold, with superscripts indicating their length. Subscripts uğ‘¢uitalic_u distinguish between users, and iğ‘–iitalic_i denotes time indices. SNRu,fsubscriptSNRğ‘¢ğ‘“\text{SNR}_{u,f}SNR start_POSTSUBSCRIPT italic_u , italic_f end_POSTSUBSCRIPT and SNRu,fâ¢bsubscriptSNRğ‘¢ğ‘“ğ‘\text{SNR}_{u,fb}SNR start_POSTSUBSCRIPT italic_u , italic_f italic_b end_POSTSUBSCRIPT represent the Signal-to-Noise Ratios for the forward and feedback channels for user uğ‘¢uitalic_u, respectively. Probability is denoted by â„™â¢(â‹…)â„™â‹…\mathbb{P}(\cdot)blackboard_P ( â‹… ) and expectation by ğ”¼â¢(â‹…)ğ”¼â‹…\mathbb{E}(\cdot)blackboard_E ( â‹… ). Real values are represented by â„â„\mathbb{R}blackboard_R, and ğ”½2subscriptğ”½2\mathbb{F}_{2}blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT denotes the finite field with elements 0 and 1. Additionally, sgnâ¡(x)=1sgnğ‘¥1\operatorname{sgn}(x)=1roman_sgn ( italic_x ) = 1 if xâ‰¥0ğ‘¥0x\geq 0italic_x â‰¥ 0, and 00 otherwise. Moreover, xâ¢ dB=10â¢logâ¡(10)â¢(x)ğ‘¥ dB1010ğ‘¥x\text{ dB}=10\log{10}(x)italic_x dB = 10 roman_log ( start_ARG 10 end_ARG ) ( italic_x )."
https://arxiv.org/html/2411.04063v1,"Soft Reverse Reconciliation for Discrete Modulationsâ€ â€ thanks:This work has been partially supported by PNRR MUR project PE0000023-NQSTI, by the QUASAR project and by the SMARTQKD scholarship funded by Sma-RTy Italia SRL and CNR-IEIIT.","The performance of the information reconciliation phase is crucial for quantum key distribution (QKD). Reverse reconciliation (RR) is typically preferred over direct reconciliation (DR) because it yields higher secure key rates. However, a significant challenge in continuous-variable (CV) QKD with discrete modulations (such as QAM) is that Alice lacks soft information about the symbol decisions made by Bob. This limitation restricts error correction to hard-decoding methods, with low reconciliation efficiency. This work introduces a reverse reconciliation softening (RRS) procedure designed for CV-QKD scenarios employing discrete modulations. This procedure generates a soft metric that Bob can share with Alice over a public channel, enabling her to perform soft-decoding error correction without disclosing any information to a potential eavesdropper. After detailing the RRS procedure, we investigate how the mutual information between Aliceâ€™s and Bobâ€™s variables changes when the additional metric is shared. We show numerically that RRS improves the mutual information with respect to RR with hard decoding, practically achieving the same mutual information as DR with soft decoding. Finally, we test the proposed RRS for PAM-4 signalling with a rate 1/2 binary LDPC code and bit-wise decoding through numerical simulations, obtaining more than 1dB SNR improvement compared to hard-decoding RR.","The problem of reconciliation has the aim of obtaining 2 identical sequences out of a pair of random correlated data. This is particularly useful in all applications where these identical sequences are employed as symmetrical keys and the pair of random correlated data is obtained from data transmission of various natures. Secrecy is therefore of paramount importance in such kinds of applications. A possible scenario of shared randomness generation is quantum key distribution (QKD) [1]. After the first phase, i.e. random data transmission, the reconciliation procedure joins the game to remove all discrepancies in the correlated data pair. The usual assumption is that the remote parties are provided with a noiseless and public channel for the completion of this procedure. The privacy amplification phase follows, to purge the information leaked during the previous phases. When the reconciliation is initiated by the same party who generated and transmitted the random data, namely Alice, it is called direct reconciliation (DR): after data transmission, Alice generates the syndrome associated with the data and publicly discloses it. The receiver, namely Bob, will use the channel output and the syndrome to detect and remove the discrepancies with Aliceâ€™s data. On the other hand, the reconciliation may be initiated by Bob, who will use the channel output to produce a syndrome, and possibly some other auxiliary data, to be disclosed to help Alice remove the discrepancies between her data and Bobâ€™s received data. In this case, it is called reverse reconciliation (RR). When a potential attacker is taken into account, the direction of the reconciliation matters. In fact, the data potentially leaked during the transmission phase have larger mutual information with the transmitted data than with the received data. Consequently, the RR exhibits lower information leakage and potentially a higher key generation rate. For the phase of data transmission, different signalling techniques may be employed. For instance, in the realm of QKD, the existing protocols may adopt single photons (discrete-variable QKD) [2], or coherent states (continuous-variable QKD) [3]. Unlike DV-QKD, CV-QKD does not require single photon sources and detectors and can use the same devices and modulation/detection schemes commonly employed in classical coherent optical communications [4]. The choice of the information carrier is not only a matter of implementation, as it also affects the kind of variables with which Alice and Bob are provided at the beginning of the reconciliation procedure. In the GG02 protocol [3], Alice and Bob share correlated Gaussian random variables. The most well-known reconciliation procedures for Gaussian variables are slice reconciliation [5] and multi-dimensional reconciliation [6]. While communication based on Gaussian variables is theoretically well-founded, it poses several practical challenges [7]. Consequently, CV-QKD protocols utilizing discrete constellations have also been explored [8, 9]. Among these, a particularly promising approach uses probabilistically-amplitude-shaped quadrature amplitude modulation (PAS-QAM), which allows the protocol to closely approach the secure key rate achievable by GG02 [10, 11]. When the transmitted symbols are drawn from a discrete constellations, DR can be formulated as a classical error correction problem over an additive white Gaussian noise (AWGN) channel, with slight modifications due to Alice and Bob working within an arbitrary coset of a given code. After Alice publicly reveals the particular coset by disclosing the syndrome of the transmitted sequence, Bob uses this syndrome and the soft information available on his side (the AWGN channel output) to infer the most likely transmitted sequence. For this task, efficient codes and soft-decoding algorithmsâ€”such as low-density parity-check (LDPC) codes and belief propagation â€”are available to closely approach channel capacity. On the other hand, RRâ€”usually preferred over DR, as discussed aboveâ€”is made more difficult by the lack of soft information on Aliceâ€™s side. After Bob makes decisions on the received symbols and discloses the corresponding syndrome, Alice has only hard information (the transmitted sequence) to guess Bobâ€™s decisions. This limitation restricts error correction to hard-decoding methods, with low reconciliation efficiency. For BPSK and QPSK constellations, a soft RR procedure has been proposed by Leverrier [12], in which Bob discloses the amplitude of the received samples. In this case, the amplitude gives no information to Eve about Bobâ€™s decisions (which depend only on the phase), but enables Alice to perform soft decoding as in the DR scheme (and with same efficiency). Unfortunately, this procedure cannot be extended to general discrete constellations (e.g., QAM), for which disclosing the received amplitude would reveal also relevant information about the key. As per our knowledge, there is no soft RR procedure for general discrete constellations. In this work, we propose a novel soft RR procedure designed for arbitrary PAM or QAM constellations. The procedure involves Bob disclosing a soft metric that enables Alice to perform soft decoding, without revealing any information to Eve. After providing a brief overview of the procedure in Sec. II, we dive deep into the formal aspects of the problem in Sec. III, presenting a solution in Sec. III-B. In Sec. IV, we investigate through numerical simulations the performance of the proposed solution. Finally, we draw some conclusions in Sec. V ."
https://arxiv.org/html/2411.03876v1,Large Generative Model-assisted Talking-face Semantic Communication System,"The rapid development of generative Artificial Intelligence (AI) continually unveils the potential of Semantic Communication (SemCom). However, current talking-face SemCom systems still encounter challenges such as low bandwidth utilization, semantic ambiguity, and diminished Quality of Experience (QoE). This study introduces a Large Generative Model-assisted Talking-face Semantic Communication (LGM-TSC) System tailored for the talking-face video communication. Firstly, we introduce a Generative Semantic Extractor (GSE) at the transmitter based on the FunASR model to convert semantically sparse talking-face videos into texts with high information density. Secondly, we establish a private Knowledge Base (KB) based on the Large Language Model (LLM) for semantic disambiguation and correction, complemented by a joint knowledge base-semantic-channel coding scheme. Finally, at the receiver, we propose a Generative Semantic Reconstructor (GSR) that utilizes BERT-VITS2 and SadTalker models to transform text back into a high-QoE talking-face video matching the userâ€™s timbre. Simulation results demonstrate the feasibility and effectiveness of the proposed LGM-TSC system.","In the future, 6G will revolutionize communication and significantly enhance the flow of information and the sharing of knowledge. However, a substantial portion of the global population still lacks access to reliable high-speed network connections, or experiences instability when using them [1]. Addressing these challenges requires the development of technologies capable of efficiently transmitting video under ultra-low bandwidth conditions. Such advancements will not only boost network efficiency and mitigate issues caused by instability but also expand access to information and knowledge in regions without high-speed networks, thereby effectively narrowing the global digital divide. In video communications, the most common type is the talking-face video, where facial expressions and mouth movements are synchronized with the audio [2]. Researchers have developed various methods to enhance the quality and efficiency of talking-face video transmission [3]. Among these approaches, Semantic Communication (SemCom) emerges as a novel communication paradigm that seeks to enable smarter and more efficient transmission by comprehending and leveraging semantic content. For instance, some SemCom systems have achieved compression of talking-face videos by modeling human faces across successive frames [4]. However, existing talking-face communication methods still encounter the following challenges: 1. Low bandwidth utilization: Video typically consists of a large number of frames containing substantial pixel information. Traditional video communication systems encode videos at the pixel level, resulting in inefficient bandwidth utilization. Given the continuity and similarity of video content, there is often significant redundancy in information between adjacent pixels and frames, leading to low semantic and information density. Consequently, effectively compressing video while enhancing the efficiency of information transmission without losing critical semantics is an urgent challenge that needs to be addressed [5]. 2. Semantic ambiguity: The raw data from the transmitter may be ambiguous for various reasons. First, users may employ vague or ambiguous language, leading to unclear intentions in the message. Even when the userâ€™s data is precise, the receiver might interpret the information differently from how it was meant to be understood due to suboptimal channel conditions during transmission. Therefore, it is crucial to reduce ambiguity and errors throughout the communication process and ensure accurate information transmission for enhancing communication quality [6]. 3. Diminished Quality of Experience (QoE): Due to lossy compression, the direct transmission of talking-face videos using previous deep-learning-based SemCom systems may result in noticeable differences in timbre and facial movements compared to the source video, significantly reducing the QoE for users. Thus, maintaining a high QoE for users during talking-face video transmission in SemCom systems is of paramount importance [7]. With the rapid advancement of generative Artificial Intelligence (AI), Large Generative Models (LGMs) have become increasingly adept at producing diverse and rich content across various modalities, including text, images, audio, and video. Models such as GPT-4 [8], Gemini Pro [9], and LLaVA [10] have achieved cross-modal information processing and content generation through extensive data learning. By leveraging their robust capabilities in semantic understanding and generation, these LGMs offer significant advantages in Semantic Communication (SemCom), including precise semantic extraction, extensive prior knowledge, and effective semantic disambiguation [11]. These strengths provide novel insights and solutions for achieving efficient and intelligent SemCom. This paper introduces a Large Generative Model-assisted Talking-face Semantic Communication System (LGM-TSC), built upon the capabilities of LGMs. Specifically, our primary contributions include: 1. Generative Semantic Extractor (GSE): We propose a GSE at the transmitter that converts talking-face video into text by utilizing an advanced Automatic Speech Recognition (ASR) model for high-precision speech recognition. By transforming the continuous audio signals in the video into discrete text, we achieve efficient compression of the talking-face video. This process significantly reduces the required bandwidth for data transmission while accurately extracting the key semantic content from the video. 2. Large Language Model (LLM)-based private Knowledge Base (KB): To address the potential semantic ambiguity and signal interference during SemCom, we introduce a private KB powered by LLM. Leveraging the robust semantic understanding and generative capabilities of LLMs, this private KB is employed for semantic disambiguation and text correction at both ends of the SemCom system. Furthermore, we have developed a joint knowledge base-semantic-channel coding method to further optimize the performance of the SemCom system, which can enable the LLM to indirectly participate in joint encoding. 3. Generative Semantic Reconstructor (GSR): At the receiver, we propose a GSR that accurately converts text back to high-fidelity talking-face video. This is accomplished using BERT-VITS2 and SadTalker models to generate high-quality audio and video, thereby ensuring an enhanced QoE for users. By leveraging the userâ€™s face image and vocal feature vector stored in the public KB, the GSR is capable of restoring the dynamic realism of the original talking-face video while maintaining consistency with the userâ€™s vocal timbre, providing users with an immersive viewing experience. The rest of this paper is structured as follows. Section II presents the related work, Section III introduces the system model, Section IV provides a detailed description of the proposed LGM-TSC system, Section V outlines the experimental setup and results, and Section VI concludes the paper."
https://arxiv.org/html/2411.03776v1,"Reconstruction of multiple strings of constant weight from prefix-suffix compositionsâ€ â€ thanks:This paper was presented in part at the 2024 IEEE International Symposium on Information Theory (ISIT 2024)[1].
Y. Yang was with the School of Data Science, The Chinese University of Hong Kong, Shenzhen, China. (Email: yaoyuyang@link.cuhk.edu.cn) Z. Chen is with School of Science and Engineering, Future Networks of Intelligence Institute, The Chinese University of Hong Kong, Shenzhen, China. (Email: chenztan@cuhk.edu.cn)
This research was supported in part by the Basic Research Project of Hetao Shenzhen-Hong Kong Science and Technology Cooperation Zone under Project HZQB-KCZYZ-2021067,
the Guangdong Provincial Key Laboratory of Future Network of Intelligence under Project 2022B1212010001,
the National Natural Science Foundation of China under grants 62201487,
and the Shenzhen Science and Technology Stable Support Program.","Motivated by studies of data retrieval in polymer-based storage systems, we consider the problem of reconstructing a multiset of binary strings that have the same length and the same weight from the compositions of their prefixes and suffixes of every possible length. We provide necessary and sufficient conditions for which unique reconstruction up to reversal of the strings is possible. Additionally, we present two algorithms for reconstructing strings from the compositions of prefixes and suffixes of constant-length constant-weight strings.","The growing demand for archival data storage calls for innovative solutions to store information beyond traditional methods that rely on magnetic tapes or hard disk drives. Recent advancement in macromolecule synthesis and sequencing suggests that polymers such as DNA are promising media for future archival data storage, largely attributed to their high storage density and durability. Data retrieval in polymer-based storage systems depends on macromolecule sequencing technologies [2, 3] to read out the information stored in polymers. However, common sequencing technologies often only read random fragments of polymers. Thus, the task of data retrieval in these systems has to be based on the information provided by the fragments. Under proper assumptions, one may represent polymers by binary strings and turn the problem of data retrieval into the problem of string reconstruction from substring compositions, i.e., from the number of zeros and the number of ones in substrings of every possible length. In [4], the authors characterized the length for which strings can be uniquely reconstructed from their substring compositions up to reversal. Extending the work of [4], the authors of [5] and [6] studied the problem of string reconstruction from erroneous substring compositions. Specifically, [5] designed coding schemes capable of reconstructing strings in the presence of substitution errors and [6] further proposed codes that can deal with insertion and deletion errors. Observing that it may not be realistic to assume the compositions of all substrings are available, the authors of [7] initiated the study of string reconstruction based on the compositions of prefixes and suffixes of all possible lengths. In fact, [7] considered the more general problem of reconstructing multiple distinct strings of the same length simultaneously from the compositions of their prefixes and suffixes. The main result of [7] reveals that for reconstruction of no more than hâ„hitalic_h distinct strings of the same length, there exists a code with rate approaching 1/h1â„1/h1 / italic_h asymptotically. Following [7], the authors of [8] studied in depth the problem of reconstructing a single string from the compositions of its prefixes and suffixes. In particular, their work completely characterized the strings that can be reconstructed from its prefixes and suffixes compositions uniquely up to reversal. Efficiency of data retrieval is a major concern for practical polymer-based storage systems, and thus low complexity algorithms for string reconstruction are of great interest. In the case of reconstruction from error-free substring compositions, [4] described a backtracking algorithm for binary strings of length nğ‘›nitalic_n with worst-case time complexity exponential in nğ‘›\sqrt{n}square-root start_ARG italic_n end_ARG. Moreover, [5] and [9] constructed sets of binary strings that can be uniquely reconstructed with time complexity polynomial in nğ‘›nitalic_n. In the case of reconstruction from error-free compositions of prefixes and suffixes, [7] and [8] presented sets of binary strings that can be efficiently reconstructed. For reconstruction in the presence of substitution composition errors, [5] showed that when the number of errors is a constant independent of nğ‘›nitalic_n, there exist coding schemes with decoding complexity polynomial in nğ‘›nitalic_n. We note that string reconstruction is classic problem [10, 11, 12] and has been studied under various settings, including reconstruction from substrings [10, 13, 14] and from subsequences [11, 12, 15, 16, 17, 18] under either combinatorial or probabilistic assumptions. In this paper, we consider the problem of reconstructing hâ„hitalic_h strings that are not necessarily distinct but have the same length nâ‰¥1ğ‘›1n\geq 1italic_n â‰¥ 1 and weight wÂ¯â‰¤nÂ¯ğ‘¤ğ‘›\bar{w}\leq noverÂ¯ start_ARG italic_w end_ARG â‰¤ italic_n from their error-free compositions of prefixes and suffixes of all possible lengths. The problem of reconstructing multiple strings from prefix-suffix compositions becomes more amenable to analysis if the strings are of constant weight. This is because nice properties due to symmetry can be tethered to the prefix-suffix compositions. Our first result is a characterization of the properties of constant-weight strings that enable unique reconstruction up to reversal. Additionally, we present two algorithms that reconstruct constant-weight strings from prefix-suffix compositions. Given prefix-suffix compositions as input, one of the algorithms can efficiently output a multiset of strings whose prefix-suffix compositions are the same as the input, and the other is able to output all multisets of strings up to reversal that are allowed by the input. Our analysis relies on the running weight information of the strings that can be extracted from the prefix-suffix compositions and the inherent symmetry of constant-weight strings and their reversals. The rest of this paper is organized as follows. In Section II, we present the problem statement and introduce necessary notation and preliminaries that are helpful for later sections. In particular, we introduce the notion of cumulative weight functions that capture the running weight information of a multiset of strings, which is used throughout the paper. In Section III, we derive the necessary and sufficient conditions for unique reconstruction. Section IV is devoted to the reconstruction algorithms. We conclude this paper and mention a few open problems in Section V."
https://arxiv.org/html/2411.03646v1,Quantum LDPC Codes of Almost Linear Distancevia Homological Productsâ€ â€ thanks:Research supported in part by a ONR grant N00014-24-1-2491 and a UC Noyce initiative award. L.Â Golowich is supported by a National Science Foundation Graduate Research Fellowship under Grant No.Â DGE 2146752. This work was done in part while the authors were attending the Spring 2024 programs at the Simons Institute for the Theory of Computing.,"We present new constructions of quantum codes of linear or close-to-linear distance and dimension with low-weight stabilizers. Only a few constructions of such codes were previously known, and were primarily based on a specific operation from homological algebra, namely the balanced product. In contrast, our constructions are based on a more basic and widely used product, namely the homological product (i.e. the tensor product of chain complexes). Our results help address the natural question: When do homological products preserve good code distance?Our first main result constructs asymptotically good [[N,Î˜â¢(N),Î˜â¢(N)]]delimited-[]ğ‘Î˜ğ‘Î˜ğ‘[[N,\Theta(N),\Theta(N)]][ [ italic_N , roman_Î˜ ( italic_N ) , roman_Î˜ ( italic_N ) ] ] quantum codes with small polynomial stabilizer weight from homological products of codes with a property called product-expansion. This notion was recently introduced and used to bound the distance of balanced product quantum codes; we apply it instead to homological products.For every Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0, our second main result constructs close-to-linear distance [[N,N1âˆ’Ïµ,N1âˆ’Ïµ]]delimited-[]ğ‘superscriptğ‘1italic-Ïµsuperscriptğ‘1italic-Ïµ[[N,N^{1-\epsilon},N^{1-\epsilon}]][ [ italic_N , italic_N start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT , italic_N start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT ] ] (subsystem) quantum LDPC codes with constant stabilizer weight from iterated homological products of a constant-sized quantum locally testable code. The key insight here is that by using subsystem codes (but still with constant-weight stabilizers), we can circumvent a particular obstruction that limited the distance of many prior product code constructions to at most O~â¢(N)~ğ‘‚ğ‘\tilde{O}(\sqrt{N})over~ start_ARG italic_O end_ARG ( square-root start_ARG italic_N end_ARG ).","Quantum low-density parity-check (qLDPC) codes provide one of the most promising means for achieving efficient quantum fault-tolerance. Such codes are defined to support error detection and correction via sparse queries (i.e. stabilizer measurements) to code states. Each such query involves, and can therefore only propagate errors across, a small number of code components. However, this qLDPC condition has proven difficult to achieve, and asymptotically optimal qLDPC codes were only recently constructed following a line of breakthrough works [HHO21, PK22b, BE21, PK22a, LZ22, DHLV23]. The latter three of these works use nearly identical techniques, and still provide the only known asymptotically good qLDPC codes, meaning that the code dimension and distance scale linearly in the block length, and the stabilizers have constant weight. It remains an open question to find new constructions of qLDPC codes with good parameters. Such alternative constructions may yield better practical parameters or have properties useful for fault-tolerant computation, and would also be of independent mathematical interest. In this paper, we develop new constructions of qLDPC codes with linear or close-to-linear dimension and distance based on homological products (i.e. tensor products of chain complexes), a well-known construction from homological algebra that generalizes classical tensor codes. Our constructions are based on new characterizations that we develop for conditions under which homological products preserve (close-to) linear quantum code distance. Homological products have long been used to construct qLDPC codes, notably including hypergraph product codes [TZ14], which are simply homological products of 2-term chain complexes associated to classical LDPC codes. Hypergraph products of good classical LDPC codes give length-Nğ‘Nitalic_N quantum codes of dimension Î˜â¢(N)Î˜ğ‘\Theta(N)roman_Î˜ ( italic_N ) and distance Î˜â¢(N)Î˜ğ‘\Theta(\sqrt{N})roman_Î˜ ( square-root start_ARG italic_N end_ARG ) [TZ14]; the well-known surface and Toric codes [Kit03] can also be viewed as hypergraph products of repetition codes. However, it was a longstanding open question to construct qLDPC codes with distance greater than Î˜â¢(N)Î˜ğ‘\Theta(\sqrt{N})roman_Î˜ ( square-root start_ARG italic_N end_ARG ). This question was resolved by the line of work described above leading to asymptotically good qLDPC codes, using balanced or lifted products, which can be viewed as quotients of hypergraph products by a group symmetry. Such balanced products remain the only known technique for obtaining qLDPC codes with (even close to) linear dimension and distance. Furthermore, balanced products are a fairly rigid construction, in that they require classical codes respecting a large group symmetry. The optimal constructions [PK22a, LZ22, DHLV23] also require classical codes with a certain strong property called product-expansion [KP23], which is difficult to obtain in practice. In light of these limitations of balanced products, we study the question of whether homological products can be used to construct qLDPC codes with comparably good parameters. Homological products are more flexible in that they require no group symmetry. At a more foundational level, it is a mathematically interesting question to determine when homological product codes have large distance. Indeed, as quantum codes can be equivalently viewed as chain complexes or as topological spaces (see also [FH21]), this question can be phrased as asking how the systolic and cosystolic distance of a topological space (see Definition 3.13) behave under topological products. In addition to its fundamental nature, this question is also of practical interest. For instance, the classical analogue of homological product codes, namely tensor codes, are widely studied and used throughout classical coding theory. Better understanding quantum homological products may yield similar benefits for quantum fault tolerance and beyond. As mentioned above, many qLDPC code constructions based on homological products had distance at most Oâ¢(N)ğ‘‚ğ‘O(\sqrt{N})italic_O ( square-root start_ARG italic_N end_ARG ). However, a few works have surpassed this barrier. Specifically, [BH14] showed that a length-Nğ‘Nitalic_N homological product of two quantum random codes has distance Î˜â¢(N)Î˜ğ‘\Theta(N)roman_Î˜ ( italic_N ) and stabilizer weight Î˜â¢(N)Î˜ğ‘\Theta(\sqrt{N})roman_Î˜ ( square-root start_ARG italic_N end_ARG ). [KT21] used homological products of chain complexes from certain high-dimensional expanders [LSV05b, LSV05a] to obtain qLDPC codes with distance Î˜â¢(Nâ‹…polyâ¡logâ¡N)Î˜â‹…ğ‘polyğ‘\Theta(N\cdot\operatorname{poly}\log N)roman_Î˜ ( italic_N â‹… roman_poly roman_log italic_N ) and constant stabilizer weight. [DH21] also showed how to obtain homological product codes with stabilizer weight wğ‘¤witalic_w and distance Î˜â¢(Nâ‹…w)Î˜â‹…ğ‘ğ‘¤\Theta(\sqrt{N\cdot w})roman_Î˜ ( square-root start_ARG italic_N â‹… italic_w end_ARG ). In this paper, we present two main results, each of which uses a different technique to construct homological product codes of linear or close-to-linear distance with low-weight stabilizers. The following two sections summarize these respective results. A more detailed overview, with necessary background notions and notation, is provided in Section 2. 1.1 Results on Product-Expanding Codes Our first main result is a simplification and generalization of the work of [BH14], from which we obtain codes of linear dimension and distance, with stabilizer weight growing as a small polynomial in the block length. Interestingly, we bound the distance of these codes using bounds of [PS94, KP23, KP24] on the product-expansion property mentioned earlier. As a result, we are able to derandomize the [BH14] result using Reed-Solomon codes, extend it to bound local testability (see Definition 3.5) in addition to distance, and also generalize it to higher-dimensional products, which have lower stabilizer weight. At a high level, these results suggest that product-expansion, viewed as a pseudorandom property, captures and generalizes the behavior of random homological products observed by [BH14]. The informal theorem statement below summarizes the code constructions described above: Theorem 1.1 (Informal statement of Theorem 2.2). Let Q1,â€¦,Qtsuperscriptğ‘„1â€¦superscriptğ‘„ğ‘¡Q^{1},\dots,Q^{t}italic_Q start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT , â€¦ , italic_Q start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT consist of either: 1. t=2ğ‘¡2t=2italic_t = 2 uniformly random quantum CSS codes over an arbitrary alphabet ğ”½qsubscriptğ”½ğ‘\mathbb{F}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT, or 2. t=2ğ‘¡2t=2italic_t = 2 quantum Reed-Solomon CSS codes, or 3. An arbitrary constant number tâˆˆâ„•ğ‘¡â„•t\in\mathbb{N}italic_t âˆˆ blackboard_N of random quantum CSS codes over a sufficiently large alphabet ğ”½qsubscriptğ”½ğ‘\mathbb{F}_{q}blackboard_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT. Then the homological product of Q1,â€¦,Qtsuperscriptğ‘„1â€¦superscriptğ‘„ğ‘¡Q^{1},\dots,Q^{t}italic_Q start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT , â€¦ , italic_Q start_POSTSUPERSCRIPT italic_t end_POSTSUPERSCRIPT gives an asymptotically good111Recall that an [[N,K,D]]qsubscriptdelimited-[]ğ‘ğ¾ğ·ğ‘[[N,K,D]]_{q}[ [ italic_N , italic_K , italic_D ] ] start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT code is a quantum code on qudits of local dimension qğ‘qitalic_q with block length Nğ‘Nitalic_N, dimension (i.e. number of logical qudits) Kğ¾Kitalic_K, and distance Dğ·Ditalic_D. The code is said to be asymptotically good if K,D=Î˜â¢(N)ğ¾ğ·Î˜ğ‘K,D=\Theta(N)italic_K , italic_D = roman_Î˜ ( italic_N ). [[N,Î˜â¢(N),Î˜â¢(N)]]qsubscriptdelimited-[]ğ‘Î˜ğ‘Î˜ğ‘ğ‘[[N,\Theta(N),\Theta(N)]]_{q}[ [ italic_N , roman_Î˜ ( italic_N ) , roman_Î˜ ( italic_N ) ] ] start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT CSS code with stabilizer weight Oâ¢(N1/t)ğ‘‚superscriptğ‘1ğ‘¡O(N^{1/t})italic_O ( italic_N start_POSTSUPERSCRIPT 1 / italic_t end_POSTSUPERSCRIPT ). Furthermore, if t=2ğ‘¡2t=2italic_t = 2, then this product code is locally testable with Oâ¢(N)ğ‘‚ğ‘O(\sqrt{N})italic_O ( square-root start_ARG italic_N end_ARG )-weight queries and constant soundness. In Theorem 1.1, the proof of item 1 applies the product-expansion result of [KP23]. The proof of item 2 applies the product-expansion result of [PS94], which is perhaps surprising given that [KP23] observe that this result is too weak to apply to known distance bounds for balanced product constructions [PK22a, LZ22, DHLV23]. The proof of item 3 applies a forthcoming product-expansion result of Kalachev & Panteleev [KP24]. 1.2 Results on Subsystem QLDPC Codes Our second main result provides a new method of taking homological products that preserve almost-linear distance by using subsystem codes, which only encode messages into a subspace of the entire logical code space. Our analysis of this method builds on techniques of [KT21]. As a result, we obtain a new construction of qLDPC codes of close-to-linear dimension and distance with constant stabilizer weight using an iterative construction, which is based on iterative homological products of a constant-sized code. We provide an informal statement below: Theorem 1.2 (Informal statement of Theorem 2.9). For every Ïµ>0italic-Ïµ0\epsilon>0italic_Ïµ > 0, there exists a constant-sized code ğ’ğ’\mathcal{C}caligraphic_C and an infinite sequence of qLDPC subsystem codes (Qi)iâˆˆâ„•subscriptsubscriptğ‘„ğ‘–ğ‘–â„•(Q_{i})_{i\in\mathbb{N}}( italic_Q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_i âˆˆ blackboard_N end_POSTSUBSCRIPT with parameters [[Ni,Ni1âˆ’Ïµ,Ni1âˆ’Ïµ]]2subscriptdelimited-[]subscriptğ‘ğ‘–superscriptsubscriptğ‘ğ‘–1italic-Ïµsuperscriptsubscriptğ‘ğ‘–1italic-Ïµ2[[N_{i},N_{i}^{1-\epsilon},N_{i}^{1-\epsilon}]]_{2}[ [ italic_N start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_N start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT , italic_N start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT ] ] start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and with constant stabilizer weight Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 ) (independent of Ïµitalic-Ïµ\epsilonitalic_Ïµ), such that each Qisubscriptğ‘„ğ‘–Q_{i}italic_Q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is obtained by applying the stabilizer-weight-reduction transformation of [Has23] to the homological product of Qiâˆ’1subscriptğ‘„ğ‘–1Q_{i-1}italic_Q start_POSTSUBSCRIPT italic_i - 1 end_POSTSUBSCRIPT with ğ’ğ’\mathcal{C}caligraphic_C. The weight-reduction step in Theorem 1.2 is needed to keep the stabilizer weight constant in each iteration, as in general the stabilizer weight of a homological product code grows as the sum of the stabilizer weights of the input codes. The key idea behind the construction in Theorem 1.2 is that by using subsystem codes, we are able to circumvent the Î˜~â¢(N)~Î˜ğ‘\tilde{\Theta}(\sqrt{N})over~ start_ARG roman_Î˜ end_ARG ( square-root start_ARG italic_N end_ARG ) distance barrier that limited most prior homological product code constructions. Specifically, we observe that this barrier only applies to certain logical operators (i.e. codewords) within the code space. Therefore, we show that appropriate homological product codes will still have good distance for a large subspace of the logical operators. Thus appropriate subsystem codes of these products will still have good distance. We prove our specific distance bounds by adapting the techniques of [KT21], which showed a similar result, but that did not use subsystem codes. To prove Theorem 1.2, we set ğ’ğ’\mathcal{C}caligraphic_C to be a constant-sized quantum locally testable code (qLTC; see Definition 3.5) such as one given by [DLV24] (which in turn applies a forthcoming result of [KP24]); such a qLTC (which we emphasize is just constant-sized) is needed for our subsystem distance bound described above. We apply this distance bound to show that the distance of each Qisubscriptğ‘„ğ‘–Q_{i}italic_Q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT remains close-to-linear (i.e. â‰¥Ni1âˆ’Ïµabsentsuperscriptsubscriptğ‘ğ‘–1italic-Ïµ\geq N_{i}^{1-\epsilon}â‰¥ italic_N start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 1 - italic_Ïµ end_POSTSUPERSCRIPT) in the block length Nisubscriptğ‘ğ‘–N_{i}italic_N start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT. This iterative construction is reminiscent of a line of work in classical pseudorandomness, coding theory, and complexity theory, which iteratively builds larger objects with properties of interest from smaller or weaker ones. For instace, [BSS04] constructed classical locally testable codes by iterative tensoring of a small classical code; at a high level, Theorem 1.2 uses a related approach to construct qLDPC codes. Other notable iterative constructions in the literature include explicit spectral expanders from the zig-zag product [RVW02], Dinurâ€™s proof of the PCP theorem [Din07], and undirected connectivity in logarithmic space [Rei08]. Theorem 1.2 can therefore be viewed as an analogue of these results for qLDPC codes. However, our construction does need to start with a strong constant-sized object, namely, a constant-sized qLTC with sufficiently good parameters. It is an interesting open question whether there exists an iterative construction with a weaker starting object."
https://arxiv.org/html/2411.03451v1,Redundancy Is All You Need,"The seminal work of BenczÃºr and Karger demonstrated cut sparsifiers of near-linear size, with several applications throughout theoretical computer science. Subsequent extensions have yielded sparsifiers for hypergraph cuts and more recently linear codes over Abelian groups. A decade ago, Kogan and Krauthgamer asked about the sparsifiability of arbitrary constraint satisfaction problems (CSPs). For this question, a trivial lower bound is the size of a non-redundant CSP instance, which admits, for each constraint, an assignment satisfying only that constraint (so that no constraint can be dropped by the sparsifier). For instance, for graph cuts, spanning trees are non-redundant instances.Our main result is that redundant clauses are sufficient for sparsification: for any CSP predicate Rğ‘…Ritalic_R, every unweighted instance of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) has a sparsifier of size at most its non-redundancy (up to polylog factors). For weighted instances, we similarly pin down the sparsifiability to the so-called chain length of the predicate. These results precisely determine the extent to which any CSP can be sparsified. A key technical ingredient in our work is a novel application of the entropy method from Gilmerâ€™s recent breakthrough on the union-closed sets conjecture.As an immediate consequence of our main theorem, a number of results in the non-redundancy literature immediately extend to CSP sparsification. We also contribute new techniques for understanding the non-redundancy of CSP predicates. In particular, we give an explicit family of predicates whose non-redundancy roughly corresponds to the structure of matching vector families in coding theory. By adapting methods from the matching vector codes literature, we are able to construct an explicit predicate whose non-redundancy lies between Î©â¢(n1.5)Î©superscriptğ‘›1.5\Omega(n^{1.5})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) and O~â¢(n1.6)~ğ‘‚superscriptğ‘›1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ), the first example with a provably non-integral exponent.","The broad goal in sparsification is to replace an object by a more compact surrogate, typically a carefully chosen subsample, that preserves the behavior of the object under some metric of interest. For instance, for preserving cuts in undirected graphs, the influential works of Karger [Kar93] and BenczÃºr and Karger [BK96] showed that every graph has an edge-weighted subgraph with near-linear number of edges that preserves the value of all (edge) cuts up to a (1Â±Ïµ)plus-or-minus1italic-Ïµ(1\pm\epsilon)( 1 Â± italic_Ïµ ) multiplicative factor. These papers have had a substantial impact in shaping the last thirty years of work in areas such as spectral sparsifiers [ST11, BSS12, LS18], clustering [KVV04, SPR11], hypergraph sparsifiers [KK15, CKN20, KKTY21, KK23, KPS24c], linear solvers [ST04, Vis13, KMP14], convex optimization [LS14, AK16, Tod16], sketching/streaming algorithms [AG09, AGM12b, AGM12a, ACK+16, McG14, KLM+17, BHM+21], max-flow/min-cut algorithms [LR99, CKM+11, KLOS14, CKL+22], machine learning [LCY+21, CSZ22, ZSW+23, GBY+24], submodular functions [KK23, Sch24, Raf24, Qua24], differential privacy [BBDS12, AU19], PageRank [Chu14], and even theoretical physics [HKTH16, Van18, TN22], among many other works. Among the multiple exciting dimensions in which cut sparsification has been generalized, we now highlight two which form the backdrop for our work. Note that the graph cut problem can be modeled by the arity-two Boolean constraint x+y=1(mod2)ğ‘¥ğ‘¦annotated1pmod2x+y=1\pmod{2}italic_x + italic_y = 1 start_MODIFIER ( roman_mod start_ARG 2 end_ARG ) end_MODIFIER. One can thus generalize cut sparsification by allowing for arbitrary constraints (of any arity over some finite domain) as considered in the field of constraint satisfaction problems (CSPs), leading to CSP sparsification. This direction was proposed by Kogan and Krauthgamer [KK15] in their work on hypergraph cut sparsifiers, where the not-all-equal constraint captures hypergraph cut. As as special case, arbitrary binary CSPs (where each constraint has two variables) were studied in [FK17] for the Boolean domain and in [BÅ½20] for general domains, leading to a dichotomy: either near-linear sized sparsifiers exist, or no improvement over quadratic is possible. In another direction, one can instead look toward more general structures to sparsify. For instance, a recent line of work by Khanna, Putterman, and Sudan turned toward sparsifying linear codes [KPS24a], or more generally subgroups of powers of Abelian groups [KPS24b]. Beyond being algorithmically efficient [KPS24b], these structural results have led to exciting new results in CSP sparsification by constructing optimal sparsifiers when the constraints can be embedded into linear/Abelian equations. In this work, we obtain sparsifiers encompassing both these generalizations via a unified approach to sparsification of non-linear codes. The resulting sparsifiers for CSPs have optimal asymptotic size up to polylogarithmic factors, for every choice of predicate defining the CSP. In other words, we pinpoint the optimal extent to which an arbitrary CSP can be sparsified.111In this work we focus on the existence of sparsifiers, which is already highly non-trivial (e.g., [KPS24a, BÅ½20] are also non-algorithmic). Future directions (and barriers) for algorithmic aspects are briefly discussed in Sections 1.7 and 9. 1.1 Non-linear code sparsification We first state our result for codes as it is very general and crisply stated, and then turn to the consequences and further new results for CSPs. For a non-linear code CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, an Îµğœ€\varepsilonitalic_Îµ-sparsifier (for a parameter Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 )) is a weight function w:[m]â†’â„â‰¥0:ğ‘¤â†’delimited-[]ğ‘šsubscriptâ„absent0w:[m]\to\mathbb{R}_{\geq 0}italic_w : [ italic_m ] â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT such that for every codeword cğ‘citalic_c, adding up the weights of its nonzero positions, i.e., âˆ‘iwâ¢(i)â¢cisubscriptğ‘–ğ‘¤ğ‘–subscriptğ‘ğ‘–\sum_{i}w(i)c_{i}âˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_w ( italic_i ) italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT, is an accurate estimate of the Hamming weight of cğ‘citalic_c (i.e., âˆ‘icisubscriptğ‘–subscriptğ‘ğ‘–\sum_{i}c_{i}âˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT) to within a (1Â±Îµ)plus-or-minus1ğœ€(1\pm\varepsilon)( 1 Â± italic_Îµ ) multiplicative factor (Definition 2.8). The goal is to minimize the support of wğ‘¤witalic_w (i.e., the number of nonzero entries wâ¢(i)ğ‘¤ğ‘–w(i)italic_w ( italic_i )), and the minimum value is called Îµğœ€\varepsilonitalic_Îµ-sparsifiability of Cğ¶Citalic_C and is denoted SPRâ¡(C,Îµ)SPRğ¶ğœ€\operatorname{SPR}(C,\varepsilon)roman_SPR ( italic_C , italic_Îµ ). One of our main results is an upper bound on the sparsifiability in terms of a natural combinatorial parameter of the code called its non-redundancy NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ), defined as follows: NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ) is the size of the largest subset of indices IâŠ†[m]ğ¼delimited-[]ğ‘šI\subseteq[m]italic_I âŠ† [ italic_m ] such that for each iâˆˆIğ‘–ğ¼i\in Iitalic_i âˆˆ italic_I, there is a codeword câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C with ci=1subscriptğ‘ğ‘–1c_{i}=1italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = 1 and ciâ€²=0subscriptğ‘superscriptğ‘–â€²0c_{i^{\prime}}=0italic_c start_POSTSUBSCRIPT italic_i start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUBSCRIPT = 0 for iâ€²âˆˆIâˆ–{i}superscriptğ‘–â€²ğ¼ğ‘–i^{\prime}\in I\setminus\{i\}italic_i start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âˆˆ italic_I âˆ– { italic_i }. In other words, if we imagine the code as a matrix whose rows are codewords, its non-redundancy is largest square submatrix which is a permutation matrix. Our result can then be stated compactly as follows. Theorem 1.1 (Main). For all CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT and Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 ), SPRâ¡(C,Îµ)=Oâ¢(NRDâ¡(C)â¢(logâ¡m)6/Îµ2).SPRğ¶ğœ€ğ‘‚NRDğ¶superscriptğ‘š6superscriptğœ€2\operatorname{SPR}(C,\varepsilon)=O(\operatorname{NRD}(C)(\log m)^{6}/% \varepsilon^{2}).roman_SPR ( italic_C , italic_Îµ ) = italic_O ( roman_NRD ( italic_C ) ( roman_log italic_m ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . To see how our theorem generalizes linear code sparsification [KPS24a, KPS24b], let ğ”½ğ”½\mathbb{F}blackboard_F be a (finite) field and let VâŠ†ğ”½mğ‘‰superscriptğ”½ğ‘šV\subseteq\mathbb{F}^{m}italic_V âŠ† blackboard_F start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT be a subspace. Let C:={(ğŸâ¢[v1=0],â€¦,ğŸâ¢[vm=0]):vâˆˆV}assignğ¶conditional-set1delimited-[]subscriptğ‘£10â€¦1delimited-[]subscriptğ‘£ğ‘š0ğ‘£ğ‘‰C:=\{({\bf 1}[v_{1}=0],\ldots,{\bf 1}[v_{m}=0]):v\in V\}italic_C := { ( bold_1 [ italic_v start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT = 0 ] , â€¦ , bold_1 [ italic_v start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT = 0 ] ) : italic_v âˆˆ italic_V } be the zero/non-zero pattern of Vğ‘‰Vitalic_V. Then, any Îµğœ€\varepsilonitalic_Îµ-sparsifier of Cğ¶Citalic_C is an Îµğœ€\varepsilonitalic_Îµ-sparsifier of Vğ‘‰Vitalic_V and NRDâ¡(C)=dimVNRDğ¶dimensionğ‘‰\operatorname{NRD}(C)=\dim Vroman_NRD ( italic_C ) = roman_dim italic_V. In fact, for any finite group GğºGitalic_G and subgroup Hâ‰¤Gmğ»superscriptğºğ‘šH\leq G^{m}italic_H â‰¤ italic_G start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, we can show for the corresponding Cğ¶Citalic_C that NRDâ¡(C)â‰¤log2â¡|H|NRDğ¶subscript2ğ»\operatorname{NRD}(C)\leq\log_{2}|H|roman_NRD ( italic_C ) â‰¤ roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_H | (see Theorem 5.1), matching [KPS24b]â€™s result for Abelian groups (modulo their efficiency). If we view CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT as a set family over the universe [m]delimited-[]ğ‘š[m][ italic_m ], the above result in effect says that the non-redundancy NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ) plays the role of the VC dimension of Cğ¶Citalic_C when the goal is to estimate the size of the set câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C rather than learn cğ‘citalic_c itself. In fact, it turns out that NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ) is precisely the VC dimension of the union-closure of Cğ¶Citalic_C. This connection to union-closed families plays a crucial role in the proof of Theorem 1.1. See the technical overview (Section 1.6) for more details, including discussion of a significantly simpler O~Îµâ¢(NRDâ¡(C)â¢logâ¡|C|)subscript~ğ‘‚ğœ€NRDğ¶ğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\log|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log | italic_C | )-sized sparsifier. 1.2 CSP sparsification We now turn to (unweighted222The weighted case is discussed in Section 1.4.) CSP sparsification. For a relation RâŠ†Drğ‘…superscriptğ·ğ‘ŸR\subseteq D^{r}italic_R âŠ† italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT of arity rğ‘Ÿritalic_r over a finite domain Dğ·Ditalic_D, an instance Î¨Î¨\Psiroman_Î¨ of the CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) problem consists a variable set Xğ‘‹Xitalic_X and a constraint set YâŠ†Xrğ‘Œsuperscriptğ‘‹ğ‘ŸY\subseteq X^{r}italic_Y âŠ† italic_X start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT. An assignment Ïƒ:Xâ†’D:ğœâ†’ğ‘‹ğ·\sigma:X\to Ditalic_Ïƒ : italic_X â†’ italic_D satisfies a constraint y=(x1,x2,â€¦,xr)âˆˆYğ‘¦subscriptğ‘¥1subscriptğ‘¥2â€¦subscriptğ‘¥ğ‘Ÿğ‘Œy=(x_{1},x_{2},\dots,x_{r})\in Yitalic_y = ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ) âˆˆ italic_Y if (Ïƒâ¢(x1),Ïƒâ¢(x2),â€¦,Ïƒâ¢(xr))âˆˆRğœsubscriptğ‘¥1ğœsubscriptğ‘¥2â€¦ğœsubscriptğ‘¥ğ‘Ÿğ‘…(\sigma(x_{1}),\sigma(x_{2}),\dots,\sigma(x_{r}))\in R( italic_Ïƒ ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT ) , italic_Ïƒ ( italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) , â€¦ , italic_Ïƒ ( italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ) ) âˆˆ italic_R. The value valâ¡(Î¨,Ïƒ)valÎ¨ğœ\operatorname{val}(\Psi,\sigma)roman_val ( roman_Î¨ , italic_Ïƒ ) of an assignment Ïƒğœ\sigmaitalic_Ïƒ is the number of constraints yâˆˆYğ‘¦ğ‘Œy\in Yitalic_y âˆˆ italic_Y that it satisfies. Similarly, for a weight function w:Yâ†’â„â‰¥0:ğ‘¤â†’ğ‘Œsubscriptâ„absent0w:Y\to\mathbb{R}_{\geq 0}italic_w : italic_Y â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT, the weighted value valâ¡(Î¨,w,Ïƒ)valÎ¨ğ‘¤ğœ\operatorname{val}(\Psi,w,\sigma)roman_val ( roman_Î¨ , italic_w , italic_Ïƒ ) is the sum of weights wâ¢(y)ğ‘¤ğ‘¦w(y)italic_w ( italic_y ) of all constraints yâˆˆYğ‘¦ğ‘Œy\in Yitalic_y âˆˆ italic_Y that Ïƒğœ\sigmaitalic_Ïƒ satisfies. The goal in CSP sparsification is to output a weight function w:Yâ†’â„â‰¥0:ğ‘¤â†’ğ‘Œsubscriptâ„absent0w:Y\to\mathbb{R}_{\geq 0}italic_w : italic_Y â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT of small support, such that for every assignment Ïƒ:Xâ†’D:ğœâ†’ğ‘‹ğ·\sigma:X\to Ditalic_Ïƒ : italic_X â†’ italic_D, (1âˆ’Îµ)â¢valâ¡(Î¨,Ïƒ)â‰¤valâ¡(Î¨,w,Ïƒ)â‰¤(1+Îµ)â¢valâ¡(Î¨,Ïƒ),1ğœ€valÎ¨ğœvalÎ¨ğ‘¤ğœ1ğœ€valÎ¨ğœ(1-\varepsilon)\operatorname{val}(\Psi,\sigma)\leq\operatorname{val}(\Psi,w,% \sigma)\leq(1+\varepsilon)\operatorname{val}(\Psi,\sigma)\ ,( 1 - italic_Îµ ) roman_val ( roman_Î¨ , italic_Ïƒ ) â‰¤ roman_val ( roman_Î¨ , italic_w , italic_Ïƒ ) â‰¤ ( 1 + italic_Îµ ) roman_val ( roman_Î¨ , italic_Ïƒ ) , and minimum such support size is denoted SPRâ¡(Î¨,Îµ)SPRÎ¨ğœ€\operatorname{SPR}(\Psi,\varepsilon)roman_SPR ( roman_Î¨ , italic_Îµ ). The Îµğœ€\varepsilonitalic_Îµ-sparsifiability of the relation RâŠ†Drğ‘…superscriptğ·ğ‘ŸR\subseteq D^{r}italic_R âŠ† italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT, as a function of number of variables, is defined to the maximum (i.e., worst-case) value of SPRâ¡(Î¨,Îµ)SPRÎ¨ğœ€\operatorname{SPR}(\Psi,\varepsilon)roman_SPR ( roman_Î¨ , italic_Îµ ) over all nğ‘›nitalic_n-variables instances Î¨Î¨\Psiroman_Î¨ of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ). We denote it by SPRâ¡(R,n,Îµ)SPRğ‘…ğ‘›ğœ€\operatorname{SPR}(R,n,\varepsilon)roman_SPR ( italic_R , italic_n , italic_Îµ ) and it is the chief object of our study. Note that this is for the unweighted case, see Section 1.4 how this result can be (tightly) applied to the weighted case. Let us note an obvious obstruction to sparsification. Suppose we have an instance Î¨=(X,Y)Î¨ğ‘‹ğ‘Œ\Psi=(X,Y)roman_Î¨ = ( italic_X , italic_Y ) of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) such that for each of its constraints yâˆˆYğ‘¦ğ‘Œy\in Yitalic_y âˆˆ italic_Y, there is an assignment Ïƒy:Xâ†’D:subscriptğœğ‘¦â†’ğ‘‹ğ·\sigma_{y}:X\to Ditalic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT : italic_X â†’ italic_D that satisfies only yğ‘¦yitalic_y and no other constraint. Then clearly Î¨Î¨\Psiroman_Î¨ cannot be sparsified at allâ€”dropping any constraint yğ‘¦yitalic_y would make the value of Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT drop from 1111 to 00. We call such an instance a non-redundant instance of CSPâ¡(RÂ¯)CSPÂ¯ğ‘…\operatorname{CSP}(\overline{R})roman_CSP ( overÂ¯ start_ARG italic_R end_ARG ), where RÂ¯=Drâˆ–RÂ¯ğ‘…superscriptğ·ğ‘Ÿğ‘…\overline{R}=D^{r}\setminus RoverÂ¯ start_ARG italic_R end_ARG = italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT âˆ– italic_R (cf., [BCH+13, BCK20]).333We use RÂ¯Â¯ğ‘…\overline{R}overÂ¯ start_ARG italic_R end_ARG rather than Rğ‘…Ritalic_R due to the conventions of each community. See Remark 2.6 for deeper technical reasons. As introduced by Bessiere, Carbonnel, and Katsirelos [BCK20], we denote the size of the largest such non-redundant instance of CSPâ¡(RÂ¯)CSPÂ¯ğ‘…\operatorname{CSP}(\overline{R})roman_CSP ( overÂ¯ start_ARG italic_R end_ARG ) on nğ‘›nitalic_n-variables by NRDâ¡(RÂ¯,n)NRDÂ¯ğ‘…ğ‘›\operatorname{NRD}(\overline{R},n)roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) and call it the non-redundancy of RÂ¯Â¯ğ‘…\overline{R}overÂ¯ start_ARG italic_R end_ARG. Thus a trivial lower bound on sparsifiability of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ), regardless of the choice of Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 ), is given by SPRâ¡(R,n,Îµ)â‰¥NRDâ¡(RÂ¯,n),SPRğ‘…ğ‘›ğœ€NRDÂ¯ğ‘…ğ‘›\displaystyle\operatorname{SPR}(R,n,\varepsilon)\geq\operatorname{NRD}(% \overline{R},n)\ ,roman_SPR ( italic_R , italic_n , italic_Îµ ) â‰¥ roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) , (1) and this holds even if the goal is merely to preserve which assignments have nonzero value. Rather remarkably, this simplistic lower bound can be met and one can sparsify all the way down to NRDâ¡(RÂ¯,n)NRDÂ¯ğ‘…ğ‘›\operatorname{NRD}(\overline{R},n)roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) times polylogarithmic factors! In fact, this turns out to be an easy corollary of Theorem 1.1. One can associate a canonical code CÎ¨âŠ†{0,1}Ysubscriptğ¶Î¨superscript01ğ‘ŒC_{\Psi}\subseteq\{0,1\}^{Y}italic_C start_POSTSUBSCRIPT roman_Î¨ end_POSTSUBSCRIPT âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_Y end_POSTSUPERSCRIPT with any CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) instance Î¨=(X,Y)Î¨ğ‘‹ğ‘Œ\Psi=(X,Y)roman_Î¨ = ( italic_X , italic_Y ) whose codewords cÏƒsubscriptğ‘ğœc_{\sigma}italic_c start_POSTSUBSCRIPT italic_Ïƒ end_POSTSUBSCRIPT correspond to the assignments Ïƒ:Xâ†’D:ğœâ†’ğ‘‹ğ·\sigma:X\to Ditalic_Ïƒ : italic_X â†’ italic_D, and cÏƒ,ysubscriptğ‘ğœğ‘¦c_{\sigma,y}italic_c start_POSTSUBSCRIPT italic_Ïƒ , italic_y end_POSTSUBSCRIPT is 1111 precisely when Ïƒğœ\sigmaitalic_Ïƒ satisfies yğ‘¦yitalic_y. It is easy to check that CSP sparsification of Î¨Î¨\Psiroman_Î¨ reduces to code sparsification of CÎ¨subscriptğ¶Î¨C_{\Psi}italic_C start_POSTSUBSCRIPT roman_Î¨ end_POSTSUBSCRIPT, and the non-redundancy of Cğ¶Citalic_C equals the size of the largest non-redundant sub-instance of Î¨Î¨\Psiroman_Î¨ (viewed as an instance of CSPâ¡(RÂ¯)CSPÂ¯ğ‘…\operatorname{CSP}(\overline{R})roman_CSP ( overÂ¯ start_ARG italic_R end_ARG )). Combining Theorem 1.1 and (1), we therefore have our main result pinning down the sparsifiability of every CSP up to polylogarithmic factors. Theorem 1.2. For every nonempty RâŠŠDrğ‘…superscriptğ·ğ‘ŸR\subsetneq D^{r}italic_R âŠŠ italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT and Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 ), we have that NRDâ¡(RÂ¯,n)â‰¤SPRâ¡(R,n,Îµ)â‰¤Oâ¢(NRDâ¡(RÂ¯,n)â¢(râ¢logâ¡n)6/Îµ2).NRDÂ¯ğ‘…ğ‘›SPRğ‘…ğ‘›ğœ€ğ‘‚NRDÂ¯ğ‘…ğ‘›superscriptğ‘Ÿğ‘›6superscriptğœ€2\operatorname{NRD}(\overline{R},n)\leq\operatorname{SPR}(R,n,\varepsilon)\leq O% (\operatorname{NRD}(\overline{R},n)(r\log n)^{6}/\varepsilon^{2}).roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) â‰¤ roman_SPR ( italic_R , italic_n , italic_Îµ ) â‰¤ italic_O ( roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) ( italic_r roman_log italic_n ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . 1.3 Non-redundancy of specific relations The non-redundancy of relations is readily computed in some simple cases. For example, for the relation ORr:=Drâˆ–{0r}assignsubscriptORğ‘Ÿsuperscriptğ·ğ‘Ÿsuperscript0ğ‘Ÿ\operatorname{OR}_{r}:=D^{r}\setminus\{0^{r}\}roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT := italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT âˆ– { 0 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT }, we have that NRDâ¡(ORr,n)=Î˜â¢(nr)NRDsubscriptORğ‘Ÿğ‘›Î˜superscriptğ‘›ğ‘Ÿ\operatorname{NRD}(\operatorname{OR}_{r},n)=\Theta(n^{r})roman_NRD ( roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT , italic_n ) = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ). Indeed Y=(Xr)ğ‘Œbinomialğ‘‹ğ‘ŸY=\binom{X}{r}italic_Y = ( FRACOP start_ARG italic_X end_ARG start_ARG italic_r end_ARG ) is a non-redundant instance because setting all but rğ‘Ÿritalic_r variables to 1111 fails to satisfy exactly that rğ‘Ÿritalic_r-tuple (see [FK17, Car22, KPS24b]). When Rğ‘…Ritalic_R is affine, NRDâ¡(R,n)=Î˜â¢(n)NRDğ‘…ğ‘›Î˜ğ‘›\operatorname{NRD}(R,n)=\Theta(n)roman_NRD ( italic_R , italic_n ) = roman_Î˜ ( italic_n ), and when Rğ‘…Ritalic_R is defined as the zero set of a degree kğ‘˜kitalic_k polynomial, NRDâ¡(R,n)=Oâ¢(nk)NRDğ‘…ğ‘›ğ‘‚superscriptğ‘›ğ‘˜\operatorname{NRD}(R,n)=O(n^{k})roman_NRD ( italic_R , italic_n ) = italic_O ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ); these follow from simple rank arguments (e.g., [LW20]). Via Theorem 1.2, these special cases (plus simple gadget reductions) already capture all the previously known upper and lower bounds for CSP sparsification (see Section 1.5 for more details on the CSP sparsification literature). Furthermore, there are also some non-trivial upper bounds known on NRD in the literature, which we can now import to sparsifiability for free courtesy Theorem 1.2. For instance, the so-called Malâ€™tsev relations, which generalize affine predicates (i.e., cosets) over Abelian groups, have been shown to have ODâ¢(n)subscriptğ‘‚ğ·ğ‘›O_{D}(n)italic_O start_POSTSUBSCRIPT italic_D end_POSTSUBSCRIPT ( italic_n ) non-redundancy [LW20, BCK20], and therefore by Theorem 1.2 their complements have near-linear sparsifiability. Carbonnel [Car22] showed that if Rğ‘…Ritalic_R is an arity rğ‘Ÿritalic_r relation that doesnâ€™t contain444See Theorem 5.2 for a precise definition. any copy of ORrsubscriptORğ‘Ÿ\operatorname{OR}_{r}roman_OR start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT, then NRDâ¡(R,n)â‰¤Oâ¢(nrâˆ’Î´r)NRDğ‘…ğ‘›ğ‘‚superscriptğ‘›ğ‘Ÿsubscriptğ›¿ğ‘Ÿ\operatorname{NRD}(R,n)\leq O(n^{r-\delta_{r}})roman_NRD ( italic_R , italic_n ) â‰¤ italic_O ( italic_n start_POSTSUPERSCRIPT italic_r - italic_Î´ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) for Î´r=21âˆ’rsubscriptğ›¿ğ‘Ÿsuperscript21ğ‘Ÿ\delta_{r}=2^{1-r}italic_Î´ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT = 2 start_POSTSUPERSCRIPT 1 - italic_r end_POSTSUPERSCRIPT (the specific bound arises from a classic hypergraph TurÃ¡n result [Erd64]). By Theorem 1.2 this immediately implies SPRâ¡(RÂ¯,n,Îµ)â‰¤O~Îµâ¢(nrâˆ’Î´r)SPRÂ¯ğ‘…ğ‘›ğœ€subscript~ğ‘‚ğœ€superscriptğ‘›ğ‘Ÿsubscriptğ›¿ğ‘Ÿ\operatorname{SPR}(\overline{R},n,\varepsilon)\leq\widetilde{O}_{\varepsilon}(% n^{r-\delta_{r}})roman_SPR ( overÂ¯ start_ARG italic_R end_ARG , italic_n , italic_Îµ ) â‰¤ over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r - italic_Î´ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ), where O~â¢(â‹…)~ğ‘‚â‹…\widetilde{O}(\cdot)over~ start_ARG italic_O end_ARG ( â‹… ) hides polylogarithmic factors in nğ‘›nitalic_n, yielding an Î©â¢(nr)Î©superscriptğ‘›ğ‘Ÿ\Omega(n^{r})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ) vs O~â¢(nrâˆ’Î´r)~ğ‘‚superscriptğ‘›ğ‘Ÿsubscriptğ›¿ğ‘Ÿ\widetilde{O}(n^{r-\delta_{r}})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT italic_r - italic_Î´ start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) dichotomy for sparsification of arity rğ‘Ÿritalic_r CSPs. (This was known for the Boolean case [KPS24b]; see the related work subsection.) The non-redundancy of a relation can in general be difficult to estimate. Thus while in principle Theorem 1.2 pins down the sparisifiability of every CSP, for specific relations, it can still be non-trivial to actually determine the asymptotic behavior of its sparsifiability. Our next set of results makes progress in this direction via novel methods to bound non-redundancy. Given that the non-redundancy of linear predicates is easy to pin down, we consider a natural family of relations which are very close to being linear. Specifically, let 3â¢Lâ¢Iâ¢NG={(x,y,z)âˆ£x+y+z=0}subscript3LINğºconditional-setğ‘¥ğ‘¦ğ‘§ğ‘¥ğ‘¦ğ‘§0\operatorname{3LIN}_{G}=\{(x,y,z)\mid x+y+z=0\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = { ( italic_x , italic_y , italic_z ) âˆ£ italic_x + italic_y + italic_z = 0 } over an Abelian group GğºGitalic_G, and consider 3â¢Lâ¢Iâ¢NGâˆ—=3â¢Lâ¢Iâ¢NGâˆ–{(0,0,0)}subscriptsuperscript3LINğºsubscript3LINğº000\operatorname{3LIN}^{*}_{G}=\operatorname{3LIN}_{G}\setminus\{(0,0,0)\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT âˆ– { ( 0 , 0 , 0 ) }. (We pick arity 3333 since the arity 2222 case is already fully resolved [FK17, BÅ½20].) Being defined by a linear equation over an Abelian group, we already know that NRDâ¡(3â¢Lâ¢Iâ¢NG,n)=Î˜Gâ¢(n)NRDsubscript3LINğºğ‘›subscriptÎ˜ğºğ‘›\operatorname{NRD}(\operatorname{3LIN}_{G},n)=\Theta_{G}(n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) = roman_Î˜ start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n ). However the non-redundancy of 3â¢Lâ¢Iâ¢NGâˆ—subscriptsuperscript3LINğº\operatorname{3LIN}^{*}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT seems challenging to understand. Existing methods in the literature only yield NRDâ¡(3â¢Lâ¢Iâ¢NGâˆ—,n)âˆˆ[Î©Gâ¢(n),OGâ¢(n2)]NRDsubscriptsuperscript3LINğºğ‘›subscriptÎ©ğºğ‘›subscriptğ‘‚ğºsuperscriptğ‘›2\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)\in[\Omega_{G}(n),O_{G}(n^{2})]roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) âˆˆ [ roman_Î© start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n ) , italic_O start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) ]. We introduce a new method for bounding the non-redundancy of predicates like 3â¢Lâ¢Iâ¢NGâˆ—subscriptsuperscript3LINğº\operatorname{3LIN}^{*}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT by connecting them to the theory of matching vector (MV) families [Yek08, DGY11] that have been used in the construction of locally decodable codes. Exploiting this connection, we construct a non-redundant instance to establish that NRDâ¡(3â¢Lâ¢Iâ¢NG,n)â‰¥Î©â¢(n1.5)NRDsubscript3LINğºğ‘›Î©superscriptğ‘›1.5\operatorname{NRD}(\operatorname{3LIN}_{G},n)\geq\Omega(n^{1.5})roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) â‰¥ roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) for all Abelian groups of order â‰¥3absent3\geq 3â‰¥ 3. Adapting ideas from the analysis of MV families together with some combinatorial ideas, we also prove an upper bound NRDâ¡(3â¢Lâ¢Iâ¢Nâ„¤/pâ¢â„¤,n)=O~pâ¢(n2âˆ’Îµp)NRDsubscript3LINâ„¤ğ‘â„¤ğ‘›subscript~ğ‘‚ğ‘superscriptğ‘›2subscriptğœ€ğ‘\operatorname{NRD}(\operatorname{3LIN}_{\mathbb{Z}/p\mathbb{Z}},n)=\widetilde{% O}_{p}(n^{2-\varepsilon_{p}})roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT blackboard_Z / italic_p blackboard_Z end_POSTSUBSCRIPT , italic_n ) = over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT 2 - italic_Îµ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) for Îµp=22â¢pâˆ’1subscriptğœ€ğ‘22ğ‘1\varepsilon_{p}=\tfrac{2}{2p-1}italic_Îµ start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT = divide start_ARG 2 end_ARG start_ARG 2 italic_p - 1 end_ARG and pğ‘pitalic_p prime. Specializing for p=3ğ‘3p=3italic_p = 3, we have the following result, which also gives the first examples of relations whose non-redundancy and sparsifiability have a non-integral exponent. Theorem 1.3. We have NRDâ¡(3â¢Lâ¢Iâ¢Nâ„¤/3â¢â„¤âˆ—,n)NRDsubscriptsuperscript3LINâ„¤3â„¤ğ‘›\displaystyle\operatorname{NRD}(\operatorname{3LIN}^{*}_{\mathbb{Z}/3\mathbb{Z% }},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT , italic_n ) âˆˆ[Î©â¢(n1.5),O~â¢(n1.6)], andabsentÎ©superscriptğ‘›1.5~ğ‘‚superscriptğ‘›1.6 and\displaystyle\in[\Omega(n^{1.5}),\widetilde{O}(n^{1.6})],\ \ \ \text{ and }âˆˆ [ roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) , over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) ] , and SPRâ¡(3â¢Lâ¢Iâ¢Nâ„¤/3â¢â„¤âˆ—Â¯,n,Îµ)SPRÂ¯subscriptsuperscript3LINâ„¤3â„¤ğ‘›ğœ€\displaystyle\operatorname{SPR}(\overline{\operatorname{3LIN}^{*}_{\mathbb{Z}/% 3\mathbb{Z}}},n,\varepsilon)roman_SPR ( overÂ¯ start_ARG start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT end_ARG , italic_n , italic_Îµ ) âˆˆ[Î©â¢(n1.5),O~â¢(n1.6/Îµ2)].absentÎ©superscriptğ‘›1.5~ğ‘‚superscriptğ‘›1.6superscriptğœ€2\displaystyle\in[\Omega(n^{1.5}),\widetilde{O}(n^{1.6}/\varepsilon^{2})].âˆˆ [ roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) , over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) ] . 1.4 Weighted CSP sparsification The discussion so far has focused on unweighted CSP instances, and we now shift our focus to the weighted case, where each constraint of Yğ‘ŒYitalic_Y comes with a weight. We also get a tight characterization of weighted CSP sparsifiablity, in terms of a parameter called the chain length, which was defined by Lagerkvist and WahlstrÃ¶m [LW17, LW20] in the context of CSP kernelization and later utilized by Bessiere, Carbonnel, and Katsirelos [BCK20] in the context of learning CSPs in a certain query model (see Section 1.5 for more details on these connections). As before, the result is obtained in the setting of weighted non-linear codes, with the consequence for weighted CSPs being an easy corollary. We just state the result for codes here (see Section 8 for the full treatment of weighted CSPs). For weighted sparsification of a code CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT, we might have an arbitrary input weighting Î¶:[m]â†’â„â‰¥0:ğœâ†’delimited-[]ğ‘šsubscriptâ„absent0\zeta:[m]\to\mathbb{R}_{\geq 0}italic_Î¶ : [ italic_m ] â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT of its coordinates, and we must find a sparsifier w~:[n]â†’â„â‰¥0:~ğ‘¤â†’delimited-[]ğ‘›subscriptâ„absent0\widetilde{w}:[n]\to\mathbb{R}_{\geq 0}over~ start_ARG italic_w end_ARG : [ italic_n ] â†’ blackboard_R start_POSTSUBSCRIPT â‰¥ 0 end_POSTSUBSCRIPT of low support that sparsifies Cğ¶Citalic_C with respect to the weighting Î¶ğœ\zetaitalic_Î¶, i.e., âŸ¨w~,câŸ©âˆˆ(1Â±Îµ)â¢âŸ¨Î¶,câŸ©~ğ‘¤ğ‘plus-or-minus1ğœ€ğœğ‘\langle\widetilde{w},c\rangle\in(1\pm\varepsilon)\langle\zeta,c\rangleâŸ¨ over~ start_ARG italic_w end_ARG , italic_c âŸ© âˆˆ ( 1 Â± italic_Îµ ) âŸ¨ italic_Î¶ , italic_c âŸ©. The minimum possible support of sparsifiers over all weightings Î¶ğœ\zetaitalic_Î¶ is called the weighted Îµğœ€\varepsilonitalic_Îµ-sparsity wSPRâ¡(C,Îµ)wSPRğ¶ğœ€\operatorname{wSPR}(C,\varepsilon)roman_wSPR ( italic_C , italic_Îµ ). Now we define chain length. If we line up the codewords of Cğ¶Citalic_C as rows of an |C|Ã—mğ¶ğ‘š|C|\times m| italic_C | Ã— italic_m matrix and allow arbitrary column permutations, the chain length of Cğ¶Citalic_C, denoted CLâ¡(C)CLğ¶\operatorname{CL}(C)roman_CL ( italic_C ), is the dimension of the largest upper triangular square submatrix with 1111â€™s on the diagonal.555In this view NRDâ¡(C)NRDğ¶\operatorname{NRD}(C)roman_NRD ( italic_C ) is the dimension of the largest identity submatrix, so clearly NRDâ¡(C)â‰¤CLâ¡(C)NRDğ¶CLğ¶\operatorname{NRD}(C)\leq\operatorname{CL}(C)roman_NRD ( italic_C ) â‰¤ roman_CL ( italic_C ). The quantity CLâ¡(C)CLğ¶\operatorname{CL}(C)roman_CL ( italic_C ) was called visible rank in [AG21] and served as a field independent lower bound on the rank of Cğ¶Citalic_C. In our main result for the weighted setting, we pin the sparsifiability of a weighted code to its chain length. Note that in the weighted case CLâ¡(C)CLğ¶\operatorname{CL}(C)roman_CL ( italic_C ) is also a lower bound. Theorem 1.4. For all CâŠ†{0,1}mğ¶superscript01ğ‘šC\subseteq\{0,1\}^{m}italic_C âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT and Îµâˆˆ(0,1)ğœ€01\varepsilon\in(0,1)italic_Îµ âˆˆ ( 0 , 1 ), we have CLâ¡(C)â‰¤wSPRâ¡(C,Îµ)=Oâ¢(CLâ¡(C)â¢(logâ¡m)6/Îµ2).CLğ¶wSPRğ¶ğœ€ğ‘‚CLğ¶superscriptğ‘š6superscriptğœ€2\operatorname{CL}(C)\leq\operatorname{wSPR}(C,\varepsilon)=O(\operatorname{CL}% (C)(\log m)^{6}/\varepsilon^{2}).roman_CL ( italic_C ) â‰¤ roman_wSPR ( italic_C , italic_Îµ ) = italic_O ( roman_CL ( italic_C ) ( roman_log italic_m ) start_POSTSUPERSCRIPT 6 end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) . The upper bound proceeds by using Theorem 1.1 as a black-box together with a geometric weight bucketing technique from [KPS24b]. The lower bound proceeds by applying an exponential sequence of weights to the indices i1,â€¦,iCLâ¡(C)âˆˆ[m]subscriptğ‘–1â€¦subscriptğ‘–CLğ¶delimited-[]ğ‘ši_{1},\ldots,i_{\operatorname{CL}{(C)}}\in[m]italic_i start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_i start_POSTSUBSCRIPT roman_CL ( italic_C ) end_POSTSUBSCRIPT âˆˆ [ italic_m ] forming a maximal chain. Of note, if for a particular set of weights, the ratio between maximum and minimal weights is Î»â‰ªexpâ¡(CLâ¡(C)/NRDâ¡(C))much-less-thanğœ†CLğ¶NRDğ¶\lambda\ll\exp(\operatorname{CL}(C)/\operatorname{NRD}(C))italic_Î» â‰ª roman_exp ( roman_CL ( italic_C ) / roman_NRD ( italic_C ) ), we get a sharper upper bound of O~Îµâ¢(NRDâ¡(C)â¢logâ¡Î»)subscript~ğ‘‚ğœ€NRDğ¶ğœ†\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\log\lambda)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log italic_Î» ) (see Corollary 8.18). We now transition to discussing the broader context of our work in the literature. 1.5 Related Work Our results and techniques have connections to many areas including computational complexity theory, extremal combinatorics, coding theory, and learning theory. We now give a general overview of these connections. CSP Sparsification. Since we already discussed the history of CSP sparsification, we give a comprehensive list of known results about CSP sparsification (up to polylog factors). â€¢ The case of binary CSPs (r=2ğ‘Ÿ2r=2italic_r = 2) is fully classified. In particular, for every finite domain Dğ·Ditalic_D and RâŠ†D2ğ‘…superscriptğ·2R\subseteq D^{2}italic_R âŠ† italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT, we either have that SPRâ¡(R,n,Îµ)=Oâ¢(n/Îµ2)SPRğ‘…ğ‘›ğœ€ğ‘‚ğ‘›superscriptğœ€2\operatorname{SPR}(R,n,\varepsilon)=O(n/\varepsilon^{2})roman_SPR ( italic_R , italic_n , italic_Îµ ) = italic_O ( italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) or SPRâ¡(R,n,Îµ)=Î©â¢(n2)SPRğ‘…ğ‘›ğœ€Î©superscriptğ‘›2\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{2})roman_SPR ( italic_R , italic_n , italic_Îµ ) = roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) [BÅ½20]. However, the sparsification routine is only efficient in the Boolean case [FK17]. Of note, SPRâ¡(R,n,Îµ)=Î©â¢(n2)SPRğ‘…ğ‘›ğœ€Î©superscriptğ‘›2\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{2})roman_SPR ( italic_R , italic_n , italic_Îµ ) = roman_Î© ( italic_n start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) if and only if there exist D1,D2âŠ†Dsubscriptğ·1subscriptğ·2ğ·D_{1},D_{2}\subseteq Ditalic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âŠ† italic_D of size exactly 2222 such that |Râˆ©(D1Ã—D2)|=1ğ‘…subscriptğ·1subscriptğ·21|R\cap(D_{1}\times D_{2})|=1| italic_R âˆ© ( italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) | = 1 (informally Rğ‘…Ritalic_R has an â€œinduced copyâ€ of AND2subscriptAND2\operatorname{AND}_{2}roman_AND start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT). â€¢ For râ‰¥3ğ‘Ÿ3r\geq 3italic_r â‰¥ 3, much less is known. Kogan and Krauthgamer [KK15] contributed near-linear hypergraph cut sparsifiers (i.e., the predicate is NAEr:={0,1}râˆ–{0r,1r}assignsubscriptNAEğ‘Ÿsuperscript01ğ‘Ÿsuperscript0ğ‘Ÿsuperscript1ğ‘Ÿ\operatorname{NAE}_{r}:=\{0,1\}^{r}\setminus\{0^{r},1^{r}\}roman_NAE start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT := { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT âˆ– { 0 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT , 1 start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT }). Since then, there have been multiple improvements in efficiently constructing hypergraph sparsifiers/sketches (e.g., [CKN20, KKTY21, KPS24c]). â€¢ The breakthroughs of Khanna, Putterman, and Sudan [KPS24a, KPS24b] construct non-linear sparsifiers for any predicate which can defined by a system of linear (in)equations (possibly over a higher domain). For example NAEr={xâˆˆ{0,1}r:x1+â‹¯+xrâ‰¢0modr}subscriptNAEğ‘Ÿconditional-setğ‘¥superscript01ğ‘Ÿnot-equivalent-tosubscriptğ‘¥1â‹¯subscriptğ‘¥ğ‘Ÿmodulo0ğ‘Ÿ\operatorname{NAE}_{r}=\{x\in\{0,1\}^{r}:x_{1}+\cdots+x_{r}\not\equiv 0\mod r\}roman_NAE start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT = { italic_x âˆˆ { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT : italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + â‹¯ + italic_x start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT â‰¢ 0 roman_mod italic_r }. Of note, their first paper [KPS24a] only proved the result over finite fields (and was nonalgorithmic), whereas their second paper [KPS24b] extended the result to all Abelian groups and was computationally efficient. â€¢ The framework of Khanna, Putterman, and Sudan [KPS24b] produced numerous corollaries. In particular, if a predicate can be expressed as the nonzero set of a degree kğ‘˜kitalic_k polynomial, then it has a sparsifier of size O~Îµâ¢(nk)subscript~ğ‘‚ğœ€superscriptğ‘›ğ‘˜\widetilde{O}_{\varepsilon}(n^{k})over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). Furthermore, they show if a predicate Rğ‘…Ritalic_R can express666More specifically, we say that RâŠ†{0,1}rğ‘…superscript01ğ‘ŸR\subseteq\{0,1\}^{r}italic_R âŠ† { 0 , 1 } start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT can express ANDksubscriptANDğ‘˜\operatorname{AND}_{k}roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT if there exits a map z:[r]â†’{0,1,x1,â€¦,xk,x1Â¯,â€¦,xkÂ¯}:ğ‘§â†’delimited-[]ğ‘Ÿ01subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜Â¯subscriptğ‘¥1â€¦Â¯subscriptğ‘¥ğ‘˜z:[r]\to\{0,1,x_{1},\ldots,x_{k},\overline{x_{1}},\ldots,\overline{x_{k}}\}italic_z : [ italic_r ] â†’ { 0 , 1 , italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT , overÂ¯ start_ARG italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_ARG , â€¦ , overÂ¯ start_ARG italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT end_ARG } such that Râ¢(zâ¢(1),â€¦,zâ¢(r))=ANDkâ¡(x1,â€¦,xk)ğ‘…ğ‘§1â€¦ğ‘§ğ‘ŸsubscriptANDğ‘˜subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘˜R(z(1),\ldots,z(r))=\operatorname{AND}_{k}(x_{1},\ldots,x_{k})italic_R ( italic_z ( 1 ) , â€¦ , italic_z ( italic_r ) ) = roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT ). We discuss a more general framework of gadget reductions in Section 5.4. ANDk:={1k}assignsubscriptANDğ‘˜superscript1ğ‘˜\operatorname{AND}_{k}:=\{1^{k}\}roman_AND start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT := { 1 start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT }, then SPRâ¡(R,n,Îµ)=Î©â¢(nk)SPRğ‘…ğ‘›ğœ€Î©superscriptğ‘›ğ‘˜\operatorname{SPR}(R,n,\varepsilon)=\Omega(n^{k})roman_SPR ( italic_R , italic_n , italic_Îµ ) = roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). As a consequence, they also classify all ternary Boolean predicates (r=3ğ‘Ÿ3r=3italic_r = 3) as well as which Boolean predicates of arity rğ‘Ÿritalic_r cannot be sparsified below Î©â¢(nr)Î©superscriptğ‘›ğ‘Ÿ\Omega(n^{r})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ) (just ANDrsubscriptANDğ‘Ÿ\operatorname{AND}_{r}roman_AND start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT and its bit flips), while also constructing a sparsifier of size O~Îµâ¢(nrâˆ’1)subscript~ğ‘‚ğœ€superscriptğ‘›ğ‘Ÿ1\widetilde{O}_{\varepsilon}(n^{r-1})over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r - 1 end_POSTSUPERSCRIPT ) in the other cases. â€¢ It appears that lower bounds with a nontrivial dependence on Îµğœ€\varepsilonitalic_Îµ are only known for cut sparsifiers (and thus hypergraph cut sparsifiers via a simple gadget reduction). See [ACK+16, CKST19] as well as Section 9 for further discussion. CSP Kernelization. Another question similar in spirit to CSP sparsification is that of CSP kernelization.777More commonly, CSP kernelization is referred to as CSP sparsification (e.g., [DvM14, LW20]). However, we refer to this line of work by the former name to reduce ambiguity. This similarity in name has been noted before in the literature (e.g., [BÅ½20]), but we appear to be the first work to notice both variants of â€œCSP sparsificationâ€ can be analyzed with similar techniques. The basic question is to, given an instance Î¨Î¨\Psiroman_Î¨ of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ), efficiently find as small of an instance Î¨â€²superscriptÎ¨â€²\Psi^{\prime}roman_Î¨ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) as possible (not necessarily a subinstance) such that Î¨Î¨\Psiroman_Î¨ and Î¨â€²superscriptÎ¨â€²\Psi^{\prime}roman_Î¨ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT are either both satisfiable or both unsatisfiable. This particular question can be attributed to Dell and van Melkebeek [DvM14], who were particularly inspired Impagliazzo, Paturi, and Zaneâ€™s sparsification lemma [IPZ01] and Harnik and Naorâ€™s compression framework [HN10]. See the literature review in [DvM14] for further motivations. At first, the problem seems rather unrelated to CSP sparsification. For example, if CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) is polynomial-time tractable, then there trivially exists a kernel of size Oâ¢(1)ğ‘‚1O(1)italic_O ( 1 ). When CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) is NP-hard, however, the size of the smallest possible kernelization seems to much more closely track with the non-redundancy of Rğ‘…Ritalic_R. In particular, Dell and van Melkebeek [DvM14], proved that assuming ğ–¼ğ—ˆğ–­ğ–¯âŠˆğ–­ğ–¯/ğ—‰ğ—ˆğ—…ğ—’not-subset-of-nor-equalsğ–¼ğ—ˆğ–­ğ–¯ğ–­ğ–¯ğ—‰ğ—ˆğ—…ğ—’\mathsf{coNP}\nsubseteq\mathsf{NP/poly}sansserif_coNP âŠˆ sansserif_NP / sansserif_poly, the problem kğ‘˜kitalic_k-SAT cannot be kernelized below Î©â¢(nkâˆ’Îµ)Î©superscriptğ‘›ğ‘˜ğœ€\Omega(n^{k-\varepsilon})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_k - italic_Îµ end_POSTSUPERSCRIPT ) for any constant Îµ>0ğœ€0\varepsilon>0italic_Îµ > 0, which is close to kğ‘˜kitalic_k-SATâ€™s non-redundancy of Î˜â¢(nk)Î˜superscriptğ‘›ğ‘˜\Theta(n^{k})roman_Î˜ ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). Furthermore, most upper bounds on the kernelization of NP-hard predicates follow from upper bounds on non-redundancy (see [Car22]). For example the works of Chen, Jansen, and Pieterse [CJP20] as well as Lagerkvist and WahlstrÃ¶m [LW17, LW20] develop various kernelization methods that happen to just be â€œefficientâ€ non-redundancy upper bounds. For example, these works show that if the predicate Rğ‘…Ritalic_R can be expressed as the zero set of a polynomial of degree kğ‘˜kitalic_k, then there exist a kernel of size Oâ¢(nk)ğ‘‚superscriptğ‘›ğ‘˜O(n^{k})italic_O ( italic_n start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ). This kernel happens to preserve every solution to Rğ‘…Ritalic_R, so it is also a non-redundancy upper bound. Using techniques like these, they are able to prove a number of results similar to the state-of-the-art in CSP sparsification, such as a complete classification of ternary Boolean predicates and a Oâ¢(nrâˆ’1)ğ‘‚superscriptğ‘›ğ‘Ÿ1O(n^{r-1})italic_O ( italic_n start_POSTSUPERSCRIPT italic_r - 1 end_POSTSUPERSCRIPT ) vs Î©â¢(nrâˆ’Îµ)Î©superscriptğ‘›ğ‘Ÿğœ€\Omega(n^{r-\varepsilon})roman_Î© ( italic_n start_POSTSUPERSCRIPT italic_r - italic_Îµ end_POSTSUPERSCRIPT ) Boolean dichotomy [CJP20]. See [JP19, JW20, Jan20, Tak23, Beu21] and citations therein for related work. We seek to emphasize that any efficient CSP sparsification algorithm for CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) is by design a kernelization algorithm for CSPâ¡(RÂ¯)CSPÂ¯ğ‘…\operatorname{CSP}(\overline{R})roman_CSP ( overÂ¯ start_ARG italic_R end_ARG ) (since all codewords with weight 00 are preserved). As such, making Theorem 1.2 efficient would require explicitly proving that every CSP can be kernelized to (approximately) its non-redundancy, which is a significant open question in the CSP kernelization community (see [Car22]). See Section 1.7 and Section 9 for further discussion. The Union-closed Sets Conjecture. A family â„±â„±\mathcal{F}caligraphic_F of subsets of [n]delimited-[]ğ‘›[n][ italic_n ] is union-closed if A,Bâˆˆâ„±ğ´ğµâ„±A,B\in\mathcal{F}italic_A , italic_B âˆˆ caligraphic_F imply that AâˆªBâˆˆâ„±ğ´ğµâ„±A\cup B\in\mathcal{F}italic_A âˆª italic_B âˆˆ caligraphic_F. In 1979, Frankl [Fra95] conjectured that there always exists iâˆˆ[n]ğ‘–delimited-[]ğ‘›i\in[n]italic_i âˆˆ [ italic_n ] which appears in at least half of the sets of â„±â„±\mathcal{F}caligraphic_F. For decades, progress on the conjecture was minimal, with the best general result being that some iâˆˆ[n]ğ‘–delimited-[]ğ‘›i\in[n]italic_i âˆˆ [ italic_n ] appears in Î©â¢(1/log2â¡|â„±|)Î©1subscript2â„±\Omega(1/\log_{2}|\mathcal{F}|)roman_Î© ( 1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | caligraphic_F | ) of the sets [Kni94, WÃ³j99, Gil22]. However, in 2022, Gilmer [Gil22] shocked the combinatorics community by using an entropy-based approach to prove that some iâˆˆ[n]ğ‘–delimited-[]ğ‘›i\in[n]italic_i âˆˆ [ italic_n ] appears in 1/10011001/1001 / 100 of the sets. This immediately led to a large number of follow-up works refining Gilmerâ€™s entropy method [AHS22, CL22, Peb22, Saw23, Yu23, Cam22]. In particular, we can now replace â€˜1/10011001/1001 / 100â€™ with â€˜0.382â¢â€¦0.382â€¦0.382\ldots0.382 â€¦â€™, leaving Franklâ€™s conjecture (technically) still open. For our application to CSP sparsification, the entropy method used by Gilmer (and its subsequent refinements by many other reseachers) is the key idea needed to show that non-redundancy is essentially the optimal size for a CSP sparsifier. In particular, the improvement from 1/log2â¡|â„±|1subscript2â„±1/\log_{2}|\mathcal{F}|1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | caligraphic_F | to Î©â¢(1)Î©1\Omega(1)roman_Î© ( 1 ) is precisely the same â€œgainâ€ we utilize to go from a very simple O~Îµâ¢(NRDâ¡(C)â‹…log2â¡|C|)subscript~ğ‘‚ğœ€â‹…NRDğ¶subscript2ğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\cdot\log_{2}|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) â‹… roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C | ) sparsifier (see Section 3) to our O~Îµâ¢(NRDâ¡(C))subscript~ğ‘‚ğœ€NRDğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C))over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ) sparsifier. See the technical overview (Section 1.6) for more details. To the best of our knowledge, our work is the first application of Gilmerâ€™s entropy method to sparsification.888Gilmerâ€™s breakthough is cited in the literature review of [CDL+24], but the property-testing question they study on union-closed families has no technical connection to Gilmerâ€™s entropy method. See also [Wak24] for applications of the entropy method to learning theory and statistical physics. Matching Vector Families and Locally Decodable Codes. In coding theory, locally decodable codes (LDCs) are a class of codes which allow for jthe reliable recovery of any message symbol based on a small sample of codeword symbols, even in the presence of a constant fraction of errors. A particularly interesting familiy of constructions of LDCs has arisen out of a theory of matching vector codes [Yek08] and follow-ups [Rag07, Gop09, Efr09, DGY11]. See [DGY11] for a literature survey. Simply stated, a matching vector (MV) family over a (finite) ring â„›â„›\mathcal{R}caligraphic_R is a pair of lists of vectors u1,â€¦,uk,v1,â€¦,vkâˆˆâ„›dsubscriptğ‘¢1â€¦subscriptğ‘¢ğ‘˜subscriptğ‘£1â€¦subscriptğ‘£ğ‘˜superscriptâ„›ğ‘‘u_{1},\ldots,u_{k},v_{1},\ldots,v_{k}\in\mathcal{R}^{d}italic_u start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_u start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_v start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT âˆˆ caligraphic_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT such that the inner products âŸ¨ui,vjâŸ©subscriptğ‘¢ğ‘–subscriptğ‘£ğ‘—\langle u_{i},v_{j}\rangleâŸ¨ italic_u start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT âŸ© are nonzero999Or, more generally the inner products lie in some restricted subset of â„›â„›\mathcal{R}caligraphic_R. if and only iâ‰ jğ‘–ğ‘—i\neq jitalic_i â‰  italic_j. Informally, the uisubscriptğ‘¢ğ‘–u_{i}italic_u start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPTâ€™s play a role in the encoding of the iğ‘–iitalic_iâ€™th message symbol, with the matching vector visubscriptğ‘£ğ‘–v_{i}italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT helping with its local decoding. Given a choice of â„›â„›\mathcal{R}caligraphic_R and dğ‘‘ditalic_d, the primary question of interest is to find the maximal possible value of kğ‘˜kitalic_k. This â€œspin offâ€ question about LDCs has become a topic of interest in its own right [DGY11, Yek12, GHSY12, BDL13]. In this work, we demonstrate a novel application of matching vector families to the study of non-redundancy and thus (by Theorem 1.2) sparsification. In particular, we construct an explicit family of predicates such that their non-redundant instances can be viewed as a generalized MV family. We then use techniques developed for MV families to given nontrivial bounds on the non-redundancy of the predicates. See Section 6 and the technical overview (Section 1.6) for more details. Extremal Combinatorics. Computing the non-redundancy of a predicate can be viewed as a problem in extremal combinatorics known as a hypergraph TurÃ¡n problem. In particular, for an instance of a CSP to be non-redundant, every instance induced by a subset of the variables must also be non-redundant. In particular, if â„±â„±\mathcal{F}caligraphic_F is a family of hypergraphs which can never appear in non-redundant instances of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ), then NRDâ¡(R,n)â‰¤exrâ¡(n,â„±)NRDğ‘…ğ‘›subscriptexğ‘Ÿğ‘›â„±\operatorname{NRD}(R,n)\leq\operatorname{ex}_{r}(n,\mathcal{F})roman_NRD ( italic_R , italic_n ) â‰¤ roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ), where the hypergraph TurÃ¡n number exrâ¡(n,â„±)subscriptexğ‘Ÿğ‘›â„±\operatorname{ex}_{r}(n,\mathcal{F})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) is the size of the largest rğ‘Ÿritalic_r-uniform hypergraph on nğ‘›nitalic_n vertices without any Fâˆˆâ„±ğ¹â„±F\in\mathcal{F}italic_F âˆˆ caligraphic_F as a subgraph. This observation was first made explicit by Carbonnel [Car22] although the technique was also used in earlier work [BCK20]. As far as we are aware, ours is the first work to observe that these insights can also benefit the study of CSP sparsification. The literature on hypergraph TurÃ¡n numbers is quite rich. For instance, Keevash [Kee11] surveys the vast body of work on the â€œnon-degenerateâ€ case in which exrâ¡(n,â„±)=Î©râ¢(nr)subscriptexğ‘Ÿğ‘›â„±subscriptÎ©ğ‘Ÿsuperscriptğ‘›ğ‘Ÿ\operatorname{ex}_{r}(n,\mathcal{F})=\Omega_{r}(n^{r})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) = roman_Î© start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ). However, for our applications, we are mostly interested in the â€œdenegerateâ€ case in which exrâ¡(n,â„±)=Oâ¢(nc)subscriptexğ‘Ÿğ‘›â„±ğ‘‚superscriptğ‘›ğ‘\operatorname{ex}_{r}(n,\mathcal{F})=O(n^{c})roman_ex start_POSTSUBSCRIPT italic_r end_POSTSUBSCRIPT ( italic_n , caligraphic_F ) = italic_O ( italic_n start_POSTSUPERSCRIPT italic_c end_POSTSUPERSCRIPT ) for some câˆˆ[1,r)ğ‘1ğ‘Ÿc\in[1,r)italic_c âˆˆ [ 1 , italic_r ). The works [BCK20, Car22] apply some of the most well-known works in this setting [Erd64, SEB73, RS78] to get some nontrivial results such as classifying precisely which predicates Rğ‘…Ritalic_R have NRDâ¡(R,n)=Î˜â¢(nr)NRDğ‘…ğ‘›Î˜superscriptğ‘›ğ‘Ÿ\operatorname{NRD}(R,n)=\Theta(n^{r})roman_NRD ( italic_R , italic_n ) = roman_Î˜ ( italic_n start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT ), extending Chen, Jansen, and Pieterseâ€™s result for the Boolean case [CJP20]. See Sections 5.2, 7.1, and 8.4.2 for more details on specific applications. Query Complexity and Learning Theory. Rather surprisingly, the definition of non-redundancy appears to have come out of the artificial intelligence community [BCK20]. In particular, a rather broad and well-studied question (e.g., [FW02, PBS08, LLMV10, BK12, BCH+13, BCK20]) is that of constraint acquisition: how can an agent learn the constraints defining an instance of a constraint satisfaction problem? A model specifically relevant to our work is the partial membership queries model studied by Bessiere, Carbonnel, and Katsirelos [BCK20]. In this model, the domain Dğ·Ditalic_D, the constraint type Rğ‘…Ritalic_R (or types), and the set of variables Xğ‘‹Xitalic_X are known but the constraints are hidden. For each query, the agent picks some subset of variables Xâ€²âŠ†Xsuperscriptğ‘‹â€²ğ‘‹X^{\prime}\subseteq Xitalic_X start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT âŠ† italic_X as well as a partial assignment Ïƒ:Xâ€²â†’D:ğœâ†’superscriptğ‘‹â€²ğ·\sigma:X^{\prime}\to Ditalic_Ïƒ : italic_X start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT â†’ italic_D. The response to the query is â€˜YESâ€™ if Ïƒğœ\sigmaitalic_Ïƒ satisfies every constraint induced by Xâ€²superscriptğ‘‹â€²X^{\prime}italic_X start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT, and â€˜NOâ€™ otherwise. The goal is to construct an instance of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) with the same solution set as the hidden CSP. For every CSP predicate Rğ‘…Ritalic_R, they prove that the query complexity of an instance of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) on nğ‘›nitalic_n variables is bounded between Î©â¢(NRDâ¡(R,n))Î©NRDğ‘…ğ‘›\Omega(\operatorname{NRD}(R,n))roman_Î© ( roman_NRD ( italic_R , italic_n ) ) and Oâ¢(CLâ¡(R,n)â‹…logâ¡n)ğ‘‚â‹…CLğ‘…ğ‘›ğ‘›O(\operatorname{CL}(R,n)\cdot\log n)italic_O ( roman_CL ( italic_R , italic_n ) â‹… roman_log italic_n ). Notably, the lower bound is proved by showing that the VC dimension of the query complexity problem equals NRDâ¡(R,n)NRDğ‘…ğ‘›\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ).101010This observation is directly used in proving our main result, see Section 4.1. 1.6 Technical Overview We next describe the primary techniques we use to prove Theorem 1.1 and Theorem 1.3. A Simple Sparsifier. To begin, we discuss a warm-up version of Theorem 1.1 which proves a weaker upper bound of SPRâ¡(C,Îµ)â‰¤O~Îµâ¢(NRDâ¡(C)â‹…logâ¡|C|)SPRğ¶ğœ€subscript~ğ‘‚ğœ€â‹…NRDğ¶ğ¶\operatorname{SPR}(C,\varepsilon)\leq\widetilde{O}_{\varepsilon}(\operatorname% {NRD}(C)\cdot\log|C|)roman_SPR ( italic_C , italic_Îµ ) â‰¤ over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) â‹… roman_log | italic_C | ) (see Theorem 3.1), which for CSPs corresponds to an extra factor of the number of variables nğ‘›nitalic_n. The key technical insight (Lemma 3.3) is that for all dâˆˆ[m]ğ‘‘delimited-[]ğ‘šd\in[m]italic_d âˆˆ [ italic_m ], the set of codewords of Cğ¶Citalic_C with Hamming weight at most dğ‘‘ditalic_d (denoted by Câ‰¤dsubscriptğ¶absentğ‘‘C_{\leq d}italic_C start_POSTSUBSCRIPT â‰¤ italic_d end_POSTSUBSCRIPT) has total support size at most dâ‹…NRDâ¡(C)â‹…ğ‘‘NRDğ¶d\cdot\operatorname{NRD}(C)italic_d â‹… roman_NRD ( italic_C ). This can proved inductively by noticing that dropping a suitable non-redundant set of coordinates decreases the Hamming weight of every codeword of Cğ¶Citalic_C by at least one. With this lemma, we can recursively construct a sparsifier as follows, similar to the divide-and-conquer framework in [KPS24a, KPS24b] for linear codes. Pick dâ‰ˆÎ˜~Îµâ¢(logâ¡|C|)ğ‘‘subscript~Î˜ğœ€ğ¶d\approx\widetilde{\Theta}_{\varepsilon}(\log|C|)italic_d â‰ˆ over~ start_ARG roman_Î˜ end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_log | italic_C | ) and let IâŠ†[m]ğ¼delimited-[]ğ‘šI\subseteq[m]italic_I âŠ† [ italic_m ] be the support of Câ‰¤dsubscriptğ¶absentğ‘‘C_{\leq d}italic_C start_POSTSUBSCRIPT â‰¤ italic_d end_POSTSUBSCRIPT. Every iâˆˆIğ‘–ğ¼i\in Iitalic_i âˆˆ italic_I is given weight 1111 in our sparsifier. For the rest of [m]delimited-[]ğ‘š[m][ italic_m ], let JâŠ†[m]âˆ–Iğ½delimited-[]ğ‘šğ¼J\subseteq[m]\setminus Iitalic_J âŠ† [ italic_m ] âˆ– italic_I be a subsample where each iâˆˆ[m]âˆ–Iğ‘–delimited-[]ğ‘šğ¼i\in[m]\setminus Iitalic_i âˆˆ [ italic_m ] âˆ– italic_I is kept independently with probability 1/3131/31 / 3. Using a standard Chernoff bound, we can show that with positive111111We only need positive probability since we are focused on existence. This can easily be amplified to 1âˆ’1/mÎ©â¢(1)11superscriptğ‘šÎ©11-1/m^{\Omega(1)}1 - 1 / italic_m start_POSTSUPERSCRIPT roman_Î© ( 1 ) end_POSTSUPERSCRIPT probability by making dğ‘‘ditalic_d a factor of logâ¡mğ‘š\log mroman_log italic_m bigger. In applications to CSPs, the main algorithmic bottleneck is (approximately) finding Iğ¼Iitalic_I, which appears to be similar in difficulty to an open problem in CSP kernelization (see Section 1.7). probability the following holds for all câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C: 3â¢Hamâ¡(c|J)+Hamâ¡(c|I)âˆˆ[1âˆ’Îµ2â¢log2â¡m,1+Îµ2â¢log2â¡m]â‹…Hamâ¡(c).3Hamevaluated-atğ‘ğ½Hamevaluated-atğ‘ğ¼â‹…1ğœ€2subscript2ğ‘š1ğœ€2subscript2ğ‘šHamğ‘3\operatorname{Ham}(c|_{J})+\operatorname{Ham}(c|_{I})\in\left[1-\frac{% \varepsilon}{2\log_{2}m},1+\frac{\varepsilon}{2\log_{2}m}\right]\cdot% \operatorname{Ham}(c).3 roman_Ham ( italic_c | start_POSTSUBSCRIPT italic_J end_POSTSUBSCRIPT ) + roman_Ham ( italic_c | start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT ) âˆˆ [ 1 - divide start_ARG italic_Îµ end_ARG start_ARG 2 roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m end_ARG , 1 + divide start_ARG italic_Îµ end_ARG start_ARG 2 roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m end_ARG ] â‹… roman_Ham ( italic_c ) . By induction, we can find a O~Îµâ€²â¢(NRDâ¡(Câ€²)â‹…logâ¡|Câ€²|)subscript~ğ‘‚superscriptğœ€â€²â‹…NRDsuperscriptğ¶â€²superscriptğ¶â€²\widetilde{O}_{\varepsilon^{\prime}}(\operatorname{NRD}(C^{\prime})\cdot\log|C% ^{\prime}|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT end_POSTSUBSCRIPT ( roman_NRD ( italic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT ) â‹… roman_log | italic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT | ) Îµâ€²superscriptğœ€â€²\varepsilon^{\prime}italic_Îµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT-sparsifier for Câ€²:=C|Jassignsuperscriptğ¶â€²evaluated-atğ¶ğ½C^{\prime}:=C|_{J}italic_C start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT := italic_C | start_POSTSUBSCRIPT italic_J end_POSTSUBSCRIPT with Îµâ€²:=(1âˆ’1/log2â¡m)â¢Îµassignsuperscriptğœ€â€²11subscript2ğ‘šğœ€\varepsilon^{\prime}:=(1-1/\log_{2}m)\varepsilonitalic_Îµ start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT := ( 1 - 1 / roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_m ) italic_Îµ. Scaling this sparsifier by 3333 and adding weights for Iğ¼Iitalic_I gives us an Îµğœ€\varepsilonitalic_Îµ-sparsifier of Cğ¶Citalic_C. Entropy-based Sparsification. The key inefficiency of the O~Îµâ¢(NRDâ¡(C)â‹…logâ¡|C|)subscript~ğ‘‚ğœ€â‹…NRDğ¶ğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C)\cdot\log|C|)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) â‹… roman_log | italic_C | ) bound is that the use of Lemma 3.3 is too conservative. For the purposes of this overview, assume that all codewords of Cğ¶Citalic_C have the same Hamming weight dâ‰ˆNRDâ¡(C)ğ‘‘NRDğ¶d\approx\operatorname{NRD}(C)italic_d â‰ˆ roman_NRD ( italic_C ) as that is is the most representative case. Naively, Lemma 3.3 says we should set aside d2superscriptğ‘‘2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT coordinates of [m]delimited-[]ğ‘š[m][ italic_m ] to â€œsparsifyâ€ all codewords of weight dğ‘‘ditalic_d. However, we can give a heuristic argument that far fewer than d2superscriptğ‘‘2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT of these potential coordinates contain useful information for our sparsifier. Assume without loss of generality that the support of Cğ¶Citalic_C lies in [d2]delimited-[]superscriptğ‘‘2[d^{2}][ italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ]. For each iâˆˆ[d2]ğ‘–delimited-[]superscriptğ‘‘2i\in[d^{2}]italic_i âˆˆ [ italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ], let pisubscriptğ‘ğ‘–p_{i}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT be the probability that a codeword câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C selected uniformly at random has ci=1subscriptğ‘ğ‘–1c_{i}=1italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = 1. Since each codeword of Cğ¶Citalic_C has Hamming weight dğ‘‘ditalic_d, we have that p1+â‹¯+pd2=dsubscriptğ‘1â‹¯subscriptğ‘superscriptğ‘‘2ğ‘‘p_{1}+\cdots+p_{d^{2}}=ditalic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + â‹¯ + italic_p start_POSTSUBSCRIPT italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUBSCRIPT = italic_d. Thus, the average value of pisubscriptğ‘ğ‘–p_{i}italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT is 1/d1ğ‘‘1/d1 / italic_d. Consider the case in which each pi=Oâ¢(1/d)subscriptğ‘ğ‘–ğ‘‚1ğ‘‘p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ). In particular, no coordinate is distinguishing itself as a â€œmustâ€ to add to the sparsifier. A priori, the size of Cğ¶Citalic_C may be expâ¡(Î©~â¢(d))~Î©ğ‘‘\exp(\widetilde{\Omega}(d))roman_exp ( over~ start_ARG roman_Î© end_ARG ( italic_d ) ), so we cannot immediately use Chernoff bounds to analyze a random subsampling of the coordinates. To get around this issue, we need to prove a much stronger upper bound on the size of Cğ¶Citalic_C, similar to BenczÃºr and Kargerâ€™s cut-counting bound [BK96] and its adaptation to linear codes [KPS24a, KPS24b]. However, we use an entirely new method for proving such bounds based on the entropy method Gilmer [Gil22] developed to prove the union-closed sets conjecture up to a constant factor. In our context, pick t=Î˜~â¢(d)ğ‘¡~Î˜ğ‘‘t=\widetilde{\Theta}(d)italic_t = over~ start_ARG roman_Î˜ end_ARG ( italic_d ) and sample uniformly and independently tğ‘¡titalic_t codewords c1,â€¦,ctâˆˆCsubscriptğ‘1â€¦subscriptğ‘ğ‘¡ğ¶c_{1},\ldots,c_{t}\in Citalic_c start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_c start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT âˆˆ italic_C. Let cğ‘citalic_c be the bitwise OR of these tğ‘¡titalic_t codewords, and let ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D be the distribution of cğ‘citalic_c over {0,1}d2superscript01superscriptğ‘‘2\{0,1\}^{d^{2}}{ 0 , 1 } start_POSTSUPERSCRIPT italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT end_POSTSUPERSCRIPT (recall that the weight dğ‘‘ditalic_d codewords are supported on d2superscriptğ‘‘2d^{2}italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT coordinates). Since each pi=Oâ¢(1/d)subscriptğ‘ğ‘–ğ‘‚1ğ‘‘p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ), by adapting Gilmerâ€™s method (or more precisely, a refinement due to Sawin [Saw23]), we can show the entropy of ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is at least Î˜~â¢(t)=Î˜~â¢(d)~Î˜ğ‘¡~Î˜ğ‘‘\widetilde{\Theta}(t)=\widetilde{\Theta}(d)over~ start_ARG roman_Î˜ end_ARG ( italic_t ) = over~ start_ARG roman_Î˜ end_ARG ( italic_d ) times the entropy of the uniform distribution over Cğ¶Citalic_C (i.e., log2â¡|C|subscript2ğ¶\log_{2}|C|roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C |)â€“a similar inequality appears in [Wak24]. To apply this fact, observe that each sample of ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D lies in the â€œOROR\operatorname{OR}roman_OR-closureâ€ of Cğ¶Citalic_C (denoted by spanORâ¡(C)subscriptspanORğ¶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C )). As such, the entropy of ğ’Ÿğ’Ÿ\mathcal{D}caligraphic_D is at most logâ¡|spanORâ¡(C)|subscriptspanORğ¶\log\lvert\operatorname{span}_{\operatorname{OR}}(C)\rvertroman_log | roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ) |, which by the Sauer-Shelah-Peres lemma is at most (up to log factors) the VC dimension of spanORâ¡(C)subscriptspanORğ¶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ). It is easily seen that the VC dimension of spanORâ¡(C)subscriptspanORğ¶\operatorname{span}_{\operatorname{OR}}(C)roman_span start_POSTSUBSCRIPT roman_OR end_POSTSUBSCRIPT ( italic_C ) equals the non-redundancy of Cğ¶Citalic_C [BCK20]. Therefore, we have proved that Î˜~â¢(t)â‹…log2â¡(C)â‰¤O~â¢(NRDâ¡(C))â‹…~Î˜ğ‘¡subscript2ğ¶~ğ‘‚NRDğ¶\widetilde{\Theta}(t)\cdot\log_{2}(C)\leq\widetilde{O}(\operatorname{NRD}(C))over~ start_ARG roman_Î˜ end_ARG ( italic_t ) â‹… roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ( italic_C ) â‰¤ over~ start_ARG italic_O end_ARG ( roman_NRD ( italic_C ) ). Since tâ‰ˆdâ‰ˆNRDâ¡(C)ğ‘¡ğ‘‘NRDğ¶t\approx d\approx\operatorname{NRD}(C)italic_t â‰ˆ italic_d â‰ˆ roman_NRD ( italic_C ), Cğ¶Citalic_C is actually at most quasipolynomial in size! Thus we can now use a Chernoff bound to prove that Cğ¶Citalic_C can be subsampled to O~Îµâ¢(d)subscript~ğ‘‚ğœ€ğ‘‘\widetilde{O}_{\varepsilon}(d)over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( italic_d ) coordinates while approximately preserving all Hamming weights. Recall this discussion was purely about the â€œuniformâ€ case pi=Oâ¢(1/d)subscriptğ‘ğ‘–ğ‘‚1ğ‘‘p_{i}=O(1/d)italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT = italic_O ( 1 / italic_d ). In general, we apply minimax theorem to prove the following â€œskewedâ€ versus â€œsparseâ€ dichotomy (see Proposition 4.14): for every code Cğ¶Citalic_C and parameter choice Î¸â‰¥1ğœƒ1\theta\geq 1italic_Î¸ â‰¥ 1 there is either a probability distribution ğ’«ğ’«\mathcal{P}caligraphic_P over Cğ¶Citalic_C for which each coordinate equals 1111 with probability at most 1/Î¸1ğœƒ1/\theta1 / italic_Î¸ (i.e., ğ’«ğ’«\mathcal{P}caligraphic_P is â€œÎ¸ğœƒ\thetaitalic_Î¸-sparseâ€); or, there is a probability distribution ğ’¬ğ’¬\mathcal{Q}caligraphic_Q over the coordinates of Cğ¶Citalic_C such that for every (nonzero) câˆˆCğ‘ğ¶c\in Citalic_c âˆˆ italic_C, we have that ğ’¬ğ’¬\mathcal{Q}caligraphic_Qâ€™s measure of suppâ¡(c)suppğ‘\operatorname{supp}(c)roman_supp ( italic_c ) is at least 1/Î¸1ğœƒ1/\theta1 / italic_Î¸ (i.e., ğ’¬ğ’¬\mathcal{Q}caligraphic_Q is a â€œÎ¸ğœƒ\thetaitalic_Î¸-cover.â€) For a suitable choice of Î¸ğœƒ\thetaitalic_Î¸, we repeatedly apply Proposition 4.14 to recursively build the sparsifier: in the Î¸ğœƒ\thetaitalic_Î¸-sparse case, we use the entropy method to prove that a â€œsmallâ€ number of codewords of Cğ¶Citalic_C can be removed to put us in the Î¸ğœƒ\thetaitalic_Î¸-cover case (see Lemma 4.15); and in the Î¸ğœƒ\thetaitalic_Î¸-cover case, we sample from the Î¸ğœƒ\thetaitalic_Î¸-cover to get a coordinate to add to our sparsifier. This procedure culminates in showing that we can set aside O~Îµâ¢(NRDâ¡(C))subscript~ğ‘‚ğœ€NRDğ¶\widetilde{O}_{\varepsilon}(\operatorname{NRD}(C))over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) ) coordinates to have weight 1111 in our sparsifier with the remainder of the code being sufficiently sparse that subsampling can be used (Theorem 4.16). Note that the statement of Theorem 4.16 resembles the analogous decompositions for linear codes [KPS24a, KPS24b]. However, their method found all the coordinates to set aside in â€œone pass,â€ whereas we iteratively understand the dense and sparse structure of our non-linear code. With Theorem 4.16 in hand, we construct the sparsifier with a recursive argument similar to that of Theorem 3.1. As mentioned earlier, extended these ideas to weighted sparsification (Theorem 1.4) is relatively straightforward. We adapt a weight-binning argument of [KPS24b] by essentially computing an (unweighted) sparsifier for each group of coordinates that is similar in weight (within polyâ¡(m)polyğ‘š\operatorname{poly}(m)roman_poly ( italic_m )). We then analyze the aggregated size of these sparsifiers by comparing the sum of the non-redundancies of the groups of coordinates to the chain length of the code. Connections to Matching Vector Families. We now switch gears to briefly discussing the key ideas behind Theorem 1.3. Let G:=â„¤/3â¢â„¤assignğºâ„¤3â„¤G:=\mathbb{Z}/3\mathbb{Z}italic_G := blackboard_Z / 3 blackboard_Z and recall that 3â¢Lâ¢Iâ¢NG={(x,y,z)âˆ£x+y+z=0}subscript3LINğºconditional-setğ‘¥ğ‘¦ğ‘§ğ‘¥ğ‘¦ğ‘§0\operatorname{3LIN}_{G}=\{(x,y,z)\mid x+y+z=0\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = { ( italic_x , italic_y , italic_z ) âˆ£ italic_x + italic_y + italic_z = 0 } and 3â¢Lâ¢Iâ¢NGâˆ—=3â¢Lâ¢Iâ¢NGâˆ–{(0,0,0)}subscriptsuperscript3LINğºsubscript3LINğº000\operatorname{3LIN}^{*}_{G}=\operatorname{3LIN}_{G}\setminus\{(0,0,0)\}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT = start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT âˆ– { ( 0 , 0 , 0 ) }. It is well-known that since 3â¢Lâ¢Iâ¢NGsubscript3LINğº\operatorname{3LIN}_{G}start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT is an affine predicate, we have that NRDâ¡(3â¢Lâ¢Iâ¢NG,n)=Î˜â¢(n)NRDsubscript3LINğºğ‘›Î˜ğ‘›\operatorname{NRD}(\operatorname{3LIN}_{G},n)=\Theta(n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) = roman_Î˜ ( italic_n ), which is much smaller than our bound on NRDâ¡(3â¢Lâ¢Iâ¢NGâˆ—,n)NRDsubscriptsuperscript3LINğºğ‘›\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ). As such, we prove that to understand the asymptotics of NRDâ¡(3â¢Lâ¢Iâ¢NGâˆ—,n)NRDsubscriptsuperscript3LINğºğ‘›\operatorname{NRD}(\operatorname{3LIN}^{*}_{G},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT , italic_n ) it suffices to look at specially-structured non-redundant instances. Recall that an instance Î¨:=(X,Y)assignÎ¨ğ‘‹ğ‘Œ\Psi:=(X,Y)roman_Î¨ := ( italic_X , italic_Y ) of CSPâ¡(3â¢Lâ¢Iâ¢NGâˆ—)CSPsubscriptsuperscript3LINğº\operatorname{CSP}(\operatorname{3LIN}^{*}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) is non redundant if for every clause yâˆˆYğ‘¦ğ‘Œy\in Yitalic_y âˆˆ italic_Y there is an assignment Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT which satisfies every clause of Î¨Î¨\Psiroman_Î¨ except yğ‘¦yitalic_y. We show that with at most an additive Î˜â¢(n)Î˜ğ‘›\Theta(n)roman_Î˜ ( italic_n ) change in size, we can assume that Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT maps yğ‘¦yitalic_y to (0,0,0)000(0,0,0)( 0 , 0 , 0 ). In other words, each Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT is a satisfying assignment to Î¨Î¨\Psiroman_Î¨ when viewed as an instance of CSPâ¡(3â¢Lâ¢Iâ¢NG)CSPsubscript3LINğº\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) (see Proposition 6.3). This idea of â€œconditionalâ€ non-redundancy abstracts and generalizes an approach from [BCK20]. Since the set of solutions to an instance of CSPâ¡(3â¢Lâ¢Iâ¢NG)CSPsubscript3LINğº\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ) form a vector space (of some dimension, say dğ‘‘ditalic_d) over ğ”½3subscriptğ”½3\mathbb{F}_{3}blackboard_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT, we can think of each variable xâˆˆXğ‘¥ğ‘‹x\in Xitalic_x âˆˆ italic_X of Î¨Î¨\Psiroman_Î¨ as a vector vxâˆˆğ”½3dsubscriptğ‘£ğ‘¥superscriptsubscriptğ”½3ğ‘‘v_{x}\in\mathbb{F}_{3}^{d}italic_v start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT âˆˆ blackboard_F start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT and the assignments as linear maps on the vectors. Because we are studying satisfying assignment to CSPâ¡(3â¢Lâ¢Iâ¢NG)CSPsubscript3LINğº\operatorname{CSP}(\operatorname{3LIN}_{G})roman_CSP ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT ), these vectors are highly structured: for each y:=(x1,x2,x3)âˆˆYassignğ‘¦subscriptğ‘¥1subscriptğ‘¥2subscriptğ‘¥3ğ‘Œy:=(x_{1},x_{2},x_{3})\in Yitalic_y := ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT ) âˆˆ italic_Y, we have that vx1+vx2+vx3=0subscriptğ‘£subscriptğ‘¥1subscriptğ‘£subscriptğ‘¥2subscriptğ‘£subscriptğ‘¥30v_{x_{1}}+v_{x_{2}}+v_{x_{3}}=0italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT + italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT + italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_POSTSUBSCRIPT = 0. Further, Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT can be viewed as a linear map taking each of vx1,vx2,vx3subscriptğ‘£subscriptğ‘¥1subscriptğ‘£subscriptğ‘¥2subscriptğ‘£subscriptğ‘¥3v_{x_{1}},v_{x_{2}},v_{x_{3}}italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT , italic_v start_POSTSUBSCRIPT italic_x start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_POSTSUBSCRIPT to 00, while mapping at least one vector in every other triple in Yğ‘ŒYitalic_Y to a nonzero value. We call this family of vectors together with these assignments a GğºGitalic_G-ensemble (Definition 6.5), and note that it bears a strong resemblance to matching vector families. In particular, we adapt techniques used by Dvir, Gopalan, and Yekhanin [DGY11] for constraining the size of matching vector families to give nontrivial upper and lower bounds on the size of GğºGitalic_G-ensembles. For the lower bound (Theorem 6.8), we directly construct a non-redundant instance with Î©â¢(n1.5)Î©superscriptğ‘›1.5\Omega(n^{1.5})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) clauses. The proof is self-contained and elementary. The upper bound (Theorem 6.13) is slightly more technical. We break the proof into cases based on whether the embedding dimension dğ‘‘ditalic_d of the vectors is small (d=O~â¢(n0.4)ğ‘‘~ğ‘‚superscriptğ‘›0.4d=\widetilde{O}(n^{0.4})italic_d = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 0.4 end_POSTSUPERSCRIPT )) or large (d=Î©~â¢(n0.4)ğ‘‘~Î©superscriptğ‘›0.4d=\widetilde{\Omega}(n^{0.4})italic_d = over~ start_ARG roman_Î© end_ARG ( italic_n start_POSTSUPERSCRIPT 0.4 end_POSTSUPERSCRIPT )). For small dğ‘‘ditalic_d, we adapt the polynomial method used in [DGY11] to prove there can be at most Oâ¢(d4)=O~â¢(n1.6)ğ‘‚superscriptğ‘‘4~ğ‘‚superscriptğ‘›1.6O(d^{4})=\widetilde{O}(n^{1.6})italic_O ( italic_d start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ) = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) non-redundant clauses. On the other hand, when dğ‘‘ditalic_d is large, we ignore the assignments Ïƒysubscriptğœğ‘¦\sigma_{y}italic_Ïƒ start_POSTSUBSCRIPT italic_y end_POSTSUBSCRIPT and use a careful induction (Lemma 6.11) to show that the geometry of the vectors imply that some xâˆˆXğ‘¥ğ‘‹x\in Xitalic_x âˆˆ italic_X is a member of at most O~â¢(n/d)=O~â¢(n0.6)~ğ‘‚ğ‘›ğ‘‘~ğ‘‚superscriptğ‘›0.6\widetilde{O}(n/d)=\widetilde{O}(n^{0.6})over~ start_ARG italic_O end_ARG ( italic_n / italic_d ) = over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 0.6 end_POSTSUPERSCRIPT ) clauses, thereby leading to a bound of at most O~â¢(n1.6)~ğ‘‚superscriptğ‘›1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) clauses total. Closing the gap between Î©â¢(n1.5)Î©superscriptğ‘›1.5\Omega(n^{1.5})roman_Î© ( italic_n start_POSTSUPERSCRIPT 1.5 end_POSTSUPERSCRIPT ) and O~â¢(n1.6)~ğ‘‚superscriptğ‘›1.6\widetilde{O}(n^{1.6})over~ start_ARG italic_O end_ARG ( italic_n start_POSTSUPERSCRIPT 1.6 end_POSTSUPERSCRIPT ) for NRDâ¡(3â¢Lâ¢Iâ¢Nâ„¤/3â¢â„¤âˆ—,n)NRDsuperscriptsubscript3LINâ„¤3â„¤ğ‘›\operatorname{NRD}(\operatorname{3LIN}_{\mathbb{Z}/3\mathbb{Z}}^{*},n)roman_NRD ( start_OPFUNCTION 3 roman_L roman_I roman_N end_OPFUNCTION start_POSTSUBSCRIPT blackboard_Z / 3 blackboard_Z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT , italic_n ) is a tantalizing open question. 1.7 Open Questions We conclude the introduction with a few directions of further study. See Section 7 and Section 9 for a more thorough discussion of directions for future exploration. â€¢ Making Theorem 1.2 efficient. Note that the underlying construction for Theorem 1.1, if made algorithmic, runs in polynomial time with respect to the size of the code, yielding an expâ¡(Oâ¢(n))ğ‘‚ğ‘›\exp(O(n))roman_exp ( italic_O ( italic_n ) )-time algorithm121212This is already nontrivial, as a naive guess-and-check algorithm would require expâ¡(O~â¢(NRDâ¡(RÂ¯,n)))~ğ‘‚NRDÂ¯ğ‘…ğ‘›\exp(\widetilde{O}(\operatorname{NRD}(\overline{R},n)))roman_exp ( over~ start_ARG italic_O end_ARG ( roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ) ) ) time. for Theorem 1.2. The primary barrier in constructing our sparsifier in polyâ¡(n)polyğ‘›\operatorname{poly}(n)roman_poly ( italic_n ) time is the fact that an efficient sparsifier is also a kernelization algorithm, but kernelizing every CSP instance to its non-redundancy is a significant open question in the kernelization community [Car22]. â€¢ Computing NRDâ¡(R,n)NRDğ‘…ğ‘›\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ). For a general predicate RâŠ†Drğ‘…superscriptğ·ğ‘ŸR\subseteq D^{r}italic_R âŠ† italic_D start_POSTSUPERSCRIPT italic_r end_POSTSUPERSCRIPT, there is no simple (even conjectured) expression for NRDâ¡(R,n)NRDğ‘…ğ‘›\operatorname{NRD}(R,n)roman_NRD ( italic_R , italic_n ). In fact, even determining when NRDâ¡(R,n)=Î˜â¢(n)NRDğ‘…ğ‘›Î˜ğ‘›\operatorname{NRD}(R,n)=\Theta(n)roman_NRD ( italic_R , italic_n ) = roman_Î˜ ( italic_n ) is an open question (e.g., [BCK20, Car22]). In Section 7, we explore a number of predicates from the various parts of the literature whose status is unresolved, including a predicate we categorize as the â€œsimplest unresolved predicate.â€ â€¢ Non-redundancy versus Chain Length. Recall we show that unweighted sparsification is closely tied to non-redundancy while weighted sparsification is closely tied to chain length. For non-linear codes, NRDNRD\operatorname{NRD}roman_NRD and CLCL\operatorname{CL}roman_CL can be very different (e.g., Example 8.8), but the relationship for CSPs is unknown [BCK20, Car22]. In particular, it seems quite possible that there exists a CSP predicate Rğ‘…Ritalic_R for which wSPRâ¡(R,n,Îµ)/SPRâ¡(R,n,Îµ)=nÎ©â¢(1).wSPRğ‘…ğ‘›ğœ€SPRğ‘…ğ‘›ğœ€superscriptğ‘›Î©1\operatorname{wSPR}(R,n,\varepsilon)/\operatorname{SPR}(R,n,\varepsilon)=n^{% \Omega(1)}.roman_wSPR ( italic_R , italic_n , italic_Îµ ) / roman_SPR ( italic_R , italic_n , italic_Îµ ) = italic_n start_POSTSUPERSCRIPT roman_Î© ( 1 ) end_POSTSUPERSCRIPT . â€¢ Average-case behavior. From Theorem 1.2, we know that every instance CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) has a sparsifier of size approximately its own non-redundancy, even if that value is much smaller than NRDâ¡(RÂ¯,n)NRDÂ¯ğ‘…ğ‘›\operatorname{NRD}(\overline{R},n)roman_NRD ( overÂ¯ start_ARG italic_R end_ARG , italic_n ). As such, it may be possible that â€˜averageâ€™ instances of CSPâ¡(R)CSPğ‘…\operatorname{CSP}(R)roman_CSP ( italic_R ) admit sparsifiers much smaller than the worst case. 1.8 Organization In Section 2, we prove some basic facts about non-redundancy, sparsification and their relationship. In Section 3, we give a straightforward proof that SPRâ¡(C,Îµ)=O~Îµâ¢(NRDâ¡(C)â¢log2â¡|C|)SPRğ¶ğœ€subscript~ğ‘‚ğœ€NRDğ¶subscript2ğ¶\operatorname{SPR}(C,\varepsilon)=\widetilde{O}_{\varepsilon}(\operatorname{% NRD}(C)\log_{2}|C|)roman_SPR ( italic_C , italic_Îµ ) = over~ start_ARG italic_O end_ARG start_POSTSUBSCRIPT italic_Îµ end_POSTSUBSCRIPT ( roman_NRD ( italic_C ) roman_log start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | italic_C | ). In Section 4, we prove Theorem 1.2 by connecting CSP sparsification to non-redundancy via Gilmerâ€™s entropy method. In Section 5, we discuss the immediate applications of Theorem 1.2 based on what is known about non-redundancy in the literature. In Section 6, we bound the non-redundancy of a family of predicates via methods related to matching vector families. In Section 7, we give examples of CSP predicates in the literature whose non-redundancy is unresolved. In Section 8, we extend Theorem 1.2 to weighted instances. In Section 9, we wrap up with other directions of exploration. 1.9 Acknowledgments We thank Libor Barto, Dmitry Zhuk, Madhu Sudan, and Aaron Putterman for valuable conversations. This research was supported in part by a Simons Investigator award and NSF grant CCF-2211972."
https://arxiv.org/html/2411.03439v1,Towards Entropic Constraints on Quantum Speedups,"Some quantum algorithms have â€œquantum speedupsâ€: improved time complexity as compared with the best-known classical algorithms for solving the same tasks. Can we understand what fuels these speedups from an entropic perspective? Information theory gives us a multitude of metrics we might choose from to measure how fundamentally â€˜quantumâ€™ is the behavior of a quantum computer running an algorithm. The entanglement entropies for subsystems of a quantum state can be analyzed for subsystems of qubits in a quantum computer throughout the running of an algorithm. Here, a framework for making this entropic analysis is constructed, and performed on a selection of quantum circuits implementing known fast quantum algorithms and subroutines: Grover search, the quantum Fourier transform, and phase estimation. Our results are largely unsatisfactory: known entropy inequalities do not suffice to identify the presence or absence of quantum speedups. Although we know our algorithms must have quantum â€œmagic,â€ the Ingleton inequality, which holds for all entropies of subsystems of stabilizer states, is not violated in any of our examples. In some cases, however, monogamy of mutual information, which is obeyed for product states but violated for highly entangled bipartite states such as the Gâ¢Hâ¢Zğºğ»ğ‘GHZitalic_G italic_H italic_Z states, fails at some point in the course of our quantum circuits.","It is well known that the Shannon entropies of probability distributions confined to subsystems are bounded by information theory Shannon:1948dpw ; 681320 ; 4557201 . The resulting constraints on the sharing of information between these subsystems define the classical entropy cone. In quantum systems, due to entanglement, we know that the quantum entropy cone is different from the classical one Araki:1970ba ; Lieb_1973 : for example, entropy can decrease as a system is made larger, as a result of entanglement between portions of the system. In this work, we initiate a study of the relationship between quantum entropy inequalities and algorithmic quantum speedups. Our goal is to study the evolution of select information-theoretic quantities as a quantum state is evolved through a quantum circuit which implements a quantum algorithm that gains a speedup over classical counterparts. The motivation of this analysis is that it must be the fundamentally quantum nature of the state that fuels the speedup, and that the saturation, or degree of failure of entropic inequalities is a potential metric to gauge this fuel. We consider these quantities to be representative of how â€˜quantumâ€™ the subsystem is behaving. It is known that stabilizer states are efficiently simulable Gottesman:1998hu ; Aaronson_2004 , and Clifford circuits can be classically simulated in polynomial (quadratic) time using the tableau representation. Hence any qubit111We limit our discussion in this paper to quantum computers consisting of qubits, i.e. with Hilbert spaces which are tensor products of â„‚2superscriptâ„‚2\mathbb{C}^{2}roman_â„‚ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. However, we note that there are obvious extensions of the concepts of stabilizer states and Clifford circuits to qudits, with base Hilbert space â„‚dsuperscriptâ„‚ğ‘‘\mathbb{C}^{d}roman_â„‚ start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT, d>2ğ‘‘2d>2italic_d > 2. Indeed, it is known that the Gottesman-Knill theorem extends to both Clifford circuits in qudit systems with dğ‘‘ditalic_d equal to an odd prime, and to Gaussian circuits in (bosonic) continuous-variable systems Mari:2012ypq . Separately, free fermionic systems, which can be mapped to â€œmatchgateâ€ qubit circuits, are also known to be efficiently classically simulable 10.1145/380752.380785 ; Terhal:2002aii . algorithm with a quantum speedup must incorporate non-Clifford gates, either by preparing a non-stabilizer initial state or using gates such as the Toffoli or T gate in a circuit implementation. Because non-stabilizer states can be used to speed up computation, they are sometimes referred to as magic states Knill:2004ctr ; Bravyi:2004isx . On the other hand, it is known that entropies of stabilizer states satisfy Ingletonâ€™s inequality ingleton1971representation ; Linden:2013kal ; Walter_2014 . There are many non-stabilizer states that themselves have entropies which similarly obey Ingleton (for example, any state reachable from a stabilizer state by acting with local unitaries), but it is still natural to wonder whether violation of Ingleton can be used to diagnose quantum speedups. Another subclass of quantum states, so-called â€œholographicâ€ states, have entropy vectors obeying monogamy of mutual information Hayden_2013 ; Bao_2015 . Holographic states are a strict subset of stabilizer states: as we discuss in the next section, states with large amounts of tripartite entanglement, such as the GHZ states Greenberger:1989tfe , violate MMI. We analyze three well-known algorithms (or subroutines of algorithms): Groverâ€™s search Grover:1996rk , the quantum Fourier transform Coppersmith:2002skh , and quantum phase estimation Kitaev:1995qy . At every timestep in the algorithm, the state of the quantum computer is represented by its density matrix, from which can be derived all the density matrices of its subsystems, and hence their entanglement entropies, which we use to check inequalities. We find, perhaps as expected, that the saturation and failure of MMI and Ingletonâ€™s inequality do not suffice to diagnose speedup potential. None of the states evolved through circuits corresponding to our algorithms exhibit Ingleton-violated entropy vectors at any time, for example. Hence the evolution of the saturation of these inequalities does not give the full picture of how information is being exploited for these algorithms. Further analysis of saturation of different inequalities, or of more general information quantities, is required. The remainder of this paper is organized as follows. In Section 2, we remind the reader of the definitions of entanglement entropy and the entropy vector, and write down the inequalities we will consider in the remainder of the paper. Section 3 briefly discusses our computational methods (our code is made available accompanying the paper). In Section 4, we discuss three quantum algorithms and describe how entropic structure evolves as they are performed. Finally, we conclude and discuss future directions in 5."
https://arxiv.org/html/2411.03127v1,User Centric Semantic Communications,"Current studies on semantic communications mainly focus on efficiently extracting semantic information to save bandwidth between a transmitter and a user. Although significant process has been made, a fundamental design problem in the semantic communications is that the semantic information is extracted based on certain criteria at the transmitter side along, without considering the userâ€™s actual requirements. As a result, the current semantic communications may cause the loss of critical information that is of primary interest to the user. In such cases, the semantic transmission makes no sense to the user since all the received information is irrelevant. To solve this problem, this paper presents a user centric semantic communication system, where the user sends its request for the desired semantic information to the transmitter at the start of each transmission. Then, the transmitter extracts the required semantic information accordingly. A key challenge is how the transmitter can understand the userâ€™s requests for semantic information and extract the required semantic information in a reasonable and robust manner. We solve this challenge by designing a well-structured framework and leveraging off-the-shelf products, such as GPT-4, along with several specialized tools for detection and estimation. Evaluation results demonstrate the feasibility and effectiveness of the proposed user centric semantic communications.","The concept of semantic communications was originally introduced by Warren Weaver in 1953, focusing on how precisely do the transmitted symbols convey the desired meaning. By concentrating on semantic content, the number of transmitted symbols can be significantly reduced, thereby increasing transmission efficiency in wireless communications. The semantic communications examine the alignment between the transmitterâ€™s intended meaning and the userâ€™s interpretation of the received symbols[1]. A key problem left unsolved in [1] is how to select transmitted symbols that best represent the transmitterâ€™s intended meaning while ensuring alignment with the userâ€™s interpretation. In [2] and its subsequent works [3, 4, 5, 6, 7], machine learning (ML) techniques such as autoencoders[8] and transformers[9] act as key enablers for the semantic communications. Typically, a neural network-based encoder at the transmitter extracts essential features of the input data, where the dimension of the features is significantly lower than that of the input data. The extracted essential features are defined as the semantic information of the input data [2, 3, 4, 5, 6, 7], which represents the transmitterâ€™s intended meaning. A neural network-based decoder at the user side performs interpretation on the received semantic information by reconstructing the original input data from the transmitter based on it. An end-to-end pre-training is performed beforehand to improve the alignment between the transmitterâ€™s intended meaning and the userâ€™s interpretation. The current semantic communication framework[2, 3, 4, 5, 6, 7] may lead to the loss of critical information for the user. As illustrated in Fig. 1, although the main content of a video frame is preserved at the user side during the semantic communications, critical details for the user such as a license plate number have been lost. This lost information might be the only detail the user intends to extract from the video frame. As a result, this semantic transmission makes no sense to the user since all the received information is irrelevant, as the information the user cares about has been lost. The loss of critical information problem arises partly due to the out-of-distribution challenge inherent in the ML models when the distribution of an unseen task is different from the distribution of the training data. In this case, the current framework inadvertently discarding subtle yet important information to the user. The out-of-distribution challenge frequently occurs in practice since it is impossible to train an ML model for every possible data distribution. (a) Original video frame with clear license plate number â€œBC54950â€. (b) Reconstructed video frame with lost license plate information. Figure 1: An autoencoder with a compression rate of 0.5 used in semantic communications fails to recover the license plate number of interest to the user due to the out-of-distribution problem. The peak signal-to-noise ratio (PSNR) of (b) is 15. 97 dB. The autoencoder is pre-trained on the MNIST dataset[10] which consists of 70000 handwritten digits images. The above observation illustrates a fundamental design flaw in the current semantic communication framework. That is, the current framework extracts the so-called semantic information (i.e., compresses input data) based on certain criteria at the transmitter side along, such as PSNR in image transmissions, and does not take the userâ€™s actual requirement into account. If the transmitter were aware of the userâ€™s information needs in advance, it could take actions to prevent the loss of the userâ€™s required information. In this paper, we present a user centric semantic communication system, where fulfilling the userâ€™s information requirements is central to each semantic transmission. In the proposed user centric system, the semantic information is redefined as the specific information that user intends to get through a particular data transmission. For example, through the transmission of the video frame in Fig. 1, the user wants to get the license plate number. Thus, the license plate number is the semantic information in this video frame at this particular transmission. In user centric semantic communications, each transmission is initialized by the user. Specifically, at the start of each transmission, the user sends its request on the semantic information to the transmitter. Then, the transmitter extracts the related semantic information and sends it to the user. We restrict our discussion on the semantic communication in scenarios where the original data at the transmitter is surveillance videos, as the user typically have clear requests for semantic information on the surveillance videos, such as checking traffic situations on a particular road. To achieve the user centric communication system, there are at least two significant challenges. The first significant challenge is how the transmitter can understand the userâ€™s requests for semantic information and extract the required semantic information from the surveillance video accordingly. To address this, we leverage a large language model (LLM) to understand the userâ€™s requests (termed as tasks), and perform task planning. Specifically, we build a system which consists of a LLM agent and several specialized tools such as an object detection tool. Based on its understanding of the semantic information request, the LLM determines which specialized tools to use and the order of their execution. Then, guided by the task planning, the specialized tools work together to extract the semantic information. Finally, the required semantic information is sent back to the user in text form. The second significant challenge is the possibility that the LLMâ€™s task planing ability is not robust such that the generated task plan is not reasonable sometimes, and thus cannot fulfill the userâ€™s request directly. To make the user still get the required semantic information, a simple but inefficient way is to have the transmitter send the original video to the user, which can lead to significant bandwidth waste. To solve this challenge, we propose a task reflection process where the LLM assesses whether the current task plan can meet the userâ€™s request on semantic information. If the task reflection result is negative, we alternatively ask the LLM and the specialized tools to select the most relevant video frames related to the userâ€™s request from the surveillance video, and send them back to the user. Upon receiving the video frames, the user can get the required semantic information from the video frames by themselves. We implement the user centric semantic communication system using the off-the-shell LLM product GPT-4 released by OpenAI [11], along with several specialized tools that have specific detection or estimation capabilities. A demo video is available at [12]. We invite 18 postgraduates from 5 Universities to evaluate the overall systemâ€™s performance through traffic surveillance videos. The results show that our system can fulfill 83.90% of the usersâ€™ requests for semantic information from the traffic surveillance videos. In addition, compared with the traditional system where the whole videos are transmitted for information extraction at the user side, our system can reduce the number of transmitted video frames by 81.70%, and video data size by 66.33%. In summary, the proposed user centric semantic communication system successfully meets usersâ€™ requirements for semantic information in most cases while significantly reducing the transmitted data size. Second, the system is independent of the data distributions of the surveillance video, as the LLM and specialized tools are off-the-shelf products, meaning we do not need to train them using our data. Third, while we discuss the user centric semantic system in the context of surveillance videos, the framework and methods have the potential to be applied to scenarios where users have clear requests for semantic information from the multimodal data stored at the transmitter."
https://arxiv.org/html/2411.02900v1,Distributed Graph Neural Network Design for Sum Ergodic Spectral Efficiency Maximization in Cell-Free Massive MIMO,"This paper proposes a distributed learning-based framework to tackle the sum ergodic rate maximization problem in cell-free massive multiple-input multiple-output (MIMO) systems by utilizing the graph neural network (GNN). Different from centralized schemes, which gather all the channel state information (CSI) at the central processing unit (CPU) for calculating the resource allocation, the local resource of access points (APs) is exploited in the proposed distributed GNN-based framework to allocate transmit powers. Specifically, APs can use a unique GNN model to allocate their power based on the local CSI. The GNN model is trained at the CPU using the local CSI of one AP, with partially exchanged information from other APs to calculate the loss function to reflect system characteristics, capturing comprehensive network information while avoiding computation burden. Numerical results show that the proposed distributed learning-based approach achieves a sum ergodic rate close to that of centralized learning while outperforming the model-based optimization.","Cell-free massive multiple-input multiple-output (MIMO) characterizes a network configuration wherein numerous access points (APs) coherently serve multiple user equipments (UEs) with the same time-frequency resources. This paradigm holds the potential to yield network enhancements in throughput, reliability, and energy efficiency [1, 2]. To fully exploit the benefits of cell-free massive MIMO systems, numerous studies and investigations have been conducted in various subjects [3, 4]. Cell-free massive MIMO systems pose increasing challenges as network size grows, making conventional optimization-driven methodologies unsuitable due to time constraints and practical implementation feasibility. Deep learning (DL) is a transformative technology for cell-free massive MIMO systems [5, 6]. However, DL models are context-specific, operating effectively only within the scenarios present during training. Consequently, retraining is needed when network dimensions change, limiting flexibility. Graph Neural Networks (GNNs) offer a solution to this scalability challenge by modeling wireless systems as graphs, where nodes and edges represent system entities and their interconnections. In this way, a GNN forecasts the outcomes on nodes or edges by analyzing their inherent features. Therefore, GNNs depend on the attributes of nodes and edges rather than system dimensions. Despite the popularity of GNNs in wireless systems [7, 8, 9], there have been few studies on their application in cell-free massive MIMO. In [10], a heterogeneous GNN-based message passing was proposed for power control in an uplink cell-free massive MIMO system, considering UEs and APs as different types of entities in the represented graph. The paper [11] developed a GNN to optimize the downlink max-min power allocation, incorporating maximum ratio transmission beamforming. Both [10] and [11] use a centralized GNN model at the central processing unit (CPU), assuming full CSI of the entire system is available at the CPU. While these approaches achieve high performance, they incur substantial computational and communication overhead, and the computational capacity of individual APs is underutilized. Previous distributed deep learning approaches, like [12], reduce the central serverâ€™s burden but are limited to specific training configurations, restricting generalizability. Meanwhile, distributed optimization approaches, like [13], still require information exchange between APs, increasing latency and complexity, especially in large-scale networks. To resolve the above issue, we propose a novel distributed GNN-based framework where each AP leverages the local CSI to predict power allocation coefficients. During the training phase, the GNN model is trained at the CPU using the local CSI of a single AP, while combined information from other APs derived from their CSI is required to calculate the loss function. This combined information reflects desired signal, pilot contamination, and user interference, allowing the model to capture comprehensive network characteristics while reducing the computational burden. To the best of our knowledge, this is the first research deploying GNN in a distributed manner to solve a power allocation problem in cell-free massive MIMO. Our main contributions are briefly summarized as follows: i) We study a distributed GNN to allocate the transmit powers in the downlink cell-free massive MIMO. Each AP uses the proposed GNN model to predict its power coefficient based on its local channel statistics; ii) During the training phase, we propose a procedure to update the GNN model and exchange information between the CPU and APs to enhance the learning ability and share the computational burden; and iii) Numerical results show our distributed GNN framework performs nearly as well as centralized learning and outperforms optimization-based methods. Notation: Boldface lowercase letters and boldface uppercase letters denote vectors and matrices, respectively. Let ()Tsuperscriptğ‘‡()^{T}( ) start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT and ()âˆ—superscript()^{*}( ) start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT denote the transpose and conjugate, respectively. The Euclidean norm and expectation are denoted by âˆ¥â‹…âˆ¥\|\cdot\|âˆ¥ â‹… âˆ¥, and ğ”¼â¢{â‹…}ğ”¼â‹…\mathbb{E}\{\cdot\}blackboard_E { â‹… }. Finally, we define the circularly symmetric complex Gaussian distribution with variance Ïƒ2superscriptğœ2\sigma^{2}italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT by ğ’â¢ğ’©â¢(0,Ïƒ2)ğ’ğ’©0superscriptğœ2\mathcal{CN}(0,\sigma^{2})caligraphic_C caligraphic_N ( 0 , italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT )."
https://arxiv.org/html/2411.02899v1,"Codes with restricted overlaps:expandability, constructions, and bounds","Consider a qğ‘qitalic_q-ary block code satisfying the property that no lğ‘™litalic_l-letters long codewordâ€™s prefix occurs as a suffix of any codeword for lğ‘™litalic_l inside some interval. We determine a general upper bound on the maximum size of these codes and a tighter bound for codes where overlaps with lengths not exceeding kğ‘˜kitalic_k are prohibited. We then provide constructions for codes with various restrictions on overlap lengths and use them to determine lower bounds on the maximum sizes. In particular, we construct (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free codes where kâ‰¥n/2ğ‘˜ğ‘›2k\geq n/2italic_k â‰¥ italic_n / 2 and nğ‘›nitalic_n denotes the block size, expand a known construction of (k,nâˆ’1)ğ‘˜ğ‘›1(k,n-1)( italic_k , italic_n - 1 )-overlap-free codes, and combine the ideas behind both constructions to obtain (t1,t2)subscriptğ‘¡1subscriptğ‘¡2(t_{1},t_{2})( italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )-overlap-free codes and codes that are simultaneously (1,k)1ğ‘˜(1,k)( 1 , italic_k )- and (nâˆ’k,nâˆ’1)ğ‘›ğ‘˜ğ‘›1(n-k,n-1)( italic_n - italic_k , italic_n - 1 )-overlap-free for some k<n/2ğ‘˜ğ‘›2k<n/2italic_k < italic_n / 2. In the case when overlaps of lengths between 1 and kğ‘˜kitalic_k are prohibited, we complete the characterisation of non-expandable codes started by Cai, Wang, and Feng (2023) [1].","Two not necessarily distinct words uğ‘¢uitalic_u and vğ‘£vitalic_v over an alphabet Î£Î£\Sigmaroman_Î£ have a tğ‘¡titalic_t-overlap if the tğ‘¡titalic_t letters long prefix of uğ‘¢uitalic_u occurs as a suffix of vğ‘£vitalic_v, or vice-versa. A code CâŠ†Î£nğ¶superscriptÎ£ğ‘›C\subseteq\Sigma^{n}italic_C âŠ† roman_Î£ start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is (t1,t2)subscriptğ‘¡1subscriptğ‘¡2(t_{1},t_{2})( italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )-overlap-free if for all t1â‰¤tâ‰¤t2subscriptğ‘¡1ğ‘¡subscriptğ‘¡2t_{1}\leq t\leq t_{2}italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT â‰¤ italic_t â‰¤ italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT no codewords in Cğ¶Citalic_C have a tğ‘¡titalic_t-overlap [2]. These codes may be useful in channels where bursts of at least minâ¡{t1,nâˆ’t2}subscriptğ‘¡1ğ‘›subscriptğ‘¡2\min\;\{t_{1},n-t_{2}\}roman_min { italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_n - italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT } and at most minâ¡{nâˆ’t1,t2}ğ‘›subscriptğ‘¡1subscriptğ‘¡2\min\;\{n-t_{1},t_{2}\}roman_min { italic_n - italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT } deletions or insertions are expected. They are guaranteed to detect deletions after 2â¢n2ğ‘›2n2 italic_n symbols are read and insertions after 3â¢n3ğ‘›3n3 italic_n symbols are read. Some parameter values may even perform better. So far, only special cases of (t1,t2)subscriptğ‘¡1subscriptğ‘¡2(t_{1},t_{2})( italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )-overlap-free codes have been studied. Non-overlapping codes, i.e., the (1,nâˆ’1)1ğ‘›1(1,n-1)( 1 , italic_n - 1 )-overlap-free codes, were established for synchronisation sixty years ago [3]. At the beginning of this millennium, Tğ‘‡Titalic_T-shift synchronisation codes were considered for data storage [4, 5]. Every uni- and bidirectional Tğ‘‡Titalic_T-shift synchronisation code is a (nâˆ’T,nâˆ’1)ğ‘›ğ‘‡ğ‘›1(n-T,n-1)( italic_n - italic_T , italic_n - 1 )-overlap-free code, but the two classes only coincide when T=1ğ‘‡1T=1italic_T = 1. In 2015, the term Îºğœ…\kappaitalic_Îº-weakly mutually uncorrelated codes was introduced for (Îº,nâˆ’1)ğœ…ğ‘›1(\kappa,n-1)( italic_Îº , italic_n - 1 )-overlap-free codes that were motivated by applications in DNA-based data storage [6, 7, 8, 9, 10]. Recently, Blackburn et al., who defined the (t1,t2)subscriptğ‘¡1subscriptğ‘¡2(t_{1},t_{2})( italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )-overlap-free codes, spotlighted the class of (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free codes that have an advantage over the class of (nâˆ’k,nâˆ’1)ğ‘›ğ‘˜ğ‘›1(n-k,n-1)( italic_n - italic_k , italic_n - 1 )-overlap-free codes in channels where deletions are more common than insertions [2]. They also suggested that codes that are simultaneously (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free and (nâˆ’k,nâˆ’1)ğ‘›ğ‘˜ğ‘›1(n-k,n-1)( italic_n - italic_k , italic_n - 1 )-overlap-free for some k<n/2ğ‘˜ğ‘›2k<n/2italic_k < italic_n / 2 might be fruitful for applications since they inherit their deletion-detection capabilities from (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free codes and insertion-detection capabilities from (nâˆ’k,nâˆ’1)ğ‘›ğ‘˜ğ‘›1(n-k,n-1)( italic_n - italic_k , italic_n - 1 )-overlap-free codes. In the same year, Cai, Wang, and Feng [1] showed that the study of a (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free code of length nğ‘›nitalic_n for nâ‰¥2â¢kğ‘›2ğ‘˜n\geq 2kitalic_n â‰¥ 2 italic_k can be reduced to the study of a (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free code of length 2â¢k2ğ‘˜2k2 italic_k. This is because for any n>2â¢kğ‘›2ğ‘˜n>2kitalic_n > 2 italic_k, the (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap property is independent of the symbols placed at positions k+1,â€¦,nâˆ’kğ‘˜1â€¦ğ‘›ğ‘˜k+1,\dots,n-kitalic_k + 1 , â€¦ , italic_n - italic_k. The (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free codes where n/2<k<nâˆ’1ğ‘›2ğ‘˜ğ‘›1n/2<k<n-1italic_n / 2 < italic_k < italic_n - 1 have not been studied much. To our knowledge, only one construction of (1,nâˆ’2)1ğ‘›2(1,n-2)( 1 , italic_n - 2 )-overlap-free codes exists. It was presented in [1]. A code that attains the largest possible size is called maximum. Herein, the maximum size of a (t1,t2)subscriptğ‘¡1subscriptğ‘¡2(t_{1},t_{2})( italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT )-overlap-free code of length nğ‘›nitalic_n over an alphabet with qğ‘qitalic_q elements will be denoted by St1t2â¢(q,n)superscriptsubscriptğ‘†subscriptğ‘¡1subscriptğ‘¡2ğ‘ğ‘›S_{t_{1}}^{t_{2}}(q,n)italic_S start_POSTSUBSCRIPT italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ( italic_q , italic_n ). The tightest known upper bound on the size of maximum non-overlapping codes given in Eq. (1) was determined in [3] by studying the corresponding generating function. In the construction from [11], the upper bound is attained when nğ‘›nitalic_n divides qğ‘qitalic_q. S1nâˆ’1â¢(q,n)â‰¤(nâˆ’1n)nâˆ’1â¢qnn.superscriptsubscriptğ‘†1ğ‘›1ğ‘ğ‘›superscriptğ‘›1ğ‘›ğ‘›1superscriptğ‘ğ‘›ğ‘›\displaystyle S_{1}^{n-1}(q,n)\leq\left(\frac{n-1}{n}\right)^{n-1}\frac{q^{n}}% {n}.italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT ( italic_q , italic_n ) â‰¤ ( divide start_ARG italic_n - 1 end_ARG start_ARG italic_n end_ARG ) start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT divide start_ARG italic_q start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG start_ARG italic_n end_ARG . (1) The first upper bound on Sknâˆ’1â¢(q,n)superscriptsubscriptğ‘†ğ‘˜ğ‘›1ğ‘ğ‘›S_{k}^{n-1}(q,n)italic_S start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT ( italic_q , italic_n ) was determined in [7]. Its improved version published in [2] is given in Eq. (2). Sknâˆ’1â¢(q,n)superscriptsubscriptğ‘†ğ‘˜ğ‘›1ğ‘ğ‘›\displaystyle S_{k}^{n-1}(q,n)italic_S start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT ( italic_q , italic_n ) â‰¤qn2â¢nâˆ’2â¢k+1.absentsuperscriptğ‘ğ‘›2ğ‘›2ğ‘˜1\displaystyle\leq\frac{q^{n}}{2n-2k+1}.â‰¤ divide start_ARG italic_q start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT end_ARG start_ARG 2 italic_n - 2 italic_k + 1 end_ARG . (2) A similar result on S1kâ¢(q,n)superscriptsubscriptğ‘†1ğ‘˜ğ‘ğ‘›S_{1}^{k}(q,n)italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ( italic_q , italic_n ) for kâ‰¤n/2ğ‘˜ğ‘›2k\leq n/2italic_k â‰¤ italic_n / 2 was first derived in [2]. The upper bound was improved in [1] (Eq. (3) below). Moreover, in the same article, two exact values were determined. They are given in Eqs. (4) and (5) below. In Eq. (5), âŒŠxâŒ‰delimited-âŒŠâŒ‰ğ‘¥\lfloor x\rceilâŒŠ italic_x âŒ‰ denotes the rounding of xğ‘¥xitalic_x to the nearest integer. S1kâ¢(q,n)superscriptsubscriptğ‘†1ğ‘˜ğ‘ğ‘›\displaystyle S_{1}^{k}(q,n)italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ( italic_q , italic_n ) â‰¤qnâˆ’qnâˆ’k2â¢k,kâ‰¤n/2,formulae-sequenceabsentsuperscriptğ‘ğ‘›superscriptğ‘ğ‘›ğ‘˜2ğ‘˜ğ‘˜ğ‘›2\displaystyle\leq\frac{q^{n}-q^{n-k}}{2k},\;k\leq n/2,â‰¤ divide start_ARG italic_q start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - italic_q start_POSTSUPERSCRIPT italic_n - italic_k end_POSTSUPERSCRIPT end_ARG start_ARG 2 italic_k end_ARG , italic_k â‰¤ italic_n / 2 , (3) S1kâ¢(q,n)superscriptsubscriptğ‘†1ğ‘˜ğ‘ğ‘›\displaystyle S_{1}^{k}(q,n)italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ( italic_q , italic_n ) =qnâˆ’2â¢kâ¢S1kâ¢(q,2â¢k),kâ‰¤n/2,formulae-sequenceabsentsuperscriptğ‘ğ‘›2ğ‘˜superscriptsubscriptğ‘†1ğ‘˜ğ‘2ğ‘˜ğ‘˜ğ‘›2\displaystyle=q^{n-2k}S_{1}^{k}(q,2k),\;k\leq n/2,= italic_q start_POSTSUPERSCRIPT italic_n - 2 italic_k end_POSTSUPERSCRIPT italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT ( italic_q , 2 italic_k ) , italic_k â‰¤ italic_n / 2 , (4) S12â¢(q,n)superscriptsubscriptğ‘†12ğ‘ğ‘›\displaystyle S_{1}^{2}(q,n)italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_q , italic_n ) =âŒŠq3âŒ‰(qâˆ’âŒŠq3âŒ‰)2qnâˆ’3,nâ‰¥4.\displaystyle=\Bigl{\lfloor}\frac{q}{3}\Bigr{\rceil}\left(q-\Bigl{\lfloor}% \frac{q}{3}\Bigr{\rceil}\right)^{2}q^{n-3},\;n\geq 4.= âŒŠ divide start_ARG italic_q end_ARG start_ARG 3 end_ARG âŒ‰ ( italic_q - âŒŠ divide start_ARG italic_q end_ARG start_ARG 3 end_ARG âŒ‰ ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_q start_POSTSUPERSCRIPT italic_n - 3 end_POSTSUPERSCRIPT , italic_n â‰¥ 4 . (5) The author is not aware of any existing bounds for other values of t1subscriptğ‘¡1t_{1}italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and t2subscriptğ‘¡2t_{2}italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT. Hence, this paper aims to derive new upper and lower bounds on St1t2superscriptsubscriptğ‘†subscriptğ‘¡1subscriptğ‘¡2S_{t_{1}}^{t_{2}}italic_S start_POSTSUBSCRIPT italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT and provide corresponding constructions. The outline of the paper is as follows. Section 2 introduces the necessary notation and summarises existing results. A general upper bound on St1t2superscriptsubscriptğ‘†subscriptğ‘¡1subscriptğ‘¡2S_{t_{1}}^{t_{2}}italic_S start_POSTSUBSCRIPT italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT and a tighter upper bound for the size of (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free codes when k<nâ‰¤2â¢kğ‘˜ğ‘›2ğ‘˜k<n\leq 2kitalic_k < italic_n â‰¤ 2 italic_k is determined in Section 3. In Section 4, we develop methods to construct both types of codes and expand a construction of (k,nâˆ’1)ğ‘˜ğ‘›1(k,n-1)( italic_k , italic_n - 1 )-overlap-free codes from [7]. Moreover, we characterise maximal (1,k)1ğ‘˜(1,k)( 1 , italic_k )-overlap-free codes and construct codes that are simultaneously (1,k)âˆ’limit-from1ğ‘˜(1,k)-( 1 , italic_k ) - and (nâˆ’k,nâˆ’1)ğ‘›ğ‘˜ğ‘›1(n-k,n-1)( italic_n - italic_k , italic_n - 1 )-overlap-free. Finally, these constructions are used to determine the corresponding lower bounds on St1t2superscriptsubscriptğ‘†subscriptğ‘¡1subscriptğ‘¡2S_{t_{1}}^{t_{2}}italic_S start_POSTSUBSCRIPT italic_t start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_t start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT in Section 5."
https://arxiv.org/html/2411.02720v1,Self-Dual Cyclic Codes with Square-Root-Like Lower Bounds on Their Minimum Distancesâ€ â€ thanks:The research of Hao Chen was supported by NSFC Grant 62032009. The research of Cunsheng Ding was supported by The Hong Kong Research Grants Council under Grant No. 16301123.,"Binary self-dual cyclic codes have been studied since the classical work of Sloane and Thompson published in IEEE Trans. Inf. Theory, vol. 29, 1983. Twenty five years later, an infinite family of binary self-dual cyclic codes with lengths nisubscriptğ‘›ğ‘–n_{i}italic_n start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT and minimum distances diâ‰¥12â¢ni+2subscriptğ‘‘ğ‘–12subscriptğ‘›ğ‘–2d_{i}\geq\frac{1}{2}\sqrt{n_{i}+2}italic_d start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‰¥ divide start_ARG 1 end_ARG start_ARG 2 end_ARG square-root start_ARG italic_n start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT + 2 end_ARG was presented in a paper of IEEE Trans. Inf. Theory, vol. 55, 2009. However, no infinite family of Euclidean self-dual binary cyclic codes whose minimum distances have the square-root lower bound and no infinite family of Euclidean self-dual nonbinary cyclic codes whose minimum distances have a lower bound better than the square-root lower bound are known in the literature. In this paper, an infinite family of Euclidean self-dual cyclic codes over the fields ğ…2ssubscriptğ…superscript2ğ‘ {\bf F}_{2^{s}}bold_F start_POSTSUBSCRIPT 2 start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT end_POSTSUBSCRIPT with a square-root-like lower bound is constructed. An infinite subfamily of this family consists of self-dual binary cyclic codes with the square-root lower bound. Another infinite subfamily of this family consists of self-dual cyclic codes over the fields ğ…2ssubscriptğ…superscript2ğ‘ {\bf F}_{2^{s}}bold_F start_POSTSUBSCRIPT 2 start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT end_POSTSUBSCRIPT with a lower bound better than the square-root bound for sâ‰¥2ğ‘ 2s\geq 2italic_s â‰¥ 2. Consequently, two breakthroughs in coding theory are made in this paper. An infinite family of self-dual binary cyclic codes with a square-root-like lower bound is also presented in this paper. An infinite family of Hermitian self-dual cyclic codes over the fields ğ…22â¢ssubscriptğ…superscript22ğ‘ {\bf F}_{2^{2s}}bold_F start_POSTSUBSCRIPT 2 start_POSTSUPERSCRIPT 2 italic_s end_POSTSUPERSCRIPT end_POSTSUBSCRIPT with a square-root-like lower bound and an infinite family of Euclidean self-dual linear codes over ğ…qsubscriptğ…ğ‘{\bf F}_{q}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT with qâ‰¡1(mod4)ğ‘annotated1pmod4q\equiv 1\pmod{4}italic_q â‰¡ 1 start_MODIFIER ( roman_mod start_ARG 4 end_ARG ) end_MODIFIER with a square-root-like lower bound are also constructed in this paper. Index terms: Cyclic code, linear code, self-dual code.","1.1 Basics of linear codes The Hamming weight of a vector ğš=(a0,â€¦,anâˆ’1)âˆˆğ…qnğšsubscriptğ‘0â€¦subscriptğ‘ğ‘›1superscriptsubscriptğ…ğ‘ğ‘›{\bf a}=(a_{0},\ldots,a_{n-1})\in{\bf F}_{q}^{n}bold_a = ( italic_a start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , â€¦ , italic_a start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT ) âˆˆ bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is defined by wtâ¢(ğš)=|{i:aiâ‰ 0}|.wtğšconditional-setğ‘–subscriptğ‘ğ‘–0{\mathrm{wt}}({\bf a})=|\{i:a_{i}\neq 0\}|.roman_wt ( bold_a ) = | { italic_i : italic_a start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT â‰  0 } | . The Hamming distance dâ¢(ğš,ğ›)ğ‘‘ğšğ›d({\bf a},{\bf b})italic_d ( bold_a , bold_b ) between two vectors ğšğš{\bf a}bold_a and ğ›ğ›{\bf b}bold_b is defined by dâ¢(ğš,ğ›)=wtâ¢(ğšâˆ’ğ›).ğ‘‘ğšğ›wtğšğ›d({\bf a},{\bf b})={\mathrm{wt}}({\bf a}-{\bf b}).italic_d ( bold_a , bold_b ) = roman_wt ( bold_a - bold_b ) . The Hamming distance dâ¢(ğ‚)ğ‘‘ğ‚d({\bf C})italic_d ( bold_C ) of a subset ğ‚âŠ†ğ…qğ‚subscriptğ…ğ‘{\bf C}\subseteq{\bf F}_{q}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT is defied by dâ¢(ğ‚)=minğšâ‰ ğ›â¡{dâ¢(ğš,ğ›):ğšâˆˆğ‚,ğ›âˆˆğ‚}.ğ‘‘ğ‚subscriptğšğ›:ğ‘‘ğšğ›formulae-sequenceğšğ‚ğ›ğ‚d({\bf C})=\min_{{\bf a}\neq{\bf b}}\{d({\bf a},{\bf b}):{\bf a}\in{\bf C},{% \bf b}\in{\bf C}\}.italic_d ( bold_C ) = roman_min start_POSTSUBSCRIPT bold_a â‰  bold_b end_POSTSUBSCRIPT { italic_d ( bold_a , bold_b ) : bold_a âˆˆ bold_C , bold_b âˆˆ bold_C } . An [n,k,d]qsubscriptğ‘›ğ‘˜ğ‘‘ğ‘[n,k,d]_{q}[ italic_n , italic_k , italic_d ] start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT linear code is a linear subspace of ğ…qnsuperscriptsubscriptğ…ğ‘ğ‘›{\bf F}_{q}^{n}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT with dimension kğ‘˜kitalic_k and minimum distance dğ‘‘ditalic_d. Throughout this paper, by an [n,k,d]qsubscriptğ‘›ğ‘˜ğ‘‘ğ‘[n,k,d]_{q}[ italic_n , italic_k , italic_d ] start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT code we mean an [n,k,d]qsubscriptğ‘›ğ‘˜ğ‘‘ğ‘[n,k,d]_{q}[ italic_n , italic_k , italic_d ] start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT linear code over ğ…qsubscriptğ…ğ‘{\mathbf{{F}}}_{q}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT. It is clear that the minimum Hamming distance of a nonzero linear code is its minimum nonzero Hamming weight. The Singleton bound asserts that dâ‰¤nâˆ’k+1ğ‘‘ğ‘›ğ‘˜1d\leq n-k+1italic_d â‰¤ italic_n - italic_k + 1 for an [n,k,d]qsubscriptğ‘›ğ‘˜ğ‘‘ğ‘[n,k,d]_{q}[ italic_n , italic_k , italic_d ] start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT code. A linear code attaining this bound is said to be maximal distance separable (MDS). Reed-Solomon codes are well-known MDS codes (see, e.g., [10, 22, 14]). The Euclidean inner product on ğ…qnsuperscriptsubscriptğ…ğ‘ğ‘›{\bf F}_{q}^{n}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is defined by <ğ±,ğ²>=Î£i=1nâ¢xiâ¢yi,formulae-sequenceabsentğ±ğ²superscriptsubscriptÎ£ğ‘–1ğ‘›subscriptğ‘¥ğ‘–subscriptğ‘¦ğ‘–<{\bf x},{\bf y}>=\Sigma_{i=1}^{n}x_{i}y_{i},< bold_x , bold_y > = roman_Î£ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , where ğ±=(x1,â€¦,xn)ğ±subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›{\bf x}=(x_{1},\ldots,x_{n})bold_x = ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) and ğ²=(y1,â€¦,yn)ğ²subscriptğ‘¦1â€¦subscriptğ‘¦ğ‘›{\bf y}=(y_{1},\ldots,y_{n})bold_y = ( italic_y start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_y start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ). The Euclidean dual of a linear code ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is ğ‚âŸ‚={ğœâˆˆğ…qn:<ğœ,ğ²>=0,âˆ€ğ²âˆˆğ‚}.{\bf C}^{\perp}=\{{\bf c}\in{\bf F}_{q}^{n}:<{\bf c},{\bf y}>=0,\forall{\bf y}% \in{\bf C}\}.bold_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT = { bold_c âˆˆ bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT : < bold_c , bold_y > = 0 , âˆ€ bold_y âˆˆ bold_C } . A linear code ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is Euclidean self-orthogonal if ğ‚âŠ†ğ‚âŸ‚ğ‚superscriptğ‚perpendicular-to{\bf C}\subseteq{\bf C}^{\perp}bold_C âŠ† bold_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT, Euclidean dual-containing if ğ‚âŸ‚âŠ†ğ‚superscriptğ‚perpendicular-toğ‚{\bf C}^{\perp}\subseteq{\bf C}bold_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT âŠ† bold_C, and Euclidean self-dual if ğ‚=ğ‚âŸ‚ğ‚superscriptğ‚perpendicular-to{\bf C}={\bf C}^{\perp}bold_C = bold_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT. The Euclidean dual of a Euclidean dual-containing code is a Euclidean self-orthogonal code. Let q=q12ğ‘superscriptsubscriptğ‘12q=q_{1}^{2}italic_q = italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. Similarly the Hermitian inner product on ğ…qnsuperscriptsubscriptğ…ğ‘ğ‘›{\bf F}_{q}^{n}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is defined by <ğ±,ğ²>H=Î£i=1nxiyiq1,<{\bf x},{\bf y}>_{H}=\Sigma_{i=1}^{n}x_{i}y_{i}^{q_{1}},< bold_x , bold_y > start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT = roman_Î£ start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT , where ğ±=(x1,â€¦,xn)ğ±subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›{\bf x}=(x_{1},\ldots,x_{n})bold_x = ( italic_x start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_x start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) and ğ²=(y1,â€¦,yn)ğ²subscriptğ‘¦1â€¦subscriptğ‘¦ğ‘›{\bf y}=(y_{1},\ldots,y_{n})bold_y = ( italic_y start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_y start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT ) are two vectors in ğ…qnsuperscriptsubscriptğ…ğ‘ğ‘›{\bf F}_{q}^{n}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT. The Hermitian dual of a linear code ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is ğ‚âŸ‚H={ğœâˆˆğ…qn:<ğœ,ğ²>H=0,âˆ€ğ²âˆˆğ‚}.{\bf C}^{\perp_{H}}=\{{\bf c}\in{\bf F}_{q}^{n}:<{\bf c},{\bf y}>_{H}=0,% \forall{\bf y}\in{\bf C}\}.bold_C start_POSTSUPERSCRIPT âŸ‚ start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = { bold_c âˆˆ bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT : < bold_c , bold_y > start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT = 0 , âˆ€ bold_y âˆˆ bold_C } . For a linear code ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, we set ğ‚q1={(c0q1,â€¦,cnâˆ’1q1):(c0,â€¦,cnâˆ’1)âˆˆğ‚}.superscriptğ‚subscriptğ‘1conditional-setsuperscriptsubscriptğ‘0subscriptğ‘1â€¦superscriptsubscriptğ‘ğ‘›1subscriptğ‘1subscriptğ‘0â€¦subscriptğ‘ğ‘›1ğ‚{\bf C}^{q_{1}}=\{(c_{0}^{q_{1}},\ldots,c_{n-1}^{q_{1}}):(c_{0},\ldots,c_{n-1}% )\in{\bf C}\}.bold_C start_POSTSUPERSCRIPT italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = { ( italic_c start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT , â€¦ , italic_c start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) : ( italic_c start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , â€¦ , italic_c start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT ) âˆˆ bold_C } . Then it is clear that ğ‚âŸ‚H=(ğ‚âŸ‚)q1=(ğ‚q1)âŸ‚.superscriptğ‚subscriptperpendicular-toğ»superscriptsuperscriptğ‚perpendicular-tosubscriptğ‘1superscriptsuperscriptğ‚subscriptğ‘1perpendicular-to\displaystyle{\bf C}^{\perp_{H}}=({\bf C}^{\perp})^{q_{1}}=({\bf C}^{q_{1}})^{% \perp}.bold_C start_POSTSUPERSCRIPT âŸ‚ start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = ( bold_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT = ( bold_C start_POSTSUPERSCRIPT italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT . (1) A linear code ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is Hermitian self-orthogonal if ğ‚âŠ†ğ‚âŸ‚Hğ‚superscriptğ‚subscriptperpendicular-toğ»{\bf C}\subseteq{\bf C}^{\perp_{H}}bold_C âŠ† bold_C start_POSTSUPERSCRIPT âŸ‚ start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUPERSCRIPT, Hermitian dual-containing if ğ‚âŸ‚HâŠ†ğ‚superscriptğ‚subscriptperpendicular-toğ»ğ‚{\bf C}^{\perp_{H}}\subseteq{\bf C}bold_C start_POSTSUPERSCRIPT âŸ‚ start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUPERSCRIPT âŠ† bold_C, and Hermitian self-dual if ğ‚=ğ‚âŸ‚Hğ‚superscriptğ‚subscriptperpendicular-toğ»{\bf C}={\bf C}^{\perp_{H}}bold_C = bold_C start_POSTSUPERSCRIPT âŸ‚ start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT end_POSTSUPERSCRIPT. The Hermitian dual of a Hermitian dual-containing code is a Hermitian self-orthogonal code. 1.2 The importance of cyclic codes in theory and practice Let ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT be a linear code. If (c0,c1,â€¦,cnâˆ’1)âˆˆğ‚subscriptğ‘0subscriptğ‘1â€¦subscriptğ‘ğ‘›1ğ‚(c_{0},c_{1},\ldots,c_{n-1})\in{\bf C}( italic_c start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , italic_c start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , italic_c start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT ) âˆˆ bold_C implies (cnâˆ’1,c0,â€¦,cnâˆ’2)subscriptğ‘ğ‘›1subscriptğ‘0â€¦subscriptğ‘ğ‘›2(c_{n-1},c_{0},\ldots,c_{n-2})( italic_c start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT , italic_c start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , â€¦ , italic_c start_POSTSUBSCRIPT italic_n - 2 end_POSTSUBSCRIPT ) âˆˆğ‚absentğ‚\in{\bf C}âˆˆ bold_C, then this code ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is said to be cyclic. A codeword ğœğœ{\bf c}bold_c in a cyclic code ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is identified with the polynomial ğœâ¢(x)=c0+c1â¢x+â‹¯+cnâˆ’1â¢xnâˆ’1âˆˆğ…qâ¢[x]/(xnâˆ’1)ğœğ‘¥subscriptğ‘0subscriptğ‘1ğ‘¥â‹¯subscriptğ‘ğ‘›1superscriptğ‘¥ğ‘›1subscriptğ…ğ‘delimited-[]ğ‘¥superscriptğ‘¥ğ‘›1{\bf c}(x)=c_{0}+c_{1}x+\cdots+c_{n-1}x^{n-1}\in{\bf F}_{q}[x]/(x^{n}-1)bold_c ( italic_x ) = italic_c start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT + italic_c start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT italic_x + â‹¯ + italic_c start_POSTSUBSCRIPT italic_n - 1 end_POSTSUBSCRIPT italic_x start_POSTSUPERSCRIPT italic_n - 1 end_POSTSUPERSCRIPT âˆˆ bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT [ italic_x ] / ( italic_x start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ). With this identification, every cyclic code ğ‚âŠ†ğ…qnğ‚superscriptsubscriptğ…ğ‘ğ‘›{\bf C}\subseteq{\bf F}_{q}^{n}bold_C âŠ† bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT is a principal ideal in the ring ğ…qâ¢[x]/(xnâˆ’1)subscriptğ…ğ‘delimited-[]ğ‘¥superscriptğ‘¥ğ‘›1{\bf F}_{q}[x]/(x^{n}-1)bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT [ italic_x ] / ( italic_x start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ) and is then generated by many polynomials in ğ…qâ¢[x]/(xnâˆ’1)subscriptğ…ğ‘delimited-[]ğ‘¥superscriptğ‘¥ğ‘›1{\bf F}_{q}[x]/(x^{n}-1)bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT [ italic_x ] / ( italic_x start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 ). Let ğ‚=(gâ¢(x))ğ‚ğ‘”ğ‘¥{\bf C}=(g(x))bold_C = ( italic_g ( italic_x ) ), where gâ¢(x)ğ‘”ğ‘¥g(x)italic_g ( italic_x ) is the monic polynomial with the lowest degree, then gâ¢(x)ğ‘”ğ‘¥g(x)italic_g ( italic_x ) must be a divisor of xnâˆ’1superscriptğ‘¥ğ‘›1x^{n}-1italic_x start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 and is called the generator polynomial of ğ‚ğ‚{\bf C}bold_C, and hâ¢(x)=xnâˆ’1gâ¢(x)â„ğ‘¥superscriptğ‘¥ğ‘›1ğ‘”ğ‘¥h(x)=\frac{x^{n}-1}{g(x)}italic_h ( italic_x ) = divide start_ARG italic_x start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT - 1 end_ARG start_ARG italic_g ( italic_x ) end_ARG is referred to as the check polynomial of ğ‚ğ‚{\bf C}bold_C. The dual code ğ‚âŸ‚superscriptğ‚perpendicular-to{\bf C}^{\perp}bold_C start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT of a cyclic code ğ‚ğ‚{\bf C}bold_C with generator polynomial gâ¢(x)ğ‘”ğ‘¥g(x)italic_g ( italic_x ) is the cyclic code with the generator polynomial hâŸ‚â¢(x)=xkâ¢hâ¢(xâˆ’1)hâ¢(0)superscriptâ„perpendicular-toğ‘¥superscriptğ‘¥ğ‘˜â„superscriptğ‘¥1â„0h^{\perp}(x)=\frac{x^{k}h(x^{-1})}{h(0)}italic_h start_POSTSUPERSCRIPT âŸ‚ end_POSTSUPERSCRIPT ( italic_x ) = divide start_ARG italic_x start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT italic_h ( italic_x start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) end_ARG start_ARG italic_h ( 0 ) end_ARG, which is the reciprocal polynomial of the check polynomial hâ¢(x)â„ğ‘¥h(x)italic_h ( italic_x ) of ğ‚ğ‚{\bf C}bold_C. Cyclic codes, in particular, the Bose-Chaudhuri-Hocquenghem (BCH) codes introduced in 1959-1960 (see [3, 4, 9]), are the most important type of linear codes in coding theory and practice due to the following: â€¢ They have the cyclic structure and the efficient Berlekamp-Massey decoding algorithm. â€¢ They (in particular, the cyclic Reed-Solomon codes) are widely used in communications and data storage systems. â€¢ They are closely related to combinatorics, number theory, group theory and many other areas of mathematics. For similar reasons, the Euclidean and Hermitian self-dual cyclic codes are more interesting than other Euclidean and Hermitian self-dual non-cyclic linear codes. This explains why we are more interested in Euclidean and Hermitian self-dual cyclic codes. The construction and decoding of cyclic and BCH codes have been extensively studied in the literature (see [14, Chapters 3, 7, 8, 9], [10, Chapters 4, 5, 6], and [22, Chapter 6]). The total number of references on cyclic codes in the literature is huge and this shows the importance of cyclic codes in another sense. 1.3 The motivations and objectives of this paper A lower bound on the minimum distance of an [n,k,d]qsubscriptğ‘›ğ‘˜ğ‘‘ğ‘[n,k,d]_{q}[ italic_n , italic_k , italic_d ] start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT code is called the square-root lower bound if it is nğ‘›\sqrt{n}square-root start_ARG italic_n end_ARG, and a square-root-like lower bound if it is at least câ¢nğ‘ğ‘›c\sqrt{n}italic_c square-root start_ARG italic_n end_ARG for a fixed positive constant cğ‘citalic_c and fixed qğ‘qitalic_q. Self-dual codes have been a very hot and interesting topic partially due to the following: â€¢ Some of them support combinatorial 5555-designs. For example, the extended binary and ternary Golay codes and some Pless symmetry codes are such codes [5, 10]. â€¢ They are related to invariant theory [15]. â€¢ They have applications in quantum error-correcting codes [15]. To the best knowledge of the authors, known infinite families of self-dual codes with unbounded length nğ‘›nitalic_n and minimum distance dâ‰¥nğ‘‘ğ‘›d\geq\sqrt{n}italic_d â‰¥ square-root start_ARG italic_n end_ARG are the following: 1. The extended codes of odd-like quadratic residue codes [10], which are not cyclic. 2. The Pless symmetry codes [16, 5], which are not cyclic. 3. The generalized Reed-Muller code of order [mâ¢(qâˆ’1)âˆ’1]/2delimited-[]ğ‘šğ‘112[m(q-1)-1]/2[ italic_m ( italic_q - 1 ) - 1 ] / 2 over ğ…qsubscriptğ…ğ‘{\bf F}_{q}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT with parameters [qm,qm/2,[(q+2)/2]â¢q(mâˆ’1)/2]superscriptğ‘ğ‘šsuperscriptğ‘ğ‘š2delimited-[]ğ‘22superscriptğ‘ğ‘š12[q^{m},q^{m}/2,[(q+2)/2]q^{(m-1)/2}][ italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT , italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT / 2 , [ ( italic_q + 2 ) / 2 ] italic_q start_POSTSUPERSCRIPT ( italic_m - 1 ) / 2 end_POSTSUPERSCRIPT ], where mğ‘šmitalic_m is odd and q=2sğ‘superscript2ğ‘ q=2^{s}italic_q = 2 start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT with a positive integer sğ‘ sitalic_s [2, Theorem 5.8, Theorem 5.25], which are not cyclic. 4. A family of negacyclic codes over ğ…qsubscriptğ…ğ‘{\bf F}_{q}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT with parameters (see [20]) [qmâˆ’12,qmâˆ’14,d],superscriptğ‘ğ‘š12superscriptğ‘ğ‘š14ğ‘‘\left[\frac{q^{m}-1}{2},\frac{q^{m}-1}{4},d\right],[ divide start_ARG italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT - 1 end_ARG start_ARG 2 end_ARG , divide start_ARG italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT - 1 end_ARG start_ARG 4 end_ARG , italic_d ] , where qğ‘qitalic_q is an odd prime power, mâ‰¥2ğ‘š2m\geq 2italic_m â‰¥ 2 is an integer, qmâ‰¡1(mod4)superscriptğ‘ğ‘šannotated1pmod4q^{m}\equiv 1\pmod{4}italic_q start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT â‰¡ 1 start_MODIFIER ( roman_mod start_ARG 4 end_ARG ) end_MODIFIER and d={qm/2ifâ¢mâ¢isâ¢even,(q+34)â¢q(mâˆ’1)/2ifâ¢mâ¢isâ¢odd.ğ‘‘casessuperscriptğ‘ğ‘š2ifğ‘šisevenğ‘34superscriptğ‘ğ‘š12ifğ‘šisodd\displaystyle d=\begin{cases}q^{m/2}~{}&{\rm if}~{}m~{}{\rm is~{}even},\\ (\frac{q+3}{4})q^{(m-1)/2}~{}&{\rm if}~{}m~{}{\rm is~{}odd}.\end{cases}italic_d = { start_ROW start_CELL italic_q start_POSTSUPERSCRIPT italic_m / 2 end_POSTSUPERSCRIPT end_CELL start_CELL roman_if italic_m roman_is roman_even , end_CELL end_ROW start_ROW start_CELL ( divide start_ARG italic_q + 3 end_ARG start_ARG 4 end_ARG ) italic_q start_POSTSUPERSCRIPT ( italic_m - 1 ) / 2 end_POSTSUPERSCRIPT end_CELL start_CELL roman_if italic_m roman_is roman_odd . end_CELL end_ROW Notice that all the families of self-dual codes above are not cyclic. Hence, no infinite family of self-dual cyclic codes whose minimum distances are better than the square-root bound are known in the literature. The main motivation of this paper is the lack of such an infinite family of self-dual cyclic codes. While it is hard to construct an infinite family of self-dual cyclic codes with the square-root lower bound, it is natural for people to construct an infinite family of self-dual cyclic codes with a square-root-like lower bound. In 2009, an important progress in this direction was made and an infinite family of binary self-dual cyclic codes with length n=2â¢(22â¢a+1âˆ’1)ğ‘›2superscript22ğ‘11n=2(2^{2a+1}-1)italic_n = 2 ( 2 start_POSTSUPERSCRIPT 2 italic_a + 1 end_POSTSUPERSCRIPT - 1 ) and minimum distance Î´â‰¥12â¢n+2ğ›¿12ğ‘›2\delta\geq\frac{1}{2}\sqrt{n+2}italic_Î´ â‰¥ divide start_ARG 1 end_ARG start_ARG 2 end_ARG square-root start_ARG italic_n + 2 end_ARG were constructed by Heijne and Top [8]. Constructing infinite families of self-dual cyclic codes with a square-root-like lower bound is not easy and is thus the second motivation of this paper. The objectives of this paper are the following: â€¢ Generalize earlier results on the construction of binary cyclic codes. â€¢ Present a new method for constructing self-dual linear codes. â€¢ Construct infinite families of Euclidean and Hermitian self-dual cyclic codes with a square-root-like lower bound. â€¢ Construct infinite families of Euclidean self-dual linear codes with a square-root-like lower bound. 1.4 The organization of this paper The rest of this paper is arranged as follows. Section 2 generalises the van Lint construction of the repeated-root binary cyclic code of length 2â¢n2ğ‘›2n2 italic_n for odd nğ‘›nitalic_n, and develops a generalised van Lint construction. Section 3 presents a [ğ®|ğ®+ğ¯]delimited-[]conditionalğ®ğ®ğ¯[{\bf u}|{\bf u}+{\bf v}][ bold_u | bold_u + bold_v ] construction of Euclidean and Hermitian self-dual cyclic codes over ğ…2ssubscriptğ…superscript2ğ‘ {\mathbf{{F}}}_{2^{s}}bold_F start_POSTSUBSCRIPT 2 start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT end_POSTSUBSCRIPT via the generalised van Lint theorem. Section 4 recalls two families of dual-containing BCH codes. Section 5 constructs families of Euclidean and Hermitian self-dual cyclic codes with a square-root-like lower bound on their minimum distances. Section 6 constructs a family of Euclidean self-dual linear codes over ğ…qsubscriptğ…ğ‘{\mathbf{{F}}}_{q}bold_F start_POSTSUBSCRIPT italic_q end_POSTSUBSCRIPT for qâ‰¡1(mod4)ğ‘annotated1pmod4q\equiv 1\pmod{4}italic_q â‰¡ 1 start_MODIFIER ( roman_mod start_ARG 4 end_ARG ) end_MODIFIER with a square-root-like lower bound on their minimum distances. Section 7 presents a family of self-dual binary cyclic codes with a square-root-like lower bound. Section 8 provides information on some self-dual linear codes with a square-root-like lower bound. Section 9 summarises the contributions of this paper and makes some concluding remarks."
https://arxiv.org/html/2411.03265v1,Information geometry of diffeomorphism groups,"The study of diffeomorphism groups and their applications to problems in analysis and geometry has a long history. In geometric hydrodynamics, pioneered by V. Arnold in the 1960s, one considers an ideal fluid flow as the geodesic motion on the infinite-dimensional group of volume-preserving diffeomorphisms of the fluid domain with respect to the metric defined by the kinetic energy. Similar considerations on the space of densities lead to a geometric description of optimal mass transport and the Kantorovich-Wasserstein metric. Likewise, information geometry associated with the Fisher-Rao metric and the Hellinger distance has an equally beautiful infinite-dimensional geometric description and can be regarded as a higher-order Sobolev analogue of optimal transportation. In this work we review various metrics on diffeomorphism groups relevant to this approach and introduce appropriate topology, smooth structures and dynamics on the corresponding infinite-dimensional manifolds. Our main goal is to demonstrate how, alongside topological hydrodynamics, Hamiltonian dynamics and optimal mass transport, information geometry with its elaborate toolbox has become yet another exciting field for applications of geometric analysis on diffeomorphism groups.","Chapter 1 Introduction One of the most prominent features of the geometric approach to hydrodynamics pioneered by V. Arnold [6] is based on the observation that the group of volume-preserving diffeomorphisms of the fluid domain has a structure of an infinite dimensional Riemannian manifold and can serve as a natural configuration space for the motions of ideal fluids. The geodesic flow on this group, which is induced by the L2superscriptğ¿2L^{2}italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT inner product corresponding to the fluidâ€™s kinetic energy, describes solutions of the Euler equations of an incompressible and inviscid fluid. The general framework of Arnold turned out to include a variety of other nonlinear partial differential equations of mathematical physics and are now often referred to as the Euler-Arnold equations. The associated L2superscriptğ¿2L^{2}italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT metric on the diffeomorphism group also happened to be relevant in another rapidly developing mathematical field, namely, the theory of optimal mass transport. Subsequently, a similar geometric approach to diffeomorphism groups, albeit related to the Sobolev H1superscriptğ»1H^{1}italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT inner product, shed new light on some of the most fundamental notions in geometric statistics and information theory. In this short book we concentrate on such L2superscriptğ¿2L^{2}italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT and H1superscriptğ»1H^{1}italic_H start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT type metrics on diffeomorphism groups and their quotient spaces viewed as spaces of densities. We have three principal goals. First of all, we focus on developing a firm basis for the formalism of tame FrÃ©chet spaces for diffeomorphism groups and demonstrate their utility in geometric hydrodynamics, information geometry, and the study of probability density spaces. In their classical paper [28] D. Ebin and J. Marsden worked out a rigorous analytical formalism for ideal hydrodynamics using Sobolev Hssuperscriptğ»ğ‘ H^{s}italic_H start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT spaces with a finite smoothness index sğ‘ sitalic_s. While this approach provides a convenient reformulation of the incompressible Euler equations of fluid dynamics as a system of ordinary differential equations on a Banach manifold, it is not free from various technical difficulties making it impossible to take full advantage of the geometric formulation or extending it to other settings. One such important obstacle is the loss of some of the most useful Lie group properties of the underlying configuration space - inevitable in the case of function spaces with bounded smoothness properties. Indeed, while right compositions with Sobolev diffeomorphisms are always smooth in the Hssuperscriptğ»ğ‘ H^{s}italic_H start_POSTSUPERSCRIPT italic_s end_POSTSUPERSCRIPT topology, left compositions turn out to be merely continuous due to the obvious loss of derivatives. On the other hand, a carefully developed formalism of tame FrÃ©chet spaces on diffeomorphism groups allows one to retain the desired regularity properties and regard both compositions on the left and on the right as smooth operations in this setting. The second goal of this work is to survey some of the recent progress in information geometry. To this end we include a thorough review of the geometry of the Fisher-Rao metric, discuss its uniqueness, compare it with the Wasserstein metric in optimal mass transport and recall the decompositions of matrices and diffeomorphisms related to the Fisherâ€“Rao geometry. We describe the corresponding geodesics as well as relations between entropy and the Fisher information functional and the Madelung transport and the SchrÃ¶dinger equation of quantum mechanics. We also describe the geometry underlying the Amari-Chentsov connections in information geometry. Finally, we present several new results related to the Euler-Arnold equations. These equations, describing the geodesic flows on Lie groups with respect to one-sided invariant metrics, are known to include many interesting equations of mathematical physics. We give examples of derivations of these equations and, in particular, demonstrate how the general Camassa-Holm equation can be obtained from a sub-Riemannian metric on the group of circle diffeomorphisms and as a geodesic equation on the extension of this group by a trivial two-cocycle. The corresponding construction turns out to be simpler than the Virasoro group and results in geometrically identical but analytically different equations. In Section 2 we start with a detailed background introducing appropriate tame FrÃ©chet topology and smooth structures on infinite dimensional manifolds with an eye to a future application to diffeomorphism groups and density spaces. This will provide a firm basis to all the relevant differential-geometric and dynamical considerations in Section 3. We continue in Section 4 by equipping these spaces with Riemannian metrics, as an outlook of the Euler-Arnold equations and the geodesic flows of one-sided invariant metrics on Lie groups in finite and infinite dimensions. We present both the Lagrangian and the Hamiltonian side of the story and discuss how these structures induce interesting dynamical systems on certain quotient spaces. In particular, we show how the L2superscriptğ¿2L^{2}italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT metric on the group of diffeomorphisms naturally descends to the celebrated Wasserstein metric on the space of densities whose geodesics describe the optimal mass transfer. Several equations including Burgersâ€™ equation and the Camassa-Holm equation are discussed in more detail. The general Camassaâ€“Holm equation is derived as a geodesic equation of a right-invariant metric on a trivial extension of the group of circle diffeomorphisms. On the other hand, the Fisher-Rao metric of geometric statistics turns out to be closely related to homogeneous Sobolev HË™1superscriptË™ğ»1\dot{H}^{1}overË™ start_ARG italic_H end_ARG start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT right-invariant Riemannian metrics on the full diffeomorphism group. This is the main subject of Section 5. In the setting of diffeomorphism groups, information geometry associated with the Fisher-Rao metric and its spherical Hellinger distance can be viewed as an HË™1superscriptË™ğ»1\dot{H}^{1}overË™ start_ARG italic_H end_ARG start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT-analogue of the standard optimal mass transport. We describe this geometry in detail and discuss properties of solutions of the associated geodesic equations in Section 6. It turns out that the geometry of the space of densities is spherical irrespective of the underlying compact manifold Mğ‘€Mitalic_M, while the corresponding Euler-Arnold equation is a natural generalization of the completely integrable one-dimensional Hunter-Saxton equation. Lastly, in Section 7 we present geometric constructions of the so-called Î±ğ›¼\alphaitalic_Î±-connections introduced in geometric statistics by Chentsov [21] and Amari [1]. We also describe their generalizations to diffeomorphism groups of higher-dimensional manifolds. The book concludes with an Appendix A with some useful background information on Banach completions of manifolds of maps. We should point out that in the literature there exist other sources which present information geometry from a different perspective and develop alternative settings for infinite dimensional manifolds; e.g., see the books and surveys [2, 3, 4, 8, 21, 22, 59, 80, 81, 89]. We hope that the approach developed in this book places information geometry squarely within the general differential-geometric framework of diffeomorphism groups as it was envisioned at various times and contexts by H. Cartan, A.N. Kolmogorov, L. Kantorovich and V. Arnold and which includes hydrodynamics, symplectic geometry, optimal transport etc.. Our approach here lays down foundations for an infinite dimensional generalization of this fast-growing subject which will hopefully lead to further fruitful developments. Acknowledgements. We are indebted to Martin Bauer, Peter Michor, Stephen Preston and other participants of â€œMath en plein airâ€ series of workshops. BK is grateful to the IHES (Bures-sur-Yvette, France) for its kind hospitality and support. He was also partially supported by an NSERC Discovery Grant. KM was supported by the Swedish Research Council (grant 2022-03453) and the Knut and Alice Wallenberg Foundation (grant WAF2019.0201)."
https://arxiv.org/html/2411.02827v1,Hybrid Beamforming for Integrated Sensing and Communications With Low Resolution DACs,"Integrated sensing and communications (ISAC) has emerged as a means to efficiently utilize spectrum and thereby save cost and power. At the higher end of the spectrum, ISAC systems operate at wideband using large antenna arrays to meet the stringent demands for high-resolution sensing and enhanced communications capacity. On the other hand, the overall design should satisfy energy-efficiency and hardware constraints such as operating on low resolution components for a practical scenario. Therefore, this paper presents the design of Hybrid ANalog and Digital BeAmformers with Low resoLution (HANDBALL) digital-to-analog converters (DACs). We introduce a greedy-search-based approach to design the analog beamformers for multi-user multi-target ISAC scenario. Then, the quantization distortion is taken into account in order to design the baseband beamformer with low resolution DACs. We evaluated performance of the proposed HANDBALL technique in terms of both spectral efficiency and sensing beampattern, providing a satisfactory sensing and communication performance for both one-bit and few-bit designs.","Integrated sensing and communications (ISAC) is considered as one of the vital technologies for deploying the next generation wireless networks as it provides joint sensing and communications (S&C) functionalities in a common hardware over a shared spectrum [1]. This has led to a great amount of research efforts by both academia and industry on the implementations and standardization activities of ISAC. The ISAC platforms are expected to achieve satisfactory performance for both S&C, which include achieving reliable communication rate while delivering sufficient power to illuminate the sensing targets [2]. Therefore, large antenna arrays are deployed at the transmitter to achieve high beamforming gain in massive multiple-input multiple-output (MIMO) configurations [3]. At millimeter-wave (mmWave) frequencies, large antenna arrays allow signal transmission with high data rates thanks to large bandwidth and provide high resolution target resolution capabilities. Unfortunately, the high hardware cost and power consumption makes it difficult to realize fully digital (FD) data transmission with a dedicated radio-frequency (RF) chain per antenna in the array. To overcome this challenge, hybrid analog/digital beamformers are employed in order to achieve a cost-effective solution [4]. A common limitation of hybrid architectures is employing high resolution digital-to-analog converters (DACs), which consume high power at mmWave. For instance, a mmWave massive MIMO system with 512512512512 high resolution (8-12 bits) DACs, the total power consumption is about 256256256256 W [5]. Thus, low resolution DACs (1-4 bits) lead to an alternative design to further reduce the power consumption as it grows exponentially with resolution [6]. In the literature, there exist several works on the design of hybrid beamformers with low resolution data converters. For instance, low resolution DAC design is considered in [4] via both the inversion as well as the singular value decomposition (SVD) of the channel matrix for mmWave massive MIMO. Also in [7], one-bit DACs are designed for hybrid beamforming based on Bussgang theorem. Similarly, an SVD-based approach is studied in [8] by investigating the energy-efficiency (EE) of the overall MIMO system based on additive quantization noise model (AQNM). In [9], an alternating optimization approach is proposed to design hybrid beamformers with both one-bit DAC and finite-quantized phase shifters. The aforementioned works mostly focus on communication-only systems [4, 7, 8, 9], whereas hybrid beamforming with low resolution data converters is rather unexamined for ISAC paradigm. A few recent works consider the ISAC scenario with FD processing rather than hybrid analog/digital beamforming. For instance, [10] and [11] consider FD beamformers with low resolution DACs for rate-splitting multiple access (RSMA) in ISAC with EE optimization. While hybrid beamforming is studied in [12] for single-user multi-target ISAC, the quantized DAC output is only considered for communication-only beamformer design, which degrades the overall S&C performance. In this work, we propose a Hybrid ANalog and Digital BeAmformers with Low resoLution (HANDBALL) approach for multi-user multi-target ISAC scenario. The proposed approach takes into account the covariance of the quantization distortion for both one-bit and few-bit designs based on both Bussgang Theorem [13] and the AQNM [14, 4]. In order to design the analog beamformers, we introduce a greedy-search (GS)-based approach, wherein the overall analog beamformer is split into two portions: communication-only and sensing-only beamformers. Then, we design the baseband beamformer with low resolution DAC by taking into account the quantization distortion. Via numerical simulations, we show that our HANDBALL approach provides satisfactory performance in terms of both communication SE and the sensing beampattern. Notation: Throughout the paper, (â‹…)âˆ—superscriptâ‹…(\cdot)^{*}( â‹… ) start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT, (â‹…)Tsuperscriptâ‹…T(\cdot)^{\textsf{T}}( â‹… ) start_POSTSUPERSCRIPT T end_POSTSUPERSCRIPT and (â‹…)Hsuperscriptâ‹…H(\cdot)^{\textsf{H}}( â‹… ) start_POSTSUPERSCRIPT H end_POSTSUPERSCRIPT denote the conjugate, transpose and conjugate transpose operations, respectively. For a matrix ğ€ğ€\mathbf{A}bold_A; [ğ€]iâ¢jsubscriptdelimited-[]ğ€ğ‘–ğ‘—[\mathbf{A}]_{ij}[ bold_A ] start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT and [ğ€]ksubscriptdelimited-[]ğ€ğ‘˜[\mathbf{A}]_{k}[ bold_A ] start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT correspond to the (i,j)ğ‘–ğ‘—(i,j)( italic_i , italic_j )-th entry and the kğ‘˜kitalic_k-th column while ğ€â€ superscriptğ€â€ \mathbf{A}^{\dagger}bold_A start_POSTSUPERSCRIPT â€  end_POSTSUPERSCRIPT denotes the Moore-Penrose pseudo-inverse of ğ€ğ€\mathbf{A}bold_A. A unit matrix of size Nğ‘Nitalic_N is represented by ğˆNsubscriptğˆğ‘\mathbf{I}_{N}bold_I start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT, and ğ’¬â¢(â‹…)ğ’¬â‹…\mathcal{Q}(\cdot)caligraphic_Q ( â‹… ) and Trâ¢{â‹…}Trâ‹…\mathrm{Tr}\{\cdot\}roman_Tr { â‹… } denote the quantization and trace operations, respectively. ||â‹…||â„±||\cdot||_{\mathcal{F}}| | â‹… | | start_POSTSUBSCRIPT caligraphic_F end_POSTSUBSCRIPT denotes the Frobenious norm while âŠ™direct-product\odotâŠ™ and âŠ—tensor-product\otimesâŠ— denote Khatri-Rao and Kronecker products, respectively. Figure 1: The ISAC hybrid beamforming architecture with low-resolution DACs."
https://arxiv.org/html/2411.02817v1,Conditional Vendi Score: An Information-Theoretic Approach to Diversity Evaluation of Prompt-based Generative Models,"Text-conditioned generation models are commonly evaluated based on the quality of the generated data and its alignment with the input text prompt. On the other hand, several applications of prompt-based generative models require sufficient diversity in the generated data to ensure the modelsâ€™ capability of generating image and video samples possessing a variety of features. However, most existing diversity metrics are designed for unconditional generative models, and thus cannot distinguish the diversity arising from variations in text prompts and that contributed by the generative model itself. In this work, our goal is to quantify the prompt-induced and model-induced diversity in samples generated by prompt-based models. We propose an information-theoretic approach for internal diversity quantification, where we decompose the kernel-based entropy Hâ¢(X)ğ»ğ‘‹H(X)italic_H ( italic_X ) of the generated data Xğ‘‹Xitalic_X into the sum of the conditional entropy Hâ¢(X|T)ğ»conditionalğ‘‹ğ‘‡H(X|T)italic_H ( italic_X | italic_T ), given text variable Tğ‘‡Titalic_T, and the mutual information Iâ¢(X;T)ğ¼ğ‘‹ğ‘‡I(X;T)italic_I ( italic_X ; italic_T ) between the text and data variables. We introduce the Conditional-Vendi score based on Hâ¢(X|T)ğ»conditionalğ‘‹ğ‘‡H(X|T)italic_H ( italic_X | italic_T ) to quantify the internal diversity of the model and the Information-Vendi score based on Iâ¢(X;T)ğ¼ğ‘‹ğ‘‡I(X;T)italic_I ( italic_X ; italic_T ) to measure the statistical relevance between the generated data and text prompts. We provide theoretical results to statistically interpret these scores and relate them to the unconditional Vendi score. We conduct several numerical experiments to show the correlation between the Conditional-Vendi score and the internal diversity of text-conditioned generative models. The codebase is available at https://github.com/mjalali/conditional-vendi.","Prompt-based generative models, including text-to-image and text-to-video generation schemes, are widely used in various artificial intelligence (AI) applications. In prompt-based generative AI, the sample creation process begins with a text input and produces a random output aligned with that text. The conditional nature of this sample generation distinguishes prompt-based generative models from standard unconditional generative models where the objective is to produce samples distributed similarly to real data without any guiding input prompt. Since most evaluation metrics for generative models had been developed for unconditional models in the previous decade, the recent literature has sought to create scores tailored specifically for text-conditioned generative models. The existing evaluation metrics for prompt-based generative models typically focus on fidelity and relevance in sample generation, i.e., they assess the visual quality of the produced samples and their alignment with the input prompt. Relevance is often measured by calculating a similarity score between a shared embedding of the text and image samples, e.g. in ClipScore [1] which utilizes the CLIP embeddings of text and image data. Such shared embedding-based evaluation mechanisms have been further adapted to quantify the aesthetics, semantic consistency, and compositional accuracy of the generated data based on the input text prompt. On the other hand, the diversity performance of prompt-based generative models has not been exclusively studied in the literature. The diversity scores proposed for unconditional generative models, such as Recall [2, 3], Coverage [4], Vendi [5, 6], and RKE [7], are often applied to quantify the variety of generated samples. However, in text-based generative models, the generated samples are typically produced in response to different input prompts, where the variation in input texts can significantly contribute to the diversity of the generated image or video samples. Thus, the diversity of data produced by prompt-based models is influenced by two main factors: 1) the variety of input prompts, and 2) the internal diversity of the model introducing randomness into the output samples. Figure 1 illustrates examples of prompt-induced diversity, where the variety of generated images is mostly due to the different prompts and the generated data has little variety in other details (images of similar people with similar poses), and model-induced diversity where the details not specified by the prompts vary significantly between generated images. This decomposition of diversity in text-based generative models has not been studied in the existing literature on conditional generative models including text-based image and video generation. In this work, we focus on quantifying the two diversity components mentioned for prompt-based generative models. To this end, we propose an information-theoretic decomposition of the diversity of the modelâ€™s output data, Xğ‘‹Xitalic_X. The proposed decomposition is based on a classical identity in information theory, which shows that for variables Xğ‘‹Xitalic_X and Tğ‘‡Titalic_T, the Shannon entropy Hâ¢(X)ğ»ğ‘‹H(X)italic_H ( italic_X ), representing the uncertainty of Xğ‘‹Xitalic_X, can be decomposed into two terms as follows: Hâ¢(X)=Hâ¢(X|T)+Iâ¢(X;T)ğ»ğ‘‹ğ»conditionalğ‘‹ğ‘‡ğ¼ğ‘‹ğ‘‡H(X)\;=\;H\bigl{(}X|T\bigr{)}+I\bigl{(}X;T\bigr{)}italic_H ( italic_X ) = italic_H ( italic_X | italic_T ) + italic_I ( italic_X ; italic_T ) Here, Hâ¢(X|T)ğ»conditionalğ‘‹ğ‘‡H(X|T)italic_H ( italic_X | italic_T ) denotes the conditional entropy of data Xğ‘‹Xitalic_X given the text variable Tğ‘‡Titalic_T, which we interpret as the internal diversity of the text-based generative model not caused by variation in the input text Tğ‘‡Titalic_T. Furthermore, the mutual information term Iâ¢(X;T)ğ¼ğ‘‹ğ‘‡I(X;T)italic_I ( italic_X ; italic_T ) can be viewed as a measure of statistical relevance between the text Tğ‘‡Titalic_T and the generated data Xğ‘‹Xitalic_X, quantifying how much information the modelâ€™s output conveys about the input text. Figure 1: Illustration of prompt-induced diversity, where the diversity of generated images follows the variety of prompts and has little variation in other details, vs. model-induced diversity, where the diversity of images for similar prompts is due to the generation model. To mathematically define the entropy-based scores, we follow the kernel-matrix-based entropy definition, which has been applied by [5, 7, 6] to unconditional generative models. These references apply the matrix-based entropy in quantum information theory, that is the entropy of the eigenvalues of the kernel matrix of generated data Xğ‘‹Xitalic_X, to measure the diversity of an unconditional modelâ€™s generated data. To extend the framework to conditional prompt-based generative models, we utilize the definition of matrix-based conditional entropy proposed by [8]. This work provides a definition for the conditional entropy of two general positive semi-definite matrices, which we select to be the kernel matrices of generated data Xğ‘‹Xitalic_X and text Tğ‘‡Titalic_T. Following these definitions, our work extends the entropy-based approach in [5, 7] to conditional generative models. We define the Conditional-Vendi and Information-Vendi scores which decompose the unconditional Vendi score to model-induced and prompt-induced diversity measures. To statistically interpret the defined scores, we first derive the statistic estimated by these scores from empirically generated samples. We show how the target statistic can be formulated in terms of the kernel covariance matrix of the Kronecker product of text Tğ‘‡Titalic_T and data Xğ‘‹Xitalic_X vectors. Also, to provide an operational meaning for the proposed score, we prove that given a mixture distribution PTsubscriptğ‘ƒğ‘‡P_{T}italic_P start_POSTSUBSCRIPT italic_T end_POSTSUBSCRIPT for text data with a hidden group variable Gâˆˆ{1,â€¦,m}ğº1â€¦ğ‘šG\in\{1,\ldots,m\}italic_G âˆˆ { 1 , â€¦ , italic_m }, the defined conditional entropy approximates the expectation of the entropy Hâ¢(X|G=g)ğ»conditionalğ‘‹ğºğ‘”H(X|G=g)italic_H ( italic_X | italic_G = italic_g ) given prompt type gâˆ¼PGsimilar-toğ‘”subscriptğ‘ƒğºg\sim P_{G}italic_g âˆ¼ italic_P start_POSTSUBSCRIPT italic_G end_POSTSUBSCRIPT. This result connects our proposed diversity assessment approach to the Vendi [5, 6] and RKE [7] scores, showing that the Conditional-Vendi score is an aggregation of the unconditional Vendi scores for different prompt groups. We numerically evaluate the proposed diversity scores for standard text-to-image, text-to-video, and image-captioning generative models. In our experiments, we simulate text-based generative models for which the ground-truth rankings of internal diversity and relevance are known. Our experimental results validate the consistency of our proposed information-theoretic scores and the ground-truth ranking of the models. We further decompose the Conditional-Vendi score across different modes of input text data, evaluating the modelsâ€™ internal diversity across different types of input text. The following is a summary of the contributions of this work: â€¢ Highlighting the diversity evaluation task in the context of conditional and prompt-based generative models, â€¢ Proposing an information-theoretic framework for decomposing the diversity of generated data into prompt-induced and model-induces components to evaluate the internal diversity of prompt-based generative models â€¢ Providing statistical analysis of the proposed scores and interpreting them as the conditional expectation of entropy scores given the text prompt â€¢ Presenting numerical results on the consistency between the conditional entropy score and the model-induced diversity of text-to-image and text-to-video generative models."
https://arxiv.org/html/2411.02707v1,Phase Group Category of Bimodule Quantum Channels,"In this paper, we study the quantum channel on a von Neuamnn algebras â„³â„³\mathcal{M}caligraphic_M preserving a von Neumann subalgebra ğ’©ğ’©\mathcal{N}caligraphic_N, namely ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodule unital completely positive map. By introducing the relative irreducibility of a bimodule quantum channel, we show that its eigenvalues with modulus 1 form a finite cyclic group, called its phase group. Moreover, the corresponding eigenspaces are invertible ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodules, which encode a categorification of the phase group. When ğ’©âŠ‚â„³ğ’©â„³\mathcal{N}\subset\mathcal{M}caligraphic_N âŠ‚ caligraphic_M is a finite-index irreducible subfactor of type II1, we prove that any bimodule quantum channel is relative irreducible for the intermediate subfactor of its fixed points. In addition, we can reformulate and prove these results intrinsically in subfactor planar algebras without referring to the subfactor using the methods of quantum Fourier analysis.","Quantum channels are widely studied in quantum information. In finite dimensional systems, a quantum channel is a trace-preserving completely positive map acting on matrix algebras. In infinite dimensional system, a von Neumann algebras â„³â„³\mathcal{M}caligraphic_M is generated by observables, which may not have trace. A quantum channel is a unital completely positive map on â„³â„³\mathcal{M}caligraphic_M in the Heisenberg picture. Furthermore, we study quantum channels with symmetry ğ’©ğ’©\mathcal{N}caligraphic_N as ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodule maps for a von Neumann subalgebra ğ’©ğ’©\mathcal{N}caligraphic_N. There are various motivations to study ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodule maps. One can consider ğ’©ğ’©\mathcal{N}caligraphic_N as conserved quantities preserved by quantum channels; such a quantum channel can be reformulated as a unital completely positive ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodule map by Kadison-Schwarz inequality. In quantum Markov process [7, 10, 24], we can consider ğ’©ğ’©\mathcal{N}caligraphic_N as observables in the past invariant under the quantum channel at the current time. In subfactor theory, when ğ’©âŠ†â„³ğ’©â„³\mathcal{N}\subseteq\mathcal{M}caligraphic_N âŠ† caligraphic_M is a subfactor, ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N bimodules are well studied. In quantum field theory, one can consider ğ’©ğ’©\mathcal{N}caligraphic_N as the observables in a local region, we refer to [19]. In classical Markov progress, Perron-Frobenius theorem is very fundamental. Evans and HÃ¸egh-Krohn [8] generalized this theorem to irreducile quantum channels on finite dimensional von Neumann algebras, which is called quantum Perron-Frobenius theorem. In this paper, we study bimodule quantum channels with quantum symmetry ğ’©ğ’©\mathcal{N}caligraphic_N and establish the Perron-Frobenius theorem with quantum symmetries, which could be infinite dimensional. Theorem 1.1 (See Theorem 3.19 and Theorem 5.10). Suppose that ğ’©âŠ†â„³ğ’©â„³\mathcal{N}\subseteq\mathcal{M}caligraphic_N âŠ† caligraphic_M is finite index and Î¦Î¦\Phiroman_Î¦ is a relative irreducible bimodule quantum channel. Suppose ğ’©ğ’©\mathcal{N}caligraphic_N is a factor. Then the eigenvalues of Î¦Î¦\Phiroman_Î¦ with modulus 1111 forms a finite cyclic group, which we call phase group. Here, our notation of relative irreduciblility for Î¦Î¦\Phiroman_Î¦ means that Î¦â¢(p)â©½Î»â¢pÎ¦ğ‘ğœ†ğ‘\Phi(p)\leqslant\lambda proman_Î¦ ( italic_p ) â©½ italic_Î» italic_p implies pâˆˆğ’©ğ‘ğ’©p\in\mathcal{N}italic_p âˆˆ caligraphic_N for any projection pâˆˆâ„³ğ‘â„³p\in\mathcal{M}italic_p âˆˆ caligraphic_M. The relative irreducibility reduces to the irreducibility introduced by Evans and HÃ¸egh-Krohn [8] when ğ’©=â„‚â¢ğŸğ’©â„‚1\mathcal{N}=\mathbb{C}\mathbf{1}caligraphic_N = blackboard_C bold_1. The finite-index condition means that the inclusion ğ’©âŠ†â„³ğ’©â„³\mathcal{N}\subseteq\mathcal{M}caligraphic_N âŠ† caligraphic_M is finite index if there exists a conditional expectation Eğ’©subscriptğ¸ğ’©E_{\mathcal{N}}italic_E start_POSTSUBSCRIPT caligraphic_N end_POSTSUBSCRIPT and Î»>0ğœ†0\lambda>0italic_Î» > 0 such that the Pimsner-Popa inequality holds [22]: Eğ’©â¢(x)â©¾Î»â¢x, for all â¢xâˆˆâ„³+.formulae-sequencesubscriptğ¸ğ’©ğ‘¥ğœ†ğ‘¥ for all ğ‘¥superscriptâ„³\displaystyle E_{\mathcal{N}}(x)\geqslant\lambda x,\quad\text{ for all }x\in% \mathcal{M}^{+}.italic_E start_POSTSUBSCRIPT caligraphic_N end_POSTSUBSCRIPT ( italic_x ) â©¾ italic_Î» italic_x , for all italic_x âˆˆ caligraphic_M start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT . The best constant Î»âˆ’1superscriptğœ†1\lambda^{-1}italic_Î» start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT for the minimal conditional expectation is the Jones index. When ğ’©=â„‚â¢ğŸğ’©â„‚1\mathcal{N}=\mathbb{C}\mathbf{1}caligraphic_N = blackboard_C bold_1 and â„³â„³\mathcal{M}caligraphic_M is finite dimensional, Theorem 1.1 reduces to the quantum Frobenius theorem of Evans and HÃ¸egh-Krohn. They also proved that the eigenspace at each phase is one dimensional and it is generated by a unitary. In our case, the eigenspace of Î¦Î¦\Phiroman_Î¦ at each phase is an ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodule, which may be an infinite dimensional Hilbert space. Theorem 1.2 (See Theorem 3.19 and Theorem 5.10). Suppose Î¦Î¦\Phiroman_Î¦ is relative irreducible and ğ’©ğ’©\mathcal{N}caligraphic_N is a factor. The eigenspaces of Î¦Î¦\Phiroman_Î¦ are ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodules {HÎ±}Î±âˆˆÎ“subscriptsubscriptğ»ğ›¼ğ›¼Î“\{H_{\alpha}\}_{\alpha\in\Gamma}{ italic_H start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_Î± âˆˆ roman_Î“ end_POSTSUBSCRIPT and they form a unitary fusion category, which is the categorification of the phase group Î“Î“\Gammaroman_Î“. In particular, the quantum dimension of each bimodule HÎ±subscriptğ»ğ›¼H_{\alpha}italic_H start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT is 1. For each ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodule HÎ±subscriptğ»ğ›¼H_{\alpha}italic_H start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT, there exists a unitary uÎ±âˆˆâ„³subscriptğ‘¢ğ›¼â„³u_{\alpha}\in\mathcal{M}italic_u start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT âˆˆ caligraphic_M such that HÎ±=uÎ±â¢ğ’©=ğ’©â¢uÎ±subscriptğ»ğ›¼subscriptğ‘¢ğ›¼ğ’©ğ’©subscriptğ‘¢ğ›¼H_{\alpha}=u_{\alpha}\mathcal{N}=\mathcal{N}u_{\alpha}italic_H start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT = italic_u start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT caligraphic_N = caligraphic_N italic_u start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT. Next we consider ğ’©âŠ†â„³ğ’©â„³\mathcal{N}\subseteq\mathcal{M}caligraphic_N âŠ† caligraphic_M to be an irreducible finite-index subfactor of type II1. Note that if â„³â„³\mathcal{M}caligraphic_M is finite dimensional, then ğ’©=â„³ğ’©â„³\mathcal{N}=\mathcal{M}caligraphic_N = caligraphic_M and Î¦Î¦\Phiroman_Î¦ is the identity, which is trivial. However, the theory is non-trivial in the infinite dimensional case. We prove that Î¦Î¦\Phiroman_Î¦ is a relative irreducible ğ’«ğ’«\mathcal{P}caligraphic_P-ğ’«ğ’«\mathcal{P}caligraphic_P-bimodule map, where ğ’«ğ’«\mathcal{P}caligraphic_P is the intermediate subfactor given by the fixed points. So the eigenvalues of Î¦Î¦\Phiroman_Î¦ with modulus 1111 forms the phase group and the eigenspaces are ğ’«ğ’«\mathcal{P}caligraphic_P-ğ’«ğ’«\mathcal{P}caligraphic_P-bimodules, which form a unitary categorification of the phase group. The quantum dimension of each eigenspace as ğ’©ğ’©\mathcal{N}caligraphic_N-ğ’©ğ’©\mathcal{N}caligraphic_N-bimodule is the Jones index [ğ’«:ğ’©]delimited-[]:ğ’«ğ’©[\mathcal{P}:\mathcal{N}][ caligraphic_P : caligraphic_N ]. We can use subfactor planar algebras to characterize a bimodule map Î¦Î¦\Phiroman_Î¦ as an element yÎ¦subscriptğ‘¦Î¦y_{\Phi}italic_y start_POSTSUBSCRIPT roman_Î¦ end_POSTSUBSCRIPT in 2-box spaces. The spectrum of Î¦Î¦\Phiroman_Î¦ is the same as the spectrum of yÎ¦subscriptğ‘¦Î¦y_{\Phi}italic_y start_POSTSUBSCRIPT roman_Î¦ end_POSTSUBSCRIPT. The bimodule map Î¦Î¦\Phiroman_Î¦ is completely positive if and only if yÎ¦subscriptğ‘¦Î¦y_{\Phi}italic_y start_POSTSUBSCRIPT roman_Î¦ end_POSTSUBSCRIPT is ğ”‰ğ”‰\mathfrak{F}fraktur_F-positive, namely its Fourier transform is positive. The projection from L2â¢(â„³)superscriptğ¿2â„³L^{2}(\mathcal{M})italic_L start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( caligraphic_M ) onto HÎ±subscriptğ»ğ›¼H_{\alpha}italic_H start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT is the spectral projection of yÎ¦subscriptğ‘¦Î¦y_{\Phi}italic_y start_POSTSUBSCRIPT roman_Î¦ end_POSTSUBSCRIPT with spectral point Î±ğ›¼\alphaitalic_Î±. In this case, we can give a canonical construction of the unitary uÎ±subscriptğ‘¢ğ›¼u_{\alpha}italic_u start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT such that the 3-cocycle Ï‰ğœ”\omegaitalic_Ï‰ is constant 1. We obtain a sequence of factors ğ’©âŠ†ğ’«âŠ†â¨Î±âˆˆÎ“HÎ±âŠ†â„³ğ’©ğ’«subscriptdirect-sumğ›¼Î“subscriptğ»ğ›¼â„³\displaystyle\mathcal{N}\subseteq\mathcal{P}\subseteq\bigoplus_{\alpha\in% \Gamma}H_{\alpha}\subseteq\mathcal{M}caligraphic_N âŠ† caligraphic_P âŠ† â¨ start_POSTSUBSCRIPT italic_Î± âˆˆ roman_Î“ end_POSTSUBSCRIPT italic_H start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT âŠ† caligraphic_M and ğ’«âŠ†â¨Î±âˆˆÎ“HÎ±ğ’«subscriptdirect-sumğ›¼Î“subscriptğ»ğ›¼\displaystyle\mathcal{P}\subseteq\bigoplus_{\alpha\in\Gamma}H_{\alpha}caligraphic_P âŠ† â¨ start_POSTSUBSCRIPT italic_Î± âˆˆ roman_Î“ end_POSTSUBSCRIPT italic_H start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT is the group subfactor of the phase group. The biprojections Pğ‘ƒPitalic_P and Qğ‘„Qitalic_Q corresponding to the intermediate subfactors ğ’«ğ’«\mathcal{P}caligraphic_P and â¨Î±âˆˆÎ“HÎ±subscriptdirect-sumğ›¼Î“subscriptğ»ğ›¼\displaystyle\bigoplus_{\alpha\in\Gamma}H_{\alpha}â¨ start_POSTSUBSCRIPT italic_Î± âˆˆ roman_Î“ end_POSTSUBSCRIPT italic_H start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT are generated by the Fourier transform of Î¦â¢Î¦âˆ—Î¦superscriptÎ¦\Phi\Phi^{*}roman_Î¦ roman_Î¦ start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT and Î¦Î¦\Phiroman_Î¦ respectively. We reformulate this statement intrinsically in subfactor planar algebras without referring to the subfactor ğ’©âŠ†â„³ğ’©â„³\mathcal{N}\subseteq\mathcal{M}caligraphic_N âŠ† caligraphic_M as follows. Theorem 1.3 (See Theorem 4.4 and Theorem 4.7). Suppose ğ’«ğ’«\mathscr{P}script_P is an irreducible subfactor planar algebra. Let xâˆˆğ’«2,Â±ğ‘¥subscriptğ’«2plus-or-minusx\in\mathscr{P}_{2,\pm}italic_x âˆˆ script_P start_POSTSUBSCRIPT 2 , Â± end_POSTSUBSCRIPT be a positive operator. Let qğ‘qitalic_q be the biprojection generated by xğ‘¥xitalic_x, and let pğ‘pitalic_p be the biprojection generated by xâˆ—xÂ¯âˆ—ğ‘¥Â¯ğ‘¥x\ast\overline{x}italic_x âˆ— overÂ¯ start_ARG italic_x end_ARG. Then q=âˆ‘Î±âˆˆÎ“pÎ±ğ‘subscriptğ›¼Î“subscriptğ‘ğ›¼\displaystyle q=\sum_{\alpha\in\Gamma}p_{\alpha}italic_q = âˆ‘ start_POSTSUBSCRIPT italic_Î± âˆˆ roman_Î“ end_POSTSUBSCRIPT italic_p start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT, where pÎ±subscriptğ‘ğ›¼p_{\alpha}italic_p start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT is a right shift of the biprojection pğ‘pitalic_p. Moreover {pÎ±}Î±âˆˆÎ“subscriptsubscriptğ‘ğ›¼ğ›¼Î“\{p_{\alpha}\}_{\alpha\in\Gamma}{ italic_p start_POSTSUBSCRIPT italic_Î± end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_Î± âˆˆ roman_Î“ end_POSTSUBSCRIPT forms a finite cyclic group under convolution. Theorem 1.3 implies Theorem 1.1 and Theorem 1.2 in the case of irreducible type II1 subfactors. We can give an intrinsic proof on this theorem using methods developed in quantum Fourier analysis [15]. The paper is organized as follows: In Â§2, we recall the bimodule quantum channels and the Fourier multipliers, and reinterpret the Pimsner-Popa inequality for bimodule quantum channels. In Â§3, we introduce the notion of relative irreducibility for bimodule quantum channels and characterize the eigenspaces of bimodule quantum channels with respect to eigenvalues with modulus 1. In Â§4, we present an intrinsic proof of the characterization of eigenspaces of bimodule quantum channels in terms of subfactor planar algebras by quantum Fourier analysis. In Â§5, we show the results in Â§3 for finite inclusions of finite von Neumann algebras. We also obtain equivalent characterizations of the relative irreducibility."
https://arxiv.org/html/2411.02425v1,"A Study on Characterization of Near-Field Sub-Regions For Phased-Array Antennasâ€ â€ thanks:This research was supported by Business Finland via project 6GBridge - Local 6G (Grant Number: 8002/31/2022), and Research Council of Finland, 6G Flagship Programme (Grant Number: 346208).","We characterize three near-field sub-regions for phased array antennas by elaborating on the boundaries Fraunhofer, radial-focal, and non-radiating distances. The Fraunhofer distance which is the boundary between near and far field has been well studied in the literature on the principal axis (PA) of single-element center-fed antennas, where PA denotes the axis perpendicular to the antenna surface passing from the antenna center. The results are also valid for phased arrays if the PA coincides with the boresight, which is not commonly the case in practice. In this work, we completely characterize the Fraunhofer distance by considering various angles between the PA and the boresight. For the radial-focal distance, below which beamfocusing is feasible in the radial domain, a formal characterization of the corresponding region based on the general model of near-field channels (GNC) is missing in the literature. We investigate this and elaborate that the maximum-ratio-transmission (MRT) beamforming based on the simple uniform spherical wave (USW) channel model results in a radial gap between the achieved and the desired focal points. While the gap vanishes when the array size Nğ‘Nitalic_N becomes sufficiently large, we propose a practical algorithm to remove this gap in the non-asymptotic case when Nğ‘Nitalic_N is not very large. Finally, the non-radiating distance, below which the reactive power dominates active power, has been studied in the literature for single-element antennas. We analytically explore this for phased arrays and show how different excitation phases of the antenna array impact it. We also clarify some misconceptions about the non-radiating and Fresnel distances prevailing in the literature.","The sixth generation of wireless technology (6G) promises phenomenal advancements, aiming to deliver speeds hundreds of times faster than current capabilities [1]. This ambitious goal is fueled by cutting-edge technologies like extremely large-scale antenna arrays (ELAAs) [2] and operation at very high frequencies, including millimeter waves (mmWave) and terahertz (THz) bands [3]. However, these advancements lead to consequences like significantly expanding the near-field region of electromagnetic (EM) wave propagation, extending its reach to potentially hundreds of meters [4]. Signal propagation in the near-field region poses challenges for designing near-field communication systems but also offers more Degrees-of-Freedom (DoFs) and new opportunities for novel applications that are not feasible in the far-field. Some of these challenges and DoFs include locally varying polarization of EM waves, beamforming in the 3D domain, non-stationary antenna element characteristics, non-sparse channel representation of ELAAs, and holographic properties of antenna arrays enabling holographic communication. These challenges and DoFs begin to appear when entering the near-field region characterized by the Fraunhofer distance. This paper aims to provide a comprehensive and categorized study of various electromagnetic propagation regions and present a more generalized perspective for the characterization of each region. We focus on three key boundaries111The Fresnel distance is another important near-field boundary investigated in many existing works for single-element antennas [5, 6, 7]. In this paper, however, we do not investigate this due to space limitations. The extensions of the results for the Fresnel distance of phased array antennas can be found in [8].: â€¢ Fraunhofer distance, which is the transition boundary between the near-field and far-field. â€¢ Radial focal distance, identifying the region inside the near-field wherein beamfocusing in the radial domain is feasible. â€¢ Non-radiative distance, below which the non-radiative reactive power dominates the active power. These distances serve as critical boundaries for understanding signal behavior in the near-field region. The Fraunhofer distance has been extensively studied and characterized in the literature for single-element center-fed antennas [5, 6, 7] on the principal axis (PA) of the antenna, where the PA denotes the axis perpendicular to the antenna surface passing from the geometrical center (i.e., feed location) of the antenna. The results are also valid for phased arrays if the PA coincides with the boresight, which is not always the case in practice. In our work, we completely characterize the Fraunhofer distance by considering various angles between the PA and the boresight. The radial focal distance and the corresponding radial focal region are only applicable to phased arrays in the near-field region; Despite limited exploration, a comprehensive study regarding the formal definition and characterization of this region is also absent in the existing literature. Especially most existing works have analyzed and characterized the beamfocusing in the radial domain based on the uniform spherical wave (USW) channel model in the near-field region (e.g., [9]), and formal characterization based on the more general near-field channel models less investigated, which is to be explored in this paper. Finally, the non-radiating region has been analytically studied for a single-element (dipole) antenna, however, this has not been studied for phased arrays under different excitation phases, and besides, there exists some misconceptions in the literature about the discrimination of Fresnel distance and non-radiating distance which will be elaborated in this work. To address these research gaps, we revisit existing definitions, perform detailed calculations, and provide characterizations for each of the above three boundaries by considering phased array antennas, and wherever possible, we present exact closed-form expressions. The regions characterized in this paper are schematically depicted in Fig. 1. I-A Background and Contributions In what follows, we explore the three regions related to the near-field propagation and the corresponding boundaries mentioned above. For each item, we commence by providing its background context. Subsequently, we delve into the specific contributions conducted in this paper. Before starting the literature review, we present some terms and definitions used in the following parts. We define the principle axis of the antenna as the axis perpendicular to the antenna surface, passing from the geometrical central point of the antenna. The boresight is the axis corresponding to the main lobe of the antenna. This is identical to the principal axis for single-element center-fed symmetrical antennas, however, for phased arrays, we use this term to represent the axis connecting the geometrical antenna center and the intended observation/transmitting point source. The principal axis and boresight are depicted for single-element and phased array antennas in Figs. 3 and 4 respectively. The on-boresight and off-boresight refer to the cases where the principal axis does and does not, respectively, coincide with the boresight of the antenna. 1- Fraunhofer region Background: The Fraunhofer distance (Rayleigh distance) is the distance between the observation point and the antenna below which we have the near-field with spherical propagation, and beyond which the far-field exists wherein the spherical incident wavefront can be approximated as planar. It is well-known that a maximum phase delay of Ï€/8ğœ‹8\pi/8italic_Ï€ / 8 between a point on the antenna surface and the feed, caused by the curvature of the wavefront, is small enough to approximate the spherical wavefront as planar. This phase delay has been accepted in the literature for defining and calculating the Fraunhofer distance. The Fraunhofer distance on the antennaâ€™s boresight is obtained as dÂ¯F0=2â¢D2/Î»superscriptÂ¯ğ‘‘F02superscriptğ·2ğœ†\overline{d}^{\mathrm{F0}}=2D^{2}/\lambdaoverÂ¯ start_ARG italic_d end_ARG start_POSTSUPERSCRIPT F0 end_POSTSUPERSCRIPT = 2 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / italic_Î», where Dğ·Ditalic_D is the maximum dimension of the antenna and Î»ğœ†\lambdaitalic_Î» is the wavelength. Several works have calculated the Fraunhofer distance for a single-element antenna following different schemes. The most straightforward scheme is to calculate the dominant terms of the binomial or Taylor series expansion approximation of the signal, and then obtain the maximum distance from the antenna where the dominant terms would result in a differential phase delay no more than Ï€/8ğœ‹8\pi/8italic_Ï€ / 8 on different points of the antenna surface [6, 10]. As an alternative solution, the authors of [5] have derived dÂ¯F0superscriptÂ¯ğ‘‘F0\overline{d}^{\mathrm{F0}}overÂ¯ start_ARG italic_d end_ARG start_POSTSUPERSCRIPT F0 end_POSTSUPERSCRIPT by considering a continuous aperture of arbitrary shape, and then they employed scalar diffraction theory for obtaining Fraunhofer and Fresnel regions. The study by [11] demonstrates that for single-element thin-wire dipole antennas, the boresight Fraunhofer distance 2â¢D2/Î»2superscriptğ·2ğœ†2D^{2}/\lambda2 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / italic_Î» is accurate only for antennas where Dâ‰¥5â¢Î»ğ·5ğœ†D\geq 5\lambdaitalic_D â‰¥ 5 italic_Î». Noting the inexactness of 2â¢D2/Î»2superscriptğ·2ğœ†2D^{2}/\lambda2 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / italic_Î» when Dğ·Ditalic_D is comparable to Î»ğœ†\lambdaitalic_Î», mathematical formulations have been obtained in [12] for characterizing a more exact on-boresight Fraunhofer distance for a thin wire of length Dğ·Ditalic_D. In [13], the effective Fraunhofer distance dÂ¯effF0subscriptsuperscriptÂ¯ğ‘‘F0eff\overline{d}^{\mathrm{F0}}_{\mathrm{eff}}overÂ¯ start_ARG italic_d end_ARG start_POSTSUPERSCRIPT F0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_eff end_POSTSUBSCRIPT is defined and characterized as the distance where the normalized beamforming gain under the far-field assumption is no less than a value Î·ğœ‚\etaitalic_Î·. By considering Î·=95%ğœ‚percent95\eta=95\%italic_Î· = 95 %, it has been shown that we have dÂ¯effF0=0.367â¢dÂ¯F0subscriptsuperscriptÂ¯ğ‘‘F0eff0.367superscriptÂ¯ğ‘‘F0\overline{d}^{\mathrm{F0}}_{\mathrm{eff}}=0.367\overline{d}^{\mathrm{F0}}overÂ¯ start_ARG italic_d end_ARG start_POSTSUPERSCRIPT F0 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT roman_eff end_POSTSUBSCRIPT = 0.367 overÂ¯ start_ARG italic_d end_ARG start_POSTSUPERSCRIPT F0 end_POSTSUPERSCRIPT on the boresight of the antenna. The authors of [14] have shown that for MIMO phased array antennas with maximum dimensions of D1subscriptğ·1D_{1}italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT and D2subscriptğ·2D_{2}italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT corresponding to a transmitter and a receiver, the on-boresight Fraunhofer distance is obtained as dÂ¯F0=2â¢(D1+D2)2/Î»superscriptÂ¯ğ‘‘F02superscriptsubscriptğ·1subscriptğ·22ğœ†\overline{d}^{\mathrm{F0}}=2(D_{1}+D_{2})^{2}/\lambdaoverÂ¯ start_ARG italic_d end_ARG start_POSTSUPERSCRIPT F0 end_POSTSUPERSCRIPT = 2 ( italic_D start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT + italic_D start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ) start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / italic_Î». To the best of our knowledge, all works in the literature except [15] have analyzed the Fraunhofer distance on the principal axis of the antenna (e.g., [4, 16, 17, 18]). In practice, however, it is of a very small probability that the observation point is exactly placed on the boresight. The authors of [15] have partially investigated the fact that for the case of an off-boresight phased array scenario, the Fraunhofer distance is increased compared to the on-boresight scenario, however, a comprehensive and analytical investigation is missing. In particular, a detailed analysis of how the observation angle Î¸ğœƒ\thetaitalic_Î¸ exactly impacts the Fraunhofer distance, and how the Fraunhofer distance changes softly when moving from on-boresight to off-boresight angles is missing. Contributions: As in [8], we delve into an analysis of the well-established derivation of the Fraunhofer distance, which traditionally applies to the boresight of a center-fed antenna model, and show that this procedure does not directly translate to off-boresight scenarios. This specifically holds for the phased array antennas, wherein each antenna element has its feed, and thus there exists not only a single central feed reference point. As a result, the widely accepted values of the on-boresight Fraunhofer distance for phased arrays, are not valid in the off-boresight scenario. Then we derive a closed-form value for the Fraunhofer distance for phased arrays for Î¸âˆˆ[0,Ï€]ğœƒ0ğœ‹\theta\in[0,\pi]italic_Î¸ âˆˆ [ 0 , italic_Ï€ ]. More specifically, we define and calculate the Fraunhofer angle Î¸FsuperscriptğœƒF\theta^{\mathrm{F}}italic_Î¸ start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT and show that for Î¸âˆˆ[0,Ï€/2âˆ’Î¸F]âˆª[Ï€/2+Î¸F,Ï€]ğœƒ0ğœ‹2superscriptğœƒFğœ‹2superscriptğœƒFğœ‹\theta\in[0,\pi/2-\theta^{\mathrm{F}}]\cup[\pi/2+\theta^{\mathrm{F}},\pi]italic_Î¸ âˆˆ [ 0 , italic_Ï€ / 2 - italic_Î¸ start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT ] âˆª [ italic_Ï€ / 2 + italic_Î¸ start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT , italic_Ï€ ] the Fraunhofer distance is dF=8â¢D2â¢sin2â¡(Î¸)/Î»superscriptğ‘‘F8superscriptğ·2superscript2ğœƒğœ†d^{\mathrm{F}}=8D^{2}\sin^{2}(\theta)/\lambdaitalic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT = 8 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_sin start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Î¸ ) / italic_Î». For the case where Î¸ğœƒ\thetaitalic_Î¸ is softly changed from Ï€/2Â±Î¸Fplus-or-minusğœ‹2superscriptğœƒF\pi/2\pm\theta^{\mathrm{F}}italic_Ï€ / 2 Â± italic_Î¸ start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT toward Ï€/2ğœ‹2\pi/2italic_Ï€ / 2 (where Ï€/2ğœ‹2\pi/2italic_Ï€ / 2 corresponds to the boresight), dFsuperscriptğ‘‘Fd^{\mathrm{F}}italic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT softly switches to 2â¢D2/Î»2superscriptğ·2ğœ†2D^{2}/\lambda2 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / italic_Î» according to a function whose value is derived in a closed form. We obtain a tight closed-form approximation for the value of Î¸FsuperscriptğœƒF\theta^{\mathrm{F}}italic_Î¸ start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT and show that it is a small angle, its value being a decreasing function of D/Î»ğ·ğœ†D/\lambdaitalic_D / italic_Î»; i.e., for phased array antennas, as the antenna array scales up, this angle sharply tends toward zero. We will elaborate on how the Fraunhofer distance for phased arrays is increased about 4 times when debating from the boresight scenario. The approximation becomes tight when studying ELAAs, wherein a very slight deviation of the (user equipment) UE location from the on-boresight scenario (as is commonly the case in practice) extends the Fraunhofer region exactly 4 times. The schematic presentation of the characterized Fraunhofer distance dFsuperscriptğ‘‘Fd^{\mathrm{F}}italic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT for the on-boresight and off-boresight scenarios is depicted in Fig. 1 per radiation angle Î¸ğœƒ\thetaitalic_Î¸ in dashed blue line. 2- Radial-domain beamfocusing region Background: The far-field 2D angular domain beamforming has been extensively investigated in the literature for phased array antennas [19, 20, 21]. The angular-domain beamforming of phased array antennas on the near-field region has also been studied in the literature [22, 23, 24], however, one of the most distinguishing and unique features of the near-field is the capability of beamfocusing in the radial domain, which if employed with extremely large-scale arrays can lead to spot-like near-field 3D beamfocusing [25, 26]. For the asymptotic case where the number of array elements Nğ‘Nitalic_N is extremely large, the authors of [25] have explored a comprehensive study on different technical and practical aspects of implementing spot beamfocusing (SBF) in the near-field region. In [26], the authors provide a mathematical framework to prove that spot-like 3D radial and angular beamfocusing corresponds to the maximum power beamformer in the asymptotic case under certain conditions. Then they propose a modular (sub-array based) meta-lens structure to focus the beam at the desired focal point near-field region in a smart manner without requiring channel state information (CSI); This idea has then been further developed in [27] by implementing transfer-learning for training subarrays in a more adaptive manner. For the non-asymptotic case where the number of array elements is not extremely large, several works have explored the practical and theoretical aspects of near-field beamfocusing in the radial domain. In this regard, to characterize the region wherein near-field beamfocusing in the radial domain is feasible, the idea of depth of focus has first been defined for continuous apertures in [28] and then characterized and applied to phased array antennas [29, 30, 31]. For phased array antennas having small-size antenna patch elements and using Fresnel approximation, the authors of [30] have proved that the 3dB depth of focus is possible at distances lower than dF/10superscriptğ‘‘F10{d^{\mathrm{F}}}/{10}italic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT / 10. For the case of a uniform linear array antenna, an approximate closed-form solution for 3dB depth of focus is calculated in [31] based on the uniform spherical wave (USW) channel model for near-field region. Contributions: The depth of focus and radial focal properties investigated in existing works (e.g., [31]) are analyzed based on the simple USW model for near-field channels which ignores the variation of the near-field channels of different antenna array elements in the distance domain. We show that this leads to inaccuracies in characterizing the focal point in the radial domain. As in [32], we express a formal definition of the radial focal distance and present the characterization of the region wherein the constitution of a radial focal point is feasible. Given a desired focal point (DFP) in the radial domain, the beamformer vector corresponding to the highest signal amplitude potentially results in the realization of a radial focal point at some other point between the antenna and the DFP. This leads to a radial focal gap between the DFP and the achieved focal point (AFP). By employing ELAAs, we show that this gap tends to zero in the asymptotic case for most practical ELAA structures, considering the non-uniform spherical model (NUSW) for near-field channels. For the case of non-asymptotic cases where the number of array elements is not too large, we provide a practical algorithm for resolving the gap, and realizing the focal point at the exact desired location point. 3- Non-radiating region Background: Transmit antennas emit both active and reactive powers. The active power is associated with the traveling wave, while the reactive power is associated with the capacitive or inductive fields. The distance close to the antenna where the active and reactive power levels are equal is termed the non-radiating distance denoted by dNRsuperscriptğ‘‘NRd^{\mathrm{NR}}italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT. The region r<dNRğ‘Ÿsuperscriptğ‘‘NRr<d^{\mathrm{NR}}italic_r < italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT corresponds to the non-radiative near-field region where the reactive power dominates, and the region r>dNRğ‘Ÿsuperscriptğ‘‘NRr>d^{\mathrm{NR}}italic_r > italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT constitutes the radiative region which includes both the radiative near-field (dNR<r<dFsuperscriptğ‘‘NRğ‘Ÿsuperscriptğ‘‘Fd^{\mathrm{NR}}<r<d^{\mathrm{F}}italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT < italic_r < italic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT), and the far-field (r>dFğ‘Ÿsuperscriptğ‘‘Fr>d^{\mathrm{F}}italic_r > italic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT) regions as depicted in Fig. 1. There has been no analytic study of dNRsuperscriptğ‘‘NRd^{\mathrm{NR}}italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT for Nğ‘Nitalic_N-element phased array antennas, not even for the simple case of N=1ğ‘1N=1italic_N = 1. To the best of our knowledge, the only theoretical investigation of dNRsuperscriptğ‘‘NRd^{\mathrm{NR}}italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT in the literature pertains to an infinitesimal dipole for which it is proven that dNR=Î»/2â¢Ï€superscriptğ‘‘NRğœ†2ğœ‹d^{\mathrm{NR}}=\lambda/2\piitalic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT = italic_Î» / 2 italic_Ï€ [6, 10]. The non-radiating near-field region has been analyzed in [33] through numerical results for three types of antennas: dipole, loop, and Yagiâ€“Uda antennas. More specifically, the extreme value of dNR=Î»/2â¢Ï€superscriptğ‘‘NRğœ†2ğœ‹d^{\mathrm{NR}}=\lambda/2\piitalic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT = italic_Î» / 2 italic_Ï€, previously derived in the literature through theoretical analysis for infinitesimal dipole antennas, has been verified through numerical results to apply to all three aforementioned types, considering infinitesimal dimensions. Contributions: Similar to the Fraunhofer distance, the Fresnel distance has been characterized based on analyzing a specific phase delay relating to the curvature of the wave for different points on the antenna. The value of Fresnel distance has been derived in several works as dÂ¯N0=0.62â¢D3/Î»superscriptÂ¯ğ‘‘N00.62superscriptğ·3ğœ†\overline{d}^{\mathrm{N0}}=0.62\sqrt{{D^{3}}/{\lambda}}overÂ¯ start_ARG italic_d end_ARG start_POSTSUPERSCRIPT N0 end_POSTSUPERSCRIPT = 0.62 square-root start_ARG italic_D start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT / italic_Î» end_ARG [6, 5]. Many related works in the literature assume that the radiative region commences at the Fresnel distance (e.g. [34, 35, 36]); we show that this assumption is not correct, as these two regions serve distinct purposes. The former is characterized through an analysis of active and reactive power, whereas the latter is defined based on an examination of phase delay on the aperture surface. Initiating from the electrical potential function and then applying Maxwellâ€™s equations, we derive exact mathematical expressions for the computation of the complex transmit power relating to an Nğ‘Nitalic_N-element dipole array of arbitrary size. By taking the active and reactive parts, we calculate the non-radiating distance dNRsuperscriptğ‘‘NRd^{\mathrm{NR}}italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT for a dipole array. We evaluate dNRsuperscriptğ‘‘NRd^{\mathrm{NR}}italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT for various numbers of array elements Nğ‘Nitalic_N, various dimensions of each antenna element Dssuperscriptğ·sD^{\mathrm{s}}italic_D start_POSTSUPERSCRIPT roman_s end_POSTSUPERSCRIPT, and various excitation phases for the antenna array elements. Our analysis reveals that, for all stated scenarios, dNRsuperscriptğ‘‘NRd^{\mathrm{NR}}italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT is consistently lower than half a wavelength, which is significantly smaller than the Fresnel distance of the phased arrays. Besides, it is seen through numerical results that a non-co-phase excitation vector results in a slightly larger value of dNRsuperscriptğ‘‘NRd^{\mathrm{NR}}italic_d start_POSTSUPERSCRIPT roman_NR end_POSTSUPERSCRIPT compared to implementing a completely co-phase excitation vector. Figure 1: Various characterized near-field sub-regions for a phased array antenna (dashed lines), versus a center-fed single-element antenna having the same dimension (dotted lines). I-B Organization The remainder of this paper is organized as follows. In Section II we present the system model. The characterization of the Fraunhofer region, radial focal region, and non-radiating region is presented in Sections III, IV and V respectively. Finally, Section VI concludes the paper. I-C Notations Throughout this paper, for any matrix ğ‘¨ğ‘¨\bm{A}bold_italic_A, ğ‘¨m,nsubscriptğ‘¨ğ‘šğ‘›\bm{A}_{m,n}bold_italic_A start_POSTSUBSCRIPT italic_m , italic_n end_POSTSUBSCRIPT, ğ‘¨Tsuperscriptğ‘¨T\bm{A}^{\mathrm{T}}bold_italic_A start_POSTSUPERSCRIPT roman_T end_POSTSUPERSCRIPT, ğ‘¨âˆ—superscriptğ‘¨\bm{A}^{*}bold_italic_A start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT, and ğ‘¨Hsuperscriptğ‘¨H\bm{A}^{\mathrm{H}}bold_italic_A start_POSTSUPERSCRIPT roman_H end_POSTSUPERSCRIPT, denote the (m,n)ğ‘šğ‘›(m,n)( italic_m , italic_n )-th entry, transpose, conjugate, and conjugate transpose respectively. Similarly, for each vector ğ’‚ğ’‚\bm{a}bold_italic_a, ğ’‚nsubscriptğ’‚ğ‘›\bm{a}_{n}bold_italic_a start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT, ğ’‚Tsuperscriptğ’‚T\bm{a}^{\mathrm{T}}bold_italic_a start_POSTSUPERSCRIPT roman_T end_POSTSUPERSCRIPT, ğ’‚âˆ—superscriptğ’‚\bm{a}^{*}bold_italic_a start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT, ğ’‚Hsuperscriptğ’‚H\bm{a}^{\mathrm{H}}bold_italic_a start_POSTSUPERSCRIPT roman_H end_POSTSUPERSCRIPT, â€–ğ’‚â€–normğ’‚\|\bm{a}\|âˆ¥ bold_italic_a âˆ¥ denote the nğ‘›nitalic_n-th entry, transpose, conjugate, conjugate transpose, and Euclidean norm respectively."
https://arxiv.org/html/2411.02417v1,Revisiting the Fraunhofer and Fresnel Boundaries for Phased Array Antennasâ€ â€ thanks:This work was supported by Business Finland via the 6GBridge - Local 6G project (grant number 8002/31/2022) and by the Research Council of Finland through the 6G Flagship (grant number 346208).,"This paper presents the characterization of near-field propagation regions for phased array antennas, with a particular focus on the propagation boundaries defined by Fraunhofer and Fresnel distances. These distances, which serve as critical boundaries for understanding signal propagation behavior, have been extensively studied and characterized in the literature for single-element antennas. However, the direct application of these results to phased arrays, a common practice in the field, is argued to be invalid and non-exact. This work calls for a deeper understanding of near-field propagation to accurately characterize such boundaries around phased array antennas. More specifically, for a single-element antenna, the Fraunhofer distance is dF=2â¢D2â¢sin2â¡(Î¸)/Î»superscriptğ‘‘F2superscriptğ·2superscript2ğœƒğœ†d^{\mathrm{F}}=2D^{2}\sin^{2}(\theta)/\lambdaitalic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT = 2 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_sin start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Î¸ ) / italic_Î» where Dğ·Ditalic_D represents the largest dimension of the antenna, Î»ğœ†\lambdaitalic_Î» is the wavelength and Î¸ğœƒ\thetaitalic_Î¸ denotes the observation angle. We show that for phased arrays, dFsuperscriptğ‘‘Fd^{\mathrm{F}}italic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT experiences a fourfold increase (i.e., dF=8â¢D2â¢sin2â¡(Î¸)/Î»superscriptğ‘‘F8superscriptğ·2superscript2ğœƒğœ†d^{\mathrm{F}}=8D^{2}\sin^{2}(\theta)/\lambdaitalic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT = 8 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_sin start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Î¸ ) / italic_Î») provided that |Î¸âˆ’Ï€2|>Î¸Fğœƒğœ‹2superscriptğœƒğ¹|\theta-\frac{\pi}{2}|>\theta^{F}| italic_Î¸ - divide start_ARG italic_Ï€ end_ARG start_ARG 2 end_ARG | > italic_Î¸ start_POSTSUPERSCRIPT italic_F end_POSTSUPERSCRIPT (which holds for most practical scenarios), where Î¸Fsuperscriptğœƒğ¹\theta^{F}italic_Î¸ start_POSTSUPERSCRIPT italic_F end_POSTSUPERSCRIPT is a small angle whose value depends on the number of array elements, and for the case |Î¸âˆ’Ï€2|â‰¤Î¸Fğœƒğœ‹2superscriptğœƒğ¹|\theta-\frac{\pi}{2}|\leq\theta^{F}| italic_Î¸ - divide start_ARG italic_Ï€ end_ARG start_ARG 2 end_ARG | â‰¤ italic_Î¸ start_POSTSUPERSCRIPT italic_F end_POSTSUPERSCRIPT, we have dFâˆˆ[2â¢D2/Î»,8â¢D2â¢cos2â¡(Î¸F)/Î»]superscriptğ‘‘F2superscriptğ·2ğœ†8superscriptğ·2superscript2superscriptğœƒğ¹ğœ†d^{\mathrm{F}}\in[2D^{2}/\lambda,8D^{2}\cos^{2}(\theta^{F})/\lambda]italic_d start_POSTSUPERSCRIPT roman_F end_POSTSUPERSCRIPT âˆˆ [ 2 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT / italic_Î» , 8 italic_D start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_cos start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ( italic_Î¸ start_POSTSUPERSCRIPT italic_F end_POSTSUPERSCRIPT ) / italic_Î» ], where the precise value is obtained according to some square polynomial function F~â¢(Î¸)~ğ¹ğœƒ\widetilde{F}(\theta)over~ start_ARG italic_F end_ARG ( italic_Î¸ ). Besides, we also prove that the Fresnel distance for phased array antennas is given by dN=1.75â¢D3/Î»superscriptğ‘‘N1.75superscriptğ·3ğœ†d^{\mathrm{N}}=1.75\sqrt{{D^{3}}/{\lambda}}italic_d start_POSTSUPERSCRIPT roman_N end_POSTSUPERSCRIPT = 1.75 square-root start_ARG italic_D start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT / italic_Î» end_ARG which is 88\sqrt{8}square-root start_ARG 8 end_ARG times greater than the corresponding distance for a conventional single-element antenna with the same dimension.","The application of near-field communication is expected to significantly expand in existing and future generations of wireless technology compared to previous generations [1, 2]. This phenomenon is attributable to two key factors. Firstly, modern applications gravitate towards higher frequencies in the millimeter wave (mmWave) and terahertz (THz) bands [3]. Secondly, due to the severe path loss experienced at such high frequencies, these applications employ extremely large-scale antenna arrays (ELAAs) to compensate for this loss through high-directivity beamforming schemes [4]. Noting that the near-field propagation region extends by increasing the frequency and antenna diameter, these advancements have collectively led to a substantial expansion of the near-field region for electromagnetic (EM) wave propagation in modern high-frequency applications exploiting ELAAs. This expansion has the potential to extend the reach of near-field communication to hundreds of meters in many applications, as highlighted in recent studies [2, 5]. Near-field communication and propagation provide a higher degree of freedom (DoF), paving the way for innovative applications that are not possible in the far-field. For example, it facilitates beamforming in both radial and angular dimensions, which opens up the potential for 3D beamfocusing. Moreover, the near-field presents unique challenges and opportunities such as locally changing polarization of EM waves, non-stationary characteristics of antenna elements, non-sparse channel representation of ELAAs, and holographic attributes of antenna arrays. In this scenario, to effectively navigate the intricacies of near-field communication, leverage its distinctive features, and build sturdy and efficient modern wireless systems, a profound comprehension of near-field signal behavior and precise characterization of near-field boundaries is essential, especially when it originates from phased array antennas. The signal propagation region can be divided into 3 subregions differentiated by the boundaries named Fraunhofer distance, Fresnel distance, and Non-radiative distance. The Fraunhofer distance determines the transition boundary between the near-field and far-field. The Fresnel distance relates to a specific phase delay approximation inside the near-field region, as explained later, and finally, the non-radiative distance is the distance below which the non-radiative reactive power dominates the active power. The latter is very close to the antenna, usually lower than half a wavelength [6, 7]. The Fraunhofer and Fresnel distances have been extensively studied and characterized in the literature for single-element antennas. These distances serve as critical boundaries in understanding antenna behavior. However, when it comes to phased arrays, a common practice has been to apply these results without modification directly. Our work rigorously argues that this approach is invalid and non-exact. In this paper, we revisit existing definitions, perform detailed calculations, and provide characterizations for the Fraunhofer and Fresnel boundaries by considering phased array antennas, and present closed-form expressions. Notably, we emphasize the inaccuracies arising from directly applying single-element antenna characterization principles to phased arrays, as observed in prior works. A schematic representation of the stated regions developed in existing works for a single-element antenna and those characterized in this work for phased array antennas having the same dimensions as the single-element one are depicted in Fig. 1 as dotted and dashed lines respectively."
https://arxiv.org/html/2411.02334v1,Diffusion-based Generative Multicasting with Intent-aware Semantic Decomposition,"Generative diffusion models (GDMs) have recently shown great success in synthesizing multimedia signals with high perceptual quality enabling highly efficient semantic communications in future wireless networks. In this paper, we develop an intent-aware generative semantic multicasting framework utilizing pre-trained diffusion models. In the proposed framework, the transmitter decomposes the source signal to multiple semantic classes based on the multi-user intent, i.e. each user is assumed to be interested in details of only a subset of the semantic classes. The transmitter then sends to each user only its intended classes, and multicasts a highly compressed semantic map to all users over shared wireless resources that allows them to locally synthesize the other classes, i.e. non-intended classes, utilizing pre-trained diffusion models. The signal retrieved at each user is thereby partially reconstructed and partially synthesized utilizing the received semantic map. This improves utilization of the wireless resources, with better preserving privacy of the non-intended classes. We design a communication/computation-aware scheme for per-class adaptation of the communication parameters, such as the transmission power and compression rate to minimize the total latency of retrieving signals at multiple receivers, tailored to the prevailing channel conditions as well as the usersâ€™ reconstruction/synthesis distortion/perception requirements. The simulation results demonstrate significantly reduced per-user latency compared with non-generative and intent-unaware multicasting benchmarks while maintaining high perceptual quality of the signals retrieved at the users. For a typical setup of multicasting street scene images to 10 users, our proposed framework achieves a 15.4%percent15.415.4\%15.4 % reduction in per-user latency at a fixed power budget, or equivalently 50%percent5050\%50 % reduction in the transmission power required to achieve a fixed per-user latency, compared with non-generative multicasting.","Semantic Communication (Semcom) is envisioned to play a crucial role in future wireless networks, specifically in emerging applications where communication of large multimodal signals with stringent latency and reliability constraints is required, e.g. the wireless metaverse and digital twins [1, 2, 3], extended/mixed reality (XR/MR) [4, 5], and holographic teleportation and the internet of senses [6, 7]. In many such applications, multicasting of multimodal signals is required, where the wireless and network resource utilization can be significantly improved by transmitting the same desired content to multiple users over shared resources. For example in the wireless metaverse, multicasting is used to communicate updates, states, or events of the virtual world to multiple users simultaneously in real-time to ensure all users remain synchronized. Another example is XR/MR streaming, where the same content may be distributed to multiple users simultaneously. In these applications, Semcom can further reduce the wireless and network resource utilization by extracting and communicating only the semantic content of interest based on the usersâ€™ intent [8, 9, 10, 11, 12]. Recently, the Generative AI (GenAI) models have shown great success in developing efficient low bitrate Generative Semantic Communication (Gen Semcom) systems [13, 14, 15, 16]. Generative models are capable of learning the general distribution of natural signals during training and synthesizing new samples with high perceptual quality at inference time. The generation process can be guided by multi-modal prompts and conditioning signals to produce high quality outputs with a desired semantic content. The emerging Generative Foundation Models and Multimodal Large Language Models (MLLMs), e.g. Sora [17], Lumiere [18], and DALL.E [19], etc., provide ample opportunities to develop efficient and universal generative Semcom frameworks [20, 21, 22, 23]. As these models possess a vast general knowledge captured via intensive pre-training on huge amount of data, they alleviate the need for a shared Knowledge Base (KB) between the semantic transmitter and receiver, thereby reducing the corresponding knowledge sharing overheads. This vast general knowledge also makes the generative Semcom framework applicable to various datasets and tasks thereby achieving universality. Moreover, generative Semcom offers an inherent advantage in privacy preservation, as only the intended features of the original signal are communicated, and the non-intended details are generated locally from random noise inputs at the receiver utilizing the generative model. Such details are thereby not precisely reproducible and are kept private from the receiver, without requiring separate anonymization techniques The GenAI models are trained to maximize the perceptual quality of the synthesized signal, and the theoretical limits of generative Semcom are governed by the rate-distortion-perception theory [24, 25, 26, 27]. This theory explores the threefold trade-off between rate, distortion, and the perceptual quality of the synthesized signal. While the rate-distortion-perception function is analytically derived only for a few source distributions, it is generally estimated empirically for natural signals, e.g. images, audio/video, point cloud, etc., by training deep source encoders with a perceptual loss function, e.g. Wasserstein distance, on large datasets [24, 25]. In generative Semcom, the transmitter extracts the intended semantics, e.g. in form of textual prompts [28, 29], compressed embeddings [30, 31], semantic/edge map [15, 21, 32] etc., which are then transmitted over the channel. The receiver uses these semantics to guide a generative model, synthesizing a signal that is semantically consistent and highly realistic. Despite the above existing works, multiuser generative semantic communications, specifically in the multicasting setup, and its scalability to increasing number of users under latency constraints remains less studied. In this paper, we develop a generative semantic multicasting framework with adaptive intent-aware resource allocation utilizing pre-trained diffusion models. We claim two key benefits for the proposed framework: Firstly, generative multicasting in our Semcom framework allows preserving privacy of the non-intended signals, while improving utilization of the wireless and network resources compared with non-generative and intent-unaware multicasting benchmarks. This also reduces the total latency, while maintaining the reconstruction/synthesis distortion/perception quality. Secondly, the adoption of pre-trained diffusion models allows a source-channel separation-based Semcom architecture, thereby alleviating the need for end-to-end joint training of the transmitter and receiver, which is required in many existing Semcom frameworks [8, 9, 10, 11]. Such a separation-based architecture offers improved adaptability to varying channel conditions, improved scalability to increasing number of users, and better compatibility with the existing design of wireless communication networks. The contributions of this work are three-fold: â€¢ We develop a generative multicasting framework where a semantic decomposition scheme splits the source signal into multiple semantic classes at the transmitter based on the multi-user intent, i.e. each user is assumed to need only a subset of the semantic classes based on its communication intent. The transmitter sends to each user only its intended classes over orthogonal wireless resources, and multicasts to all users a highly compressed semantic map over shared resources. Each user then locally synthesizes the non-intended classes using a pre-trained generative diffusion model. â€¢ For a typical image synthesis task, we train a generative diffusion model with classifier-free semantic guidance to derive estimates of the corresponding rate-distortion/perception curves achieved by the model through pre-training. We use these curves to determine the communication parameters, i.e. the transmission power and compression rate in our proposed framework. â€¢ We design a communication/computation-aware scheme for per-class adaptation of the communication parameters to minimize the total latency for varying channel conditions and usersâ€™ reconstruction/synthesis distortion/perception requirements. The signal retrieved at each user is partially reconstructed and partially synthesized utilizing the pre-trained diffusion model, and the communication parameters are optimized for latency-aware synchronisation of the synthesized and reconstructed datastreams based on the prevailing channel conditions and multi-user intent. The rest of this paper is organized as follows. In Section II we provide the related works. In Section III, we present our proposed diffusion-based generative multicasting framework and the corresponding intent and latency-aware adaptive semantic communication scheme. Simulation results are provided in Section IV, and we conclude the paper in Section V. Notations: Boldface lower and upper-case symbols denote column vectors and matrices, respectively. Calligraphic letters denote mathematical operators. [K]delimited-[]ğ¾[K][ italic_K ] is {1,2,â€¦,K}12â€¦ğ¾\{1,2,...,K\}{ 1 , 2 , â€¦ , italic_K }, and |ğ¯|ğ¯\left|{\bf v}\right|| bold_v | denotes the length of vector ğ¯ğ¯{\bf v}bold_v. Additionally, âŠ•direct-sum\oplusâŠ• and âŠ™direct-product\odotâŠ™ denote point/pixel/voxel-wise summation and product, and â‹ƒ\bigcupâ‹ƒ is the union operator. Expectation is denoted by ğ”¼[.]\mathbb{E}[.]blackboard_E [ . ]. Finally, ğ’°[.,.]\mathcal{U}[.,.]caligraphic_U [ . , . ] and ğ’©[.,.]\mathcal{N}[.,.]caligraphic_N [ . , . ] denote the uniform and Gaussian probability distributions, respectively."
https://arxiv.org/html/2411.02108v3,Optimizing AoI at Query in Multiuser Wireless Uplink Networks: A Whittle Index Approach,"In this paper, we explore how to schedule multiple users to optimize information freshness in a pull-based wireless network, where the status updates from users are requested by randomly arriving queries at the destination. We use the age of information at query (QAoI) to characterize the performance of information freshness. Such a decision-making problem is naturally modeled as a Markov decision process (MDP), which, however, is prohibitively high to be solved optimally by the standard method due to the curse of dimensionality. To address this issue, we employ Whittle index approach, which allows us to decouple the original MDP into multiple sub-MDPs by relaxing the scheduling constraints. However, the binary Markovian query arrival process results in a bi-dimensional state and complex state transitions within each sub-MDP, making it challenging to verify Whittle indexability using conventional methods. After a thorough analysis of the sub-MDPâ€™s structure, we show that it is unichain and its optimal policy follows a threshold-type structure. This facilitates the verification of Whittle indexability of the sub-MDP by employing an easy-to-verify condition. Subsequently, the steady-state probability distributions of the sub-MDP under different threshold-type policies are analyzed, constituting the analytical expressions of different Whittle indices in terms of the expected average QAoI and scheduling time of the sub-MDP. Building on these, we devise an efficient algorithm to calculate Whittle indices for the formulated sub-MDPs. The simulation results validate our analyses and show the proposed Whittle index policy outperforms baseline policies and achieves near-optimal performance.","In recent years, the widespread adoption of time-critical wireless communication systems has drawn significant attention to the information freshness [1, 2, 3]. As a result, the age of information (AoI) metric, defined as the time elapsed since the generation of the most recently received message at the destination, has been proposed to quantify information freshness, see e.g., [4, 5, 6, 7, 8, 9] and references therein. Most studies focused on the AoI metric have primarily investigated the minimization of the long-term average AoI across various network settings (e.g., see [10, 11, 12, 13, 9, 14, 15, 16]). That is, these works assumed a push-based wireless communication system, where monitors at the destination continuously request the most recently received information. In contrast, the information freshness in pull-based wireless networks has obtained relatively less consideration. Specifically, at the destinations in the pull-based communication systems, a query arrival process occurs at each monitor, and the received messages are sampled and used by the monitor only at specific time instants when queries arrive, such as satellite Internet of Things (IoT) networks and ecological monitoring systems [17, 18, 19, 20]. To more effectively quantify information freshness in pull-based communication systems, the Age of Information at Query (QAoI) metric has been introduced and increasingly explored in the literature, for instance, in[21, 22, 23, 24, 25] and references therein. In particular, QAoI is defined as the instantaneous AoI values when the queries arrive at the destination. There have been some research efforts dedicated to addressing the transmission scheduling problems to optimize the long-term average QAoI in different network scenarios. The QAoI-oriented transmission scheduling coordinations for single-user networks were researched in [21, 22, 23], in which when to transmit the status update of the single user is guided by the query arrivals. Efforts on solving the QAoI-based scheduling problem in wireless two-user uplink networks have also been made in the open literature. In such a scenario, monitors with query arrivals are deployed at a base station (BS), which schedules the transmissions of status update packets from the end devices corresponding to the monitors in the uplink. In [24], the authors investigated the QAoI optimization of a reconfigurable intelligent surface-assisted wireless network, including two energy harvesting sensors and a monitor. The optimization problem was approximated as a convex problem, which was solved by an alternating optimization approach. However, this study cannot be applied to networks with more than two sensors. Zakeri et al. in [25] considered a time-slotted heterogeneous status update system with transmission and sampling frequency limitations with one source in the â€œstochastic arrivalâ€ model, one source in the â€œgenerate-at-willâ€ model, and a transmitter deploying a buffer-aided and a monitor. In each time slot, the transmitter decides whether the generate-at-will source is sampled by its transmitter and schedules the transmission of the two sources to minimize the QAoI performance of the network. After modeling the decision-making problem as a constrained Markov decision process (CMDP), the authors selected to optimize the long-term discounted network-wide QAoI reward, since the CMDP is not unichain, by solving the corresponding linear programming (LP) of the CMDP. Then, a reduced-complexity heuristic policy also built upon the LP approach was developed by investigating a weakly coupled CMDP problem relaxed from the original CMDP. Although the proposed heuristic policy was shown applicable to networks including multiple stochastic arrival sources, this method suffers from high computational complexity with a large number of sources. This is because of the increase in the number of variables and constraints in the LP associated with the weakly coupled CMDP, which grows with the number of sources, leading to an exponential rise in the complexity of solving this LP. To the best of our knowledge, an efficient scheduling scheme for optimizing the long-term average QAoI in wireless multiuser uplink networks has not been thoroughly explored in the literature. To fill this gap, in this paper we consider a multiuser scheduling problem for maximizing the expected sum QAoI of a wireless uplink network, where multiple status-updating end devices are scheduled to transmit their updates to the corresponding monitors deployed at a base station (BS). Moreover, each monitor experiences stochastic query arrivals, which follow a binary Markovian process. In this context, the most recent status update packets received by the monitor are requested when queries arrive. We model the considered QAoI-oriented scheduling problem as an MDP problem. The network-wide instantaneous AoI and query arrival situations are jointly defined as the state of the formulated MDP. We summarize the main contributions of this paper as follows. â€¢ As the number of end devices increases, the state space grows exponentially, making it challenging to compute the optimal scheduling policy of the formulated MDP using standard methods due to the curse of dimensionality [26]. Hence, we adopt the Whittle index method [27] by regarding the formulated MDP as a restless multi-armed bandit (RMAB). Specifically, we relax the scheduling constraint of the formulated MDP. This allows us to decouple the original problem into multiple constrained problems, which are then formulated as independent sub-MDPs using Lagrange relaxation. â€¢ Through an in-depth analysis of the sub-MDP structure, we rigorously prove that the sub-MDP is unichain, and its optimal scheduling policy is threshold-type with two thresholds associated with the query arrival state. Building on this, we establish the Whittle indexability of the sub-MDP by verifying the active condition of indexability, a recently introduced and easy-to-verify criterion [28]. To obtain more design insights, we investigate the steady-state probability distributions of the formulated sub-MDP under the threshold-type policies in a variety of contexts. On this basis, we derive the analytical expressions for different Whittle indices in terms of the expected average QAoI and scheduling time of the sub-MDP under threshold-type policies. â€¢ We design an efficient algorithm to calculate Whittle indices for the sub-MDP, inspired by the framework in [29] for computing Whittle indices of MDPs with discounted rewards. The computational complexity of the proposed algorithm is reduced compared to the referenced approach by leveraging the threshold structure and the derived analytical expressions of Whittle indices of the sub-MDP. Moreover, closed-form expressions for the Whittle index of the sub-MDP under error-free channels are also obtained based on the simplified sub-MDP structure. Simulation results validate our theoretical analysis and demonstrate the superior, asymptotically optimal performance of the proposed Whittle index policy compared to baseline schemes. We note that Whittle index methods have been used to address AoI-related scheduling problems without considering the query arrival process (see, e.g., [30, 31, 14, 32]). In these works, the authors carefully analyzed the structures of the formulated RMABs and derived the value functions in closed form. They then established the Whittle indexability of these problems using the closed-form value functions. However, in our problem, the query arrival processes at the BS result in bi-dimensional sub-MDP states and complex state transitions. This makes deriving closed-form value functions and subsequently a closed-form Whittle index challenging, if not impossible. Thus, the methods used to establish Whittle indexability in previous works are not applicable to our problem. Notations: In this paper, â„¤+superscriptâ„¤\mathbb{Z}^{+}blackboard_Z start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT represents the set of positive integers, ğ”¼â¢[â‹…]ğ”¼delimited-[]â‹…\mathbb{E}[\cdot]blackboard_E [ â‹… ] denotes the operator of expectation, entity [â‹…]delimited-[]â‹…[\cdot][ â‹… ] is the representation of a vector containing the same type of elements, and âŸ¨â‹…âŸ©delimited-âŸ¨âŸ©â‹…\langle\cdot\rangleâŸ¨ â‹… âŸ© denotes a tuple containing different types of elements."
https://arxiv.org/html/2411.02061v1,"Massive MIMO over Correlated Fading Channels: Multi-Cell MMSE Processing, Pilot Assignment and Power Control","We consider a multi-cell massive multiple-input-multiple-output (MIMO) system with correlated Rayleigh fading channels, where pilot reuse is permitted within each cell (to reduce pilot overhead), and each base station (BS) utilizes multi-cell minimum mean square (M-MMSE) precoders and combining. We derive a large-scale approximation of the uplink signal-to-interference-and-noise ratio (SINR) that is asymptotically tight in the large system limit. By leveraging the derived SINR approximation, we (i) develop a low-complexity multi-cell pilot assignment (PA) scheme aimed at minimizing pilot contamination from pilot-sharing users, via effectively exploiting the channel spatial correlation matrices of all users in the network, (ii) design pilot and data power allocation schemes, using both the weighted sum and max-min spectral efficiency (SE) metrics. Simulations demonstrate the superiority of our multi-cell PA scheme, requiring significantly less pilot overhead. The proposed power allocation schemes also achieve substantial sum SE gains with good fairness among users compared to equal power allocation.","Massive Multiple-Input Multiple-Output (MIMO) wireless communications have emerged as a key technology not only for 5G but also for 6G networks, particularly when integrated with intelligent reflecting surfaces (IRSs) [1, 2, 3], wireless information and power transfer (WIPT) [4], and integrated sensing and communication (ISAC) [5, 6]. The concept entails equipping cellular base stations (BSs) with an extensive number of antennas to simultaneously serve multiple single-antenna users on the same time-frequency resource. Deploying a large number of antennas allows for averaging out intra-cell interference and uncorrelated additive noise (assuming no pilot reuse within a cell) through the use of linear precoders and decoders, enhancing system spectral efficiency (SE)[7]. A significant literature explores achievable SE in massive MIMO systems, focusing on single-cell processing schemes such as matched filtering (MF), zero-forcing (ZF), and single-cell minimum mean square error (S-MMSE) for both uplink reception and downlink transmission [8][9]. The main characteristic of single-cell processing schemes is that each BS only utilizes the channel estimates of its own intra-cell users to generate the precoders and decoders. It is worth mentioning that the majority of these works focus on simple single-cell processors (MF and ZF) and an uncorrelated channel model, enabling the derivation of a closed-form expression for achievable SE and finding the optimal power allocation. While these simple single-cell processors demonstrate computational efficiency, and enabling the derivation of a closed-form expression [1, 10, 11, 12], they fall short in achieving the highest SE when compared to multi-cell processors. [13] and [14] proposed the multi-cell MMSE (M-MMSE) scheme, considered as the optimal linear processor. In this scheme, each BS utilizes the channel estimates of all users in the network to generate the decoders. The authors in [15] employed a method similar to [9] to derive a closed-form SE for M-MMSE processors with an uncorrelated channel model. While assuming an uncorrelated channel model simplifies deriving a closed-form SE and developing power allocation algorithms, it lacks realism where practical massive MIMO channels are spatially correlated. The literature lacks a closed-form SE for M-MMSE or S-MMSE processors when pilot reuse is permitted within each cell under a spatially correlated channel model. Deriving a closed-form SE for M-MMSE processors for spatially correlated channels is a highly challenging task, and one of our contributions in this work is to address this gap. Accurate channel estimation is crucial for constructing precoders and detectors. Nevertheless, pilot contamination, resulting from the reuse of pilots in adjacent cells due to limited pilot resources, persists even with an increased number of BS antennas, establishing pilot contamination as the recognized performance bottleneck in multi-cell massive MIMO systems[16], [8]. Pilot designs have undergone thorough investigation to effectively mitigate the pilot contamination effect. In [17], a smart pilot assignment (PA) scheme is proposed to enhance the max-min fairness SE, by exploiting the large-scale characteristics of fading channels and optimizing a heuristic metric that quantifies the mutual interference between pilot sharing users in adjacent cells.In [18], a PA scheme based on weighted graph coloring is proposed to increase the uplink sum SE, leveraging a key observation that the strength of potential pilot contamination varies among users, and demonstrating its superior performance compared to the schemes presented in [17] and [19]. Rather than framing the pilot design as a combinatorial assignment problem, [20] represented the pilot signals using a pilot basis and regarded the corresponding power coefficients as continuous optimization variables. However, extending this design and the proposed optimization problem in [20] to S-MMSE and M-MMSE processing poses significant mathematical challenges. Moreover, the computational time required to reach the optimization solution is considerable when compared to the time-scale of variations in channel statistics. For correlated fading, the authors in [21] proved that if pilot sharing users in different cells have non-overlapping AOA intervals, then a BS can estimate the channel of each user in its cell free of pilot contamination. However, the proposed PA scheme in [21] targets minimizing the sum of channel estimation error covariances in the network and does not directly utilize the principle of having non-overlapping AOA intervals for pilot sharing users. Further, the assumption of small AOA spread for each user in [21] may not hold true in practical wireless systems. Moreover, for the algorithm in [21] to be executed, each BS requires access to all spatial correlation matrices of the network, resulting in a significant overhead for information exchange. It is worth emphasizing that all the aforementioned works operate under the assumption that each BS employs single-cell precoders and detectors, resulting in what we term single-cell PA schemes. One of our contributions is to demonstrate (in Section IV) the inefficiency of these schemes in effectively suppressing pilot contamination when each BS utilizes M-MMSE precoders and detectors. This motivates us to propose our multi-cell PA scheme, specifically tailored for scenarios where each BS utilizes M-MMSE processing. Considering M-MMSE processing and uncorrelated Rayleigh fading channels, [15] introduced a pilot reuse factor fğ‘“fitalic_f to mitigate pilot contamination, ensuring each pilot is only reused in 1/f1ğ‘“1/f1 / italic_f of the cells. While this approach significantly reduces pilot contamination and enhances uplink sum rate, even with random PA within each cell, it necessitates using fğ‘“fitalic_f times more pilots than in systems reusing pilots in every cell. To address the increased pilot overhead associated with a large fğ‘“fitalic_f, [15] assumed a large coherence block. However, this overlooks the fact that blind channel estimation methods [22, 23, 24] can minimize interference without requiring additional pilot overhead for large coherence blocks. In this paper, we investigate a multi-cell massive MIMO system with correlated Rayleigh fading channels, where pilot reuse is permitted within each cell (to reduce pilot overhead), and each BS utilizes M-MMSE precoders and detectors. Our main contributions follow. âˆ™âˆ™\bulletâˆ™ Applying random matrix theory, we derive a large-scale approximation of the uplink signal-to-interference-and-noise ratio (SINR) that is asymptotically tight in the large-system limit. Compared to [15], which derived a large-scale approximation of the uplink SINR for M-MMSE processors under an uncorrelated channel model, our derivation (Theorem 3 and its proof) is significantly more complex due to the inclusion of a spatially correlated channel model and the allowance of pilot reuse within each cell. âˆ™âˆ™\bulletâˆ™ By leveraging the derived SINR approximation, we introduce a low-complexity multi-cell PA scheme aimed at minimizing interference from pilot-sharing users. This is achieved by effectively exploiting the channel covariance matrices of all users in the network. Notably, the scheme entails minimal information exchange among BSs and incurs low pilot overhead. Additionally, we devise a single-cell PA scheme using weighted graph coloring tailored for M-MMSE processing and correlated Rayleigh fading. Integrating this single-cell scheme into our analysis ensures impartial validation and facilitates a comprehensive comparison with our proposed multi-cell PA scheme. âˆ™âˆ™\bulletâˆ™ Given the proposed multi-cell PA, we find the optimal pilot power allocation among all users such that a weighted sum of all the channel estimation error covariance matrices in the network is minimized, subject to a constraint on average power per user, while allows users to conserve power for data transmission without compromising the quality of channel estimation. With the multi-cell PA and pilot power allocation determined, we utilize the derived SINR approximation to optimize the uplink data power allocation. Moreover, leveraging the uplink-downlink duality, we determine the optimal downlink data power to maximize both the weighted sum and max-min SE metrics, while adhering to a constraint on the average energy per user. Notation: Upper and lower case bold letters are used for matrices and vectors. The superscripts ()Tsuperscriptğ‘‡{()}^{T}( ) start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT, ()Hsuperscriptğ»{()}^{H}( ) start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT stand for transpose and Hermitian operations, respectively. The â„â„\mathbb{R}blackboard_R and â„‚â„‚\mathbb{C}blackboard_C are adopted for real value and complex numbers. The expectation, variance, trace and diagonal of a matrix, real part of the argument, Euclidean norm and Frobenius norm are denoted by ğ”¼â¢{}ğ”¼\mathbb{E}\left\{\ \right\}blackboard_E { }, ğ•â¢{}ğ•\mathbb{V}\left\{\ \right\}blackboard_V { }, tr(.)tr(.)italic_t italic_r ( . ), diag(.)diag(.)italic_d italic_i italic_a italic_g ( . ), â„œâ¢{}\Re\left\{\ \right\}roman_â„œ { }, âˆ¥âˆ¥2\|\|_{2}âˆ¥ âˆ¥ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT and âˆ¥âˆ¥F\|\|_{F}âˆ¥ âˆ¥ start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT, respectively. ğˆMsubscriptğˆğ‘€\mathbf{I}_{M}bold_I start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT and ğŸMsubscript0ğ‘€\mathbf{0}_{M}bold_0 start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT is the size-Mğ‘€Mitalic_M identity and all-zero matrix, respectively. We use ğ’©â„‚â¢(ğŸ,ğ‘)subscriptğ’©â„‚0ğ‘\mathcal{N}_{\mathbb{C}}\left(\mathbf{0},\mathbf{R}\right)caligraphic_N start_POSTSUBSCRIPT blackboard_C end_POSTSUBSCRIPT ( bold_0 , bold_R ) to denote the circularly symmetric complex Gaussian distribution with zero mean and covariance matrix R. Also we use aâ‰basymptotically-equalsğ‘ğ‘a\asymp bitalic_a â‰ italic_b to denote aâˆ’bâŸ¶a.s.0superscriptâŸ¶a.s.ğ‘ğ‘0a-b\stackrel{{\scriptstyle{\text{a.s.}}}}{{\longrightarrow}}0italic_a - italic_b start_RELOP SUPERSCRIPTOP start_ARG âŸ¶ end_ARG start_ARG a.s. end_ARG end_RELOP 0 almost surely (a.s.) for two random sequences. User jâ¢kğ‘—ğ‘˜jkitalic_j italic_k refers to user kğ‘˜kitalic_k in cell jğ‘—jitalic_j. The rest of the paper is organized as follows. In Section II, we describe the system model, derive achievable uplink and downlink rates, and provide an intuition for the M-MMSE scheme. In Section III, we derive an asymptotically tight approximation of the uplink SINR. In Section IV, we characterize our proposed multi-cell and single-cell PA schemes. Section V details our proposed pilot and data power allocation. Section VI includes our numerical results. Section VII contains our concluding remarks."
https://arxiv.org/html/2411.02008v1,"Fair Beam Synthesis and Suppression via Transmissive Reconfigurable Intelligent Surfacesâ€ â€ thanks:This work is supported in part by the National Natural Science Foundation of China (NSFC) under Grants NO.12141107 and NO.11801200, and the Interdisciplinary Research Program of HUST (2023JCYJ012).","Existing phase optimization methods in reconfigurable intelligent surfaces (RISs) face significant challenges in achieving flexible beam synthesis, especially for directional beam suppression. This paper introduces a Max-min criterion incorporating non-linear constraints, utilizing optimization techniques to enable multi-beam enhancement and suppression via transmissive RISs. A realistic model grounded in geometrical optics is first presented to characterize the input/output behavior of transmissive RIS, effectively linking explicit beam-forming operations with practical implementation. Subsequently, a highly efficient bisection-based algorithm for constrained Max-min optimization involving quadratic forms is developed, utilizing an auxiliary variable and Moreau envelope to iteratively reach the optimal solution. This approach demonstrates excellent extensibility and is applicable to a wide range of constrained Max-min problems. Numerical simulations validate the proposed methods, confirming that the framework enables beam enhancement or suppression at designated spatial positions.","Reconfigurable intelligent surface (RIS) is anticipated to be a pivotal technology for future 6G communications networks due to its great capability to reconfigure and optimize wireless propagation environments [1]. Despite RIS has been demonstrated to enhance system performance in various wireless networks, current implementations predominantly rely on reflective designs, which introduces certain limitations and results in undesirable coverage gaps in practical applications [2]. Specifically, reflective RIS requires both the base station (BS) and the user equipment (UE) to be positioned on the same side of the RIS, imposing additional geographical constraints on the physical topology [3]. For instance, reflective RIS encounters difficulties in facilitating communication between a transmitter outside a vehicle and a receiver inside it, as well as in establishing communication links between indoor and outdoor environments through walls or windows. To tackle these limitations, the transmissive RIS technique is garnering increasing attention [4, 5]. transmissive RIS allows signals to transmit through itself to form directional beams. Similar to reflective RISs, transmissive RISs can be utilized to establish extra refractive communication links between the BS and UE. Additionally, due to the absence of physical topology constraints, transmissive RIS is increasingly utilized to design novel transmitter architectures, facilitating beamforming design and power allocation [6]. Compared to reflective RISs, transmissive RISs boast higher aperture efficiency due to their structural features, which eliminates the issues of feed source occlusion and the interference from reflected waves [7]. As a primary function of a passive array, beam synthesis (allocation) characterizes the process through which RISs convert the energy from incident electromagnetic waves into reflected or refracted waves, explicitly forming directional beams [8]. In both reflective RIS and transmissive RIS, the beam synthesis functionality can be achieved through phase configuration, and the existing phase configuration methods employed in reflective RIS can be readily applied to transmissive RIS systems due to the similarity of mathematical models [2]. The simple beam scanning can be realized through phase compensations [2, 9], alongside employing exhaustive search techniques [10], hierarchical search methods [11], and machine learning approaches [12] to tackle beam training and alignment. Additionally, certain multi-beam synthesis can be achieved through physical-related transfer functions [13], pattern approximations and lookup table [14], and the superposition of reflection coefficients [15]. Our previous research has also illustrated that by resolving max-min optimization problems, specific beam synthesis capabilities can be attained [8]. However, these studies primarily concentrate on the main beam, with limited consideration for sidelobe energy. Conversely, sidelobes introduce interference and noise, potentially degrading system performance in dense networks or complex environments. Furthermore, the presence of extra sidelobes heightens the risk of information leakage in communications. In this work, we explore the beam synthesis while incorporating sidelobe constraints. By formulating and optimizing constrained Max-min problems, the proposed framework allows the signal to be either enhanced or physically suppressed in desired spatial directions, manifesting high-directional beams or beam nulls. To our knowledge, this marks the first successful implementation of flexible beam synthesis and suppression using a passive reconfigurable array. The main contributions can be summarized as follows: â€¢ Physical model and constrained Max-min problem formulation. We present practical and realistic models grounded in geometrical optics to characterize the input/output behaviors of transmissive RISs. Based on that, a max-min optimization problem with non-linear constraints is then formulated to explore the beam synthesis capabilities of the transmissive RIS. â€¢ Novel methods for constrained Max-min problem. In this context, we introduce an auxiliary variable, along with a smooth approximation function given by Moreau envelope to reformulate the original constrained Max-min problem, and then iteratively obtain the optimal solution with a bisection-based (BIS) method. In each iteration, a smooth unconstrained sub-problem is solved using an accelerated gradient descent algorithm. â€¢ Flexible beam synthesis exploration and achievement. The proposed algorithms enable either precise signal enhancement or suppression across different directions simultaneously. These beam capabilities is applicable to reflective RISs through appropriate modeling and reflection coefficients. Extensive simulations validated the effectiveness of the framework."
https://arxiv.org/html/2411.01878v1,Rician Channel Modelling for Super Wideband MIMO Communications,"Recent developments in Multiple-Input-Multiple-Output (MIMO) technology include packing a large number of antenna elements in a compact array to access the bandwidth benefits provided by higher mutual coupling (MC). The resulting super-wideband (SW) systems require a circuit-theoretic framework to handle the MC and channel models which span extremely large bands. Hence, in this paper, we make two key contributions. First, we develop a physically-consistent Rician channel model for use with SW systems. Secondly, we express the circuit-theoretic models in terms of a standard MIMO model, so that insights into the effects of antenna layouts, MC, and bandwidth can be made using standard communication theory. For example, we show the bandwidth widening resulting from the new channel model. In addition, we show that MC distorts line-of-sight paths which has beamforming implications. We also highlight the interaction between spatial correlation and MC and show that tight coupling reduces spatial correlations at low frequencies.","The advantages of conventional Multiple-Input-Multiple-Output (MIMO) in terms of enhanced spatial diversity and spectral efficiency are well-known [1]. More recently, interest has turned to the use of large arrays in compact spaces resulting in closely packed antenna elements. In addition to increasing spatial diversity and spectral efficiency, the use of closely packed antennas leads to operational bandwidth widening and super-wideband (SW) systems [2]. This bandwidth widening effect has been demonstrated in [2] through modelling the mutual coupling (MC) between antenna elements in an array. Although traditional array designs typically avoid the adverse effects of high MC by spatially isolating antenna elements [3, 4], designs of colinear connected arrays have been shown to achieve SW performance [5, 6]. However, previous works are heavily based on circuit theory and the use of simple channel models when analyzing communications performance. Also, the channel models used do not maintain consistency in the parameters and channel values across the massive bandwidth. Hence, in this paper, we make two key contributions. First, we develop a physically-consistent, correlated Rician channel model for use across the whole bandwidth. Secondly, we express the circuit-theoretic models in terms of a standard MIMO model, so that insights into the effects of antenna layouts, MC and bandwidth can be made using standard communication theory. In developing the correlated Rician channel model, we integrate multiport network theory [7] into communication theory to properly account for MC effects and provide a physically-consistent channel model. We include spatial channel correlations and frequency correlations in our channel modelling, as opposed to [2, 8] that only considered spatial correlations. We present a method to compute the Rician K-factor across the frequency domain based on recent measurement campaigns. Numerical results based on the developed channel model show the SW gains of tightly coupled arrays in the presence of spatial and frequency correlations. We also show two key changes to the global channel structure caused by tightly coupled arrays: a) the steering vector structure of line-of-sight (LoS) rays is distorted and has beamforming implications; and b) the spatial correlation at low frequencies is reduced. All of these observations are illustrated using extensive numerical examples. Notation: â„œ{.}\Re\{.\}roman_â„œ { . } represents the real part of a complex number or matrix. For any matrix ğ€ğ€\mathbf{A}bold_A or vector ğ’‚ğ’‚\bm{a}bold_italic_a, ğ€Tsuperscriptğ€ğ‘‡\mathbf{A}^{T}bold_A start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT and ğ’‚Tsuperscriptğ’‚ğ‘‡\bm{a}^{T}bold_italic_a start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT denote the transpose, while ğ€Hsuperscriptğ€ğ»\mathbf{A}^{H}bold_A start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT and ğ’‚Hsuperscriptğ’‚ğ»\bm{a}^{H}bold_italic_a start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT indicate the conjugate transpose. diagâ¢(ğ€)diagğ€\text{diag}(\mathbf{A})diag ( bold_A ) creates a diagonal matrix by setting all off-diagonal elements to zero. ğˆMsubscriptğˆğ‘€\mathbf{I}_{M}bold_I start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT is the identity matrix of size MÃ—Mğ‘€ğ‘€M\times Mitalic_M Ã— italic_M, and ğ”¼[.]\mathbb{E}[.]blackboard_E [ . ] denotes the statistical expectation."
https://arxiv.org/html/2411.01821v1,IRS-Enhanced Secure Semantic Communication Networks: Cross-Layer and Context-Awared Resource Allocation,"Learning-task oriented semantic communication is pivotal in optimizing transmission efficiency by extracting and conveying essential semantics tailored to the specific tasks, such as image reconstruction and classification. Nevertheless, the challenge of eavesdropping poses a formidable threat to semantic privacy due to open nature of wireless communications. In this paper, intelligent reflective surface (IRS)-enhanced secure semantic communication (IRS-SSC) is proposed to guarantee the physical layer security from a task-oriented semantic perspective. Specifically, a multi-layer codebook is exploited to discretize continuous semantic features and describe semantics with different numbers of bits, thereby meeting the need for hierarchical semantic representation and further enhancing the transmission efficiency. Novel semantic security metrics, i.e., secure semantic rate (S-SR) and secure semantic spectrum efficiency (S-SSE), are defined to map the task-oriented security requirements at the application layer into the physical layer. To achieve artificial intelligence (AI)-native secure communication, we propose a noise disturbance enhanced hybrid deep reinforcement learning (NdeHDRL)-based resource allocation scheme. This scheme dynamically maximizes the S-SSE by jointly optimizing the bits for semantic representations, reflective coefficients of the IRS, and the subchannel assignment. Moreover, we propose a novel semantic context awared state space (SCA-SS) to fusion the high-dimensional semantic space and the observable system state space, which enables the agent to perceive semantic context and solves the dimensional catastrophe problem. Simulation results demonstrate the efficiency of our proposed schemes in both enhancing the security performance and the S-SSE compared to several benchmark schemes.","Task-oriented semantic communication can alleviate network congestion and enhance communication efficiency, which is a promising technology for the sixth-generation (6G) communications [1, 2, 3]. Several works demonstrate the efficiency of semantic communication from mathematical theory [4, 5]. As one of emantic communication paradigms, artificial intelligence (AI)-driven semantic communication can characterize the task-oriented information over semantic symbols by leveraging the formidable knowledge extraction capabilities of machine learning (ML), thus significantly reducing the irrelevant information and improving the transmission efficiency [6, 7, 8]. However, the open nature of wireless channel poses the challenge of semantic eavesdropping, leading to serious task exposure and privacy leakage. Different from the traditional secure communication that relies on bit-level security at the physical layer, task-oriented secure semantic communication should be concerned with task-level privacy preservation. Hence, it is necessary for semantic communication networks to rethink secrecy protection from the task-centered semantic perspective [9]. Research on secure semantic communication mainly focuses on the application layer security [10] and the physical layer security [11]. The objective of semantic security at the application layer is to protect the task intention and the task implementation. Hence, main research focus is secure semantic coding [9] and semantic encryption schemes [12] for task-level privacy protection. Different from semantic security at the application layer, the traditional physical layer technologies for semantic security remain the protection of semantic symbols over the physical channel [13]. Therefore, conventional metrics for symbol protection at the physical layer are insufficient for effectively assessing task-oriented security. Similarly, metrics for single intention protection at the application layer struggle to measure the semantic transmission efficiency over physical bits, which in turn hinders the ability to optimize the physical resource at the semantic level. To the best knowledge of authors, it remains a tricky problem to measure and ensure the physical layer security from a semantic-level intention protection perspective [14, 15, 11], which is essential for efficient secure semantic communications. Recently, intelligent reflective surface (IRS) has gained significant attention due to its ability to accurately reshape signal propagation in a low-cost and programmable manner [16], which has been widely used to improve spectrum efficiency [17] and communication security [18]. Specifically, an IRS is a planar array of numerous programmable and passive reflective elements [19]. Compared to traditional physical security techniques, such as relaying and artificial noise [20, 21, 22], IRS is more energy efficient in manipulating signals by utilizing passive reflection [18]. The signal reshaping capability of IRS is promising to create a secure transmission environment for semantic communications, suppressing semantic eavesdropping and enhancing task performance [23]. Hence, it is crucial to investigate resource allocation with the programmable IRS to bolster semantic security toward future wireless networks. Deep reinforcement learning (DRL)-based resource allocation schemes exhibit superior real-time performance with intelligence, which has been used to rapidly tackle large-scale intricate problems [24, 17]. Compared to the traditional mathematical optimization methods, such as the block coordinate descent (BCD) [25] and the alternating optimization (AO) [26], DRL-based schemes can manage the network resource in a low-complex and time-efficient way, particularly to address the system complexity caused by the IRS [18]. Moreover, since DRL is AI-native, it works in coordination with ML-driven semantic communication networks [27], where the intelligent agent can perceive the task-related semantics. Given the above considerations, DRL-based resource allocation schemes can be a promising solution for the development of efficient and intelligent seucre semantic communication [28]. At the application layer, semantic symbol encryption [10, 12, 29] and secure semantic coding [29, 9] are two main approaches to ensure semantic security. For the secrecy over encrypted semantic symbols, a public-key cryptographic game was played in [10] against the chosen-plaintext attack. The authors in [12] utilized neural networks, trained by adversarial encryption, to embed the encrypted information into the semantics. However, the public-key encryption scheme [10] is computationally expensive, and the encryption embedding scheme [12] increases communication costs with extra security information. For the secure semantic coding, the authors in [29] introduced the semantic perturbations to the semantic symbols and misled the semantic interpreter at the eavesdropper with the unseen perturbations. In [9], further considering the worst case that the semantic interpreters were the same for both the users and eavesdroppers, the authors directly trained the semantic coding networks with the physical channel differences. However, the security of semantic coding is threatened since the neural networks are non-interpretable and fragile, making it hard to be applicable to practical wireless communication environments with dynamic channel. For the semantic security at the physical layer, the authors in [11] investigated the covert communication and used a jammer to interfere with the warden to detect semantic information. However, the artificial jamming requires the extra energy consumption. To address this problem, the authors in [13] applied the IRS to suppress the information leakage to the eavesdropper. It is worth noting that there have been few works that consider the IRS-enhanced semantic communication networks. In fact, the research on IRS-assisted conventional communication has demonstrated the significant security gain from the IRS. The authors in [30] utilized the IRS to counteract eavesdropping from the malicious terminals in multiple-input multiple-output (MIMO) systems. In [18] and [17], IRS-enhanced secure cognitive networks were considered, where the IRS improved the security of the secondary network and alleviated the interference from the secondary network to the primary network. However, similar to the conventional communication, the work [13] on semantic communication solely aimed to suppress the signal-to-noise ratio (SNR) at the eavesdroppers, i.e., the bit-level security gain, which had practical limitations from the task perspective. Aimed at further enhancing the semantic security efficiency, several semantic resource allocation schemes were investigated. The authors in [31] defined the metric of semantic spectral efficiency, and used the look-up table method to search the optimal semantic symbols assignment. In [32], the authors considered multi-task and multi-cell semantic communications, and utilized deep Q networks to improve the quality-of-experience. To explore the robust and interpretable resource management, the works [33, 34, 35] incorporated causal reference into the semantic resource allocation schemes. An attention-based DRL method was proposed in [33] to optimize the transmitted resource blocks. From a gaming perspective, the authors in [34] and [35] considered resource allocation as a two-player signaling game. Extending to the resource allocation for secure semantic communication, the authors in [11] applied the diffusion model to generate the optimal resource allocation scheme. In [13], the AO method was used to optimize the transmit power and IRS reflective coefficients. However, semantic-awared resource allocation remains unexplored since the resource requirements differ with different task-related semantics. Moreover, ML-driven semantic communications call for AI-native communication networks with intelligent resource allocation schemes. Motived by above-mentioned considerations, in this paper, we investigate a context-awared resource allocation scheme for IRS-enhanced secure semantic communication (IRS-SSC) networks. Since the existing secure communication metrics at the physical layer focus on the bit-level security, firstly, we map the security requirements of the application layer into the physical layer and define the novel metrics for cross-layer secure semantic communication. Then, the IRS can reshape semantic symbols to suppress the semantic eavesdropping related to the reconstruction task. To enhance the security performance and robustness of resource allocation, a DRL-based intelligent resource allocation scheme with noise disturbance for action decisions is proposed. The neuron network-based space fusion method is leveraged to form the semantic-context-aware state space (SCA-SS), which consists of rich semantic space and the observable environment state space. In this case, our proposed resource allocation scheme can effectively perceive the semantic context and address the high-dimensionality problem, thus enhancing the security efficiency. The main contributions of this paper are summarized as follows. â€¢ Considering the semantic eavesdropping over open wireless communications, we propose a novel IRS-SSC network, where the reflective elements of the IRS can adaptively reshape the propagation of semantic symbols to suppress the semantic eavesdropping and enhance the task performance. To discretize the continuous semantic vectors and further enhance the semantic transmission efficiency, a multi-layer codebook is proposed for the first time, where the multi-layer framework aims to trade off the security requirements, semantic difference, task performance and resource limitations. â€¢ Since task-oriented semantic security depends on intention protection at the application layer, we map the security requirement of the application layer into the physical layer and redefine cross-layer semantic security (CL-SS) metrics, such as secure semantic rate (S-SR) and secure semantic spectrum efficiency (S-SSE), enabling the physical layer to be aware of intention protection performance. We design an adaptive resource allocation scheme achieved by using the noise-disturbance-enhanced hybrid DRL (NdeHDRL). This implementation establishes a robust and AI-native secure semantic communication network. Moreover, to effectively address the problem of dimensional catastrophe caused by high-dimensional semantic features and IRS reflective coefficients, we develop a novel SCA-SS to furnish the agent with the semantic context and observable state features. â€¢ Simulation results demonstrate that our proposed NdeHDRL scheme achieves 15.4%percent15.415.4\%15.4 % semantic secure performance improvement compared to the HDRL-DS scheme. Moreover, our proposed NdeHDRL scheme with SCA-SS obtains 283%percent283283\%283 % S-SSE improvement compared to the schemes without IRS, and 16.5%percent16.516.5\%16.5 % S-SSE improvement compared to the NdeHDRL-DS scheme with simple collocation of semantic spaces and observable state spaces (CSO-SS). Furthermore, we verify the superior computational efficiency and real-time performance of our proposed scheme compared to the traditional method. The remainder of this paper is organized as follows. Section II presents the IRS-SSC network. In Section III, the cross-layer security metric is defined, and the formulated resource allocation problem is presented. Section IV presents the NdeHDRL-based intelligent resource allocation scheme and the SCA-SS. In Section V, the simulation results and analyses are presented. Finally, Section VI concludes this paper. Notation: The real matrices set with size xÃ—yğ‘¥ğ‘¦x\times yitalic_x Ã— italic_y is represented by â„xÃ—ysuperscriptâ„ğ‘¥ğ‘¦\mathbb{R}^{x\times y}blackboard_R start_POSTSUPERSCRIPT italic_x Ã— italic_y end_POSTSUPERSCRIPT, and the complex matrices with size xÃ—yğ‘¥ğ‘¦x\times yitalic_x Ã— italic_y is denoted by â„‚xÃ—ysuperscriptâ„‚ğ‘¥ğ‘¦\mathbb{C}^{x\times y}blackboard_C start_POSTSUPERSCRIPT italic_x Ã— italic_y end_POSTSUPERSCRIPT. The mathematical expectation is represented by ğ”¼â¢[â‹…]ğ”¼delimited-[]â‹…\mathbb{E}[\cdot]blackboard_E [ â‹… ]. The element set is denoted by {â‹…}â‹…\{\cdot\}{ â‹… }, and (x)+superscriptğ‘¥(x)^{+}( italic_x ) start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT means it makes sense only when xğ‘¥xitalic_x is positive. The function argâ¡maxğ‘¥â¢gâ¢(x)ğ‘¥ğ‘”ğ‘¥\arg\underset{x}{\max}g(x)roman_arg underitalic_x start_ARG roman_max end_ARG italic_g ( italic_x ) denotes the value of xğ‘¥xitalic_x that can maximize fâ¢(x)ğ‘“ğ‘¥f(x)italic_f ( italic_x ). The diagâ¡(ğ±)diagğ±\operatorname{diag}(\mathbf{x})roman_diag ( bold_x ) denotes a diagonal matrix with diagonal elements corresponding to the elements of ğ±ğ±\mathbf{x}bold_x. The vector is denoted by ğ¯ğ¯\mathbf{v}bold_v while the matrix is denoted by ğ•ğ•\mathbf{V}bold_V. The transpose of the vector is denoted by ğ¯Tsuperscriptğ¯ğ‘‡\mathbf{v}^{T}bold_v start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT and the conjugate transpose is denoted by ğ¯Hsuperscriptğ¯ğ»\mathbf{v}^{H}bold_v start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT. The notation (x)+superscriptğ‘¥\left(x\right)^{+}( italic_x ) start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT denotes the positive part of xğ‘¥xitalic_x."
https://arxiv.org/html/2411.01776v1,On Energy Efficiency of Hybrid NOMA,"This paper aims to prove the significant superiority of hybrid non-orthogonal multiple access (NOMA) over orthogonal multiple access (OMA) in terms of energy efficiency. In particular, a novel hybrid NOMA scheme is proposed in which a user can transmit signals not only by using its own time slot but also by using the time slots of other users. The data rate maximization problem is studied by optimizing the power allocation, where closed-form solutions are obtained. Furthermore, the conditions under which hybrid NOMA can achieve a higher instantaneous data rate with less power consumption than OMA are obtained. It is proved that the probability that hybrid NOMA can achieve a higher instantaneous data rate with less power consumption than OMA approaches one in the high SNR regime, indicating the superiority of hybrid NOMA in terms of power efficiency. Numerical results are also provided to verify the developed analysis and also to demonstrate the superior performance of hybrid NOMA.","The development of next-generation multiple access (NGMA) techniques to enable sixth-generation (6G) mobile communications has recently attracted considerable attention and effort from both academia and industry [1]. In particular, non-orthogonal multiple access (NOMA) has been recognized as an important candidate for NGMA [2, 3, 4]. For example, NOMA is expected to be considered to meet the future requirements of the recently released International Mobile Telecommunications (IMT)-2030 Framework [5]. Hybrid NOMA, which can be treated as a general form of NOMA and conventional orthogonal multiple access (OMA), has been proposed recently [6, 7, 8]. Unlike existing schemes in [9, 10], where a user can choose to transmit in either OMA or NOMA, in hybrid NOMA, a user can divide its transmission into several orthogonal subchannels (which can be time slots [6], subcarriers [8], spatial beams [7], etc.), and in each subchannel, the user can transmit either in NOMA mode or OMA mode. The advantages of NOMA are mainly twofold [8]. One is its flexibility in implementation, since hybrid NOMA can be developed as a simple add-on to the existing OMA-based legacy network framework. The other is its effective resource utilization, since hybrid NOMA allows multidimensional resource allocation, which provides more freedom for optimization. Although promising, research on hybrid NOMA is still in its infancy. This paper aims to investigate the superior advantage of hybrid NOMA in terms of energy efficiency by seeking the answer to the following fundamental question: can hybrid NOMA achieve a higher data rate while consuming less energy than OMA? The main contributions of this thesis are as follows: â€¢ A novel hybrid NOMA scheme is proposed, where a user can transmit signals not only by using its own timeslot, but also by using other usersâ€™ timeslots. The instantaneous data rate maximization problem for the proposed hybrid NOMA scheme is solved with a closed-form solution. â€¢ Based on the obtained expression for the achievable data rate of hybrid NOMA, the comparisons with OMA are made. Specifically, the conditions under which hybrid NOMA can achieve a higher instantaneous data rate with less energy consumption compared to pure OMA are provided. Furthermore, the probability of these conditions is analyzed taking into account the randomness of the channel gains. It is shown that the probability for hybrid NOMA to achieve a higher instantaneous data rate with less power consumption compared to OMA approaches one in the high SNR regime."
https://arxiv.org/html/2411.01766v2,Lyapunov-guided Multi-Agent Reinforcement Learning for Delay-Sensitive Wireless Scheduling,"In this paper, a two-stage intelligent scheduler is proposed to minimize the packet-level delay jitter while guaranteeing delay bound. Firstly, Lyapunov technology is employed to transform the delay-violation constraint into a sequential slot-level queue stability problem. Secondly, a hierarchical scheme is proposed to solve the resource allocation between multiple base stations and users, where the multi-agent reinforcement learning (MARL) gives the user priority and the number of scheduled packets, while the underlying scheduler allocates the resource. Our proposed scheme achieves lower delay jitter and delay violation rate than the Round-Robin Earliest Deadline First algorithm and MARL with delay violation penalty.","With the advancement of 5G technology, the Ultra-Reliable Low Latency Communication (URLLC) scenario has garnered increasing attention. Within the URLLC scenario, there is a significant subset of applications related to industrial process control. According to 3GPP standards [1], in the closed-loop control application, the end-to-end (E2E) delay should be controlled within 2 ms, the reliability needs to achieve 1âˆ’10âˆ’61superscript1061-10^{-6}1 - 10 start_POSTSUPERSCRIPT - 6 end_POSTSUPERSCRIPT, and the delay jitter should be controlled to 1 Î¼Î¼\upmuroman_Î¼s. Such applications impose stringent performance requirements on the communication systems, necessitating the assurance of reliability while minimizing the delay and jitter. Related work has studied the resource allocation problem in delay-sensitive scenarios. Yin et al. [2] proposed a long-term energy efficiency optimization scheme considering the queue conditions for the cell-free multiple-input multiple-output system in the URLLC scenario. Addressing the joint scheduling and power allocation problem in a downlink cellular system, Ewaisha et al. [3] proposed two algorithms to cater to both real-time and non-real-time users. With the support of Lyapunov techniques, these algorithms achieve the systemâ€™s capacity region. Similarly, Neely et al. [4] developed a scheduling algorithm suitable for users with different delay constraints in a single-hop wireless communication system. Moreover, Reinforcement Learning (RL) has been widely applied to address the resource allocation problem in URLLC scenarios due to its strong adaptability to dynamic networks. Shafieirad et al. [5] explored the challenge of scheduling under maximum delay constraints in downlink multi-cell wireless communication networks. The authors introduced a novel approach within an RL framework to tackle these constraints effectively. Fan et al. [6] transformed the resource allocation problem into an integer nonlinear optimization problem, focusing on minimizing the delay of all tasks while ensuring the constraint of the Quality of Service (QoS) requirements, and an online RL strategy is further employed for the real-time dynamic resource allocation. Elsayed et al. [7] investigated the coexistence of URLLC and enhanced Mobile Broadband users in 5G networks, and proposed a Q-learning-based RL algorithm optimizing the power and resource allocation. In existing works, the impact of delay jitter is often neglected. In the time-sensitive scenarios such as industrial automation and remote healthcare, the delay jitter can lead to unstable data transmission, affecting the system responsiveness and processing efficiency [8]. Furthermore, prior studies often treat delay violation as an optimization objective, aiming to minimize the probability of delay violation, rather than considering it as a strict constraint. Although Yin et al. [2] addressed delay violation as a constraint, their approach transformed the constraint on delay violation probability into a constraint on queue length. This transformation gradually relaxes the original constraint condition over an extended time window, introducing bias in practical applications. Moreover, due to the substantial uncertainties inherent in practical communication systems, ensuring deterministic low delay has become exceedingly challenging. In aiming to ensure communication delay falls within a certain range with a specified probability, guaranteeing probabilistic delay holds significant value. The contributions of this letter can be summarized as follows: Firstly, a multi-cell multi-user scenario requiring low delay jitter and ensuring probabilistic delay constraints is investigated. Secondly, a joint model and data-driven two-stage intelligent scheduling algorithm aimed at minimizing jitter with the probabilistic delay constraint is proposed. In the first stage, assisted by Lyapunov techniques, the long-term delay violation probability constraint is transformed into a single-slot virtual queue stability condition. In the second stage, to address the challenge of a large action space when directly allocating resources, a hierarchical algorithm is introduced. A multi-agent RL (MARL) algorithm is employed to allocate priorities and guide the number of packets to be scheduled for each user, based on which the underlying scheduler allocates resources to each user. Simulations show that compared to the Round-Robin Earliest Deadline First (EDF) algorithm and the MARL with delay violation penalty, the proposed two-stage scheme perfectly guarantees bounded delay and effectively reduces delay jitter with medium-to-low traffic load. Under high traffic load, it also reduces delay jitter while achieves lower delay-bound violation."
https://arxiv.org/html/2411.01504v1,Quantum Locally Recoverable Codesvia Good Polynomials,"Locally recoverable codes (LRCs) with locality parameter rğ‘Ÿritalic_r can recover any erased code symbol by accessing rğ‘Ÿritalic_r other code symbols. This local recovery property is of great interest in large-scale distributed classical data storage systems as it leads to efficient repair of failed nodes. A well-known class of optimal (classical) LRCs are subcodes of Reed-Solomon codes constructed using a special type of polynomials called good polynomials. Recently, Golowich and Guruswami initiated the study of quantum LRCs (qLRCs), which could have applications in quantum data storage systems of the future. The authors presented a qLRC construction based on good polynomials arising out of subgroups of the multiplicative group of finite fields. In this paper, we present a qLRC construction method that can employ any good polynomial. We also propose a new approach for designing good polynomials using subgroups of affine general linear groups. Golowich and Guruswami also derived a lower bound on the minimum distance of their qLRC under the restriction that r+1ğ‘Ÿ1r+1italic_r + 1 is prime. Using similar techniques in conjunction with the expander mixing lemma, we develop minimum distance lower bounds for our qLRCs without the r+1ğ‘Ÿ1r+1italic_r + 1 prime restriction.","In large-scale classical data storage systems, the failure of a single storage node is a more common occurrence than the catastrophic failure of multiple nodes simultaneously. This observation led to the development of various classes of codes that can repair single-node failure efficiently. Locally recoverable codes (LRCs) are an important family of such erasure codes designed for distributed storage. The goal of LRCs is to minimize the number of nodes that are contacted to repair a failed node. In an LRC with locality rğ‘Ÿritalic_r, for any code symbol, there exist at most rğ‘Ÿritalic_r other symbols from which the value of the code symbol can be determined. Some of the early works that investigated codes having local recovery property are [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]. In [13], Golowich and Guruswami introduced the quantum counterpart of LRCs, which will be referred to as quantum LRCs (qLRCs). Although quantum computation and storage are still in their infancy, it is possible that large-scale quantum data storage could become a reality in the future, thereby making quantum codes like qLRCs inevitable. The authors of [13] also pointed to the connections between quantum LDPC codes and qLRCs as an additional motivation to study qLRCs. The CSS construction [14, 15, 16] is a well-known method to construct quantum codes from classical codes. As shown in [13], using CSS framework, one can reduce the problem of constructing qLRCs to that of constructing classical LRCs which contain their dual. Of particular interest for our paper is the LRC construction in [9]. This work presented a family of LRCs that are subcodes of Reed-Solomon codes. These LRCs attain the optimal value of the minimum distance and require only an alphabet of size comparable to the block length. The qLRC construction in [13] essentially involves modifying a special case of the LRC construction in [9] to make it dual-containing. Our work aims to generalize the qLRC construction in [13] to leverage the full potential of the LRC construction in [9]. In detail, the LRC in [9] is obtained by evaluating specially constructed polynomials at a chosen set of points in a finite field. This construction relies on the existence of a special type of polynomials associated with evaluation points, called good polynomials. The annihilator polynomials of cosets of a subgroup of the multiplicative group of the field form one class of good polynomials. In [13], good polynomials of this particular type are used to construct dual-containing LRCs. Many other ways to obtain good polynomials are known in the literature [9, 17, 18, 19, 20]. For example, annihilator polynomials of cosets of an additive subgroup of the field also yield good polynomials. In this paper, we present a method to construct dual-containing LRCs that can employ any good polynomial. The flexibility to choose good polynomials enables us to construct qLRCs for parameters that are not achievable using the construction in [13]. Additionally, we propose a general approach for constructing good polynomials, which, to the best of our knowledge, is not previously known in the literature. This approach is based on subgroups of the affine general linear group and encompasses the good polynomial constructions in [9] as special cases. We also present a lower bound on the minimum distance of our qLRCs constructed using good polynomials based on this affine general linear group approach. This lower bound can be viewed as a generalization of the bound given in [13]. The rest of the paper is organized as follows. In Section II, we introduce relevant notions and provide definitions of LRC and qLRC. Our qLRC construction is presented in Section III. In Section IV, we present a method to obtain good polynomials using subgroups of the affine general linear group. In Section V, we derive lower bounds on the minimum distance of our qLRCs. We conclude the paper in Section VI."
https://arxiv.org/html/2411.01407v1,Reducing Data Fragmentation in Data Deduplication Systems via Partial Repetition and Coding,"Data deduplication, one of the key features of modern Big Data storage devices, is the process of removing replicas of data chunks stored by different users. Despite the importance of deduplication, several drawbacks of the method, such as storage robustness and file fragmentation, have not been previously analyzed from a theoretical point of view. Storage robustness pertains to ensuring that deduplicated data can be used to reconstruct the original files without service disruptions and data loss. Fragmentation pertains to the problems of placing deduplicated data chunks of different user files in a proximity-preserving linear order, since neighboring chunks of the same file may be stored in sectors far apart on the server. This work proposes a new theoretical model for data fragmentation and introduces novel graph- and coding-theoretic approaches for reducing fragmentation via limited duplication (repetition coding) and coded deduplication (e.g., linear coding). In addition to alleviating issues with fragmentation, limited duplication and coded deduplication can also serve the dual purpose of increasing the robusteness of the system design. The contributions of our work are three-fold. First, we describe a new model for file structures in the form of self-avoiding (simple) paths in specialized graphs. Second, we introduce several new metrics for measuring the fragmentation level in deduplication systems on graph-structured files, including the stretch metric that captures the worst-case â€œspreadâ€ of adjacent data chunks within a file when deduplicated and placed on the server; and, the jump metric that captures the worst-case number of times during the reconstruction process of a file that one has to change the readout location on the server. For the stretch metric, we establish a connection between the level of fragmentation and the bandwidth of the file-graph. In particular, we derive lower and upper bounds on degree of fragmentation and describe instances of the problem where repetition and coding reduce fragmentation. The key ideas behind our approach are graph folding and information-theoretic arguments coupled with graph algorithms such as matching. For the jump metric, we provide a new algorithm for computing the jump number of hierarchical data structures captured by trees. Third, we describe how controlled repetition and coded redundancy added after deduplication can ensure valuable trade-offs between the storage volume and the degree of fragmentation.","Data deduplication is a data management technique employed in modern large-scale data storage systems to increase storage efficiency by removing content replicas of different users [1, 2, 3, 4]. For example, cloud storage providers such as Microsoft and Dropbox, as well as intelligent data infrastructure companies such as NetApp, actively support deduplication schemes in their storage systems. A typical deduplication algorithm first splits the input files into smaller data subunits, referred to as â€œchunksâ€ [5, 6, 7], then removes duplicate data chunks and proceeds to place the chunks on servers. For duplicate chunk identification, one typically uses hash values [5, 6, 7]. The chunk placement is based either on some predetermined protocol or the order of arrival of new chunks. After deduplication, each file is stored in â€˜compressedâ€™ form, involving a set of pointers explaining how to assemble it (e.g., a set of hash values pointing to the actual locations of the data chunks and labels indicating their order). During the file restoration phase, the server uses the compressed description to recreate files by retrieving chunks guided by the pointers. The trade-off between the chunk size and the length of the assembly instruction under various chunking strategies is an important practical system compression feature, addressed in [5]. Since the volume of the assembly instruction data is usually negligible compared to the actual user data, this consideration is irrelevant for protocol-level analyses of deduplication. Although deduplication algorithms provide significant storage savings, they introduce a number of readout issues, including data fragmentation [8] and data instability [9, 10]. Data fragmentation arises due to storing information chunks of a single file at multiple potentially distal locations, which slows down data retrieval and potentially creates problems with accessing large volumes of secondary, unwanted interspersing data. Deduplication instability, on the other hand, refers to the vulnerability to data loss (i.e., lack of robustness) of the file system when only one replica of each chunk is maintained. These problems are partly mitigated in practice by using caches and specialized chunk placements [11], as well as â€˜incomplete deduplicationâ€™ protocols, where not all redundant chunks are removed but only a portion of them, dictated by their popularity [1, 2]. Despite the widespread use of deduplication and the many practical implementations of the method, little is known about the theoretical performance limits of such systems with regards to data fragmentation. Prior work [4] provided a mathematical analysis of the influence of deduplication on distributed storage codes, while [5] initiated an information-theoretic study of deduplication as a form of compression. Some other works [7, 6] focused on examining the influence of errors on chunking and deduplication. None of these contributions considered fragmentation problems or issues associated with partial deduplication and file retrieval robustness. Here, we initiate the first analytical study of the trade-off between storage redundancy and file fragmentation. The key features supporting our analysis are: a) A new model for files that share chunks in terms of self-avoiding (simple) paths/walks in what we call a chunk or file graph. In particular, we model the data as being either generated by a sparse Hamiltonian-path graph in which nodes represent chunks and nodes on connected paths correspond to files to be stored; or, as hierarchical structures whose chunks are organized on a tree. The Hamiltonian path requirement is used to both model a natural linear ordering of concatenated files and to simplify challenging analyses. Similarly, tree models are used to capture chunk organizations in omnipresent hierarchical data; b) Several new metrics for measuring the level of fragmentation, including a worst-case metric which examines the maximum stretch of allotted locations of adjacent data chunks (i.e., the stretch metric) and a metric that captures the worst-case number of times the location on a server needs to be changed to retrieve a file (i.e., the jump metric). Average-case metrics, although formally defined in this work will be examined elsewhere. Our main contributions are bounds on the worst-case fragmentation metrics and algorithms for chunk placements that produce provably good fragmentation results. Most importantly, we examine these key features of deduplication systems for the case of completely deduplicated files (for which the solution involves optimization over permutations, i.e., over the symmetric group), partially deduplicated files with data chunk repetitions (repetition-coded deduplication) and coded deduplication, in which the stored chunks may represent linear (or, in general nonlinear) combinations of systematic user chunks. The outlined analysis involves information-theoretic arguments but also strongly relies on results in graph theory pertaining to the graph bandwith and related concepts [12], as well as matchings in graphs. In the former context, we introduce graph folding which allows one to transfer the domain of the problem from graphs to functions. Additional ideas used in this context include graph factorization and concatenation of different permutations of the chunks, and results already established in the context of the related problem of graph bandwidth analysis [13]. We also describe a number of examples pertaining to deduplication systems in which one is either allowed to retain multiple copies of the same chunk or use coded chunks. In these settings, it is a priori clear that redundant chunks can help reduce fragmentation, since concatenating all files (e.g., not performing deduplication) results in no fragmentation. What is at this point completely unknown is how much redundancy is needed to reduce fragmentation to practically acceptable levels. Furthermore, repeated and/or coded chunks both increase the robustness of the system, which is desirable, but at the cost of increasing the storage overhead of the system. The work closest to our new study is the work that established ultimate performance limits of information retrieval with and without redundancy [14]. There, the questions were posed in a probabilistic context that does not include deduplication nor fragmentation models. Furthermore, information is modelled as arising from a Markovian grid or torus, by traversing a path whose length increases in an unbounded manner. The main objective of the work was to explore the expansion of the average walk lengths of 1-D retrieval versus 2-D retrieval approaches. The work also included an analysis of coding approaches that can aid in reducing the gap introduced by lowering the dimension of the data space. A more detailed description of this work, which is of independent interest, is provided in Section VII. The paper is organized as follows. Section II provides a review of deduplication approaches and introduces terms needed for our analysis and the problem formulations that follow. Section III describes the problem formulation(s), based on the description of the file and chunk store model and the metrics used to measure the fragmentation level. Results pertaining to fragmentation bounds and limits for uncoded, repetition- and linearly encoded chunk stores under the stretch metrics are discussed in Section V. This section also contains the description of our graph folding approach and pertinent bounds based on it. Similar results for the jump fragmentation metric are presented in Section VI. A collection of open problems is discussed in Section VIII."
https://arxiv.org/html/2411.01388v1,Study of Iterative Detection and Decoding for RIS-Aided Multiuser Multi-Antenna Systems,"We present a novel iterative detection and decoding (IDD) scheme for Reconfigurable Intelligent Surface (RIS)-assisted multiuser multiple-antenna systems. The proposed approach introduces a joint iterative detection strategy that integrates Low-Density Parity-Check (LDPC) codes, RIS processing and iterative detection and decoding. In particular, we employ a minimum mean square error receive filter that performs truncation at the RIS and soft interference cancellation at the receiver. Simulation results evaluate the systemâ€™s overall capacity and bit error rate, and demonstrate substantial improvements in bit error rate across block-fading channels.","In the ever-evolving landscape of wireless communication systems, the escalating demand for higher data rates, improved coverage, and reduced power consumption persists. Addressing these challenges requires exploring cutting-edge technologies such as large-scale multiple-antenna systems [1, 2] and the concept of Reconfigurable Intelligent Surfaces (RIS). These reflective surfaces exhibit significant potential for optimizing wireless networks and are expected to play a crucial role in the development of the sixth generation of communication systems (6G) [3]. The fundamental concept of RIS-assisted systems diverges from the conventional approach of altering the transmitted signal to reshape the wireless environmentâ€™s propagation properties. Instead, it focuses on modifying the characteristics of the equivalent channel between users and the access point [4]. The adoption of RIS holds the potential to extend coverage [5], reduce power consumption [6], and increase channel capacity [7, 8]. Several works propose modifications to the traditional RIS system to address the practical issues associated with passive RIS. In [7], an active RIS is proposed, with the capability not only to change phase but also to amplify reflected signals. In [8], the authors introduce a reflective surface whose elements are fully- and group-interconnected. This design not only allows for characterization by scattering parameters but also enhances the performance of the system by enabling a beyond-diagonal reconfigurable intelligent surface. In [9], the authors have studied the performance of an RIS-assisted wireless communication system where the signal from the transmitter is protected by LDPC codes. Instead of addressing the performance of the system by maximizing the Signal-to-Noise-and-Interference Ratio (SNIR) at the receiver [6, 7, 8, 10], the most common form of optimization, this work uses bit-error rate (BER) as a benchmark for performance evaluation, contrasting Monte Carlo simulation results with analytic bounds. Meanwhile, in [11, 12, 13], the authors evaluate the iterative detection and decoding (IDD) algorithm using LDPC codes for multiple-antenna systems under block-fading channels. In this work, we investigate the uplink of multiuser multiple-antenna systems that employ RIS, channel coding and iterative processing techniques [14, 15]. In particular, we present a novel approach by formulating a problem that aims to minimize the mean squared error between a transmitted symbol and an estimated symbol at the receiver while incorporating an IDD scheme [11]. By employing an IDD scheme, the detector and decoder exchange soft information, commonly represented in log likelihood ratios (LLRs). Previous research on MIMO and IDD schemes has explored block-fading channels [12, 13] and LDPC codes. This information exchange results in performance enhancements, with the degree of improvement growing proportionally to the number of information exchanges. We evaluate the performance of a RIS-aided multiuser multiple-input single-output (MU-MISO) system in typical wireless scenarios based on the 3GPP standard [16]. By resorting to constraint relaxation and alternating optimization, we propose a joint iterative detection approach that combines LDPC decoding and RIS. Numerical results evaluate the proposed system in terms of BER and sum-rates. The rest of this paper is organized as follows. In Section II we describe the system model. Section III describes the derivation of the proposed RIS-MMSE detector and decoding technique. Section IV discusses the simulation results and Section V concludes this paper. Notations: Bold capital letters indicate matrices while vectors are in bold lowercase. ğˆğ§subscriptğˆğ§\mathbf{I_{n}}bold_I start_POSTSUBSCRIPT bold_n end_POSTSUBSCRIPT denotes a nâ¢xâ¢nğ‘›xğ‘›n\text{x}nitalic_n x italic_n identity matrix and diag(ğ€ğ€\mathbf{A}bold_A) is a diagonal matrix only containing the diagonal elements of ğ€ğ€\mathbf{A}bold_A. â„‚â„‚\mathbb{C}blackboard_C and â„â„\mathbb{R}blackboard_R denote the sets of complex and real numbers, respectively; [Â·]-1, [Â·]T and [Â·]H denote the inverse, transpose, and conjugate transpose operations, respectively;"
https://arxiv.org/html/2411.01028v1,SKI-SAT: A CMOS-compatible Hardwarefor Solving SAT Problems,"Nature-inspired computation is receiving increasing attention. Various Ising machine implementations have recently been proven to be effective in solving numerous combinatorial optimization problems including maximum cut, low density parity check (LDPC) decoding, and Boolean satisfiability (SAT) problems. In this paper, a novel method is presented to solve SAT or MAX-SAT problems with a CMOS circuit implementation. The technique solves a SAT problem by mapping the SAT variables onto quantized capacitor voltages generated by an array of nodes that interact through a network of coupling units. The nodal interaction is achieved through coupling currents produced by the coupling units, which charge or discharge capacitor voltages, implementing a gradient descent along the SAT problemâ€™s cost function to minimize the number of unsatisfied clauses. The system also incorporates a unique low-complexity perturbation scheme to avoid settling in local minima, greatly enhancing the performance of the system. The simulation results demonstrate that the proposed SKI-SAT is a high-performance and low-energy alternative that surpasses existing solvers by significant margins, achieving more than 10 times faster solution and 300 times less power.","Digital computers revolutionized the world by automating complex tasks, enabling instant communication, and providing unmatched performance for data processing and artificial intelligence applications. However, recent years have seen an incredible surge in energy-intensive applications for cryptocurrency and neural network training. In digital systems information is represented and processed in one of the two discrete states while analog computers process and store information as analog values such as voltages or currents with inherently higher resolution enabling time and power-efficient solutions for certain problems. The drawback associated with analog computers is their lack of versatility, but they can outperform digital computers in certain specific functions. Although widespread use of analog computers for general purpose computing is unlikely, analog computers can be a favorable option for specific applications. In recent years, a subset of analog computation models, known as nature-inspired computation, has garnered attention for providing new avenues to solve NP-hard and NP-complete problems. Since analytical solutions donâ€™t typically exist for these problems, digital computers are often required to rely on rather inefficient trial-and-error methods. An Ising machine is an emerging nature-inspired computation model that maps a problem into an energy space. The system naturally creates a gradient descent to the Hamiltonian function based on its energy, allowing Ising machines to progress toward the optimal solution with the help of random perturbations. The system is, however, likely to settle into a sub-optimal solution without a perturbation scheme[1]. The efficiency of Ising machines in solving quadratic unconstrained binary optimization (QUBO) problems has been demonstrated to be almost a million times faster than conventional simulated annealing [1] owing to the trivial mapping of QUBO to Ising formula. However, functions containing higher-order polynomials cannot be directly mapped to the quadratic Ising machines and therefore require preprocessing. The work in [2] demonstrates a methodology that first transforms a 3-SAT problem into a QUBO format, which is then decomposed into sub-problems and mapped onto a ring oscillator-based 49-spin Ising machine. However, the auxiliary spin overhead created during the conversion of third-order terms in SAT cost function to quadratic terms in QUBO severely limits the size of 3-SAT problems that can be solved on a specific size QUBO solver (e.g., a 49-spin QUBO hardware in [2] is able to solve a 3-SAT problem with up to 20 literals and 91 clauses only by decomposing into sub-Hamiltonians). Therefore, supporting larger problems with more variables becomes increasingly challenging and time consuming. Hizzani et al. [3] report on a memristor based system that employs a Hopfield Neural Network, which eliminates the need for order reduction for third-order polynomials present in a 3-SAT problem. This makes the design intrinsically compatible with polynomial unconstrained binary optimization (PUBO) problems, particularly those involving SAT. However, the hardware implementation of this work imposes significant physical design constraints due to the quadratically growing word lines. This indicates that scalability for larger problems remains a challenging issue. Furthermore, Elmitwalli et al. [4] demonstrate how a QuBRIM system [1], originally designed to solve MaxCUT problems, can be altered to address higher-order combinatorial optimization problems, including SAT and the Traveling Salesman Problem, particularly for LDPC decoding, without the need for order reduction through multi-body interactions. However, the proposed systemâ€™s limitation lies in the nodal interactions being constrained by the linearity of the DAC units and dynamic range for programmable resistance, which reduces the accuracy of the solution to a certain degree. The proposed Salim-KÃ¶se-Ignjatovic SAT hardware solver (SKI-SAT) offers a scheme that is not restricted by polynomial terms, as it inherently supports polynomial terms of any order. Additionally, the coupling precision limitations of the previous studies are no longer a concern for SKI-SAT, thanks to the binary nature of its coupling. Finally, SKI-SAT is easily scalable and cost-efficient thanks to the compact footprint, which is compatible with standard CMOS processes and can accommodate hundreds or even thousands of clauses."
https://arxiv.org/html/2411.02366v1,Accelerating Multi-UAV Collaborative Sensing Data Collection: A Hybrid TDMA-NOMA-Cooperative Transmission in Cell-Free MIMO Networks,"This work investigates a collaborative sensing and data collection system in which multiple unmanned aerial vehicles (UAVs) sense an area of interest and transmit images to a cloud server (CS) for processing. To accelerate the completion of sensing missions, including data transmission, the sensing task is divided into individual private sensing tasks for each UAV and a common sensing task that is executed by all UAVs to enable cooperative transmission. Unlike existing studies, we explore the use of an advanced cell-free multiple-input multiple-output (MIMO) network, which effectively manages inter-UAV interference. To further optimize wireless channel utilization, we propose a hybrid transmission strategy that combines time-division multiple access (TDMA), non-orthogonal multiple access (NOMA), and cooperative transmission. The problem of jointly optimizing task splitting ratios and the hybrid TDMA-NOMA-cooperative transmission strategy is formulated with the objective of minimizing mission completion time. Extensive numerical results demonstrate the effectiveness of the proposed task allocation and hybrid transmission scheme in accelerating the completion of sensing missions.","Unmanned Aerial Vehicle (UAV)-based sensing is promised to become a leading sensing technology in the future due to its extensive coverage area and flexible observation capabilities [1, 2, 3]. This system offers rapid mission execution as UAVs can transmit sensory data to ground base stations (BSs) through line-of-sight (LoS) wireless links, eliminating the need to return to the BSs. Additionally, UAVs excel in sensing areas inaccessible to terrestrial vehicles due to their increased heights and less signal blockage [1, 2, 3], further enhancing their utility. References [4] and [5] explored the optimization of UAV trajectory and transmit power to maximize energy efficiency. In reference [6], the authors addressed the joint design of UAV trajectory, UAV-BS association, and sensing order with the aim of minimizing the overall mission completion time. Reference [7] investigated a UAV-assisted integrated sensing and communication (ISAC) system, focusing on the joint optimization of UAV trajectory, sensing and communication time duration, and UAV power allocation. References [8] and [9] proposed UAV-aided joint communication, sensing, and computing frameworks, leveraging mobile edge computing capability at BSs. Furthermore, UAV sensing for cellular inter-cell interference coordination (ICIC) was investigated in [10, 11]. In particular, reference [10] highlighted the spectrum sensing capabilities of UAVs across wide coverage areas, which can be leveraged to overcome the limitations of traditional terrestrial ICIC techniques. The synergetic benefits of integrating UAV-based networks with reconfigurable intelligent surfaces (RISs), along with corresponding design strategies, were explored in [12, 13, 14]. Specifically, the impact of operating RISs on the ground to assist air-to-ground communication between UAVs and terrestrial BSs was studied in [12] and [13], while the potential of aerial RISs mounted on UAVs was discussed in [12] and [14]. Given the complexity of integrating UAV sensing techniques with other key enablers for 6G wireless systems, the application of artificial intelligence (AI) techniques is crucial for practical optimization. The benefits of utilizing AI for UAV cognitive sensing tasks, such as object detection in aerial scenes captured by UAVs, were examined in [15], while reference [16] provided an extensive overview of potential AI applications for UAV-based wireless networks. UAV-assisted communication systems are a key component of non-terrestrial networks, which also encompass satellite and high-altitude platform (HAP) systems [17, 18, 19, 20]. In [17] and [18], beamforming design problems were explored for satellite and terrestrial integrated networks (STINs), with [17] focusing on the use of RISs and [18] addressing the criterion of maximizing secrecy-energy efficiency. Reference [19] discussed beamforming design for simultaneous wireless information and power transfer (SWIPT) in RIS-assisted HAP networks, where each receiver is equipped multi-layer refracting RISs. Additionally, [20] investigated multicast beamforming design for satellite and aerial integrated networks (SAINs), employing rate-splitting multiple access (RSMA) for UAV transmission. Figure 1: Illustration of a collaborative sensing system with multiple multi-antenna UAVs reporting to a CS through distributed multi-antenna APs. While references [4, 6, 7, 8, 9] focused on the UAV sensing and transmission systems with a single UAV, there has been a notable shift towards investigating multi-UAV cooperative sensing systems. As illustrated in Fig. 1, these systems involve multiple UAVs collaborating to conduct the sensing task [21, 22, 23]. However, due to the independence of sensory data signals from different UAVs, orthogonal multiple access techniques such as time-division multiple access (TDMA) were considered to avoid interference among UAVsâ€™ transmissions. In contrast, in [24], the authors proposed the partial utilization of a common sensing task executed by all UAVs. Despite the inefficiency stemming from the repeated execution of the same task among UAVs, the shared sensory data can be possessed by all UAVs, thereby reducing uplink transmission time through cooperative transmission. Since the presence of a common sensing task yields conflicting impacts on the overall mission completion time, the work [24] addressed the problem of finding the optimal portions of common and private tasks. TABLE I: Comparison of existing UAV sensing and transmission literature. Papers Number of nodes Task allocation Number of antennas Transmission UAV AP UAV AP Network Scheme [4] single single - single single cellular P2P [5] single single - single single cellular P2P [6] single single - single single cellular P2P [7] single single - single single cellular P2P [8] single single - single single cellular P2P [9] single single - multiple multiple cellular P2P [21] multiple single exclusive single multiple cellular orthogonal [22] multiple single exclusive multiple multiple cellular TDMA [23] multiple single exclusive single single cellular TDMA [24] multiple single exclusive/overlap. single single cellular TDMA/coop. This work multiple multiple exclusive/overlap. multiple multiple cell-free TDMA/NOMA/coop. While reference [24] highlighted the advantages of employing a common sensing task to reduce wireless transmission of sensory data, it primarily focused on TDMA-based transmission of private sensory data within a simplistic uplink network served by a single BS, with both the UAVs and the BS equipped with a single antenna. Building on this background, in this work, we explore the impact of incorporating a common sensing task among UAVs within a more sophisticated cell-free network [25, 26, 27] that leverages multiple-input multiple-output (MIMO) technology. In this setup, multi-antenna UAVs transmit their sensory data to a cloud server (CS) via multi-antenna access points (APs). These APs are linked to the CS through finite-capacity fronthaul connections, necessitating the use of fronthaul quantization and compression techniques [28, 29, 30]. Additionally, unlike the approach in [24], which solely relied on TDMA transmission for UAVsâ€™ private sensory data, we propose a hybrid utilization of TDMA and non-orthogonal multiple access (NOMA) [31]. This is motivated by the potential advantages of NOMA over TDMA, especially within cell-free MIMO networks, since the CS can utilize the uplink received signals from all APs to effectively manage the interference signals. However, the design of the outlined system presents challenges. In fact, one needs to concurrently optimize task allocation between common and per-UAV private sensing tasks. Additionally, one needs to optimize hybrid TDMA-NOMA and cooperative transmission strategies for transmitting sensory data for private and common tasks, respectively. It is also noted that the choice between employing TDMA and NOMA modes for private sensory data transmission involves a tradeoff depending on system factors such as signal-to-noise ratio (SNR) of the wireless link, capacity of fronthaul links, and network configurations, including the numbers of UAVs, APs, and their antennas. We establish the problem of jointly optimizing the task allocation variables for sensing tasks, along with hybrid TDMA-NOMA-cooperative transmission strategies, with the aim of minimizing mission completion time. To tackle the non-convex nature of the problem, we reformulate it using fractional programming (FP) [32] and matrix FP techniques [33]. These techniques were proven effective in optimizing user-cloud assignment and downlink beamforming for multi-cloud radio access networks (RAN) [34], as well as two-tier receive signal combining for fully-decoupled RAN scenarios [35]. Based on the reformulated problem, we propose an iterative algorithm that alternately optimizes primary and auxiliary block variables, resulting in monotonically decreasing completion time values. Through extensive numerical results, we validate the efficacy of the proposed task allocation and hybrid TDMA-NOMA-cooperative transmission scheme in expediting the completion of sensing mission tasks. In Table I, we compare this work with recent literature on UAV sensing [6, 7, 8, 9, 22, 23, 24]. The paper is organized as follows. In Sec. II, we describe the system model of a multi-UAV collaborative sensing system, encompassing the wireless channel model from UAVs to APs, the fronthaul connections, and the splitting variables for common and private sensing tasks. In Sec. III, we outline the overall process of the proposed sensing and hybrid TDMA-NOMA-cooperative transmission system, accompanied by quantification of the total mission completion time. In Sec. IV, we formulate the optimization problem for the proposed multi-UAV sensing system and develop an iterative optimization algorithm. In Sec. V, we present numerical results that validate the efficacy of the proposed system. Finally, the paper concludes in Sec. VI."
https://arxiv.org/html/2411.02225v1,Variable Selection in Convex Piecewise Linear Regression,"This paper presents Sparse Gradient Descent as a solution for variable selection in convex piecewise linear regression where the model is given as the maximum of kğ‘˜kitalic_k-affine functions ğ’™â†¦maxjâˆˆ[k]â¡âŸ¨ğ’‚jâ‹†,ğ’™âŸ©+bjâ‹†maps-toğ’™subscriptğ‘—delimited-[]ğ‘˜superscriptsubscriptğ’‚ğ‘—â‹†ğ’™superscriptsubscriptğ‘ğ‘—â‹†\bm{x}\mapsto\max_{j\in[k]}\langle\bm{a}_{j}^{\star},\bm{x}\rangle+b_{j}^{\star}bold_italic_x â†¦ roman_max start_POSTSUBSCRIPT italic_j âˆˆ [ italic_k ] end_POSTSUBSCRIPT âŸ¨ bold_italic_a start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT , bold_italic_x âŸ© + italic_b start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT for j=1,â€¦,kğ‘—1â€¦ğ‘˜j=1,\dots,kitalic_j = 1 , â€¦ , italic_k. Here, {ğ’‚jâ‹†}j=1ksuperscriptsubscriptsuperscriptsubscriptğ’‚ğ‘—â‹†ğ‘—1ğ‘˜\{\bm{a}_{j}^{\star}\}_{j=1}^{k}{ bold_italic_a start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT } start_POSTSUBSCRIPT italic_j = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT and {bjâ‹†}j=1ksuperscriptsubscriptsuperscriptsubscriptğ‘ğ‘—â‹†ğ‘—1ğ‘˜\{b_{j}^{\star}\}_{j=1}^{k}{ italic_b start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT } start_POSTSUBSCRIPT italic_j = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT denote the ground-truth weight vectors and intercepts. A non-asymptotic local convergence analysis is provided for Sp-GD under sub-Gaussian noise when the covariate distribution satisfies sub-Gaussianity and anti-concentration property. When the model order and parameters are fixed, Sp-GD provides an Ïµitalic-Ïµ\epsilonitalic_Ïµ-accurate estimate given ğ’ªâ¢(maxâ¡(Ïµâˆ’2â¢Ïƒz2,1)â¢sâ¢logâ¡(d/s))ğ’ªsuperscriptitalic-Ïµ2superscriptsubscriptğœğ‘§21ğ‘ ğ‘‘ğ‘ \mathcal{O}(\max(\epsilon^{-2}\sigma_{z}^{2},1)s\log(d/s))caligraphic_O ( roman_max ( italic_Ïµ start_POSTSUPERSCRIPT - 2 end_POSTSUPERSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , 1 ) italic_s roman_log ( italic_d / italic_s ) ) observations where Ïƒz2superscriptsubscriptğœğ‘§2\sigma_{z}^{2}italic_Ïƒ start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT denotes the noise variance. This also implies the exact parameter recovery by Sp-GD from ğ’ªâ¢(sâ¢logâ¡(d/s))ğ’ªğ‘ ğ‘‘ğ‘ \mathcal{O}(s\log(d/s))caligraphic_O ( italic_s roman_log ( italic_d / italic_s ) ) noise-free observations. Since optimizing the squared loss for sparse max-affine is non-convex, an initialization scheme is proposed to provide a suitable initial estimate within the basin of attraction for Sp-GD, i.e. sufficiently accurate to invoke the convergence guarantees. The initialization scheme uses sparse principal component analysis to estimate the subspace spanned by {ğ’‚jâ‹†}j=1ksuperscriptsubscriptsuperscriptsubscriptğ’‚ğ‘—â‹†ğ‘—1ğ‘˜\{\bm{a}_{j}^{\star}\}_{j=1}^{k}{ bold_italic_a start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT } start_POSTSUBSCRIPT italic_j = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT then applies an rğ‘Ÿritalic_r-covering search to estimate the model parameters. A non-asymptotic analysis is presented for this initialization scheme when the covariates and noise samples follow Gaussian distributions. When the model order and parameters are fixed, this initialization scheme provides an Ïµitalic-Ïµ\epsilonitalic_Ïµ-accurate estimate given ğ’ªâ¢(Ïµâˆ’2â¢maxâ¡(Ïƒz4,Ïƒz2,1)â¢s2â¢log4â¡(d))ğ’ªsuperscriptitalic-Ïµ2superscriptsubscriptğœğ‘§4superscriptsubscriptğœğ‘§21superscriptğ‘ 2superscript4ğ‘‘\mathcal{O}(\epsilon^{-2}\max(\sigma_{z}^{4},\sigma_{z}^{2},1)s^{2}\log^{4}(d))caligraphic_O ( italic_Ïµ start_POSTSUPERSCRIPT - 2 end_POSTSUPERSCRIPT roman_max ( italic_Ïƒ start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT , italic_Ïƒ start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , 1 ) italic_s start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT ( italic_d ) ) observations. Numerical Monte Carlo results corroborate theoretical findings for Sp-GD and the initialization scheme.","We consider a multivariate regression problem where the target variable yâˆˆâ„ğ‘¦â„y\in\mathbb{R}italic_y âˆˆ blackboard_R depends non-linearly on covariates in ğ’™âˆˆâ„dğ’™superscriptâ„ğ‘‘\bm{x}\in\mathbb{R}^{d}bold_italic_x âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT and noise zâˆˆâ„ğ‘§â„z\in\mathbb{R}italic_z âˆˆ blackboard_R as y=fâ¢(ğ’™;ğœ½â‹†)+zğ‘¦ğ‘“ğ’™superscriptğœ½â‹†ğ‘§y=f(\bm{x};\bm{\theta}^{\star})+zitalic_y = italic_f ( bold_italic_x ; bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT ) + italic_z (1) through a max-affine function f:â„dâ†’â„:ğ‘“â†’superscriptâ„ğ‘‘â„f:\mathbb{R}^{d}\to\mathbb{R}italic_f : blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT â†’ blackboard_R given by ğ’™âˆˆâ„dâ†¦fâ¢(ğ’™;ğœ½â‹†)=max1â‰¤jâ‰¤kâ¡(âŸ¨ğ’‚jâ‹†,ğ’™âŸ©+bjâ‹†),ğ’™superscriptâ„ğ‘‘maps-toğ‘“ğ’™superscriptğœ½â‹†subscript1ğ‘—ğ‘˜subscriptsuperscriptğ’‚â‹†ğ‘—ğ’™subscriptsuperscriptğ‘â‹†ğ‘—\bm{x}\in\mathbb{R}^{d}\mapsto f(\bm{x};\bm{\theta}^{\star})=\max_{1\leq j\leq k% }\left(\langle\bm{a}^{\star}_{j},\bm{x}\rangle+b^{\star}_{j}\right),bold_italic_x âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT â†¦ italic_f ( bold_italic_x ; bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT ) = roman_max start_POSTSUBSCRIPT 1 â‰¤ italic_j â‰¤ italic_k end_POSTSUBSCRIPT ( âŸ¨ bold_italic_a start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT , bold_italic_x âŸ© + italic_b start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ) , (2) where ğœ½â‹†âˆˆâ„kâ¢(d+1)superscriptğœ½â‹†superscriptâ„ğ‘˜ğ‘‘1\bm{\theta}^{\star}\in\mathbb{R}^{k(d+1)}bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_k ( italic_d + 1 ) end_POSTSUPERSCRIPT collects all ground-truth parameters {(ğ’‚jâ‹†,bjâ‹†)}j=1kâŠ‚â„dÃ—â„superscriptsubscriptsuperscriptsubscriptğ’‚ğ‘—â‹†superscriptsubscriptğ‘ğ‘—â‹†ğ‘—1ğ‘˜superscriptâ„ğ‘‘â„\{(\bm{a}_{j}^{\star},b_{j}^{\star})\}_{j=1}^{k}\subset\mathbb{R}^{d}\times% \mathbb{R}{ ( bold_italic_a start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT , italic_b start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT ) } start_POSTSUBSCRIPT italic_j = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT âŠ‚ blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT Ã— blackboard_R. The max-affine structure in (2) induces a class of convex piecewise linear functions. The set of max-affine functions provides an efficient approximation of a class of smooth convex functions [BalÃ¡zs et al., 2015]. It is also considered a special instance of tropical algebra [Maragos et al., 2021]. Furthermore, we assume that only up to sğ‘ sitalic_s variables in ğ’™ğ’™\bm{x}bold_italic_x contribute to the evaluation of each linear model in (2), i.e. |suppâ¢(ğ’‚jâ‹†)|â‰¤s,âˆ€j=1,â€¦,k,formulae-sequencesuppsubscriptsuperscriptğ’‚â‹†ğ‘—ğ‘ for-allğ‘—1â€¦ğ‘˜\left|\mathrm{supp}(\bm{a}^{\star}_{j})\right|\leq s,\quad\forall j=1,\dots,k,| roman_supp ( bold_italic_a start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ) | â‰¤ italic_s , âˆ€ italic_j = 1 , â€¦ , italic_k , (3) where suppâ¢(â‹…)suppâ‹…\mathrm{supp}(\cdot)roman_supp ( â‹… ) denotes the index set for non-zero entries of the input vector. We refer to the estimation of the ground-truth parameters in ğœ½â‹†superscriptğœ½â‹†\bm{\theta}^{\star}bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT from noisy samples {(ğ’™i,yi)}i=1nsuperscriptsubscriptsubscriptğ’™ğ‘–subscriptğ‘¦ğ‘–ğ‘–1ğ‘›\{(\bm{x}_{i},y_{i})\}_{i=1}^{n}{ ( bold_italic_x start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT , italic_y start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) } start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT under the sparsity constraint in (3) as sparse max-affine regression. This is equivalent to convex piecewise linear regression with variable selection. The estimation procedure naturally implements variable selection as the support of the estimate identifies the active covariate variables. The max-affine model in (2) proved useful in various applications such as computer vision and circuit design [Magnani and Boyd, 2009]. The target variable in these applications often has a non-linear dependence on a subset of the covariates. In high dimensional settings, i.e. the number of covariates is large, identifying the set of active covariates can significantly improve the generalization performance and the interpretability of the learned model [Wasserman and Roeder, 2009]. We illustrate these aspects over data fitting to an exponential polynomial, which extends the polynomial model so that the exponents are not necessarily integers. For example, in labor economics [Zhao et al., 2016, Eq. 15], the Gross Domestic Product (GDP), Gâˆˆâ„ğºâ„G\in\mathbb{R}italic_G âˆˆ blackboard_R, is written as a multivariate exponential polynomial G=c1â¢LÎ±â¢HÎ¸â¢SÎ³â¢DÎ´+c2â¢K+c3â¢Sâ¢D/K+c4ğºsubscriptğ‘1superscriptğ¿ğ›¼superscriptğ»ğœƒsuperscriptğ‘†ğ›¾superscriptğ·ğ›¿subscriptğ‘2ğ¾subscriptğ‘3ğ‘†ğ·ğ¾subscriptğ‘4G=c_{1}L^{\alpha}H^{\theta}S^{\gamma}D^{\delta}+c_{2}K+c_{3}SD/K+c_{4}italic_G = italic_c start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT italic_L start_POSTSUPERSCRIPT italic_Î± end_POSTSUPERSCRIPT italic_H start_POSTSUPERSCRIPT italic_Î¸ end_POSTSUPERSCRIPT italic_S start_POSTSUPERSCRIPT italic_Î³ end_POSTSUPERSCRIPT italic_D start_POSTSUPERSCRIPT italic_Î´ end_POSTSUPERSCRIPT + italic_c start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT italic_K + italic_c start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT italic_S italic_D / italic_K + italic_c start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT (4) with coefficients {ci}i=14âŠ‚â„superscriptsubscriptsubscriptğ‘ğ‘–ğ‘–14â„\{c_{i}\}_{i=1}^{4}\subset\mathbb{R}{ italic_c start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_i = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT âŠ‚ blackboard_R and exponents {Î±,Î¸,Î³,Î´}âŠ‚â„ğ›¼ğœƒğ›¾ğ›¿â„\{\alpha,\theta,\gamma,\delta\}\subset\mathbb{R}{ italic_Î± , italic_Î¸ , italic_Î³ , italic_Î´ } âŠ‚ blackboard_R, where L,H,S,D,Kğ¿ğ»ğ‘†ğ·ğ¾L,H,S,D,Kitalic_L , italic_H , italic_S , italic_D , italic_K respectively denote labor, human capital, innovation, investment, and capital stock. Employing a log\logroman_log-log\logroman_log mapping, we can transform an exponential polynomial into a sparse max-affine function [Maragos et al., 2021, Boyd et al., 2004]. The procedure is described as follows: Let y=Ï†â¢logâ¢(G),ğ’™=Ï†â¢[logâ¡L,logâ¡H,logâ¡S,logâ¡D,logâ¡K]ğ–³.formulae-sequenceğ‘¦ğœ‘logğºğ’™ğœ‘superscriptmatrixğ¿ğ»ğ‘†ğ·ğ¾ğ–³y=\varphi\,\mathrm{log}(G),\quad\bm{x}=\varphi\begin{bmatrix}\log L,\log H,% \log S,\log D,\log K\end{bmatrix}^{\mathsf{T}}.italic_y = italic_Ï† roman_log ( italic_G ) , bold_italic_x = italic_Ï† [ start_ARG start_ROW start_CELL roman_log italic_L , roman_log italic_H , roman_log italic_S , roman_log italic_D , roman_log italic_K end_CELL end_ROW end_ARG ] start_POSTSUPERSCRIPT sansserif_T end_POSTSUPERSCRIPT . for some Ï†>0ğœ‘0\varphi>0italic_Ï† > 0. As Ï†ğœ‘\varphiitalic_Ï† decreases toward 00, the expression of yğ‘¦yitalic_y converges to a sparse max-affine function given by limÏ†â†’0+â¢y=maxjâˆˆ{1,2,3,4}â¢âŸ¨ğœ½j,[ğ’™,1]âŸ©,â†’ğœ‘superscript0limğ‘¦ğ‘—1234maxsubscriptğœ½ğ‘—ğ’™1\underset{\varphi\rightarrow 0^{+}}{\mathrm{lim}}y=\underset{j\in\{1,2,3,4\}}{% \mathrm{max}}\langle\bm{\theta}_{j},[\bm{x},1]\rangle,start_UNDERACCENT italic_Ï† â†’ 0 start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT end_UNDERACCENT start_ARG roman_lim end_ARG italic_y = start_UNDERACCENT italic_j âˆˆ { 1 , 2 , 3 , 4 } end_UNDERACCENT start_ARG roman_max end_ARG âŸ¨ bold_italic_Î¸ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT , [ bold_italic_x , 1 ] âŸ© , where [ğœ½1,â€¦,ğœ½4]â‰œ[Î±000Î¸000Î³010Î´01001âˆ’100000].â‰œsubscriptğœ½1â€¦subscriptğœ½4matrixğ›¼000ğœƒ000ğ›¾010ğ›¿01001100000[\bm{\theta}_{1},\ldots,\bm{\theta}_{4}]\triangleq\begin{bmatrix}\alpha&0&0&0% \\ \theta&0&0&0\\ \gamma&0&1&0\\ \delta&0&1&0\\ 0&1&-1&0\\ 0&0&0&0\end{bmatrix}.[ bold_italic_Î¸ start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , bold_italic_Î¸ start_POSTSUBSCRIPT 4 end_POSTSUBSCRIPT ] â‰œ [ start_ARG start_ROW start_CELL italic_Î± end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL italic_Î¸ end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL italic_Î³ end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL italic_Î´ end_CELL start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 1 end_CELL start_CELL - 1 end_CELL start_CELL 0 end_CELL end_ROW start_ROW start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL start_CELL 0 end_CELL end_ROW end_ARG ] . More generally, even when the exact dependence like (4) is not known, sparse max-affine regression can identify active variables in each component of the target-covariate dependence modeled as an exponential polynomial. Contributions: In this paper, we present theoretical convergence guarantees for the sparse gradient descent algorithm (Sp-GD) that implements variable selection for max-affine regression. Since learning the regression parameters casts as a nonconvex optimization problem, it is important for Sp-GD to start from a suitable initialization. We propose an initialization scheme leveraging the sparsity structure backed by performance guarantees on its error bound. The theoretical results for both Sp-GD and the initialization scheme, presented respectively in pseudo Theorems 1.1 and 1.2, show that the sample complexity is governed by the number of active variables sğ‘ sitalic_s instead of the total number of variables dğ‘‘ditalic_d. Monte Carlo simulations in Sections 4.1 and 4.2 corroborate these theoretical guarantees. Optimization algorithm: Sp-GD is a variant of the projected gradient descent method. Sp-GD differs from standard projected gradient descent by utilizing a generalized gradient. This gradient is an extension to non-smooth functions, such as the piecewise linear functions we are working with [Hiriart-Urruty, 1979, Clarke, 1990]. Sp-GD moves along the generalized gradient with a set of adaptive step sizes and then projects to the feasible set of sparse parameters defined in (3). Since the nonlinear least squares problem for the model in (1) is non-convex, Sp-GD provides a local convergence guarantee presented in the following pseudo-theorem. Theorem 1.1 (Informal). Let the covariates and noise be sampled independently from Sub-Gaussian distributions. For fixed kğ‘˜kitalic_k and ground-truth ğ›‰â‹†superscriptğ›‰â‹†\bm{\theta}^{\star}bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT satisfying (3), with high proability, a suitably initialized Sp-GD converges linearly to an Ïµitalic-Ïµ\epsilonitalic_Ïµ-accurate estimate of ğ›‰â‹†superscriptğ›‰â‹†\bm{\theta}^{\star}bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT given ğ’ªâ¢(maxâ¡(Ïµâˆ’2â¢Ïƒz2,1)â¢sâ¢logâ¡(d/s))ğ’ªsuperscriptitalic-Ïµ2superscriptsubscriptğœğ‘§21ğ‘ ğ‘‘ğ‘ \mathcal{O}\left(\max(\epsilon^{-2}\sigma_{z}^{2},1)s\log(d/s)\right)caligraphic_O ( roman_max ( italic_Ïµ start_POSTSUPERSCRIPT - 2 end_POSTSUPERSCRIPT italic_Ïƒ start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , 1 ) italic_s roman_log ( italic_d / italic_s ) ) observations, where Ïƒz2superscriptsubscriptğœğ‘§2\sigma_{z}^{2}italic_Ïƒ start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT denotes the noise variance. This result can be compared to a line of research on plain max-affine regression without the sparsity constraint. Ghosh et al. [2021] presented non-asymptotic convergence analyses of the alternating minimization algorithm by Magnani and Boyd [2009] under random covariates and independent stochastic noise assumptions. Later, Kim and Lee [2024] showed that stochastic gradient descent provides comparable sample complexities and estimation errors with faster convergence. Authors Algorithm Sample complexity Ghosh et al. [2021] Alternating Minimization ğ’ª~â¢(d)~ğ’ªğ‘‘\widetilde{\mathcal{O}}(d)over~ start_ARG caligraphic_O end_ARG ( italic_d ) Kim and Lee [2024] First Order Methods ğ’ª~â¢(d)~ğ’ªğ‘‘\widetilde{\mathcal{O}}(d)over~ start_ARG caligraphic_O end_ARG ( italic_d ) This paper Sparse Gradient Descent ğ’ª~â¢(sâ¢logâ¡(d/s))~ğ’ªğ‘ ğ‘‘ğ‘ \widetilde{\mathcal{O}}\left(s\log({d}/{s})\right)over~ start_ARG caligraphic_O end_ARG ( italic_s roman_log ( italic_d / italic_s ) ) Table 1: Comparison of estimation algorithms in the sample complexity for exact parameter recovery of max-affine models from noiseless observations. Table 1 compares the required sample complexity for Sp-GD and previous parameter estimation algorithms for max-affine models. Sp-GD drops the sample complexity from ğ’ªâ¢(d)ğ’ªğ‘‘\mathcal{O}(d)caligraphic_O ( italic_d ) required by previous algorithms to ğ’ªâ¢(sâ¢logâ¡(d/s))ğ’ªğ‘ ğ‘‘ğ‘ \mathcal{O}(s\log(d/s))caligraphic_O ( italic_s roman_log ( italic_d / italic_s ) ) which is sub-linear. This marks a significant improvement especially when the number of active variables sğ‘ sitalic_s is significantly smaller than the total number of variables dğ‘‘ditalic_d. It is also worth noting that the convergence result in Theorem 1.1 applies to a practical implementation of SpGD. Specifically, the step sizes are given in an explicit form determined by the parameter estimates of the previous iteration. The step size for the jğ‘—jitalic_jth block will concentrate around the inverse of the probability where the jğ‘—jitalic_jth linear model in (2) achieves the maximum. In contrast, Kim and Lee [2024] used an unspecified constant step size to prove the local convergence of their first-order methods. Our step size strategy also applies to plain max-affine regression. Initialization: Recall that Theorem 1.1 requires a suitable initial estimate to guarantee local convergence of Sp-GD. To obtain this desired initialization, one may use the spectral method for max-affine regression [Ghosh et al., 2021]. Simply stated, their initialization scheme first employs principal component analysis (PCA) to estimate the span of {ğ’‚jâ‹†}j=1ksuperscriptsubscriptsuperscriptsubscriptğ’‚ğ‘—â‹†ğ‘—1ğ‘˜\{\bm{a}_{j}^{\star}\}_{j=1}^{k}{ bold_italic_a start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT } start_POSTSUBSCRIPT italic_j = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT. Then a discrete search over an rğ‘Ÿritalic_r-covering in the span of the principal components is applied. It requires ğ’ªâ¢(Ïµâˆ’2â¢dâ¢log3â¡d)ğ’ªsuperscriptitalic-Ïµ2ğ‘‘superscript3ğ‘‘\mathcal{O}(\epsilon^{-2}d\log^{3}d)caligraphic_O ( italic_Ïµ start_POSTSUPERSCRIPT - 2 end_POSTSUPERSCRIPT italic_d roman_log start_POSTSUPERSCRIPT 3 end_POSTSUPERSCRIPT italic_d ) observations for their method to guarantee an Ïµitalic-Ïµ\epsilonitalic_Ïµ-accurate estimate with r=ğ’ªâ¢(Ïµ)ğ‘Ÿğ’ªitalic-Ïµr=\mathcal{O}(\epsilon)italic_r = caligraphic_O ( italic_Ïµ ) for fixed ğœ½â‹†superscriptğœ½â‹†\bm{\theta}^{\star}bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT and noise level. This voids the gain due to Theorem 1.1. We propose a variant of the initialization by Ghosh et al. [2021] that substitutes PCA with sparse PCA (sPCA) and provides the desired initial estimate from fewer observations in the following special scenario: Suppose that the sparse coefficient vectors {ğ’‚jâ‹†}j=1ksuperscriptsubscriptsuperscriptsubscriptğ’‚ğ‘—â‹†ğ‘—1ğ‘˜\{\bm{a}_{j}^{\star}\}_{j=1}^{k}{ bold_italic_a start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT } start_POSTSUBSCRIPT italic_j = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT are simultaneously supported within a set of cardinality sğ‘ sitalic_s, i.e. |â‹ƒj=1ksuppâ¢(ğ’‚jâ‹†)|â‰¤s.superscriptsubscriptğ‘—1ğ‘˜suppsubscriptsuperscriptğ’‚â‹†ğ‘—ğ‘ \left|\bigcup_{j=1}^{k}\mathrm{supp}(\bm{a}^{\star}_{j})\right|\leq s.| â‹ƒ start_POSTSUBSCRIPT italic_j = 1 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT roman_supp ( bold_italic_a start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ) | â‰¤ italic_s . (5) Then the following pseudo-theorem quantifies the gain via the modified initialization scheme under this scenario. Theorem 1.2 (Informal). Let the covariates and noise be sampled independently from Gaussian distributions. Fix kğ‘˜kitalic_k and ground-truth ğ›‰â‹†superscriptğ›‰â‹†\bm{\theta}^{\star}bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT to satisfy the joint sparsity assumption in (5). Then, with high probability, the initialization via sPCA and rğ‘Ÿritalic_r-covering search provides an Ïµitalic-Ïµ\epsilonitalic_Ïµ-accurate estimate of ğ›‰â‹†superscriptğ›‰â‹†\bm{\theta}^{\star}bold_italic_Î¸ start_POSTSUPERSCRIPT â‹† end_POSTSUPERSCRIPT given ğ’ªâ¢(Ïµâˆ’2â¢maxâ¡(Ïƒz4,Ïƒz2,1)â¢s2â¢log4â¡d)ğ’ªsuperscriptitalic-Ïµ2superscriptsubscriptğœğ‘§4superscriptsubscriptğœğ‘§21superscriptğ‘ 2superscript4ğ‘‘\mathcal{O}(\epsilon^{-2}\max(\sigma_{z}^{4},\sigma_{z}^{2},1)s^{2}\log^{4}d)caligraphic_O ( italic_Ïµ start_POSTSUPERSCRIPT - 2 end_POSTSUPERSCRIPT roman_max ( italic_Ïƒ start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT , italic_Ïƒ start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT , 1 ) italic_s start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_log start_POSTSUPERSCRIPT 4 end_POSTSUPERSCRIPT italic_d ) observations and r=ğ’ªâ¢(Ïµ)ğ‘Ÿğ’ªitalic-Ïµr=\mathcal{O}(\epsilon)italic_r = caligraphic_O ( italic_Ïµ ) where Ïƒz2subscriptsuperscriptğœ2ğ‘§\sigma^{2}_{z}italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_z end_POSTSUBSCRIPT is the noise variance. Compared to previous work [Ghosh et al., 2021], the initialization scheme leveraging the joint sparsity drops the linear dependence on the ambient dimension dğ‘‘ditalic_d and replaces it with a quadratic dependence on sğ‘ sitalic_s. Our implementation and theoretical analysis build on sPCA by semi-definite program by Vu et al. [2013] where the estimation error decays as ğ’ªâ¢(s2â¢logâ¡d/n)ğ’ªsuperscriptğ‘ 2ğ‘‘ğ‘›\mathcal{O}(\sqrt{s^{2}\log d/n})caligraphic_O ( square-root start_ARG italic_s start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT roman_log italic_d / italic_n end_ARG ). A recent framework improved the error bound to ğ’ªâ¢(sâ¢logâ¡d/n)ğ’ªğ‘ ğ‘‘ğ‘›\mathcal{O}(\sqrt{s\log d/n})caligraphic_O ( square-root start_ARG italic_s roman_log italic_d / italic_n end_ARG ) under the assumption that data are obtained through a linear transform acting on special multivariate distributions [Wang et al., 2014]. However, this assumption is not satisfied by data generated with the max-affine model. Related work: Variable selection for linear regression models has been extensively studied in the literature (e.g. [George, 2000, Wasserman and Roeder, 2009]). Various optimization approaches including Lasso and basis pursuit have been studied [Hastie et al., 2009, Wainwright, 2019]. In practical applications, the covariate-target dependence often exhibits non-linearity not captured by linear models. There have been efforts to extend variable selection for linear regression to the non-linear models via basis change [Meier et al., 2009, Koltchinskii and Yuan, 2010]. They modeled the nonlinear function describing the target-covariate relation as a sparse superposition over a certain function basis (e.g. splines). Variable selection in their methods identifies active multivariate functions in the basis expansion. This approach is similar to the well-known order selection for polynomial regression [Peixoto, 1987]. Unlike the above model, similar to variable selection for linear regression, the sparse max-affine model directly identifies the active covariate variables to explain the target variable. Variable selection has also been used along with dimensionality reduction for high-dimensional nonlinear models. The sparse minimum average variance estimator (sMAVE) [Wang and Yin, 2008] and sparse sliced inverse regression (sSIR) [Tan et al., 2020] considered the model where the target is given by a nonlinear function acting on linear combinations of a subset of covariates. Both sMAVE and sSIR estimate the span of the weight vectors in the linear combinations without attempting to learn the unknown non-linear function. Only asymptotic analyses of these algorithms exist in the high sample regime, i.e. the total number of samples goes to infinity while the model order remains fixed. The sparse max-affine model corresponds to a special case of their model where the non-linear function is known. Under this scenario, we provide a stronger non-asymptotic theoretical analysis for variable selection for the nonlinear max-affine model. Paper organization: Section 2 presents Sp-GD and its non-asymptotic theoretical guarantees as local analysis of sparse max-affine regression. Section 3.1 describes the initialization scheme the corresponding non-asymptotic theoretical guarantees. Section 4 presents the numerical results that corroborate the theoretical guarantees for Sp-GD and the initialization scheme. Section 5 provides final remarks and future directions. Notation: We use lightface characters to denote scalars, lowercase boldface characters to denote column vectors and uppercase boldface to denote matrices. We also adopt the symbols for the max and min operators in the lattice theory, i.e. aâˆ¨b=maxâ¡(a,b)ğ‘ğ‘ğ‘ğ‘a\vee b=\max(a,b)italic_a âˆ¨ italic_b = roman_max ( italic_a , italic_b ) and aâˆ§b=minâ¡(a,b)ğ‘ğ‘ğ‘ğ‘a\wedge b=\min(a,b)italic_a âˆ§ italic_b = roman_min ( italic_a , italic_b ) for a,bâˆˆâ„ğ‘ğ‘â„a,b\in\mathbb{R}italic_a , italic_b âˆˆ blackboard_R. We use multiple matrix norms. The Frobenius norm, the spectral norm, and the largest magnitude of entries will be respectively denoted by âˆ¥â‹…âˆ¥Fsubscriptdelimited-âˆ¥âˆ¥â‹…F{\left\lVert\cdot\right\rVert}_{\mathrm{F}}âˆ¥ â‹… âˆ¥ start_POSTSUBSCRIPT roman_F end_POSTSUBSCRIPT, âˆ¥â‹…âˆ¥delimited-âˆ¥âˆ¥â‹…{\left\lVert\cdot\right\rVert}âˆ¥ â‹… âˆ¥, and âˆ¥â‹…âˆ¥âˆsubscriptdelimited-âˆ¥âˆ¥â‹…{\left\lVert\cdot\right\rVert}_{\infty}âˆ¥ â‹… âˆ¥ start_POSTSUBSCRIPT âˆ end_POSTSUBSCRIPT. We use a shorthand notation [d]delimited-[]ğ‘‘[d][ italic_d ] for the set {1,2,â€¦,d}12â€¦ğ‘‘\{1,2,\dots,d\}{ 1 , 2 , â€¦ , italic_d }. For a column vector ğ’™âˆˆâ„dğ’™superscriptâ„ğ‘‘\bm{x}\in\mathbb{R}^{d}bold_italic_x âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT, its subvector with the entries indexed by ğ’®âŠ‚[d]ğ’®delimited-[]ğ‘‘\mathcal{S}\subset[d]caligraphic_S âŠ‚ [ italic_d ] is denoted by [ğ’™]ğ’®subscriptdelimited-[]ğ’™ğ’®[\bm{x}]_{\mathcal{S}}[ bold_italic_x ] start_POSTSUBSCRIPT caligraphic_S end_POSTSUBSCRIPT. Similarly, for a matrix ğ‘¿âˆˆâ„dÃ—dğ‘¿superscriptâ„ğ‘‘ğ‘‘\bm{X}\in\mathbb{R}^{d\times d}bold_italic_X âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d Ã— italic_d end_POSTSUPERSCRIPT, its submatrix with the entries indexed by ğ’®1Ã—ğ’®2âŠ‚[d]Ã—[d]subscriptğ’®1subscriptğ’®2delimited-[]ğ‘‘delimited-[]ğ‘‘\mathcal{S}_{1}\times\mathcal{S}_{2}\subset[d]\times[d]caligraphic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— caligraphic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT âŠ‚ [ italic_d ] Ã— [ italic_d ] is denoted by [ğ‘¿]ğ’®1,ğ’®2subscriptdelimited-[]ğ‘¿subscriptğ’®1subscriptğ’®2[\bm{X}]_{\mathcal{S}_{1},\mathcal{S}_{2}}[ bold_italic_X ] start_POSTSUBSCRIPT caligraphic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , caligraphic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT end_POSTSUBSCRIPT. Finally, we denote by C,C1,C2,â€¦ğ¶subscriptğ¶1subscriptğ¶2â€¦C,C_{1},C_{2},\dotsitalic_C , italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_C start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , â€¦ universally absolute constants, not necessarily the same at each occurrence."
https://arxiv.org/html/2411.02148v1,Optimality of Frequency Moment Estimation,"Estimating the second frequency moment of a stream up to (1Â±Îµ)plus-or-minus1ğœ€(1\pm\varepsilon)( 1 Â± italic_Îµ ) multiplicative error requires at most Oâ¢(logâ¡n/Îµ2)ğ‘‚ğ‘›superscriptğœ€2O(\log n/\varepsilon^{2})italic_O ( roman_log italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) bits of space, due to a seminal result of Alon, Matias, and Szegedy. It is also known that at least Î©â¢(logâ¡n+1/Îµ2)Î©ğ‘›1superscriptğœ€2\Omega(\log n+1/\varepsilon^{2})roman_Î© ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) space is needed. We prove an optimal lower bound of Î©â¢(logâ¡(nâ¢Îµ2)/Îµ2)Î©ğ‘›superscriptğœ€2superscriptğœ€2\Omega\left(\log\left(n\varepsilon^{2}\right)/\varepsilon^{2}\right)roman_Î© ( roman_log ( italic_n italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) for all Îµ=Î©â¢(1/n)ğœ€Î©1ğ‘›\varepsilon=\Omega(1/\sqrt{n})italic_Îµ = roman_Î© ( 1 / square-root start_ARG italic_n end_ARG ). Note that when Îµ>nâˆ’1/2+cğœ€superscriptğ‘›12ğ‘\varepsilon>n^{-1/2+c}italic_Îµ > italic_n start_POSTSUPERSCRIPT - 1 / 2 + italic_c end_POSTSUPERSCRIPT, where c>0ğ‘0c>0italic_c > 0, our lower bound matches the classic upper bound of AMS. For smaller values of Îµğœ€\varepsilonitalic_Îµ we also introduce a revised algorithm that improves the classic AMS bound and matches our lower bound. Our lower bound holds also for the more general problem of pğ‘pitalic_p-th frequency moment estimation for the range of pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ], giving a tight bound in the only remaining range to settle the optimal space complexity of estimating frequency moments.","An extensive body of literature is devoted to the streaming model of computation, which is important for the analysis of massive datasets and in network traffic monitoring. A central problem in this model is the frequency moment estimation problem: Elements from a universe Uğ‘ˆUitalic_U are given to the algorithm one-by-one, defining a vector of frequencies â€” that is, fxâˆˆâ„•subscriptğ‘“ğ‘¥â„•f_{x}\in\mathbb{N}italic_f start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT âˆˆ blackboard_N is the number of times the element xâˆˆUğ‘¥ğ‘ˆx\in Uitalic_x âˆˆ italic_U appeared in the stream; Finally, the algorithm has to return, with good probability, a (1Â±Îµ)plus-or-minus1ğœ€(1\pm\varepsilon)( 1 Â± italic_Îµ )-estimation of Fp:=âˆ‘xâˆˆUfxpassignsubscriptğ¹ğ‘subscriptğ‘¥ğ‘ˆsuperscriptsubscriptğ‘“ğ‘¥ğ‘F_{p}:=\sum_{x\in U}f_{x}^{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT := âˆ‘ start_POSTSUBSCRIPT italic_x âˆˆ italic_U end_POSTSUBSCRIPT italic_f start_POSTSUBSCRIPT italic_x end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_p end_POSTSUPERSCRIPT â€” the pğ‘pitalic_p-th frequency moment of the stream. We generally denote the length of the stream by nğ‘›nitalic_n and assume that |U|=polyâ¢(n)ğ‘ˆpolyğ‘›|U|=\text{poly}(n)| italic_U | = poly ( italic_n ). The main complexity parameter studied in this model is how much space is needed for the algorithm to succeed. The study of both the streaming model and of frequency moment estimation in it was initiated in the seminal 1996 work of Alon, Matias, and Szegedy [AMS96]. The case of p=2ğ‘2p=2italic_p = 2, or second moment estimation, is of particular importance. It is often called the repeat rate or surprise index, and is used in various tasks such as database query optimization [AGMS99], network traffic anomaly detection [KSZC03], approximate histogram maintenance [GGI+02] and more. Other moments of particular interest are p=1ğ‘1p=1italic_p = 1, corresponding to the approximate counting problem [Mor78, NY22], and p=0ğ‘0p=0italic_p = 0, corresponding to the distinct elements problem [FM85, IW03, KNW10b]. Among these special cases, only the space complexity of the first remains not fully understood. The original algorithm for F2subscriptğ¹2F_{2}italic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-estimation given by Alon, Matias, and Szegedy uses Oâ¢(logâ¡n/Îµ2)ğ‘‚ğ‘›superscriptğœ€2O(\log n/\varepsilon^{2})italic_O ( roman_log italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) bits of space; while the highest known lower bound due to Woodruff in 2004 [Woo04] is Î©â¢(logâ¡n+1/Îµ2)Î©ğ‘›1superscriptğœ€2\Omega(\log n+1/\varepsilon^{2})roman_Î© ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) â€” leaving up to a quadratic gap between the upper and lower bounds for certain choices of Îµğœ€\varepsilonitalic_Îµ. While Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation for pâ‰¤2ğ‘2p\leq 2italic_p â‰¤ 2 uses amount of space that is only logarithmic in the length of the stream, it was shown that for p>2ğ‘2p>2italic_p > 2 at least Î©â¢(n1âˆ’2/p/polyâ¢(Îµ))Î©superscriptğ‘›12ğ‘polyğœ€\Omega(n^{1-2/p}/\text{poly}(\varepsilon))roman_Î© ( italic_n start_POSTSUPERSCRIPT 1 - 2 / italic_p end_POSTSUPERSCRIPT / poly ( italic_Îµ ) ) space is needed [BYJKS04, CKS03b] â€” which is polynomial in the streamâ€™s length. A long list of works [IW05, BGKS06, MW10, AKO11, BO10, And17, Gan11b, WZ12, Gan11a, LW13] resulted in a nearly-tight bound of Î˜~â¢(n1âˆ’2/p/Îµ2)~Î˜superscriptğ‘›12ğ‘superscriptğœ€2\tilde{\Theta}\left(n^{1-2/p}/\varepsilon^{2}\right)over~ start_ARG roman_Î˜ end_ARG ( italic_n start_POSTSUPERSCRIPT 1 - 2 / italic_p end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) for Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation for every p>2ğ‘2p>2italic_p > 2 (not necessarily an integer) and Îµğœ€\varepsilonitalic_Îµ, for some ranges of parameters the bounds are tight â€” in others there is a gap between the bounds that is poly-logarithmic in the bound itself. For pâ‰¤2ğ‘2p\leq 2italic_p â‰¤ 2 the space complexity is not as well understood. Woodruff [Woo04] showed a lower bound of Î©â¢(logâ¡n+1/Îµ2)Î©ğ‘›1superscriptğœ€2\Omega(\log n+1/\varepsilon^{2})roman_Î© ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) for every pâ‰ 1ğ‘1p\neq 1italic_p â‰  1, this is optimal in terms of Îµğœ€\varepsilonitalic_Îµ alone and is also known to be optimal for the distinct elements problem (that is, p=0ğ‘0p=0italic_p = 0). For the special case of approximate counting (that is, p=1ğ‘1p=1italic_p = 1), a tight bound of Î˜â¢(logâ¡logâ¡n+logâ¡Îµâˆ’1)Î˜ğ‘›superscriptğœ€1\Theta(\log\log n+\log\varepsilon^{-1})roman_Î˜ ( roman_log roman_log italic_n + roman_log italic_Îµ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) is known [NY22]. For the range of pâˆˆ[0,1)ğ‘01p\in[0,1)italic_p âˆˆ [ 0 , 1 ), the upper bound of AMS was improved by Jayaram and Woodruff who presented a nearly-tight O~â¢(logâ¡n+1/Îµ2)~ğ‘‚ğ‘›1superscriptğœ€2\tilde{O}\left(\log n+1/\varepsilon^{2}\right)over~ start_ARG italic_O end_ARG ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) bound in that range [JW19]. This leaves pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ] as the last remaining range within no nearly-tight bounds are known. For certain generalizations more is known: When the stream is randomly shuffled and given in random order, then in the range pâˆˆ(1,2)ğ‘12p\in(1,2)italic_p âˆˆ ( 1 , 2 ) (excluding p=2ğ‘2p=2italic_p = 2) [BVWY18] showed an improved upper bound of O~â¢(logâ¡n+1/Îµ2)~ğ‘‚ğ‘›1superscriptğœ€2\tilde{O}\left(\log n+1/\varepsilon^{2}\right)over~ start_ARG italic_O end_ARG ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ). When updates are allowed in the stream, that is, elements can also be deleted and not only added to it, then [KNW10a] showed that Î˜â¢(logâ¡n/Îµ2)Î˜ğ‘›superscriptğœ€2\Theta(\log n/\varepsilon^{2})roman_Î˜ ( roman_log italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) is optimal for pâ‰¤2ğ‘2p\leq 2italic_p â‰¤ 2. In this work, we settle the space complexity of frequency moment estimation in the entire remaining range of pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ], including the special case of second frequency moment estimation. For p=2ğ‘2p=2italic_p = 2, we show that the AMS bound is essentially tight. Theorem. Let ğ’œğ’œ\mathcal{A}caligraphic_A be a streaming algorithm that gives an (1Â±Îµ)plus-or-minus1ğœ€\left(1\pm\varepsilon\right)( 1 Â± italic_Îµ ) multiplicative approximation to the F2subscriptğ¹2F_{2}italic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of its input stream and succeeds with probability â‰¥2/3absent23\geq 2/3â‰¥ 2 / 3, for some Îµ=Î©â¢(1/n)ğœ€Î©1ğ‘›\varepsilon=\Omega(1/\sqrt{n})italic_Îµ = roman_Î© ( 1 / square-root start_ARG italic_n end_ARG ). Then, the space used by ğ’œğ’œ\mathcal{A}caligraphic_A is Î©â¢(logâ¡(Îµ2â¢n)/Îµ2)Î©superscriptğœ€2ğ‘›superscriptğœ€2\Omega\left(\log\left(\varepsilon^{2}n\right)/\varepsilon^{2}\right)roman_Î© ( roman_log ( italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ). Note that the range Îµ<1/nğœ€1ğ‘›\varepsilon<1/\sqrt{n}italic_Îµ < 1 / square-root start_ARG italic_n end_ARG is less interesting as Oâ¢(minâ¡{nâ¢logâ¡n,|U|})ğ‘‚ğ‘›ğ‘›ğ‘ˆO\left(\min\{n\log n,|U|\}\right)italic_O ( roman_min { italic_n roman_log italic_n , | italic_U | } ) space suffices for exactly maintaining the vector of frequencies. We observe that in the range where Îµğœ€\varepsilonitalic_Îµ is very close to 1/n1ğ‘›1/\sqrt{n}1 / square-root start_ARG italic_n end_ARG our lower bound is (slightly) lower than the AMS upper bound, we show that this is inherent by introducing a modification of the AMS algorithm that matches our lower bound in this range. Theorem. For Îµ=Î©â¢(1/n)ğœ€Î©1ğ‘›\varepsilon=\Omega(1/\sqrt{n})italic_Îµ = roman_Î© ( 1 / square-root start_ARG italic_n end_ARG ), we can get a (1Â±Îµ)plus-or-minus1ğœ€(1\pm\varepsilon)( 1 Â± italic_Îµ )-approximation of the F2subscriptğ¹2F_{2}italic_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT of a stream of length nğ‘›nitalic_n using Oâ¢(logâ¡(Îµ2â¢n)/Îµ2)ğ‘‚superscriptğœ€2ğ‘›superscriptğœ€2O\left(\log\left(\varepsilon^{2}n\right)/\varepsilon^{2}\right)italic_O ( roman_log ( italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_n ) / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) space with success probability >2/3absent23>2/3> 2 / 3. 0â‰¤p<10ğ‘10\leq p<10 â‰¤ italic_p < 1 p=1ğ‘1p=1italic_p = 1 1<pâ‰¤21ğ‘21<p\leq 21 < italic_p â‰¤ 2 p>2ğ‘2p>2italic_p > 2 Î˜~â¢(logâ¡n+1/Îµ2)~Î˜ğ‘›1superscriptğœ€2\tilde{\Theta}(\log n+1/\varepsilon^{2})over~ start_ARG roman_Î˜ end_ARG ( roman_log italic_n + 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) Î˜â¢(logâ¡logâ¡n+logâ¡Îµâˆ’1)Î˜ğ‘›superscriptğœ€1\Theta(\log\log n+\log\varepsilon^{-1})roman_Î˜ ( roman_log roman_log italic_n + roman_log italic_Îµ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) Î˜â¢(logâ¡n/Îµ2)Î˜ğ‘›superscriptğœ€2\Theta(\log n/\varepsilon^{2})roman_Î˜ ( roman_log italic_n / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) Î˜~â¢(n1âˆ’2/p/Îµ2)~Î˜superscriptğ‘›12ğ‘superscriptğœ€2\tilde{\Theta}(n^{1-2/p}/\varepsilon^{2})over~ start_ARG roman_Î˜ end_ARG ( italic_n start_POSTSUPERSCRIPT 1 - 2 / italic_p end_POSTSUPERSCRIPT / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) Figure 1: Space complexity of Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation. We also extend our lower bound to the range pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ], which settles the space complexity of Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation for all values of pğ‘pitalic_p. See Figure 1 for a summary of the space complexity of Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation for all pâ‰¥0ğ‘0p\geq 0italic_p â‰¥ 0. Theorem. Fix pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ]. Let ğ’œğ’œ\mathcal{A}caligraphic_A be a streaming algorithm that gives an (1Â±Îµ)plus-or-minus1ğœ€\left(1\pm\varepsilon\right)( 1 Â± italic_Îµ ) approximation to the Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT of its input stream, for some Îµâˆˆ(Î©â¢(nâˆ’1/p),4âˆ’1/(pâˆ’1))ğœ€Î©superscriptğ‘›1ğ‘superscript41ğ‘1\varepsilon\in\left(\Omega\left(n^{-1/p}\right),{4^{-1/(p-1)}}\right)italic_Îµ âˆˆ ( roman_Î© ( italic_n start_POSTSUPERSCRIPT - 1 / italic_p end_POSTSUPERSCRIPT ) , 4 start_POSTSUPERSCRIPT - 1 / ( italic_p - 1 ) end_POSTSUPERSCRIPT ), and succeeds with probability â‰¥2/3absent23\geq 2/3â‰¥ 2 / 3. Then, the space used by ğ’œğ’œ\mathcal{A}caligraphic_A is Î©â¢(logâ¡(Îµ1/pâ¢n)/Îµ2)Î©superscriptğœ€1ğ‘ğ‘›superscriptğœ€2\Omega\left(\log\left(\varepsilon^{1/p}n\right)/\varepsilon^{2}\right)roman_Î© ( roman_log ( italic_Îµ start_POSTSUPERSCRIPT 1 / italic_p end_POSTSUPERSCRIPT italic_n ) / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ). Most of the lower bounds for streaming problems are based on reductions from communication complexity. In [JW19], a natural barrier to prove a better than Î©~â¢(1/Îµ2)~Î©1superscriptğœ€2\tilde{\Omega}(1/\varepsilon^{2})over~ start_ARG roman_Î© end_ARG ( 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) lower bound was shown: Even in a very strong model of communication, Oâ¢(1/Îµ2â‹…(logâ¡logâ¡n+logâ¡d+logâ¡Îµâˆ’1))ğ‘‚â‹…1superscriptğœ€2ğ‘›ğ‘‘superscriptğœ€1O\left(1/\varepsilon^{2}\cdot\left(\log\log n+\log d+\log\varepsilon^{-1}% \right)\right)italic_O ( 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT â‹… ( roman_log roman_log italic_n + roman_log italic_d + roman_log italic_Îµ start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ) ) bits of communication suffice for the players to correctly produce a Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT estimation, where dğ‘‘ditalic_d is the diameter of the communication graph. This means that problems who reduce to Fpsubscriptğ¹ğ‘F_{p}italic_F start_POSTSUBSCRIPT italic_p end_POSTSUBSCRIPT-estimation have a too low communication complexity to improve the existing lower bounds. To overcome this natural barrier, we present a new type of a direct sum theorem that takes place at the level of the streaming algorithm rather than the level of the communication model â€” informally, we pack many instances of problems with communication complexity Î˜â¢(1/Îµ2)Î˜1superscriptğœ€2\Theta(1/\varepsilon^{2})roman_Î˜ ( 1 / italic_Îµ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) into a single stream, and then directly show that a successful streaming algorithm must solve them all. In Section 2 we give a detailed high-level overview of our proofs. The lower bound is presented in Section 4 and Section 5, and then extended from p=2ğ‘2p=2italic_p = 2 to pâˆˆ(1,2]ğ‘12p\in(1,2]italic_p âˆˆ ( 1 , 2 ] in Section 5.3. The improved upper bound is presented in Section 6. We conclude and present remaining open problems in Section 7."
https://arxiv.org/html/2411.01974v1,On the phase diagram of extensive-rank symmetric matrix denoisingbeyond rotational invariance,"Matrix denoising is central to signal processing and machine learning. Its statistical analysis when the matrix to infer has a factorised structure with a rank growing proportionally to its dimension remains a challenge, except when it is rotationally invariant. In this case the information theoretic limits and an efficient Bayes-optimal denoising algorithm, called rotational invariant estimator [1, 2], are known. Beyond this setting few results can be found. The reason is that the model is not a usual spin system because of the growing rank dimension, nor a matrix model (as appearing in high-energy physics) due to the lack of rotation symmetry, but rather a hybrid between the two.In this paper we make progress towards the understanding of Bayesian matrix denoising when the hidden signal is a factored matrix ğ—ğ—âŠºsuperscriptğ—ğ—âŠº{\mathbf{X}}{\mathbf{X}}^{\intercal}bold_XX start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT that is not rotationally invariant. Monte Carlo simulations suggest the existence of a denoising-factorisation transition separating a phase where denoising using the rotational invariant estimator remains Bayes-optimal due to universality properties of the same nature as in random matrix theory, from one where universality breaks down and better denoising is possible by exploiting the signalâ€™s prior and factorised structure, though algorithmically hard. We also argue that it is only beyond the transition that factorisation, i.e., estimating ğ—ğ—{\mathbf{X}}bold_X itself, becomes possible up to sign and permutation ambiguities. On the theoretical side, we combine mean-field techniques in an interpretable multiscale fashion in order to access the minimum mean-square error and mutual information. Interestingly, our alternative method yields equations which can be reproduced using the replica approach of [3]. Using numerical insights, we then delimit the portion of the phase diagram where this mean-field theory is reliable, and correct it using universality when it is not. Our final ansatz matches well the numerics when accounting for finite size effects.","Denoising a large matrix modelled as a product of two factors is a hard problem, both algorithmically, and from the viewpoint of theoretical analysis, especially if its rank is proportional to its dimension. Its applications range from signal processing and machine learning [4, 5], representation learning [6], sparse coding [7, 8, 9], robust principal components analysis [10, 11], sub-matrix localization [12], blind source separation [13], matrix completion [14, 15], community detection [16, 17, 18], video processing [4, 19], or recommender systems [20]. In this paper we focus on the symmetric version of matrix denoising for signal matrices wich have a product structure. Denoising is formulated as a Bayesian inference problem over ğ—ğ—âŠºsuperscriptğ—ğ—âŠº{\mathbf{X}}{\mathbf{X}}^{\intercal}bold_XX start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT given a noisy data matrix ğ˜âˆˆâ„NÃ—Nğ˜superscriptâ„ğ‘ğ‘{\mathbf{Y}}\in\mathbb{R}^{N\times N}bold_Y âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_N Ã— italic_N end_POSTSUPERSCRIPT generated as ğ˜=Î»Nâ¢ğ—ğ—âŠº+ğ™,ğ˜ğœ†ğ‘superscriptğ—ğ—âŠºğ™\displaystyle{\mathbf{Y}}=\sqrt{\frac{\lambda}{N}}{\mathbf{X}}{\mathbf{X}}^{% \intercal}+{\mathbf{Z}},bold_Y = square-root start_ARG divide start_ARG italic_Î» end_ARG start_ARG italic_N end_ARG end_ARG bold_XX start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT + bold_Z , (1) where the rectangular matrix ğ—âˆˆâ„NÃ—Mğ—superscriptâ„ğ‘ğ‘€{\mathbf{X}}\in\mathbb{R}^{N\times M}bold_X âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_N Ã— italic_M end_POSTSUPERSCRIPT is the hidden factor (also called signal, a terminology we will also use for ğ—ğ—âŠºsuperscriptğ—ğ—âŠº{\mathbf{X}}{\mathbf{X}}^{\intercal}bold_XX start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT if there is no ambiguity), ğ™âˆˆâ„NÃ—Nğ™superscriptâ„ğ‘ğ‘{\mathbf{Z}}\in\mathbb{R}^{N\times N}bold_Z âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_N Ã— italic_N end_POSTSUPERSCRIPT is a noise matrix drawn from the Gaussian orthogonal ensemble (GOE), i.e. with Gaussian entries Ziâ¢j=Zjâ¢iâˆ¼ğ’©â¢(0,1+Î´iâ¢j)subscriptğ‘ğ‘–ğ‘—subscriptğ‘ğ‘—ğ‘–similar-toğ’©01subscriptğ›¿ğ‘–ğ‘—Z_{ij}=Z_{ji}\sim\mathcal{N}(0,1+\delta_{ij})italic_Z start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT = italic_Z start_POSTSUBSCRIPT italic_j italic_i end_POSTSUBSCRIPT âˆ¼ caligraphic_N ( 0 , 1 + italic_Î´ start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT ) and all independent. The signal ğ—ğ—{\mathbf{X}}bold_X has i.i.d. components (Xiâ¢Î¼)iâ‰¤N,Î¼â‰¤Msubscriptsubscriptğ‘‹ğ‘–ğœ‡formulae-sequenceğ‘–ğ‘ğœ‡ğ‘€(X_{i\mu})_{i\leq N,\mu\leq M}( italic_X start_POSTSUBSCRIPT italic_i italic_Î¼ end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_i â‰¤ italic_N , italic_Î¼ â‰¤ italic_M end_POSTSUBSCRIPT drawn from a sub-Gaussian symmetric prior distribution PXsubscriptğ‘ƒğ‘‹P_{X}italic_P start_POSTSUBSCRIPT italic_X end_POSTSUBSCRIPT with zero mean and unit variance. The rank of ğ—ğ—âŠºsuperscriptğ—ğ—âŠº{\mathbf{X}}{\mathbf{X}}^{\intercal}bold_XX start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT is thus at most minâ¡(N,M)ğ‘ğ‘€\min(N,M)roman_min ( italic_N , italic_M ). When the prior is different than centered Gaussian, the signal ğ—ğ—âŠºsuperscriptğ—ğ—âŠº{\mathbf{X}}{\mathbf{X}}^{\intercal}bold_XX start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT (and thus the data) is not rotational invariant. Rotational invariance means in this context that the probability Pâ¢(ğ—ğ—âŠº)ğ‘ƒsuperscriptğ—ğ—âŠºP({\mathbf{X}}{\mathbf{X}}^{\intercal})italic_P ( bold_XX start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT ) would be equal to Pâ¢(ğğ—ğ—âŠºâ¢ğâŠº)ğ‘ƒsuperscriptğğ—ğ—âŠºsuperscriptğâŠºP({\mathbf{O}}{\mathbf{X}}{\mathbf{X}}^{\intercal}{\mathbf{O}}^{\intercal})italic_P ( bold_OXX start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT bold_O start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT ) for any NÃ—Nğ‘ğ‘N\times Nitalic_N Ã— italic_N orthogonal matrix ğğ{\mathbf{O}}bold_O. The setting where the prior PXsubscriptğ‘ƒğ‘‹P_{X}italic_P start_POSTSUBSCRIPT italic_X end_POSTSUBSCRIPT breaks this invariance, as well as the differences this induces w.r.t. the rotational invariant Gaussian prior PX=ğ’©â¢(0,1)subscriptğ‘ƒğ‘‹ğ’©01P_{X}=\mathcal{N}(0,1)italic_P start_POSTSUBSCRIPT italic_X end_POSTSUBSCRIPT = caligraphic_N ( 0 , 1 ), is the main focus of this paper. The low rank version of matrix estimation (M=Oâ¢(1)ğ‘€ğ‘‚1M=O(1)italic_M = italic_O ( 1 ) while Nâ†’âˆâ†’ğ‘N\to\inftyitalic_N â†’ âˆ) is called the spiked Wigner model and was introduced as a statistical model for sparse principal components analysis (PCA) [21, 22, 23, 24]. Spiked models are largely studied both in random matrix theory [25, 26, 27] and in high-dimensional inference [28, 29, 30, 31, 32, 33, 34, 35]. As a matter of fact, both the replica analysis [29] and the rigorous proofs [36, 37, 38, 39, 17, 30, 40, 41, 42] heavily rely on the rank of the hidden matrix being finite. This, in turn, implies that from a thermodynamic point of view the system is controlled by the value of a finite number of order parameters, identifiable with the elements of a matrix overlap ğ—âŠºâ¢ğ±/Nâˆˆâ„MÃ—Msuperscriptğ—âŠºğ±ğ‘superscriptâ„ğ‘€ğ‘€{\mathbf{X}}^{\intercal}{\mathbf{x}}/{N}\in\mathbb{R}^{M\times M}bold_X start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT bold_x / italic_N âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_M Ã— italic_M end_POSTSUPERSCRIPT, where ğ±ğ±{\mathbf{x}}bold_x here is a sample from the posterior measure associated to (1). Crucially the number of order parameters in these approaches is thus Oâ¢(M2)=Oâ¢(1)ğ‘‚superscriptğ‘€2ğ‘‚1O(M^{2})=O(1)italic_O ( italic_M start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) = italic_O ( 1 ), yielding to exact tractable formulas often derived by saddle point in the replica formalism. However, when the rank Mğ‘€Mitalic_M grows proportionally to Nğ‘Nitalic_N, MNâ†’Î±>0,â†’ğ‘€ğ‘ğ›¼0\frac{M}{N}\to\alpha>0,divide start_ARG italic_M end_ARG start_ARG italic_N end_ARG â†’ italic_Î± > 0 , as considered in the present paper, the saddle point does not apply anymore and the problem boils down to a matrix model. Matrix models appear frequently in high energy physics, in particular in Yang-Mills theories with internal symmetry groups of diverging dimension [43], in random matrix theory approaches to quantum gravity [44, 45], quantum chromo-dynamics [46], statistical mechanics models on planar random lattices [47, 48, 49, 50] or counting planar diagrams [51, 52]. We refer the interested reader to the review [53]. A prototypical matrix model is a partition function of the type ğ’µMMâ¢(ğ€):=âˆ«â„Nğ‘‘ğ…â¢expâ¡(âˆ’Trâ¢ğ…2+Trâ¢Vâ¢(ğ€ğ…)),assignsubscriptğ’µMMğ€subscriptsubscriptâ„ğ‘differential-dğ…Trsuperscriptğ…2Trğ‘‰ğ€ğ…\displaystyle\mathcal{Z}_{\rm MM}({\mathbf{A}}):=\int_{\mathbb{H}_{N}}d{% \mathbf{F}}\exp\big{(}-{\rm Tr}{\mathbf{F}}^{2}+{\rm Tr}V({\mathbf{A}}{\mathbf% {F}})\big{)},caligraphic_Z start_POSTSUBSCRIPT roman_MM end_POSTSUBSCRIPT ( bold_A ) := âˆ« start_POSTSUBSCRIPT blackboard_H start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT end_POSTSUBSCRIPT italic_d bold_F roman_exp ( - roman_Tr bold_F start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT + roman_Tr italic_V ( bold_AF ) ) , (2) where â„Nsubscriptâ„ğ‘\mathbb{H}_{N}blackboard_H start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT is the space of Hermitian NÃ—Nğ‘ğ‘N\times Nitalic_N Ã— italic_N matrices, dâ¢ğ…ğ‘‘ğ…d{\mathbf{F}}italic_d bold_F denotes the Lebesgue measure over it, the source ğ€âˆˆâ„Nğ€subscriptâ„ğ‘{\mathbf{A}}\in\mathbb{H}_{N}bold_A âˆˆ blackboard_H start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT and Vğ‘‰Vitalic_V is a function applied only to each eigenvalue of its argument: Vâ¢(ğ‡)=ğâ¢diagâ¢(Vâ¢(di)iâ‰¤N)â¢ğâŠºğ‘‰ğ‡ğdiagğ‘‰subscriptsubscriptğ‘‘ğ‘–ğ‘–ğ‘superscriptğâŠºV({\mathbf{H}})={\mathbf{O}}\text{diag}(V(d_{i})_{i\leq N}){\mathbf{O}}^{\intercal}italic_V ( bold_H ) = bold_O diag ( italic_V ( italic_d start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_i â‰¤ italic_N end_POSTSUBSCRIPT ) bold_O start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT whenever ğ‡=ğâ¢diagâ¢((di)iâ‰¤N)â¢ğâŠºğ‡ğdiagsubscriptsubscriptğ‘‘ğ‘–ğ‘–ğ‘superscriptğâŠº{\mathbf{H}}={\mathbf{O}}\text{diag}((d_{i})_{i\leq N}){\mathbf{O}}^{\intercal}bold_H = bold_O diag ( ( italic_d start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_i â‰¤ italic_N end_POSTSUBSCRIPT ) bold_O start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT with unitary ğğ{\mathbf{O}}bold_O. The one-matrix integral in (2) can be solved in the large Nğ‘Nitalic_N limit by the character expansion method [54, 55], or if V is sufficiently simple by means of the HarishChandra-Itzykson-Zuber (HCIZ) integral [56, 57]. Integration over real symmetric matrices instead of Hermitian can also be considered. The HCIZ integral is defined as ğ’µHCIZâ¢(ğ€,ğ):=âˆ«ğ‘‘Î¼â¢(ğ)â¢expâ¡(Î²â¢N2â¢Trâ¢ğğ€ğâŠºâ¢ğ)assignsubscriptğ’µHCIZğ€ğdifferential-dğœ‡ğğ›½ğ‘2Trsuperscriptğğ€ğâŠºğ\displaystyle\mathcal{Z}_{\rm HCIZ}({\mathbf{A}},{\mathbf{B}}):=\int d\mu({% \mathbf{O}})\exp\Big{(}\frac{\beta N}{2}{\rm Tr}{\mathbf{O}}{\mathbf{A}}{% \mathbf{O}}^{\intercal}{\mathbf{B}}\Big{)}caligraphic_Z start_POSTSUBSCRIPT roman_HCIZ end_POSTSUBSCRIPT ( bold_A , bold_B ) := âˆ« italic_d italic_Î¼ ( bold_O ) roman_exp ( divide start_ARG italic_Î² italic_N end_ARG start_ARG 2 end_ARG roman_Tr bold_OAO start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT bold_B ) (3) where Î²=2ğ›½2\beta=2italic_Î² = 2 if ğ€,ğğ€ğ{\mathbf{A}},{\mathbf{B}}bold_A , bold_B are NÃ—Nğ‘ğ‘N\times Nitalic_N Ã— italic_N Hermitian, and Î²=1ğ›½1\beta=1italic_Î² = 1 if they are real symmetric. Respectively the integral is over the unitary ğ•Œâ¢(N)ğ•Œğ‘\mathbb{U}(N)blackboard_U ( italic_N ) or orthogonal ğ•†â¢(N)ğ•†ğ‘\mathbb{O}(N)blackboard_O ( italic_N ) group, w.r.t. the corresponding uniform Haar measure Î¼ğœ‡\muitalic_Î¼. Remarkably, this integral is solved in closed form [57] for any Nğ‘Nitalic_N, and its asymptotics was also computed first by Matytsin [58] and then rigorously proved in [59, 60]. The approaches to the computation of these partition functions need Lebesgue measure over the matrix elements or a rotational invariant one. This is usually what allows to integrate away the Oâ¢(N2)ğ‘‚superscriptğ‘2O(N^{2})italic_O ( italic_N start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) rotational degrees of freedom, leaving only Nğ‘Nitalic_N degrees of freedom for the eigenvalues or the corresponding spectral density. If, as it occurs for (3), the exponent of the integrand stays Oâ¢(N2)ğ‘‚superscriptğ‘2O(N^{2})italic_O ( italic_N start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) then a saddle point over the eigenvalues is justified. In the present paper, however, we can no longer rely on this symmetry, because it is in general broken by the prior PXsubscriptğ‘ƒğ‘‹P_{X}italic_P start_POSTSUBSCRIPT italic_X end_POSTSUBSCRIPT as we shall see. Organization of the paper. In Section II we introduce the main objects under investigation with the precise definition of the problem. We also give a preview of the theoretical and numerical results of the paper. Given the number of conjectures revolving around matrix factorisation in the extensive-rank regime, we thoroughly review relevant results in the literature about the problem. In Section III we present the observations obtained from numerical experiments based on parallel tempering [61, 62] and annealed importance sampling (AIS) [63], as well as simple arguments showing the existence of a regime where universality in the prior cannot hold. From these findings we draw a qualitative phase diagram and, in particular, we discuss a phase transition coined denoising-factorisation transition, separating two regions of the phase diagram of a very different nature. Section IV presents an effective mean-field theory able to match the numerical observations, in particular the existence of the denoising-factorisation transition. The theory will provide an approximation for both the mutual information between observations and ground truth as well as the for the minimum mean-square error using a combination of the cavity method from statistical physics, a mean-field ansatz as well as known rigorous proofs of replica symmetric formulas in high-dimensional inference. Our theoretical insights are then discussed. Section V elaborates around the possibility to carry out factorization, namely finding ğ—ğ—{\mathbf{X}}bold_X alone, up to unresolvable symmetries. The picture that emerges from our numerical results is consistent with the one of Section IV. Notations. Symbol âˆ¼similar-to\simâˆ¼ expresses that a random variable is drawn from a certain law. Xiâ¢Î¼âˆ¼iidPsuperscriptsimilar-toiidsubscriptğ‘‹ğ‘–ğœ‡ğ‘ƒX_{i\mu}\mathrel{\stackrel{{\scriptstyle\makebox[0.0pt]{\mbox{\tiny iid}}}}{{% \sim}}}Pitalic_X start_POSTSUBSCRIPT italic_i italic_Î¼ end_POSTSUBSCRIPT start_RELOP SUPERSCRIPTOP start_ARG âˆ¼ end_ARG start_ARG iid end_ARG end_RELOP italic_P means that (Xiâ¢Î¼)i,Î¼subscriptsubscriptğ‘‹ğ‘–ğœ‡ğ‘–ğœ‡(X_{i\mu})_{i,\mu}( italic_X start_POSTSUBSCRIPT italic_i italic_Î¼ end_POSTSUBSCRIPT ) start_POSTSUBSCRIPT italic_i , italic_Î¼ end_POSTSUBSCRIPT are independent and identically distributed according to Pğ‘ƒPitalic_P. For a matrix ğ±=(xiâ¢Î¼)ğ±subscriptğ‘¥ğ‘–ğœ‡{\mathbf{x}}=(x_{i\mu})bold_x = ( italic_x start_POSTSUBSCRIPT italic_i italic_Î¼ end_POSTSUBSCRIPT ) we denote dâ¢PXâ¢(ğ±)=âˆi,Î¼dâ¢PXâ¢(xiâ¢Î¼)ğ‘‘subscriptğ‘ƒğ‘‹ğ±subscriptproductğ‘–ğœ‡ğ‘‘subscriptğ‘ƒğ‘‹subscriptğ‘¥ğ‘–ğœ‡dP_{X}({\mathbf{x}})=\prod_{i,\mu}dP_{X}(x_{i\mu})italic_d italic_P start_POSTSUBSCRIPT italic_X end_POSTSUBSCRIPT ( bold_x ) = âˆ start_POSTSUBSCRIPT italic_i , italic_Î¼ end_POSTSUBSCRIPT italic_d italic_P start_POSTSUBSCRIPT italic_X end_POSTSUBSCRIPT ( italic_x start_POSTSUBSCRIPT italic_i italic_Î¼ end_POSTSUBSCRIPT ). Vectors are columns, their transpose are rows. We denote the inner product between vectors equivalently as ğ®â‹…ğ¯=ğ®âŠºâ¢ğ¯=âˆ‘iuiâ¢viâ‹…ğ®ğ¯superscriptğ®âŠºğ¯subscriptğ‘–subscriptğ‘¢ğ‘–subscriptğ‘£ğ‘–{\mathbf{u}}\cdot{\mathbf{v}}={\mathbf{u}}^{\intercal}{\mathbf{v}}=\sum_{i}u_{% i}v_{i}bold_u â‹… bold_v = bold_u start_POSTSUPERSCRIPT âŠº end_POSTSUPERSCRIPT bold_v = âˆ‘ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_u start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT italic_v start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT. Symbol =DsuperscriptD\mathrel{\stackrel{{\scriptstyle\makebox[0.0pt]{\mbox{\tiny D}}}}{{=}}}start_RELOP SUPERSCRIPTOP start_ARG = end_ARG start_ARG D end_ARG end_RELOP means equality in law. The norm â€–ğ€â€–=(âˆ‘iâ¢jAiâ¢j2)1/2normğ€superscriptsubscriptğ‘–ğ‘—superscriptsubscriptğ´ğ‘–ğ‘—212\|{\mathbf{A}}\|=(\sum_{ij}A_{ij}^{2})^{1/2}âˆ¥ bold_A âˆ¥ = ( âˆ‘ start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT italic_A start_POSTSUBSCRIPT italic_i italic_j end_POSTSUBSCRIPT start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) start_POSTSUPERSCRIPT 1 / 2 end_POSTSUPERSCRIPT is the Frobenius norm. The limit limNâ†’âˆsubscriptâ†’ğ‘\lim_{N\to\infty}roman_lim start_POSTSUBSCRIPT italic_N â†’ âˆ end_POSTSUBSCRIPT means that both N,Mğ‘ğ‘€N,Mitalic_N , italic_M diverge with M=Î±â¢N+oNâ¢(1)ğ‘€ğ›¼ğ‘subscriptğ‘œğ‘1M=\alpha N+o_{N}(1)italic_M = italic_Î± italic_N + italic_o start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT ( 1 ) and we call it the thermodynamic limit. ğ’©â¢(m,Ïƒ2)ğ’©ğ‘šsuperscriptğœ2\mathcal{N}(m,\sigma^{2})caligraphic_N ( italic_m , italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) is the density of a Gaussian with mean mğ‘šmitalic_m and variance Ïƒ2superscriptğœ2\sigma^{2}italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT. Code repository. The Monte Carlo simulations used in this paper are accessible at the following link [64]."
https://arxiv.org/html/2411.01579v1,Flexible Coded Distributed Convolution Computing for Enhanced Fault Tolerance and Numerical Stability in Distributed CNNs,"Deploying Convolutional Neural Networks (CNNs) on resource-constrained devices necessitates efficient management of computational resources, often via distributed systems susceptible to latency from straggler nodes. This paper introduces the Flexible Coded Distributed Convolution Computing (FCDCC) framework to enhance fault tolerance and numerical stability in distributed CNNs. We extend Coded Distributed Computing (CDC) with Circulant and Rotation Matrix Embedding (CRME) which was originally proposed for matrix multiplication to high-dimensional tensor convolution. For the proposed scheme, referred to as Numerically Stable Coded Tensor Convolution (NSCTC) scheme, we also propose two new coded partitioning schemes: Adaptive-Padding Coded Partitioning (APCP) for input tensor and Kernel-Channel Coded Partitioning (KCCP) for filter tensor. These strategies enable linear decomposition of tensor convolutions and encoding them into CDC subtasks, combining model parallelism with coded redundancy for robust and efficient execution. Theoretical analysis identifies an optimal trade-off between communication and storage costs. Empirical results validate the frameworkâ€™s effectiveness in computational efficiency, fault tolerance, and scalability across various CNN architectures.","In the rapidly evolving domain of distributed machine learning, Convolutional Neural Networks (CNNs) have become fundamental due to their exceptional capabilities in image feature extraction and classification [1, 2, 3], as well as their versatility enabled by transfer learning [4, 5, 6]. A significant trend in this field, particularly relevant to Internet of Things (IoT) applications, is the shift towards edge computing, where data processing is conducted directly on edge devices [7]. This paradigm reduces dependency on cloud resources, minimizing latency [8] and enhancing data privacy [9]. Deploying CNNs in distributed systems, especially on resource-constrained devices, poses significant challenges due to intensive computational requirements, particularly within convolutional layers (ConvLs). Convolution operations represent over 90% of the Multiply-Accumulate operations (MACs) in mainstream CNN architectures[10], including AlexNet [11], VGGNet [12], GoogleNet [13] and ResNet [14], and account for more than 80% of the computational time during inference [15]. Collaborative inference across multiple devices has emerged as a viable approach to mitigate the computational burden on individual devices and enhance CNN deployment efficiency [16]. However, inference latency is often significantly impacted by slow worker nodes, commonly referred to as stragglers. These stragglers, arising from hardware heterogeneity and variable network conditions [17], can lead to performance degradation and potential failures, particularly in IoT systems where data loss rates may exceed 70% per layer [15]. Coded Distributed Computing (CDC) has been introduced to enhance computational resilience and efficiency in distributed systems. By dividing a task into mğ‘šmitalic_m subtasks and introducing redundancy through an (n,m)ğ‘›ğ‘š(n,m)( italic_n , italic_m ) error correction code (with n>mğ‘›ğ‘šn>mitalic_n > italic_m workers), CDC allows the master node to obtain the desired solution by waiting for the fastest kğ‘˜kitalic_k workers (mâ‰¤k<nğ‘šğ‘˜ğ‘›m\leq k<nitalic_m â‰¤ italic_k < italic_n), referred to as the recovery threshold, thereby significantly reducing computation time against the straggler effect. CDC has been successfully applied in Coded Matrix-Matrix Multiplication (CMMM) and other matrix multiplication-based algorithms [18, 19, 20, 21, 22, 23], due to the ease of linear decomposition of these operations. The application of CDC in distributed deep learning systems has garnered significant attention. Dutta et al. introduced a unified coded deep neural network (DNN) scheme utilizing Generalized PolyDot codes [24], which demonstrated the feasibility of deploying large DNNs on unreliable nodes prone to soft errors. Subsequent works, such as [25, 15], further integrated CDC at the model parallelism level in DNNs. However, these CMMM-based methods are not directly extensible to tensor convolutions in CNNs. Specifically, the decomposition of tensors ğ“âˆˆâ„d1Ã—â‹¯Ã—dnğ“superscriptâ„subscriptğ‘‘1â‹¯subscriptğ‘‘ğ‘›\mathbf{T}\in\mathbb{R}^{d_{1}\times\cdots\times d_{n}}bold_T âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_d start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— â‹¯ Ã— italic_d start_POSTSUBSCRIPT italic_n end_POSTSUBSCRIPT end_POSTSUPERSCRIPT for CDC subtasks introduces multiple splitting dimensions, necessitating specialized partitioning schemes. Numerical stability is also a critical concern for CDC in DNNs due to the substantial propagation depth and cumulative errors associated with deep architectures [26]. Most existing CDC schemesâ€”including Polynomial Codes [19], MatDot Codes [22], PolyDot Codes [20], and Lagrange Codes [23]â€”rely on polynomial methods that perform well over finite field, while encountering challenges in the real field. Specifically, the condition number of a real Vandermonde matrix, used in the recovery process during decoding of polynomial methods, grows exponentially with its dimension [27], exacerbating numerical instability. To address this issue, Ramamoorthy et al. enhanced numerical stability in CMMM by incorporating Circulant and Rotation Matrix Embeddings (CRME) into polynomial codes [28]. This approach exploits the well-conditioned nature of complex Vandermonde matrices with parameters on the unit circle while performing computations over the real field â„â„\mathbb{R}blackboard_R. This advancement suggests the potential for employing CRME into the real-valued applications, such as tensor convolutions in CNNs. Integrating CDC into CNNs poses significant challenges due to the complex and tightly coupled nature of ConvLs. These layers involve intricate interactions between three-dimensional input tensors (feature maps) and four-dimensional filter tensors (kernels), requiring careful management during tensor decomposition to preserve spatial continuity at the model parallelism level [29]. Existing research on CDC within this field was limited to one-dimensional vector convolutions [30, 31], which were insufficient for CNN architectures. Recent efforts, such as the Resilient, Secure, and Private Coded Convolution (RSPCC) scheme by Qiu et al. [32], have sought to broaden CDCâ€™s applicability to ConvLs by adapting the im2col-based algorithm [33], transforming tensor convolutions into matrix-vector multiplications. However, due to this specific pre-encoding transformation, RSPCC exhibits limited compatibility with alternative convolution techniques, including FFT-based methods [34], Winograd-based algorithms [35], and approximation methods [36]. Additionally, RSPCC requires each node to retain complete filter, thereby increasing storage requirement. It also relies on finite field computations, which introduce numerical stability challenges in real-valued environments [28]. Addressing these challenges is crucial for the effective deployment of CDC in large-scale distributed CNNs. New tensor block encoding and decoding strategies are required to manage high-dimensional structures, ensuring numerical stability while optimizing the trade-off between communication and storage costs [37]. This paper introduces a Flexible Coded Distributed Convolution Computing (FCDCC) framework designed specifically for ConvLs in CNNs within distributed environments. The framework enhances model parallelism through a numerically stable coded computing scheme, improving both efficiency and robustness while minimizing computational and memory requirements. The primary contributions of this work are as follows: â€¢ Numerically Stable Coded Tensor Convolution (NSCTC): We extend the CDC scheme based on Circulant and Rotation Matrix Embedding (CRME) from matrix multiplication to high-dimensional tensor convolution, by introducing a new tensor-matrix multiplication operation for encoding and decoding. This approach leverages complex Vandermonde matrices computed over the real field to achieve numerical stability, achieving a maximum mean squared error (MSE) of 10âˆ’27superscript102710^{-27}10 start_POSTSUPERSCRIPT - 27 end_POSTSUPERSCRIPT for AlexNetâ€™s ConvLs in a distributed setting with 20 worker nodes. This represents the first CDC scheme specifically designed for high-dimensional tensor operations. â€¢ Adaptive-Padding Coded Partitioning (APCP): We introduce an adaptive partitioning strategy that divides the input tensor along its spatial dimensions (height Hğ»Hitalic_H or width Wğ‘ŠWitalic_W), based on kernel size (KH,KWsubscriptğ¾ğ»subscriptğ¾ğ‘ŠK_{H},K_{W}italic_K start_POSTSUBSCRIPT italic_H end_POSTSUBSCRIPT , italic_K start_POSTSUBSCRIPT italic_W end_POSTSUBSCRIPT) and stride sğ‘ sitalic_s, with the addition of coded redundancy. This reduces communication cost and workload per node compared to single node scheme. â€¢ Kernel-Channel Coded Partitioning (KCCP): We employ a partitioning approach for the filter tensor along the output channel dimension Nğ‘Nitalic_N, generating coded partitions to enhance resilience, while also lowering storage cost and per-node workload compared to RSPCC scheme. â€¢ Framework Optimization: The FCDCC framework is then analyzed to determine optimal partitioning parameters kAsubscriptğ‘˜ğ´k_{A}italic_k start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT and kBsubscriptğ‘˜ğµk_{B}italic_k start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT, balancing communication and storage costs while maintaining a fixed number of subtasks (where kAâ¢kBsubscriptğ‘˜ğ´subscriptğ‘˜ğµk_{A}k_{B}italic_k start_POSTSUBSCRIPT italic_A end_POSTSUBSCRIPT italic_k start_POSTSUBSCRIPT italic_B end_POSTSUBSCRIPT is constant). â€¢ Generality: The framework is applicable to CNN libraries such as PyTorch and various CNN models, including LeNet, AlexNet, and VGGNet. Figure 1: The FCDCC framework demonstrating the main workflow and tensor definitions in a comprehensive 3-D representation. We assume 3 kinds of straggler problems in this diagram: Upload failures, computing failures, and download failures. The remainder of the paper is organized as follows: Section II presents the system model, Section III introduces the NSCTC scheme, Section IV describes the FCDCC framework and cost optimization, Section V provides theoretical analysis and complexity evaluation, Section VI offers experimental validation, and Section VII concludes with future research directions. Notations: The imaginary unit is denoted by i=âˆ’1i1\mathrm{i}=\sqrt{-1}roman_i = square-root start_ARG - 1 end_ARG. The set of integers modulo mğ‘šmitalic_m is represented by ğ’µm={0,1,â€¦,mâˆ’1}subscriptğ’µğ‘š01â€¦ğ‘š1\mathcal{Z}_{m}=\{0,1,\ldots,m-1\}caligraphic_Z start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT = { 0 , 1 , â€¦ , italic_m - 1 }, and the cardinality of a finite set â„â„\mathcal{I}caligraphic_I is denoted by |â„|â„|\mathcal{I}|| caligraphic_I |. We employ various matrix and tensor operations, including the Kronecker product (âŠ—tensor-product\otimesâŠ—) and tensor convolution (âˆ—*âˆ—). For a matrix ğŒğŒ\mathbf{M}bold_M, ğŒâ¢(i,j)ğŒğ‘–ğ‘—\mathbf{M}(i,j)bold_M ( italic_i , italic_j ) denotes its (i,j)ğ‘–ğ‘—(i,j)( italic_i , italic_j )-th entry; ğŒi,jsubscriptğŒğ‘–ğ‘—\mathbf{M}_{i,j}bold_M start_POSTSUBSCRIPT italic_i , italic_j end_POSTSUBSCRIPT represents its (i,j)ğ‘–ğ‘—(i,j)( italic_i , italic_j )-th block sub-matrix; and ğŒisubscriptğŒğ‘–\mathbf{M}_{i}bold_M start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT denotes its iğ‘–iitalic_i-th column block sub-matrix. For a tensor ğ“âˆˆâ„N1Ã—N2Ã—N3ğ“superscriptâ„subscriptğ‘1subscriptğ‘2subscriptğ‘3\mathbf{T}\in\mathbb{R}^{N_{1}\times N_{2}\times N_{3}}bold_T âˆˆ blackboard_R start_POSTSUPERSCRIPT italic_N start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT Ã— italic_N start_POSTSUBSCRIPT 3 end_POSTSUBSCRIPT end_POSTSUPERSCRIPT, (ğ“)i,j,ksubscriptğ“ğ‘–ğ‘—ğ‘˜(\mathbf{T})_{i,j,k}( bold_T ) start_POSTSUBSCRIPT italic_i , italic_j , italic_k end_POSTSUBSCRIPT (or ti,j,ksubscriptğ‘¡ğ‘–ğ‘—ğ‘˜t_{i,j,k}italic_t start_POSTSUBSCRIPT italic_i , italic_j , italic_k end_POSTSUBSCRIPT) refers to its (i,j,k)ğ‘–ğ‘—ğ‘˜(i,j,k)( italic_i , italic_j , italic_k )-th entry; similar notation applies to higher-dimensional tensors. We denote a 1Ã—Uk1subscriptğ‘ˆğ‘˜1\times U_{k}1 Ã— italic_U start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT tensor block list as ğ“â€²=[ğ“0â€²,ğ“1â€²,â€¦,ğ“Ukâˆ’1â€²]superscriptğ“â€²subscriptsuperscriptğ“â€²0subscriptsuperscriptğ“â€²1â€¦subscriptsuperscriptğ“â€²subscriptğ‘ˆğ‘˜1\mathbf{T}^{\prime}=[\mathbf{T}^{\prime}_{0},\,\mathbf{T}^{\prime}_{1},\,% \ldots,\,\mathbf{T}^{\prime}_{U_{k}-1}]bold_T start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT = [ bold_T start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , bold_T start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , bold_T start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_U start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT - 1 end_POSTSUBSCRIPT ] or {ğ“iâ€²}i=0Ukâˆ’1superscriptsubscriptsubscriptsuperscriptğ“â€²ğ‘–ğ‘–0subscriptğ‘ˆğ‘˜1\{\mathbf{T}^{\prime}_{i}\}_{i=0}^{U_{k}-1}{ bold_T start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT } start_POSTSUBSCRIPT italic_i = 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_U start_POSTSUBSCRIPT italic_k end_POSTSUBSCRIPT - 1 end_POSTSUPERSCRIPT, where each tensor block ğ“iâ€²subscriptsuperscriptğ“â€²ğ‘–\mathbf{T}^{\prime}_{i}bold_T start_POSTSUPERSCRIPT â€² end_POSTSUPERSCRIPT start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT has identical dimensions."
https://arxiv.org/html/2411.01244v1,Precoded Faster-than-Nyquist Signaling Using Optimal Power Allocation for OTFS,"A precoded orthogonal time frequency space (OTFS) modulation scheme relying on faster-than-Nyquist (FTN) transmission over doubly selective fading channels is proposed, which enhances the spectral efficiency and improves the Doppler resilience. We derive the input-output relationship of the FTN signaling in the delay-Doppler domain. Eigenvalue decomposition (EVD) is used for eliminating both the effects of inter-symbol interference and correlated additive noise encountered in the delay-Doppler domain to enable efficient symbol-by-symbol demodulation. Furthermore, the power allocation coefficients of individual frames are optimized for maximizing the mutual information under the constraint of the derived total transmit power. Our performance results demonstrate that the proposed FTN-based OTFS scheme can enhance the information rate while achieving a comparable BER performance to that of its conventional Nyquist-based OTFS counterpart that employs the same root-raised-cosine shaping filter.","Traditional wireless technologies, such as orthogonal frequency-division multiplexing (OFDM), typically struggle to cope with high Doppler shifts in high-mobility scenarios. In order to overcome this limitation, orthogonal time frequency space (OTFS) modulation [1] was proposed, which modulates data symbols in the delay-Doppler (DD) domain and allows a sparse and quasi-static channel representation. Several studies [2, 3, 4] considered the OFDM-based OTFS (OFDM-OTFS) architecture, where a cyclic prefix (CP) is inserted in each frame, while employing an ideal rectangular pulse shaping filter that satisfies bi-orthogonality in the time and frequency domains [1]. By contrast, the input-output relationship of OTFS using a non-rectangular pulse shaping filter was derived in [5]. The symbol interval of faster-than-Nyquist (FTN) signaling is designed to be lower than that given by the Nyquist criterion. Hence, FTN signaling allows us to boost the transmission rate without increasing the bandwidth requirement, albeit at the cost of producing inevitable inter-symbol interference (ISI) at the receiver, as detailed in [6]. Several precoded FTN schemes were proposed for mitigating the impairments encountered [7, 8, 9, 10]. In [7], precoding-aided FTN signaling based on the eigenvalue decomposition (EVD) of an FTN-specific ISI matrix was proposed. In [8], EVD-precoded FTN signaling relying on optimal power allocation (PA) was developed to improve the information rate. In [9], the EVD-precoded FTN signaling scheme of [8] was extended to that applicable to generalized frequency-selective fading channels. In [10], fast Fourier transform (FFT)-spread multi-carrier FTN (MFTN) signaling was proposed by relying on the circulant approximation of the FTN-specific ISI matrix and the noise covariance matrix. Additionally, several studies discussed data detection [11, 12, 13] and channel estimation [14, 15] for FTN signaling transmission over doubly selective fading channels to improve the robustness to the Doppler shift. However, all previous OTFS studies assumed that the transmitted signal obeys the time-orthogonal Nyquist criterion, similar to conventional signaling. Moreover, none of the above FTN signaling schemes have been designed to mitigate doubly selective fading in the DD domain. Against the above background, the novel contributions of this paper are as follows. â€¢ For the first time in literature, we propose an EVD-precoded OTFS-based FTN (OTFS-FTN) architecture for doubly selective fading channels. We will demonstrate that the proposed OTFS-FTN scheme exhibits robustness to high Doppler shifts, while enhancing the spectral efficiency as a benefit of the reduced FTN symbol interval. We derive the input-output relationship between the transmitted and received symbols of the proposed OTFS-FTN scheme employing a root-raised-cosine (RRC) pulse shaping filter in the DD domain. Furthermore, both the effects of FTN-specific ISI and of the correlated noise are eliminated with the aid of EVD-based diagonalization in the DD domain, hence allowing efficient symbol-by-symbol demodulation at the receiver. â€¢ As an additional contribution, we derive the mutual information (MI) characterizing the proposed scheme and then design the PA to maximize the MI for transmission over doubly selective fading channels. â€¢ Our simulation results will demonstrate that the proposed OTFS-FTN scheme achieves a higher information rate and better BER performance than its conventional time-orthogonal signaling counterpart using the same RRC shaping filter."
https://arxiv.org/html/2411.00374v2,"RSRP Measurement Based Channel Autocorrelation Estimation for IRS-Aided Wideband Communicationâ€ â€ thanks:This work has been submitted to the IEEE for possible publication. Copyright may be transferred without notice, after which this version may no longer be accessible.","The passive and frequency-flat reflection of IRS, as well as the high-dimensional IRS-reflected channels, have posed significant challenges for efficient IRS channel estimation, especially in wideband communication systems with significant multi-path channel delay spread. To address these challenges, we propose a novel neural network (NN)-empowered framework for IRS channel autocorrelation matrix estimation in wideband orthogonal frequency division multiplexing (OFDM) systems. This framework relies only on the easily accessible reference signal received power (RSRP) measurements at users in existing wideband communication systems, without requiring additional pilot transmission. Based on the estimates of channel autocorrelation matrix, the passive reflection of IRS is optimized to maximize the average user received signal-to-noise ratio (SNR) over all subcarriers in the OFDM system. Numerical results verify that the proposed algorithm significantly outperforms existing power-measurement-based IRS reflection designs in wideband channels.","Intelligent reflecting surfaces (IRSs) have developed as a promising technology for creating cost-effective and adaptable wireless communication environments [1]. An IRS typically consists of a planar array of numerous quasi-passive, low-cost reflective elements that can tune the phase shifts and amplitudes of incoming signals. To effectively harness the potential benefits of IRS for channel reconfiguration, IRS passive reflection/beamforming should be properly designed[1, 2]. Most of the existing IRS passive reflection designs require channel state information (CSI) or dedicated pilot training. For example, the IRS channels are estimated explicitly or implicitly by exploiting the received complex-valued pilots for IRS reflection optimization[1, 2, 3, 4]. However, the pilot signals in existing communication systems (e.g., cellular or WiFi) are designed only for estimating the base station (BS)-user direct channels, with no additional resources allocated for IRS-related channel estimation. As a result, pilot-based IRS channel estimation and reflection pattern optimization would require substantial modifications to current communication protocols, posing significant challenges for practical implementation. Figure 1: An IRS-assisted wideband OFDM system. To enable seamless integration of IRS into existing wireless communication systems, recent studies [5, 6] have explored practical IRS reflection designs by leveraging usersâ€™ received signal (pilot/data) power measurements readily available in current communication systems, which are thus compatible with current cellular/WiFi protocols. It was shown that the conditional sample mean (CSM) method [5], with a sufficiently large number of reference signal received power (RSRP) measurement samples, can achieve the same signal-to-noise ratio (SNR) scaling order as under perfect CSI. However, CSM generally requires substantial power measurements due to the absence of channel recovery from power measurements. To address this, the authors in [6] introduced channel recovery methods for power-measurement-based IRS reflection design. These studies, however, focus only on frequency-flat narrowband systems, leaving the more complex frequency-selective wideband channels unexplored. In wideband systems, IRS channel recovery is more challenging due to the increased channel coefficients caused by multi-path delay spread and their more intricate effects on RSRP measurements. To tackle the above challenges, we propose a user power-/RSRP-measurement-based IRS channel estimation and reflection design framework for the wideband orthogonal frequency division multiplexing (OFDM) wireless system, as shown in Fig. 1. First, we derived the userâ€™s average received signal power over all OFDM subcarriers in terms of the IRS channel autocorrelation matrix for the IRS-cascaded wideband channel, showing that it could be efficiently recovered based on the userâ€™s RSRP measurements over only a subset of subcarriers. To estimate this wideband channel autocorrelation matrix, we propose a single-layer neural network (NN)-enabled method utilizing the userâ€™s RSRP measurements. In particular, we reveal that under any given IRS passive reflection, the RSRP can be expressed as the output of a NN, which is the sum of the outputs of multiple single-layer subnetworks. Thus, the channel autocorrelation matrix can be recovered from the weights of the subnetworks trained via supervised learning. With the estimated channel autocorrelation matrix, the passive reflection coefficients of IRS are then optimized for maximizing the average received SNR over all OFDM subcarriers. Extensive simulation results verify that our proposed methods can outperform other benchmark schemes under wideband channels with significantly reduced power-measurement overhead and approach the average SNR upper bound assuming perfect CSI. Notations: ğ‘°Msubscriptğ‘°ğ‘€\boldsymbol{I}_{M}bold_italic_I start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT stands for the identity matrix of size MÃ—Mğ‘€ğ‘€M\times Mitalic_M Ã— italic_M, and 0Msubscript0ğ‘€\textbf{0}_{M}0 start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT denotes an all-zero vector of dimension Mğ‘€Mitalic_M. â„‚nÃ—msuperscriptâ„‚ğ‘›ğ‘š\mathbb{C}^{n\times m}blackboard_C start_POSTSUPERSCRIPT italic_n Ã— italic_m end_POSTSUPERSCRIPT and â„nÃ—msuperscriptâ„ğ‘›ğ‘š\mathbb{R}^{n\times m}blackboard_R start_POSTSUPERSCRIPT italic_n Ã— italic_m end_POSTSUPERSCRIPT stand for the sets of the complex-valued and the real-valued matrices with size of nÃ—mğ‘›ğ‘šn\times mitalic_n Ã— italic_m, respectively. â„•â„•\mathbb{N}blackboard_N stands for the set of nonnegative integers. |â‹…|\left|\cdot\right|| â‹… | represents the cardinality of a set or the absolute value of a complex scalar. âˆ¥â‹…âˆ¥\left\|\cdot\right\|âˆ¥ â‹… âˆ¥ stands for the Euclidean norm of a vector, and âˆ¥â‹…âˆ¥F\left\|\cdot\right\|_{F}âˆ¥ â‹… âˆ¥ start_POSTSUBSCRIPT italic_F end_POSTSUBSCRIPT represents the Frobenius norm of a matrix. â„œâ¡(â‹…)â‹…\Re\left(\cdot\right)roman_â„œ ( â‹… ) and â„‘â¡(â‹…)â‹…\Im\left(\cdot\right)roman_â„‘ ( â‹… ) stand for the real part and the imaginary part of a complex-valued number/vector, respectively. È·=âˆ’1italic-È·1\jmath=\sqrt{-1}italic_È· = square-root start_ARG - 1 end_ARG denotes the imaginary unit. ğ’â¢ğ’©â¢(ğŸM,Ïƒ2â¢ğ‘°M)ğ’ğ’©subscript0ğ‘€superscriptğœ2subscriptğ‘°ğ‘€{\cal CN}{\left(\boldsymbol{0}_{M},\sigma^{2}\boldsymbol{I}_{M}\right)}caligraphic_C caligraphic_N ( bold_0 start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT , italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT bold_italic_I start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT ) stands for the distribution of a circularly symmetric complex Gaussian (CSCG) random vector that has mean ğŸMsubscript0ğ‘€\boldsymbol{0}_{M}bold_0 start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT and covariance Ïƒ2â¢ğ‘°Msuperscriptğœ2subscriptğ‘°ğ‘€\sigma^{2}\boldsymbol{I}_{M}italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT bold_italic_I start_POSTSUBSCRIPT italic_M end_POSTSUBSCRIPT. For a vector/matrix, (â‹…)Tsuperscriptâ‹…ğ‘‡\left(\cdot\right)^{T}( â‹… ) start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT and (â‹…)Hsuperscriptâ‹…ğ»\left(\cdot\right)^{H}( â‹… ) start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT represent its transpose and its conjugate transpose, respectively. rankâ¢(â‹…)rankâ‹…\text{rank}(\cdot)rank ( â‹… ) computes the rank of a matrix, and Trâ¢(â‹…)Trâ‹…\text{Tr}(\cdot)Tr ( â‹… ) returns the trace of a square matrix. ğ‘¹âª°0succeeds-or-equalsğ‘¹0\boldsymbol{R}\succeq 0bold_italic_R âª° 0 indicates that ğ‘¹ğ‘¹\boldsymbol{R}bold_italic_R is positive semi-definite (PSD). diagâ¢(ğ’™)diagğ’™\text{diag}\left(\boldsymbol{x}\right)diag ( bold_italic_x ) denotes a square diagonal matrix with vector ğ’™ğ’™\boldsymbol{x}bold_italic_x denoting the entries on its main diagonal. ğ”¼â¢[â‹…]ğ”¼delimited-[]â‹…\mathbb{E}\left[\cdot\right]blackboard_E [ â‹… ] represents the expectation of a random variable/vector."
https://arxiv.org/html/2411.00373v1,Discrete RIS Enhanced Space Shift Keying MIMO System via Reflecting Beamforming Optimization,"In this paper, a discrete reconfigurable intelligent surface (RIS)-assisted spatial shift keying (SSK) multiple-input multiple-output (MIMO) scheme is investigated, in which a direct link between the transmitter and the receiver is considered. To improve the reliability of the RIS-SSK-MIMO scheme, we formulate an objective function based on minimizing the average bit error probability (ABEP). Since the reflecting phase shift of RIS is discrete, it is difficult to address this problem directly. To this end, we optimize the RIS phase shift to maximize the Euclidean distance between the minimum constellations by applying the successive convex approximation (SCA) and penalty-alternating optimization method. Simulation results verify the superiority of the proposed RIS-SSK-MIMO scheme and demonstrate the impact of the number of RIS elements, the number of phase quantization bits, and the number of receive and transmit antennas in terms of reliability.","To meet the growing communication demands, conventional multiple-input multiple-output (MIMO) technique is adopted, which can improve system effectiveness and reliability by utilizing space-time resources for multiplexing and diversity [1]. However, MIMO has drawbacks like high complexity, cost and power consumption[2]. In response, reconfigurable intelligent surface (RIS), a planar structure of numerous low-cost and low-power reflective elements that can control wireless signal propagation by adjusting their phase and amplitude, has attracted wide attention for its unique advantages such as enhancing spectrum utilization efficiency, reducing power consumption and offering high flexibility [3]. Meanwhile, spatial modulation (SM) [4, 5], which uses transmit antenna indices to transmit information and improve spectral efficiency and reduce system complexity, and spatial shift keying (SSK), which transmits information only by activating different transmit antenna positions and provides new ideas for wireless communication development, are other solutions to address insufficient spectrum[6]. Inspired by the advantages of RIS, [7] investigated the RIS-assisted SSK system. It presents a mathematical framework and provides simulation results, indicating that the scheme enables highly reliable transmission with high energy efficiency. Besides, [8] studied RIS-assisted SSK modulation and reflection phase modulation scheme where RIS embeds information in reflection phase shift. To improve the spectral efficiency, [9] and [10] studied the full-duplex SSK system based on RIS, and investigated the cases of perfect and imperfect channel state information (CSI), respectively. It is worth noting that the RIS-assisted SSK technique in [7, 8, 9, 10] is implemented at the transmit end. In contrast, the RIS-assisted SSK technology in [11, 14, 12, 13] is implemented at the receive end. To be specific, [11] designed a RIS-assisted generalized space-shift keying (GSSK) based antennas selection scheme where GSSK works at receiver and RIS elements are adjusted for antennas selection to maximize signal-to-noise ratio (SNR). Moreover, [12] proposed two RIS-based SSK schemes, RIS-SSK passive beamforming which employs RIS for beamforming to maximize minimum squared Euclidean distance and RIS-SSK Alamouti space-time block coding which employs RIS for ASTBC and transmits its own Alamouti-coded information while reflecting SSK signals. Additionally, [13] enhances wireless communication systems with RIS by introducing RIS-assisted receive GSSK. Furthermore, [14] investigated RIS-receive quadrature SSK to enhance spectral efficiency via independent use of real and imaginary dimensions. By using low-complexity greedy detector, a max-min optimization for SNR is performed. The above work is to align all the reflected phase shifts of RIS with a single target antenna, obtain the composite channel distribution, and then derive the closed-form ABEP. However, in the RIS-assisted SSK-MIMO system, RIS cannot eliminate the phase of multiple antennas in the receive array, so the previous method is no longer applicable. Against this background, we study a RIS-SSK-MIMO system model that considers discrete RIS phase shift. Then, we formulate an optimization problem to minimize the average bit error probability (ABEP) by designing the reflecting coefficients of the RIS. To simplify the problem, we convert it into a problem of maximizing the minimum constellation point Euclidean distance subject to the discrete phase shift of RIS. To tackle this issue, we adopt successive convex approximation (SCA) and penalty-alternative method to get a suboptimal solution. Lastly, simulation results show that the proposed RIS-SSK-MIMO outperforms the benchmarks in term of ABEP."
https://arxiv.org/html/2411.00344v1,Energy Efficiency Analysis of IRS-aided Wireless Communication Systems Under Statistical QoS Constraints: An Information-Theoretic Perspective,"This paper investigates the information-theoretic energy efficiency of intelligent reflecting surface (IRS)-aided wireless communication systems, taking into account the statistical quality-of-service (QoS) constraints on delay violation probabilities. Specifically, effective capacity is adopted to capture the maximum constant arrival rate that can be supported by a time-varying service process while fulfilling these statistical QoS requirements. We derive the minimum bit energy required for the IRS-aided wireless communication system under QoS constraints and analyze the spectral efficiency and energy efficiency tradeoff at low but nonzero signal-to-noise ratio (SNR) levels by also characterizing the wideband slope values. Our analysis demonstrates that the energy efficiency for the considered system under statistical QoS constraints can approach that for a system without QoS limitations in the low-SNR regime. Additionally, deploying a sufficiently large number of practical IRS reflecting elements can substantially reduce energy consumption required to achieve desired spectral efficiency performance in the low-power regime, even with limited bit-resolution phase shifters. Besides, we reveal that compared with the results applied to the low-power regime, higher effective capacity performance can be achieved in scenarios with sparse multipath fading while achieving the same minimum bit energy in the wideband regime.","There are two fundamental considerations for designing future wireless communication systems: the scarcity of energy resources and the random variability of propagation channels [1]. On the one hand, wireless communication systems are expected to provide high data rates and reliable transmissions at low energy costs, leading to extensive research focused on energy-efficient system designs over the past few decades, e.g., [2, 3, 4]. On the other hand, guaranteeing deterministic quality-of-service (QoS) proves highly challenging due to the time-varying and stochastic natures of wireless channels caused by mobility, multipath fading, and changing environments [5]. In general, improving energy efficiency while satisfying statistical QoS constraints is of vital importance for achieving optimal system performance and quality [6]. Recently, intelligent reflecting surface (IRS) has been extensively recognized as a promising technique to improve system energy efficiency by flexibly establishing a favorable communication environment [7]. In particular, an IRS equipped with various reconfigurable and low-cost passive elements that can reflect desired signals by appropriately altering controllable phase shifts [8]. By properly designing the IRS phase shift matrix, desired signals transmitted in the direct path can be constructively combined with the reflected signals to achieve substantial power gains at the targeted receivers [9]. In fact, there have been numerous studies investigating energy-efficient designs of IRS-aided wireless communication systems, e.g., [10, 11, 12]. However, these works only capture performance of classical Shannon capacity in the physical layer assuming infinite backlog, overlooking statistical QoS limitations attributed to queue length violation and buffer overflow probabilities in the data-link layer [13]. As a result, these studies are not applicable to emerging wireless communication systems with delay-sensitive applications [14], such as automatic driving, extended reality, and factory automation, etc. It is widely recognized that effective capacity [13] serves as an efficient metric to measure cross-layer performance in wireless communication systems, particularly under the influence of statistical QoS constraints. Specifically, effective capacity captures the maximum constant arrival rate that a time-varying service process can sustain while fulfilling a statistical QoS requirement, i.e., buffer overflow probability or delay violation probability [15]. It is noteworthy that there have been a few literatures studying the energy-efficient IRS-aided wireless communication systems by exploiting effective capacity formulation, e.g., [16, 17, 18]. Nonetheless, these researches merely focus on the effective rate-per-Joule as an energy efficiency metric that cannot provide the fundamental performance limits and identify the most efficient utilization of scarce energy resources [19]. From an information-theoretic perspective, the energy required for reliably transmitting one bit of information, commonly referred to as bit energy, has been extensively adopted to evaluate the energy efficiency performances of wireless communication systems [19, 20, 21]. In particular, when a system operates at low signal-to-noise ratio (SNR) levels, e.g., in the low-power or wideband regimes, minimizing bit energy is equivalent to maximizing energy efficiency [19, 20, 21]. Based on the theory, there have been numerous literatures evaluating the energy-efficient wireless communication systems under statistical QoS limitations. For example, the authors analyzed the energy efficiencies at low-SNR levels for simple-input simple-output (SISO) [20] and multi-input multi-output (MIMO) [21] wireless communication systems under statistical QoS constraints. Also, the tradeoff between normalized effective capacity and bit energy in the low-power or wideband regimes by characterizing the wideband slope values was investigated in [22], which unveiled the impact of statistical QoS constraints on energy efficiency performance. These analytical insights facilitate the determination of the energy required to achieve specific spectral efficiency in the existence of statistical QoS limitations, which is desired for designing practical IRS-aided wireless communication systems, whereas the relevant research is still in its infancy. Additionally, it remains unclear whether IRS implementation is beneficial for significantly improving the system performance without incurring excessive energy costs, particularly due to potential spectral efficiency degradation caused by strict QoS constraints. Hence, there is a crucial need to study the tradeoff between spectral efficiency and energy efficiency for IRS-aided wireless communication systems under statistical QoS constraints in the low-power or wideband regimes. Motivated by the above observations, we analyze the energy efficiency performance of an IRS-aided wireless communication system taking into account statistical QoS constraints from the information-theoretic perspective. The main contributions of our paper are summarized below: â€¢ We derive the expression for the minimum bit energy in the low-power and wideband regimes for the IRS-aided wireless communication system, considering the existence of statistical QoS constraints. Also, we demonstrate that the energy efficiency for the considered system can approach that of a system without statistical QoS limitations at low but nonzero SNR levels. â€¢ To shed light on the effectiveness of IRS in optimizing energy efficiency, we further approximate the results acquired in the low-power regime under specific scenarios where a sufficiently large number of IRS reflecting elements are implemented with continuous and discrete phase shifts. Moreover, we demonstrate that deploying a sufficiently large number of the practical IRS reflecting elements can substantially reduce the energy consumption need to achieve the required spectral efficiency performance at low but nonzero SNR levels, even with limited bit-resolution phase shifters. â€¢ We reveal that the results acquired in the low-power regime are also applicable to scenarios with rich multipath fading in the wideband regime. Furthermore, under the assumption of employing an infinite large number of IRS reflecting elements, compared to the low-power regime, higher effective capacity performance can be achieved in scenarios characterized by sparse multipath fading where the number of the independent resolvable subchannels is bounded while satisfying the same minimum bit energy requirement in the wideband regime. â€¢ We prove that the expression for the minimum bit energy in scenarios with rich multipath fading is identical to that for scenarios with sparse multipath fading, where the number of subchannels grows sublinearly with the increasing bandwidth. Besides, we unveil that the energy efficiency performance of the considered system without the multipath sparsity can approach that for a system in sparse multipath fading without QoS limitations. We organize the rest of the paper as follows. Specifically, we first introduce preliminaries including system model, effective capacity, and spectral efficiency-energy efficiency tradeoff in Section II. Then, Sections III and IV present the energy efficiency in the low-power and wideband regimes, respectively. In Sections V and VI, we present the simulation results that valid our theoretical findings and conclude the paper. Notations: Î“â¢(x)=âˆ«0âˆtxâˆ’1â¢expâ¢(âˆ’t)â¢dtÎ“ğ‘¥superscriptsubscript0superscriptğ‘¡ğ‘¥1expğ‘¡differential-dğ‘¡\Gamma\left(x\right)=\int\nolimits_{0}^{\infty}t^{x-1}{\mathrm{exp}}({-t}){% \mathrm{d}}troman_Î“ ( italic_x ) = âˆ« start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT âˆ end_POSTSUPERSCRIPT italic_t start_POSTSUPERSCRIPT italic_x - 1 end_POSTSUPERSCRIPT roman_exp ( - italic_t ) roman_d italic_t denotes the Gamma function for any x>0ğ‘¥0x>0italic_x > 0. â„‚mÃ—nsuperscriptâ„‚ğ‘šğ‘›{\mathbb{C}^{m\times n}}blackboard_C start_POSTSUPERSCRIPT italic_m Ã— italic_n end_POSTSUPERSCRIPT represents the set of an mÃ—nğ‘šğ‘›m\times nitalic_m Ã— italic_n complex-valued matrix, while â„+superscriptâ„{\mathbb{R}}^{+}blackboard_R start_POSTSUPERSCRIPT + end_POSTSUPERSCRIPT indicates a positive real-valued scalar. È·=âˆ’1italic-È·1\jmath=\sqrt{-1}italic_È· = square-root start_ARG - 1 end_ARG denotes an imaginary unit. ğ”¼â¢{â‹…}ğ”¼â‹…\mathbb{E}\left\{\cdot\right\}blackboard_E { â‹… }, Prâ¢{â‹…}Prâ‹…\mathrm{Pr}\left\{\cdot\right\}roman_Pr { â‹… }, expâ¢(â‹…)expâ‹…{\mathrm{exp}}\left(\cdot\right)roman_exp ( â‹… ), |â‹…|\left|\cdot\right|| â‹… |, (â‹…)âˆ’1superscriptâ‹…1{\left(\cdot\right)^{-1}}( â‹… ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT, (â‹…)Tsuperscriptâ‹…ğ‘‡{\left(\cdot\right)^{T}}( â‹… ) start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT, (â‹…)Hsuperscriptâ‹…ğ»{\left(\cdot\right)^{H}}( â‹… ) start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT, and (â‹…)âˆ—superscriptâ‹…{\left(\cdot\right)^{*}}( â‹… ) start_POSTSUPERSCRIPT âˆ— end_POSTSUPERSCRIPT denote statistical expectation, occurrence probability of an event, exponential, absolute value, inverse, transpose, conjugate transpose, and conjugate of a input, respectively. y=oâ¢(x)ğ‘¦ğ‘œğ‘¥y=o(x)italic_y = italic_o ( italic_x ) means limyâ†’0,xâ†’0y/x=0subscriptformulae-sequenceâ†’ğ‘¦0â†’ğ‘¥0ğ‘¦ğ‘¥0\lim\nolimits_{y\rightarrow 0,x\rightarrow 0}y/x=0roman_lim start_POSTSUBSCRIPT italic_y â†’ 0 , italic_x â†’ 0 end_POSTSUBSCRIPT italic_y / italic_x = 0. diagâ¢(ğ±)diagğ±{\mathrm{diag}}\left({\mathbf{x}}\right)roman_diag ( bold_x ) represents a diagonal matrix whose main diagonal elements are the associated elements in vector ğ±ğ±{\mathbf{x}}bold_x. â‰œâ‰œ\triangleqâ‰œ and âˆ¼similar-to\simâˆ¼ stand for â€œdefined asâ€ and â€œdistributed asâ€, respectively. Nakagamiâ¢(Î±,Î²)Nakagamiğ›¼ğ›½\mathrm{Nakagami}(\alpha,\beta)roman_Nakagami ( italic_Î± , italic_Î² ) and Gammaâ¢(Î±,Î²)Gammağ›¼ğ›½\mathrm{Gamma}(\alpha,\beta)roman_Gamma ( italic_Î± , italic_Î² ) denote the Nakagami and Gamma distributions, respectively, where Î±ğ›¼\alphaitalic_Î± and Î²ğ›½\betaitalic_Î² are the corresponding shape and scaling parameters."
https://arxiv.org/html/2411.00721v1,New classes of reversible cellular automata,"A Boolean function fğ‘“fitalic_f on kğ‘˜kitalic_k bits induces a shift-invariant vectorial Boolean function Fğ¹Fitalic_F from nğ‘›nitalic_n bits to nğ‘›nitalic_n bits for every nâ‰¥kğ‘›ğ‘˜n\geq kitalic_n â‰¥ italic_k. If Fğ¹Fitalic_F is bijective for every nğ‘›nitalic_n, we say that fğ‘“fitalic_f is a proper lifting, and it is known that proper liftings are exactly those functions that arise as local rules of reversible cellular automata. We construct new families of such liftings for arbitrary large kğ‘˜kitalic_k and discuss whether all have been identified for kâ‰¤6ğ‘˜6k\leq 6italic_k â‰¤ 6.","Shift-invariant functions are integral to symmetric cryptography, especially for lightweight cryptography, particularly in designing substitution boxes (S-boxes) for block ciphers and hash functions. These functions, and also connections to their associated cellular automata, which have a broad range of applications, have been studied by several authors, see e.g., [4] for a survey. Any shift-invariant function on nğ‘›nitalic_n-bits is derived by a local rule, that is, a Boolean function on kğ‘˜kitalic_k-bits for some kâ‰¤nğ‘˜ğ‘›k\leq nitalic_k â‰¤ italic_n. Conversely, every Boolean function f:ğ”½2kâ†’ğ”½2:ğ‘“â†’superscriptsubscriptğ”½2ğ‘˜subscriptğ”½2f\colon\mathbb{F}_{2}^{k}\to\mathbb{F}_{2}italic_f : blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_k end_POSTSUPERSCRIPT â†’ blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT induces a shift-invariant function F:ğ”½2nâ†’ğ”½2n:ğ¹â†’superscriptsubscriptğ”½2ğ‘›superscriptsubscriptğ”½2ğ‘›F\colon\mathbb{F}_{2}^{n}\to\mathbb{F}_{2}^{n}italic_F : blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT â†’ blackboard_F start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT for every nâ‰¥kğ‘›ğ‘˜n\geq kitalic_n â‰¥ italic_k. If for every such nğ‘›nitalic_n the induced map Fğ¹Fitalic_F is bijective, then fğ‘“fitalic_f is called a proper lifting, and the corresponding cellular automaton is reversible. This work constructs and classifies new families of proper liftings, thus advancing the understanding of reversible cellular automata, and evaluate their resistance to differential cryptanalysis. In Section 1, we describe a new way of produce proper liftings through composition of landscape functions, generalizing existing constructions coming from sets of landscapes, see e.g., [1]. In Section 2, we study in detail the case k=6ğ‘˜6k=6italic_k = 6, and analyze whether these families are exhaustive. Finally, in Section 4, we present a few other constructions of families of proper liftings."
https://arxiv.org/html/2411.00522v1,Analyzing Multimodal Integration in the Variational Autoencoder from an Information-Theoretic Perspective,"Human perception is inherently multimodal. We integrate, for instance, visual, proprioceptive and tactile information into one experience. Hence, multimodal learning is of importance for building robotic systems that aim at robustly interacting with the real world. One potential model that has been proposed for multimodal integration is the multimodal variational autoencoder. A variational autoencoder (VAE) consists of two networks, an encoder that maps the data to a stochastic latent space and a decoder that reconstruct this data from an element of this latent space. The multimodal VAE integrates inputs from different modalities at two points in time in the latent space and can thereby be used as a controller for a robotic agent. Here we use this architecture and introduce information-theoretic measures in order to analyze how important the integration of the different modalities are for the reconstruction of the input data. Therefore we calculate two different types of measures, the first type is called single modality error and assesses how important the information from a single modality is for the reconstruction of this modality or all modalities. Secondly, the measures named loss of precision calculate the impact that missing information from only one modality has on the reconstruction of this modality or the whole vector. The VAE is trained via the evidence lower bound, which can be written as a sum of two different terms, namely the reconstruction and the latent loss. The impact of the latent loss can be weighted via an additional variable, which has been introduced to combat posterior collapse. Here we train networks with four different weighting schedules and analyze them with respect to their capabilities for multimodal integration.","1 INTRODUCTION Multimodal integration is the combination of different modalities, such as visual, auditory and olfactory. This is crucial for human perception since it increases its precision. The integration of the different modalities also plays an important role in the development of a sensorimotor representation of the body, also called a body schema. This has been identified as one important aspect in the development of a human minimal self, see, for instance, [georgie2019interdisciplinary]. In order to develop robots that are able to interact in the real world we would need to equip them with a robust sensorimotor representation of their body. In [Nguyen2021] the authors identify a representation of multimodal sensorimotor contingencies as a critical component of a robotic self. There are various approaches to multimodal learning, which we discuss briefly in the next section. In this article we focus on the multimodal variational autoencoder, introduced in [zambelli2020multimodal]. This architecture is well suited for multimodal integration since there the different modalities are first encoded by independent networks and then they are combined in one latent space. In this latent space a truly multimodal representation of the agentâ€™s input modalities can be learned. In this work we define four different measures with which this integration can be analyzed in detail. This could be used to identify the primary sense of model, detect whether one or multiple modalities are informative for a certain task or guide the learning of a robot to resemble the phases of human development. During the early stages of human live the importance of the different modalities change, for example, it has been suggested that touch and smell are highly important senses during early infancy, [BIGELOW2020101494, olfactory]. Additionally, we use the measures to analyze the integration capacities of different weighting schedules of the latent loss in the evidence lower bound. An introduction to the VAE and the ELBO is given in Section 2.1. We then discuss the architecture of the multimodal VAE and the specific experiment and training model of [zambelli2020multimodal] in Section 2.2. The different information-theoretic measures are introduced in Section 2.3 and we present the results in Section 3. 1.1 Related Work 1.1.1 Multimodal Computational Models There are various approaches to implement multimodal integration. Here we only provide a brief introduction to this field. One survey with a thorough taxonomy of the multimodal learning approach is given in [Baltruaitis2017MultimodalML]. The authors there do not focus on sensory modalities, but on natural language, visual signals and vocal signals. They suggest a differentiation between coordinated and joint multimodal representations, where the modalities of joint representations are projected to the same space, while modalities in coordinated models exist in their own spaces and are coordinated through similarities. One problem that arises for these model is that they potentially have to deal with very high dimensional data, like the whole visual field. Hence, the authors of [Noda2014] suggest an approach to multimodal learning using deep neural networks. Their input data is very high dimensional and includes raw RGB images, sound spectra and joint angles and they use multiple encoders and a central hidden layer for the integration. Similarly, the authors of [jVAE] propose a joint VAE. The architecture from [zambelli2020multimodal], that we use in this work, can be considered in this context. Additionally, the authors of [Meo2021] use a multimodal VAE as part of an active inference controller. Apart from variational autoencoders also other architectures for deep neural networks have been explored. The authors in [Ngiam2011] present an approach with a shared representation using restricted Boltzmann machines, for instance, and the authors of [schillaci] use a multimodal forward model that is a combination of convolutional networks and a gating system. A more exhaustive overview over multimodal deep generative networks can be found in [doi:10.1080/01691864.2022.2035253], where the authors discuss 22 different models and their properties in detail. They highlight the advantages of a VAE and categorize the different approaches, similar to [Baltruaitis2017MultimodalML]. 1.1.2 Information-theoretic Measures Information theory originated from Shannonâ€™s theory of communication [Shannon]. There he formalizes a communication channel and defines quantities like entropy and mutual information with which the information flow between sender and receiver can be investigated. This framework developed into a rich theory with tools to analyze and optimize various types of channels. Here we only want to quickly mention some important information-theoretic measures, that can also be used for guiding the learning and actions of artificial agents. This includes â€œempowermentâ€, which can be seen as a measure of control of an agent [Klyubin]. Another useful measure is â€œpredictive informationâ€, which is defined as the mutual information between the past and the future of a time series [Bialek], for instance the sensory input of an agent. Additionally, the authors of [seitzer2021causal] define an information-theoretic measure for the causal action influence of reinforcement learning agents. The loss function of the variational autoencoder, the ELBO, is information-theoretic in nature and consists of cross entropy and relative entropy, also called KL-divergence, terms. Hence, if we want to analyze the multimodal integration inside a VAE it is natural to make use of information-theoretic quantities. Here in this work we define four different measures that assess the importance of the different modalities by calculating the KL-divergence between representations generated with a varying amount of information about the modalities. A similar approach to quantifying the importance of an information flow, although in the discrete setting, was used, for instance, in [Langer2020, Langer2021, Langer2024]."
https://arxiv.org/html/2411.00319v1,Task-oriented Age of Information for Remote Monitoring Systems,"The emergence of intelligent applications has fostered the development of a task-oriented communication paradigm, where a comprehensive, universal, and practical metric is crucial for unleashing the potential of this paradigm. To this end, we introduce an innovative metric, the Task-oriented Age of Information (TAoI), to measure whether the content of information is relevant to the system task, thereby assisting the system in efficiently completing designated tasks. Also, we study the TAoI in a remote monitoring system, whose task is to identify target images and transmit them for subsequent analysis. We formulate the dynamic transmission problem as a Semi-Markov Decision Process (SMDP) and transform it into an equivalent Markov Decision Process (MDP) to minimize TAoI and find the optimal transmission policy. Furthermore, we demonstrate that the optimal strategy is a threshold-based policy regarding TAoI and propose a relative value iteration algorithm based on the threshold structure to obtain the optimal transmission policy. Finally, simulation results show the superior performance of the optimal transmission policy compared to the baseline policies.","Generally, conventional communications rely on Shannonâ€™s channel coding theory to achieve reliable transmission from sources to destinations [1]. The core idea is to abstract information into bits and design source coding/decoding, channel coding/decoding, and modulation/demodulation parts to minimize bit/symbol error rate or signal distortion measures (e.g., Mean Square Error) and achieve error-free replication of bits from source to destination [2]. This approach has demonstrated tremendous success across a range of voice and data communication systems [3]. However, with the emergence of intelligent systems such as real-time cyber-physical systems, interactive systems, and autonomous multi-agent systems, the communication goals of these systems are no longer to reconstruct the underlying message but to enable the destination to make the right inference or to take the right decision at the right time and within the right context [4]. This shift poses new technical challenges to conventional communication systems [5]. Therefore, a new communication paradigm, task-oriented communication or goal-oriented communication, has been proposed as a promising solution [6]. Figure 1: An illustration of the task-oriented monitoring system. The key to unlocking the potential of task-oriented communication lies in a comprehensive, universal, and practical metric. This metric measures the relevance of information to system task, thereby significantly reducing computational and transmission costs by only acquiring, transmitting, and reconstructing task-relevant information. In recent years, there have been several studies on metrics for task-oriented communication [7, 8, 9, 10, 11]. In [7], the Age of Information (AoI) was proposed as a pioneering metric to capture the freshness of data perceived by the destination. However, AoI is limited in that it cannot measure the content of information or the dynamic changes in information content. To address this issue, the authors of [8] proposed the Age of Incorrect Information (AoII), which reflects the discrepancy between the receiverâ€™s estimate and the actual system state. In [9], the authors introduced the Age of Changed Information (AoCI), positing that changes in information content to be more beneficial to the system. In [10], the Age of Version (AoV) was introduced, counting the integer difference between the versions at the database and the local cache. The authors of [11] proposed the Age of Actuation (AoA), which captures the elapsed time since the last performed actuation at a destination based on data received by a source. However, none of these metrics directly assess whether the information content is relevant to the system task. In this paper, we consider a remote monitoring system consisting of a sensor, a processor, a transmitter, and a receiver. Specifically, the sensor captures real-time images, which are pre-identified by the processor, and then the receiver decides whether to require the transmitter to transmit the images based on the pre-identification results and monitoring target. A new task-oriented communication metric called Task-oriented Age of Information (TAoI) is introduced, which directly characterizes whether the information content is relevant to the system task. If the transmitted image matches the target, TAoI decreases; otherwise, it increases. We focus on finding the optimal transmission policy for the remote monitoring system to minimize TAoI. By modeling the problem as an infinite time-horizon Semi-Markov Decision Process (SMDP) and transforming it into an equivalent MDP with uniform time steps, we prove that the optimal transmission policy is a threshold-type policy. Furthermore, we propose a low-complexity relative value iteration algorithm based on the threshold structure to obtain the optimal transmission policy. Finally, simulation results demonstrate that the optimal transmission policy outperforms the two baseline policies."
https://arxiv.org/html/2410.22746v2,Unauthorized UAV Countermeasure for Low-Altitude Economy: Joint Communications and Jamming based on MIMO Cellular Systems,"To ensure the thriving development of low-altitude economy, countering unauthorized unmanned aerial vehicles (UAVs) is an essential task. The existing widely deployed base stations hold great potential for joint communication and jamming. In light of this, this paper investigates the joint design of beamforming to simultaneously support communication with legitimate users and countermeasure against unauthorized UAVs based on dual-functional multiple-input multiple-output (MIMO) cellular systems. We first formulate a joint communication and jamming (JCJ) problem, relaxing it through semi-definite relaxation (SDR) to obtain a tractable semi-definite programming (SDP) problem, with SDR providing an essential step toward simplifying the complex JCJ design. Although the solution to the relaxed SDP problem cannot directly solve the original problem, it offers valuable insights for further refinement. Therefore, we design a novel constraint specifically tailored to the structure of the SDP problem, ensuring that the solution adheres to the rank-1 constraint of the original problem. Finally, we validate effectiveness of the proposed JCJ scheme through extensive simulations. Simulation codes are provided to reproduce the results in this paper: https://github.com/LiZhuoRan0. The results confirm that the proposed JCJ scheme can operate effectively when the total number of legitimate users and unauthorized UAVs exceeds the number of antennas.","The concept of low-altitude economy (LAE) is conceived as an economic system that integrates a variety of low-altitude aviation activities involving both unmanned and manned craft, including unmanned aerial vehicles (UAVs) and electric vertical take-off and landing (eVTOL) aircraft[1]. Anticipated to facilitate a multitude of low-altitude services across sectors such as transportation, environmental surveillance, agriculture, and entertainment, LAE holds the promise of significant economic and social benefits. This potential has sparked a surge in research interest[2, 3, 4, 5, 6]. For LAE to be successful, it is essential not only to ensure continuous wireless communication with authorized UAVs, but also to implement necessary countermeasures against unauthorized UAVs[7, 8]. Generally, there are two kinds of countermeasure techniques including physical capture and jamming[9]. Physical capture approaches are efficient and low-cost, but not friendly to pilots. Jamming is the most popular method used in neutralizing UAVs entering restricted areas, and there are four categories of jamming[7]. The first category is emitting noise-like unstructured signals to reduce the signal-to-interference-plus-noise ratio (SINR) of the unauthorized UAVs. Partial-band noise jamming was implemented to cut off the control link between the UAV and its controller in [10]. The second category entails broadcasting deceptive Global Position System (GPS) signals to lead unauthorized UAVs out of restricted areas. The third category involves hacking the communication protocols of the unauthorized UAVs and generating fake commands to control them to fly away restricted areas[11, 12, 13, 14]. The fourth category is passive interference, which involves using passive devices to modify the signals in the environment, causing multipath signals to superpose destructively at the receiver. A common approach is to design the phase of a reconfigurable intelligent surface (RIS)[15, 16, 17, 18]. Traditional counter-UAV methods, which require dedicated devices, platforms, and architectures [8], significantly increase the cost of countering unauthorized UAVs. However, the potential of widely deployed multiple-input multiple-output (MIMO) base stations (BSs) has not been fully utilized for this purpose. With the evolution of dense cell infrastructures into networks with integrated sensing and communication (ISAC) capabilities, referred to as perceptive mobile networks (PMNs) [19], there is a promising opportunity to leverage BSs for countering unauthorized UAVs. In addition to providing communication and sensing services, BSs can also offer effective countermeasures, ensuring the lawful and orderly use of the airspace while minimizing the need for costly specialized equipment. I-A Prior Works Most of existing ISAC studies focus on utilizing a unified hardware platform and/or waveform to simultaneously achieve demodulation of communication data and extraction of target parameters with noisy observations[20, 21, 22]. Userâ€™s activity, channel, and location in extra-large MIMO systems were joint sensed in [23]. A compressed sampling perspective to facilitate ISAC processing was proposed in [24]. User equipment (UE)â€™s uplink channel and location in Terahertz extra-large array systems were jointly obtained in [25]. Sensing-centric index modulation-based ISAC systems was proposed in [26]. Given the potential of UAVs to empower a wide range of industries, there is also an abundance of work integrating UAVs with ISAC[27, 28, 1]. However, the aforementioned ISAC efforts fall short in considering countermeasures against unauthorized UEs. Various methods for both jamming and anti-jamming have been extensively reviewed in [29]. To address the challenges posed by interference during communication, specialized waveforms were developed to maximize detection capabilities [30]. Additionally, researchers have investigated the use of jamming signal echoes for sensing, while simultaneously preserving communication functionality. This approach enables dynamic resource allocation based on the sensing outcomes [31]. In [32], deep reinforcement learning (DRL) methods were employed to jam devices utilizing frequency hopping spread spectrum, leveraging specialized jamming equipment. The scenario of a full-duplex system with a single UE and UAV was also investigated, where the unauthorized UAV was detected and jammed with the uplink signals from the UE [33]. Furthermore, simultaneous communication and jamming in the presence of CSI errors was rigorously studied [34]. A novel approach using optical devices to generate electromagnetic signals was proposed in [35], enabling secure communication while conducting radar range and velocity deception jamming. Real-world tests have demonstrated the efficacy of narrowband signals with low energy in disrupting the fifth-generation networks [36]. The concept of integrating radar, communications, and jamming was proposed for jamming illegal UEs in [37]. The premise of this study centers around security, with the assumption that an entity being jammed is an eavesdropper. This assumption is restrictive and does not necessarily apply to scenarios involving all the unauthorized UAV flights, where the unauthorized UAVs might not engage in eavesdropping. Therefore, further research is required to overcome the challenge of jamming common unauthorized UAVs. Recently, a generalized integrated communications and jamming (ICAJ) framework has been proposed to enable communication and jamming to reinforce each other in one system, thereby achieving more reliable communication and more efficient jamming[38, 39]. However, the aforementioned studies assume separate communication data streams and jamming streams. In reality, the communication data streams and jamming streams can be jointly designed for a more coordinated ICAJ. TABLE I: State-of-the-art Jamming Solutions Ref. Jamming Methods Jamming Categories Relationship with Sensing and Communi- cation Algorithms Additional Equipment Additional Jamming Streams Reusing Communi- cation Signals Active Passive Deception [15] âœ“ âœ“ âœ“ â‘  BCD+SDR [16] âœ“ âœ“ âœ“ â‘  alternating opti- mization+SCA [17] âœ“ âœ“ âœ“ â‘  â€”â€”â€”â€” [30] âœ“ âœ“ â‘¢ convex optimization [31] âœ“ âœ“ â‘¢ S-procedure SDR [32] âœ“ âœ“ â‘  DRL [33] âœ“ âœ“ â‘¢ alternating opti- mization+SCA [34] âœ“ âœ“ â‘¢ customized optimization [35] âœ“ âœ“ âœ“ â‘¡ â€”â€”â€”â€” [37] âœ“ âœ“ â‘¢ SDR+convex optimization [38] âœ“ âœ“ â‘¡ SDR+interior point method [39] âœ“ âœ“ â‘¢ DRL proposed âœ“ âœ“ â‘¡ SDR+convex optimization â€¢ â‘ : jamming, â‘¡: jamming+communication, â‘¢: jamming+communication+sensing. â€¢ SDR: semi-definite relaxation, DRL: deep reinforcement learning, BCD: block coordinate descent, SCA: successive convex approximation. In addition to these active jamming techniques, passive methods have also garnered attention. When acting as a collaborator, an RIS can effectively cover blind spots and enhance signal quality. However, when an RIS operates as an interferer, it can reshape the characteristics of multipath signals passing through it, resulting in destructive interference at the receiver [15, 16, 17]. The aforementioned jamming-related work is summarized in Table I. Parallel to these advancements, there has been significant progress in anti-jamming research. Authors in [40] examined the dynamic interaction between a jammer and a BS, where the BS continuously adjusts its beamformer in response to the jamming power of the jammer. Authors in [41] focused on designing robust passive beamforming using RIS to counter jamming, even when angle information is inaccurate. Furthermore, a different approach was proposed to utilize additional transceivers in the environment to remodulate jamming signals, embedding structured information for potential use [42]. The continuous advancements in jamming and anti-jamming technologies reinforce each other, driving ongoing progress in both fields. Essentially, integrating ISAC with UAV countermeasures relies on downlink beamforming as one of the key technologies. There are numerous classical schemes. For fully digital beamforming, there are famous channel inversion (CI)-based scheme[43], linear minimum mean squared error-based scheme[44], and optimization-based schemes [45, 46, 47]. For hybrid beamforming, there are semi-definite programming (SDP)-based schemes[48], orthogonal matching pursuit-based schemes[49], and alternating minimization-based schemes[50]. Thanks to the development of deep learning, there are some advanced data-driven-based beamforming schemes [51, 52, 53] However, to the best of our knowledge, in the scenario of integrated communication and unauthorized UAV countermeasures, there is currently no generalized downlink beamforming solution. I-B Our Contributions Our contributions are summarized as follows. â€¢ We develop a joint communication and jamming (JCJ) model and formulate an associated optimization problem, which can demonstrate how a BS fulfills essential communication demands while efficiently counters unauthorized UAVs with minimal power expenditure. Through theoretical analysis of the formulated problem, we yield the suggestion that additional jamming streams are unnecessary. Effective countermeasures against unauthorized UAVs can be seamlessly integrated within the UEsâ€™ data streams. â€¢ Upon further in-depth analysis of the proposed JCJ optimization problemâ€™s structure, we develop an additional constraint. Specifically, the real part of the sum of the elements along any diagonal direction parallel to the main diagonal of the complex symmetric matrix, including cyclically wrapped diagonals, should be no less than a fraction, ranging between 0 and 1, of the matrixâ€™s trace. This constraint ensures that the solution obtained through the SDP satisfies the rank-1 constraint. Simulations confirm the effectiveness of this constraint. â€¢ Since the proposed JCJ scheme does not require additional signal streams to jam unauthorized UAVs, the proposed JCJ scheme can operate effectively when the total number of UEs111Here, â€˜UEsâ€™ also includes legitimate UAVs. and unauthorized UAVs exceeds the number of transmit antennas, where traditional schemes fail to operate altogether. Moreover, when the number of transmit antennas is fewer than 32, the proposed JCJ scheme is always superior to the traditional channel inversion scheme. I-C Notation Throughout this paper, if not otherwise stated, normal-face letters, boldface lower letters, and boldface uppercase letters denote scalar variables, column vectors, and matrices, respectively; the transpose operator and the conjugate transpose operator are denoted by (â‹…)Tsuperscriptâ‹…ğ‘‡(\cdot)^{T}( â‹… ) start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT and (â‹…)Hsuperscriptâ‹…ğ»(\cdot)^{H}( â‹… ) start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT, respectively; j=âˆ’1ğ‘—1j=\sqrt{-1}italic_j = square-root start_ARG - 1 end_ARG is the imaginary unit; â„â„\mathbb{R}blackboard_R and â„‚â„‚\mathbb{C}blackboard_C are the sets of real-valued and complex-valued numbers, respectively; ğ—[:,m1:m2]\mathbf{X}[:,m_{1}:m_{2}]bold_X [ : , italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT : italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT ] is the matrix composed of column vectors from m1subscriptğ‘š1m_{1}italic_m start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT-th column to m2subscriptğ‘š2m_{2}italic_m start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT-th column of matrix ğ—âˆˆâ„‚NÃ—Mğ—superscriptâ„‚ğ‘ğ‘€\mathbf{X}\in\mathbb{C}^{N\times M}bold_X âˆˆ blackboard_C start_POSTSUPERSCRIPT italic_N Ã— italic_M end_POSTSUPERSCRIPT; |s|ğ‘ |s|| italic_s | is the magnitude of sğ‘ sitalic_s, whether sğ‘ sitalic_s is a real number or a complex-valued number; ğ’â¢ğ’©â¢(Î¼,Ïƒ2)ğ’ğ’©ğœ‡superscriptğœ2\mathcal{CN}(\mu,\sigma^{2})caligraphic_C caligraphic_N ( italic_Î¼ , italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ) is the circularly-symmetric complex Gaussian distribution with mean Î¼ğœ‡\muitalic_Î¼ and covariance Ïƒ2superscriptğœ2\sigma^{2}italic_Ïƒ start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT; ğ’°â¢(a,b)ğ’°ğ‘ğ‘\mathcal{U}(a,b)caligraphic_U ( italic_a , italic_b ) is the uniform distribution with interval ağ‘aitalic_a and bğ‘bitalic_b; ğ”¼â¢[â‹…]ğ”¼delimited-[]â‹…\mathbb{E}[\cdot]blackboard_E [ â‹… ] is the expectation operation; Reâ¢(â‹…)Reâ‹…\text{Re}(\cdot)Re ( â‹… ) denotes extraction of the real part; ğŸNsubscript0ğ‘\mathbf{0}_{N}bold_0 start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT is the NÃ—1ğ‘1N\times 1italic_N Ã— 1 vector with all the elements being 0; ğŸNÃ—Msubscript0ğ‘ğ‘€\mathbf{0}_{N\times M}bold_0 start_POSTSUBSCRIPT italic_N Ã— italic_M end_POSTSUBSCRIPT is the NÃ—Mğ‘ğ‘€N\times Mitalic_N Ã— italic_M matrix with all the elements being 0; ğˆNsubscriptğˆğ‘\mathbf{I}_{N}bold_I start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT is the NÃ—Nğ‘ğ‘N\times Nitalic_N Ã— italic_N unit matrix; ğ…âª°ğŸsucceeds-or-equalsğ…0\mathbf{F}\succeq\mathbf{0}bold_F âª° bold_0 denotes ğ…ğ…\mathbf{F}bold_F is a semi-definite matrix; cğ‘citalic_c is the speed of light."
https://arxiv.org/html/2406.08887v1,Low-Overhead Channel Estimation via 3D Extrapolation for TDD mmWave Massive MIMO Systems Under High-Mobility Scenarios,"In time division duplexing (TDD) millimeter wave (mmWave) massive multiple-input multiple-output (MIMO) systems, the downlink channel state information (CSI) can be attained through uplink channel estimation thanks to the uplink-downlink channel reciprocity. However, the channel aging issue is significant under high-mobility scenarios and thus necessitates frequent uplink channel estimation. In addition, large amounts of antennas and subcarriers lead to high-dimensional CSI matrices, aggravating the pilot training overhead. To systematically reduce the pilot overhead, a spatial, frequency, and temporal domain (3D) channel extrapolation framework is proposed in this paper. Considering the marginal effects of pilots in the spatial and frequency domains and the effectiveness of traditional knowledge-driven channel estimation methods, we first propose a knowledge-and-data driven spatial-frequency channel extrapolation network (KDD-SFCEN) for uplink channel estimation by exploiting the least square estimator for coarse channel estimation and joint spatial-frequency channel extrapolation to reduce the spatial-frequency domain pilot overhead. Particularly, we propose the attention-based sub-element extrapolation module and the progressive extrapolation architecture to improve the accuracy of joint spatial-frequency channel extrapolation. Then, resorting to the uplink-downlink channel reciprocity and temporal domain dependencies of downlink channels, a temporal uplink-downlink channel extrapolation network (TUDCEN) is proposed for slot-level channel extrapolation, aiming to enlarge the pilot signal period and thus reduce the temporal domain pilot overhead under high-mobility scenarios. Specifically, we propose the spatial-frequency sampling embedding module to reduce the representation dimension and consequent computational complexity, and we propose to exploit the autoregressive generative Transformer for generating downlink channels autoregressively thanks to the powerful capability of generative artificial intelligence. Numerical results demonstrate the superiority of the proposed framework in significantly reducing the pilot training overhead by more than 16161616 times and improving the systemâ€™s spectral efficiency under high-mobility scenarios.","MILLIMETER wave (mmWave) massive multi-input multi-output (MIMO) has been recognized as a pivotal technology for the fifth generation (5G) wireless communication systems and beyond [1, 2, 3]. mmWave massive MIMO is anticipated to provide spatial degrees of freedom, diversity or multiplexing gain, and array gain, thereby improving the spectral and energy efficiencies of wireless communication systems. To reap the benefits of massive MIMO, accurate channel state information (CSI) should be attained whether operating in the time division duplexing (TDD) or frequency division duplexing (FDD) modes[4, 5]. In FDD massive MIMO systems, the base station (BS) needs to obtain the downlink CSI through downlink channel estimation and CSI feedback from the user equipment (UE) due to the lack of uplink-downlink channel reciprocity. While in TDD massive MIMO systems, thanks to the uplink-downlink channel reciprocity, the BS can obtain the downlink CSI via uplink channel estimation and derive the downlink CSI from the estimated uplink CSI. The uplink-downlink channel reciprocity in the TDD massive MIMO systems holds within the channel coherence time. However, in high-mobility scenarios, the channel is fast time-varying due to the UE movement, resulting in a short channel coherence time and the consequent channel aging issue, i.e., the channel varies between when it is acquired at the BS and when it is used for downlink precoding[6]. In addition, compared with sub-6 GHz bands, mmWave bands are more vulnerable to the UE movement since higher frequency bands generally lead to a shorter channel coherence time[7], deteriorating the channel aging issue in mmWave massive MIMO systems under high-mobility scenarios. To avoid significant performance degradation caused by channel aging, frequent channel estimation needs to be conducted such that the downlink precoding can be conducted based on up-to-date CSI, leading to huge temporal domain pilot training overhead. Besides, due to the large number of antennas at the BS and large amounts of subcarriers in orthogonal frequency-division multiplexing (OFDM) systems, the spatial and frequency domain pilot training overhead is also huge and unacceptable. In addition, to reduce the hardware cost and power consumption, hybrid beamforming structure is usually adopted and only a small number of radio frequency (RF) chains are deployed at the BS, especially for a millimeter wave (mmWave) massive MIMO system. To obtain the uplink CSI at all receiving antennas at the BS, the BS has to switch the antennas connected to these RF chains several times during the uplink channel estimation, leading to substantial time and power consumption. Therefore, it is of great significance to minimize the pilot training overhead in the spatial, frequency, and temporal domains while estimating the CSI accurately. To circumvent huge frequency domain pilot training overhead, frequency domain channel extrapolation has been widely investigated in related works. In [8], a linear interpolation least square (LS) channel estimation method was proposed for channel estimation with pilots in partial subcarriers. In [9], the performance of various interpolation methods for mmWave MIMO-OFDM systems, including spline interpolation, discrete Fourier transform (DFT) -based interpolation, etc., was investigated. Recently, with the advances in deep learning, many deep learning-based frequency domain channel extrapolation methods were proposed to further reduce pilot training overhead and improve channel estimation accuracy from the frequency domain perspective. In [10], the super-resolution convolutional neural network (SRCNN) was presented to obtain full channel responses with the channel responses at pilot positions via deep image processing techniques. By jointly learning the spatial-temporal domain features of massive MIMO channels with a temporal attention module and a spatial attention module, a dual-attention-based channel estimation network (DACEN) was proposed to realize accurate channel estimation via low-density pilots in the frequency domain[11]. The development of deep learning has also led to increasing attention in antenna (spatial) domain channel extrapolation in recent years, aiming at reducing the huge spatial domain pilot training overhead and prohibitive time and power consumption. For example, two fully connected neural networks (FCNNs) were proposed to use the CSI of a subset of antennas to extrapolate the CSI of other antennas[12, 13]. In addition to spatial and frequency domain channel extrapolation, channel prediction (i.e., temporal domain channel extrapolation) is also a convincing method for alleviating the huge pilot training overhead in high-mobility scenarios. Linear extrapolation methods [14] and statistical prediction models, e.g., autoregressive (AR) models [15, 16], were proposed and have demonstrated that channel prediction is promising to mitigate the impacts of channel aging. The advancements of DNNs further improve the channel prediction performance and thus would further reduce the channel estimation frequency in high-mobility scenarios. In [17], a novel long short-term memory (LSTM) based channel predictor was proposed to learn channel variations and thereby reduce the pilot training overhead for channel estimation. An attention-based channel predictor was proposed in [18] to achieve frame-level channel estimates for mobile scenarios. Nonetheless, existing channel prediction methods are unable to deal with massive MIMO-OFDM systems with substantial antennas and subcarriers due to the high-dimensional CSI matrices and the consequent tremendous computational complexity. In addition, since the channel aging issue is critical in high-mobility scenarios, frame-level channel prediction methods are unable to achieve high spectral efficiency due to the varying channels, posing demands on slot-level channel extrapolation. However, existing channel prediction methods predict future channels at the same time granularity as the collected historical channels. This indicates that exploiting these methods for slot-level channel extrapolation comes at the cost of sacrificing a large amount of time-frequency resources for slot-level historical channel estimation, making them infeasible in practice. To overcome the limitations of these existing works and to systematically reduce the pilot overhead, a spatial, frequency, and temporal domain (3D) channel extrapolation framework is proposed in this paper to reduce the pilot training overhead from these three domains respectively. First, it can be observed that the number of pilots in one certain domain shows the marginal effect, i.e., as the number of pilots in this domain increases, the improvement in channel estimation accuracy gradually decreases.111This observation is further validated with our simulation results in Section V-B. Due to the capability of deep neural networks (DNNs) in extracting the spatial and frequency domain characteristics of massive MIMO channels, it is expected that exploiting DNNs for joint spatial and frequency domain channel extrapolation will further reduce the pilot training overhead. However, although some works have pointed out that jointly learning spatial-frequency domain features is beneficial to channel estimation[11, 19], spatial-frequency channel extrapolation has not yet been well investigated to reduce the pilot training overhead for mmWave massive MIMO-OFDM systems. Therefore, considering the marginal effects of pilots in the spatial and frequency domains and the effectiveness of traditional knowledge-driven channel estimation methods, we first propose a knowledge-and-data driven spatial-frequency channel extrapolation network (KDD-SFCEN) for uplink channel estimation by exploiting the least square estimator for coarse channel estimation and joint spatial-frequency channel extrapolation to reduce the spatial-frequency domain pilot overhead. Then, resorting to the uplink-downlink channel reciprocity and temporal domain dependencies of downlink channels, a temporal uplink-downlink channel extrapolation network (TUDCEN) is proposed for slot-level channel extrapolation, aiming to enlarge the pilot signal period and thus reduce the temporal domain pilot overhead. To the best of our knowledge, none of the existing works have investigated such a systematic framework to reduce the pilot training overhead and improve the spectral efficiency of mmWave massive MIMO-OFDM systems under high-mobility scenarios. The major contributions of this paper are summarized as follows: 1. We propose the KDD-SFCEN to reduce the spatial-frequency domain pilot overhead effectively via joint spatial-frequency channel extrapolation. In addition, it is worth emphasizing that the substantial time and power consumption due to antenna switching can be avoided through spatial extrapolation. The proposed KDD-SFCEN consists of a knowledge-driven coarse channel estimator to provide coarse channel estimates and accelerate the training of the proposed network. The KDD-SFCEN also comprises a spatial-frequency channel extrapolator encompassing the attention-based sub-element extrapolation module and the progressive extrapolation architecture. The proposed attention-based sub-element extrapolation module mimics the sub-pixel imaging technology and is demonstrated to be highly effective in learning spatial-frequency channel characteristics for joint spatial and frequency extrapolation. Moreover, the progressive extrapolation architecture is proposed to progressively extrapolate the uplink CSI, thereby further improving the performance of joint spatial-frequency channel extrapolation with few pilots in the spatial and frequency domains. 2. We propose the TUDCEN for accurate slot-level channel extrapolation given the estimated uplink CSI at the first slot. Through the proposed TUDCEN, channel estimation can be conducted less frequently and more slots can be configured for data transmission under high-mobility scenarios, further reducing the pilot training overhead from the temporal domain perspective and improving the systemâ€™s spectral efficiency. The TUDCEN is composed of an uplink-downlink channel calibration network (UDCCN) and a downlink channel extrapolation network (DCEN). The UDCCN calibrates the estimated uplink channel to the downlink channel at the first downlink slot to compensate for the hardware asymmetry in transceivers. The proposed DCEN achieves slot-level channel extrapolation via spatial-frequency sampling embedding and autoregressive generation with the generative Transformer[20]. Spatial-frequency sampling embedding is proposed to reduce the tremendous computational complexity due to high-dimensional CSI matrices. Specifically, the spatial-frequency sampling embedding layer samples the spatial and frequency domain representation of downlink channels with a spatial sampling factor and a frequency sampling factor to reduce the representation dimension by resorting to the spatial and frequency correlations of downlink channels. Meanwhile, the sampled antenna groups and subcarrier groups are combined to facilitate model training. We exploit the generative Transformer for generating downlink channels autoregressively thanks to the powerful capability of generative artificial intelligence (AI), which is able to conduct slot-level downlink channel extrapolation given only the first downlink channel, thereby avoiding heavy slot-level historical downlink channel estimation. 3. We use the sounding reference signal (SRS) defined by the 3rd generation partnership project (3GPP) 5G technical specification [21] as the pilot signal for uplink pilot training. The frame structures and system settings in framework design and numerical simulations also follow the 3GPP 5G technical specification. Numerical results demonstrate the superiority of the proposed framework in significantly reducing the spatial-frequency domain pilot overhead by more than 4444 times via spatial-frequency channel extrapolation. In addition, via enlarging the pilot signal period with slot-level channel extrapolation, the proposed framework further reduces the temporal domain pilot overhead by 4444 times and significantly improves the mmWave massive MIMO systemâ€™s spectral efficiency under high-mobility scenarios. The remainder of this paper is organized as follows. In Section II, we introduce the system model and formulate the spatial, frequency, and temporal channel extrapolation problem. In Section III, we propose the KDD-SFCEN for uplink channel estimation to reduce the spatial-frequency domain pilot training overhead. In Section IV, we propose the TUDCEN for slot-level channel extrapolation to enlarge the pilot signal period and thus reduce the temporal domain pilot overhead. In Section V, simulation results are presented to demonstrate the superiority of the proposed spatial, frequency, and temporal channel extrapolation framework. Finally, we conclude this work in Section VI. Notation: Underlined bold uppercase letter ğ€Â¯Â¯ğ€\underline{\mathbf{A}}underÂ¯ start_ARG bold_A end_ARG, bold uppercase letter ğ€ğ€\mathbf{A}bold_A, and bold lowercase letter ğšğš\mathbf{a}bold_a represent a tensor, a matrix, and a vector, respectively. Calligraphy uppercase letter ğ’œğ’œ\mathcal{A}caligraphic_A represents a set. ğ€â¢{s,t}ğ€ğ‘ ğ‘¡\mathbf{A}\{s,t\}bold_A { italic_s , italic_t } denotes the representation of ğ€ğ€\mathbf{A}bold_A at the tğ‘¡titalic_t-th slot of the sğ‘ sitalic_s-th sub-frame. ğ€:,nsubscriptğ€:ğ‘›\mathbf{A}_{:,n}bold_A start_POSTSUBSCRIPT : , italic_n end_POSTSUBSCRIPT and ğ€m,nsubscriptğ€ğ‘šğ‘›\mathbf{A}_{m,n}bold_A start_POSTSUBSCRIPT italic_m , italic_n end_POSTSUBSCRIPT denote the nğ‘›nitalic_n-th column and the element at the mğ‘šmitalic_m-th row and nğ‘›nitalic_n-th column of the matrix ğ€ğ€\mathbf{A}bold_A, respectively. (â‹…)Tsuperscriptâ‹…ğ‘‡(\cdot)^{T}( â‹… ) start_POSTSUPERSCRIPT italic_T end_POSTSUPERSCRIPT, (â‹…)Hsuperscriptâ‹…ğ»(\cdot)^{H}( â‹… ) start_POSTSUPERSCRIPT italic_H end_POSTSUPERSCRIPT, and (â‹…)âˆ’1superscriptâ‹…1(\cdot)^{-1}( â‹… ) start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT denote the transpose, conjugate-transpose, and inverse of a matrix, respectively. âŒˆâ‹…âŒ‰â‹…\lceil\cdot\rceilâŒˆ â‹… âŒ‰, âŠ™direct-product\odotâŠ™, ğ”¼â¢{â‹…}ğ”¼â‹…\mathbb{E}\{\cdot\}blackboard_E { â‹… }, and âˆ¥â‹…âˆ¥2\|\cdot\|_{2}âˆ¥ â‹… âˆ¥ start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT denote the ceiling function, Hadamard product, expectation, and L2 norm, respectively. Figure 1: A TDD massive MIMO system with the hybrid precoding architecture at the BS. (a) The TDD massive MIMO system; (b) The hybrid precoding architecture at the BS; (c) The 5G frame structure; (d) An exampled TDD slot pattern with a general pilot training scheme; (e) An exampled TDD slot pattern with the SLCE-aided pilot training scheme; (f) An exampled uplink SRS pattern."
