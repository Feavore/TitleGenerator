URL,Title,Abstract,Introduction
https://arxiv.org/html/2411.03601v1,One-dimensional cellular automata with a unique active transition,"A one-dimensional cellular automaton Ï„:Aâ„¤â†’Aâ„¤:ðœâ†’superscriptð´â„¤superscriptð´â„¤\tau:A^{\mathbb{Z}}\to A^{\mathbb{Z}}italic_Ï„ : italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT â†’ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT is a transformation of the full shift defined via a finite neighborhood SâŠ‚â„¤ð‘†â„¤S\subset\mathbb{Z}italic_S âŠ‚ blackboard_Z and a local function Î¼:ASâ†’A:ðœ‡â†’superscriptð´ð‘†ð´\mu:A^{S}\to Aitalic_Î¼ : italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT â†’ italic_A. We study the family of cellular automata whose finite neighborhood Sð‘†Sitalic_S is an interval containing 00, and there exists a pattern pâˆˆASð‘superscriptð´ð‘†p\in A^{S}italic_p âˆˆ italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT satisfying that Î¼â¢(z)=zâ¢(0)ðœ‡ð‘§ð‘§0\mu(z)=z(0)italic_Î¼ ( italic_z ) = italic_z ( 0 ) if and only if zâ‰ pð‘§ð‘z\neq pitalic_z â‰  italic_p; this means that these cellular automata have a unique active transition. Despite its simplicity, this family presents interesting and subtle problems, as the behavior of the cellular automaton completely depends on the structure of pð‘pitalic_p. We show that every cellular automaton Ï„ðœ\tauitalic_Ï„ with a unique active transition pâˆˆASð‘superscriptð´ð‘†p\in A^{S}italic_p âˆˆ italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT is either idempotent or strictly almost equicontinuous, and we completely characterize each one of these situations in terms of pð‘pitalic_p. In essence, the idempotence of Ï„ðœ\tauitalic_Ï„ depends on the existence of a certain subpattern of pð‘pitalic_p with a translational symmetry. Keywords: cellular automaton; unique active transition; idempotent; strictly almost equicontinuous.","Cellular automata (CA) are transformations of a discrete space with the key characteristic of being defined via local function that only depends on a finite neighborhood. Originally introduced by John von Neumann and Stanislaw Ulam in the 1940s, CA have gained significance due to their connections with discrete complex modeling, symbolic dynamics, and theoretical computer science. In particular, one-dimensional cellular automata are transformations Ï„:Aâ„¤â†’Aâ„¤:ðœâ†’superscriptð´â„¤superscriptð´â„¤\tau:A^{\mathbb{Z}}\to A^{\mathbb{Z}}italic_Ï„ : italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT â†’ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT, where Að´Aitalic_A is a set with at least two elements, known as the alphabet, and Aâ„¤superscriptð´â„¤A^{\mathbb{Z}}italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT is the set of all bi-infinite sequences of symbols in Að´Aitalic_A, known as the full shift, such that there exists a finite neighborhood SâŠ‚â„¤ð‘†â„¤S\subset\mathbb{Z}italic_S âŠ‚ blackboard_Z and a local function Î¼:ASâ†’A:ðœ‡â†’superscriptð´ð‘†ð´\mu:A^{S}\to Aitalic_Î¼ : italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT â†’ italic_A satisfying Ï„â¢(x)â¢(k)=Î¼â¢((kâ‹…x)|S),âˆ€xâˆˆAâ„¤,kâˆˆâ„¤,formulae-sequenceðœð‘¥ð‘˜ðœ‡evaluated-atâ‹…ð‘˜ð‘¥ð‘†formulae-sequencefor-allð‘¥superscriptð´â„¤ð‘˜â„¤\tau(x)(k)=\mu((k\cdot x)|_{S}),\quad\forall x\in A^{\mathbb{Z}},k\in\mathbb{Z},italic_Ï„ ( italic_x ) ( italic_k ) = italic_Î¼ ( ( italic_k â‹… italic_x ) | start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT ) , âˆ€ italic_x âˆˆ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT , italic_k âˆˆ blackboard_Z , where kâ‹…xâˆˆAâ„¤â‹…ð‘˜ð‘¥superscriptð´â„¤k\cdot x\in A^{\mathbb{Z}}italic_k â‹… italic_x âˆˆ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT denotes the shift action of kð‘˜kitalic_k on xð‘¥xitalic_x, and |S|_{S}| start_POSTSUBSCRIPT italic_S end_POSTSUBSCRIPT denotes the restriction to Sð‘†Sitalic_S. The famous Curtis-Hedlund-Lyndon theorem (see [4, 13]) establishes that a transformation Ï„:Aâ„¤â†’Aâ„¤:ðœâ†’superscriptð´â„¤superscriptð´â„¤\tau:A^{\mathbb{Z}}\to A^{\mathbb{Z}}italic_Ï„ : italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT â†’ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT is a cellular automaton if and only if it is uniformly continuous and commutes with the shift action. This result builds an important bridge between symbolic dynamics and the theory of cellular automata. In this paper, we consider the class of one-dimensional cellular automata Ï„:Aâ„¤â†’Aâ„¤:ðœâ†’superscriptð´â„¤superscriptð´â„¤\tau:A^{\mathbb{Z}}\to A^{\mathbb{Z}}italic_Ï„ : italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT â†’ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT defined via a local function Î¼:ASâ†’A:ðœ‡â†’superscriptð´ð‘†ð´\mu:A^{S}\to Aitalic_Î¼ : italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT â†’ italic_A whose finite neighborhood Sð‘†Sitalic_S is an interval containing 00, and there exists pâˆˆASð‘superscriptð´ð‘†p\in A^{S}italic_p âˆˆ italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT such that Î¼â¢(z)=zâ¢(0)ðœ‡ð‘§ð‘§0\mu(z)=z(0)italic_Î¼ ( italic_z ) = italic_z ( 0 ) if and only if zâ‰ pð‘§ð‘z\neq pitalic_z â‰  italic_p. This means that such a cellular automaton Ï„ðœ\tauitalic_Ï„ will act on Aâ„¤superscriptð´â„¤A^{\mathbb{Z}}italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT almost as the identity function, except that when it reads a fixed pattern pð‘pitalic_p in a bi-infinite sequence, it will write a symbol a:=Î¼â¢(p)âˆˆAâˆ–{pâ¢(0)}assignð‘Žðœ‡ð‘ð´ð‘0a:=\mu(p)\in A\setminus\{p(0)\}italic_a := italic_Î¼ ( italic_p ) âˆˆ italic_A âˆ– { italic_p ( 0 ) }. This is equivalent of saying that Ï„ðœ\tauitalic_Ï„ has a unique active transition pâˆˆASð‘superscriptð´ð‘†p\in A^{S}italic_p âˆˆ italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT in the terminology recently introduced in [7, 9, 10]. The class of one-dimensional cellular automata with a unique active transition resemble the so-called Coven cellular automata (see [1, 8]), which were remarkably the first nontrivial class of cellular automata in which the exact computation of the topological entropy was obtained (see [14, p. 1]). However, it follows by their construction that Coven cellular automata actually have two active transitions. In [3], a wider class of cellular automata Ï„:AGâ†’AG:ðœâ†’superscriptð´ðºsuperscriptð´ðº\tau:A^{G}\to A^{G}italic_Ï„ : italic_A start_POSTSUPERSCRIPT italic_G end_POSTSUPERSCRIPT â†’ italic_A start_POSTSUPERSCRIPT italic_G end_POSTSUPERSCRIPT (where the group of integers â„¤â„¤\mathbb{Z}blackboard_Z is replaced by an arbitrary group GðºGitalic_G) with a unique active transition pâˆˆASð‘superscriptð´ð‘†p\in A^{S}italic_p âˆˆ italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT were studied. It was noticed that such CA are often idempotents, which means that Ï„âˆ˜Ï„=Ï„ðœðœðœ\tau\circ\tau=\tauitalic_Ï„ âˆ˜ italic_Ï„ = italic_Ï„; for example, it was shown that if pð‘pitalic_p is constant or symmetric (in the sense that S=Sâˆ’1ð‘†superscriptð‘†1S=S^{-1}italic_S = italic_S start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT and pâ¢(s)=pâ¢(sâˆ’1)ð‘ð‘ ð‘superscriptð‘ 1p(s)=p(s^{-1})italic_p ( italic_s ) = italic_p ( italic_s start_POSTSUPERSCRIPT - 1 end_POSTSUPERSCRIPT ), âˆ€sâˆˆSfor-allð‘ ð‘†\forall s\in Sâˆ€ italic_s âˆˆ italic_S), then Ï„ðœ\tauitalic_Ï„ is idempotent. Moreover, a full characterization of the idempotency of Ï„ðœ\tauitalic_Ï„ was given when pð‘pitalic_p is quasi-constant (i.e. there is sâˆˆSð‘ ð‘†s\in Sitalic_s âˆˆ italic_S such that p|Sâˆ–{s}evaluated-atð‘ð‘†ð‘ p|_{S\setminus\{s\}}italic_p | start_POSTSUBSCRIPT italic_S âˆ– { italic_s } end_POSTSUBSCRIPT is constant). However, the full characterization of the idempotency of Ï„:AGâ†’AG:ðœâ†’superscriptð´ðºsuperscriptð´ðº\tau:A^{G}\to A^{G}italic_Ï„ : italic_A start_POSTSUPERSCRIPT italic_G end_POSTSUPERSCRIPT â†’ italic_A start_POSTSUPERSCRIPT italic_G end_POSTSUPERSCRIPT when pð‘pitalic_p is an arbitrary pattern remains open. The main result of this paper is the characterization of the idempotency of one-dimensional cellular automata with a unique active transition pâˆˆASð‘superscriptð´ð‘†p\in A^{S}italic_p âˆˆ italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT. Furthermore, we show that when the cellular automaton is not idempotent, then it follows a specific dynamic behavior. A cellular automaton Ï„:Aâ„¤â†’Aâ„¤:ðœâ†’superscriptð´â„¤superscriptð´â„¤\tau:A^{\mathbb{Z}}\to A^{\mathbb{Z}}italic_Ï„ : italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT â†’ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT is a topological dynamical system, where the dynamics is given by the iteration of Ï„ðœ\tauitalic_Ï„. In this context, a cellular automaton is equicontinuous if all bi-infinite sequences xâˆˆAâ„¤ð‘¥superscriptð´â„¤x\in A^{\mathbb{Z}}italic_x âˆˆ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT are equicontinuous points in the sense that the trajectories of all neighbors of xð‘¥xitalic_x stay close to the trajectory of xð‘¥xitalic_x. A cellular automaton is almost equicontinuous if its equicontinuous points are dense in Aâ„¤superscriptð´â„¤A^{\mathbb{Z}}italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT, and it is strictly almost equicontinuous if it is almost equicontinuous but not equicontinuous. Before we state the main result of this paper, we introduce some notation. For k,â„“âˆˆâ„¤ð‘˜â„“â„¤k,\ell\in\mathbb{Z}italic_k , roman_â„“ âˆˆ blackboard_Z, we denote an interval by [k,â„“]:={nâˆˆâ„¤:kâ‰¤nâ‰¤â„“}assignð‘˜â„“conditional-setð‘›â„¤ð‘˜ð‘›â„“[k,\ell]:=\{n\in\mathbb{Z}:k\leq n\leq\ell\}[ italic_k , roman_â„“ ] := { italic_n âˆˆ blackboard_Z : italic_k â‰¤ italic_n â‰¤ roman_â„“ }. For a subset SâŠ†â„¤ð‘†â„¤S\subseteq\mathbb{Z}italic_S âŠ† blackboard_Z, we use the notation S+:={sâˆˆS:s>0}assignsubscriptð‘†conditional-setð‘ ð‘†ð‘ 0S_{+}:=\{s\in S:s>0\}italic_S start_POSTSUBSCRIPT + end_POSTSUBSCRIPT := { italic_s âˆˆ italic_S : italic_s > 0 } and Sâˆ’:={sâˆˆS:s<0}assignsubscriptð‘†conditional-setð‘ ð‘†ð‘ 0S_{-}:=\{s\in S:s<0\}italic_S start_POSTSUBSCRIPT - end_POSTSUBSCRIPT := { italic_s âˆˆ italic_S : italic_s < 0 }. Theorem 1. Let Ï„:Aâ„¤â†’Aâ„¤:ðœâ†’superscriptð´â„¤superscriptð´â„¤\tau:A^{\mathbb{Z}}\to A^{\mathbb{Z}}italic_Ï„ : italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT â†’ italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT be a cellular automaton with a unique active transition pâˆˆASð‘superscriptð´ð‘†p\in A^{S}italic_p âˆˆ italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT, where S:=[k,â„“]âŠ‚â„¤assignð‘†ð‘˜â„“â„¤S:=[k,\ell]\subset\mathbb{Z}italic_S := [ italic_k , roman_â„“ ] âŠ‚ blackboard_Z is such that kâ‰¤0â‰¤â„“ð‘˜0â„“k\leq 0\leq\ellitalic_k â‰¤ 0 â‰¤ roman_â„“. Let Î¼:ASâ†’A:ðœ‡â†’superscriptð´ð‘†ð´\mu:A^{S}\to Aitalic_Î¼ : italic_A start_POSTSUPERSCRIPT italic_S end_POSTSUPERSCRIPT â†’ italic_A be the corresponding local defining function for Ï„ðœ\tauitalic_Ï„. Then, Ï„ðœ\tauitalic_Ï„ is not idempotent if and only if there exists tâˆˆS+ð‘¡subscriptð‘†t\in S_{+}italic_t âˆˆ italic_S start_POSTSUBSCRIPT + end_POSTSUBSCRIPT such that pâ¢(t)=Î¼â¢(p) and pâ¢(i)=pâ¢(iâˆ’t),âˆ€iâˆˆ[k+t,â„“]âˆ–{t},formulae-sequenceð‘ð‘¡ðœ‡ð‘ and formulae-sequenceð‘ð‘–ð‘ð‘–ð‘¡for-allð‘–ð‘˜ð‘¡â„“ð‘¡p(t)=\mu(p)\quad\text{ and }\quad p(i)=p(i-t),\ \forall i\in[k+t,\ell]% \setminus\{t\},italic_p ( italic_t ) = italic_Î¼ ( italic_p ) and italic_p ( italic_i ) = italic_p ( italic_i - italic_t ) , âˆ€ italic_i âˆˆ [ italic_k + italic_t , roman_â„“ ] âˆ– { italic_t } , or there exists tâˆˆSâˆ’ð‘¡subscriptð‘†t\in S_{-}italic_t âˆˆ italic_S start_POSTSUBSCRIPT - end_POSTSUBSCRIPT such that pâ¢(t)=Î¼â¢(p) and pâ¢(i)=pâ¢(iâˆ’t),âˆ€iâˆˆ[k,â„“+t]âˆ–{t}.formulae-sequenceð‘ð‘¡ðœ‡ð‘ and formulae-sequenceð‘ð‘–ð‘ð‘–ð‘¡for-allð‘–ð‘˜â„“ð‘¡ð‘¡p(t)=\mu(p)\quad\text{ and }\quad p(i)=p(i-t),\ \forall i\in[k,\ell+t]% \setminus\{t\}.italic_p ( italic_t ) = italic_Î¼ ( italic_p ) and italic_p ( italic_i ) = italic_p ( italic_i - italic_t ) , âˆ€ italic_i âˆˆ [ italic_k , roman_â„“ + italic_t ] âˆ– { italic_t } . Moreover, Ï„ðœ\tauitalic_Ï„ is not idempotent if and only if it is strictly almost equicontinuous. In essence, Theorem 1 characterizes the idempotence of Ï„ðœ\tauitalic_Ï„ in terms of the existence of tâˆˆSâˆ–{0}ð‘¡ð‘†0t\in S\setminus\{0\}italic_t âˆˆ italic_S âˆ– { 0 } such that pâ¢(t)=Î¼â¢(p)ð‘ð‘¡ðœ‡ð‘p(t)=\mu(p)italic_p ( italic_t ) = italic_Î¼ ( italic_p ) and there is a subpattern of pð‘pitalic_p invariant with respect to the translation by tð‘¡titalic_t. One-dimensional cellular automata satisfy a well-known dichotomy that they are either almost equicontinuous or sensitive, which are considered to be chaotic systems [12, Ch. 5]. In this spirit, Theorem 1 may be considered as a dichotomy satisfied by one-dimensional cellular automata with a unique active transition, as it shows that they are either idempotent, which are trivial as dynamical systems, or strictly almost equicontinuous, which are dynamical systems with intermediate complexity. Theorem 1 also has a relevant algebraic interpretation. The monoid CAâ¢(â„¤,A)=Endâ¢(Aâ„¤)CAâ„¤ð´Endsuperscriptð´â„¤\mathrm{CA}(\mathbb{Z},A)=\text{End}(A^{\mathbb{Z}})roman_CA ( blackboard_Z , italic_A ) = End ( italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT ) consisting of the set all one-dimensional cellular automata equipped with the composition of functions has an intricate structure (see [4]), and its group of invertible elements (denoted by Autâ¢(Aâ„¤)Autsuperscriptð´â„¤\mathrm{Aut}(A^{\mathbb{Z}})roman_Aut ( italic_A start_POSTSUPERSCRIPT blackboard_Z end_POSTSUPERSCRIPT ) or ICAâ¢(â„¤,A)ICAâ„¤ð´\mathrm{ICA}(\mathbb{Z},A)roman_ICA ( blackboard_Z , italic_A )) has been widely studied (see [13, Sec. 13.2]). In this context, Theorem 1 characterizes an infinite family of idempotents in CAâ¢(â„¤,A)CAâ„¤ð´\mathrm{CA}(\mathbb{Z},A)roman_CA ( blackboard_Z , italic_A ), which is relevant as idempotents are fundamental tools in the theory of monoids (see [6]). Since it is known that Ï„âˆˆCAâ¢(â„¤,A)ðœCAâ„¤ð´\tau\in\mathrm{CA}(\mathbb{Z},A)italic_Ï„ âˆˆ roman_CA ( blackboard_Z , italic_A ) is equicontinuous if and only if Ï„ðœ\tauitalic_Ï„ has finite order (i.e. Ï„m=Ï„nsuperscriptðœð‘šsuperscriptðœð‘›\tau^{m}=\tau^{n}italic_Ï„ start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT = italic_Ï„ start_POSTSUPERSCRIPT italic_n end_POSTSUPERSCRIPT, for some mâ‰ nð‘šð‘›m\neq nitalic_m â‰  italic_n), Theorem 1 also gives the algebraic dichotomy that every one-dimensional cellular automaton with a unique active transition is either idempotent or it has infinite order. The structure of this paper is as follows. In Section 2 we fix the notation and introduce some basic properties of one-dimensional cellular automata with a unique active transition. In Section 3 we present the proof of Theorem 1. Finally, in Section 4, we discuss some open problems and future work."
https://arxiv.org/html/2411.03160v1,Hybrid Rebeca Revisited,"Hybrid Rebeca is introduced for modeling asynchronous event-based Cyber-Physical Systems (CPSs). In this work, we extend Hybrid Rebeca to allow the modeling of non-deterministic time behavior. We provide a set of rules to define the semantic model of Hybrid Rebeca models in terms of Time Transition Systems which represents an over-approximation of the reachable states of a Hybrid Rebeca model. Then, we adapt the reachability analysis algorithm of Flowâˆ—for Hybrid Rebeca models leveraging our semantic rules. This improves the analysis significantly because the previous technique relied on the reachability analysis of hybrid automata by deriving a monolithic hybrid automaton from a given Hybrid Rebeca model, leading to a huge hybrid automaton. We illustrate the applicability of our approach through a case study.","Cyber-Physical Systems (CPSs) are usually composed of distributed discrete controllers interacting with physical environment via networked communication. Nowadays, CPSs are ubiquitous in safety-critical situations such as automotive, manufacturing, and transportation. It is important to verify the safety properties of such Hybrid systems at design time before their implementation. Formal verification can be useful for this purpose, and Hybrid automata is a widely used mathematical model for modeling hybrid systems supported with many automated reachability analysis tools. We introduced Hybrid Rebeca in [15, 16], as an extension of (Timed) Rebeca [28, 26], to faithfully model asynchronously event-based CPSs. Rebeca provides an operational interpretation of the actor model through a Java-like syntax. Actors, called rebec in this language, are units of concurrency that can only communicate by asynchronous message passing. Each actor is equipped with a mailbox in which the received messages are buffered. The computation model of actors provides a suitable level of abstraction for cyber/physical components and the network to realize the full potential of CPSs. This formalism allows modeling the continuous and discrete aspects of CPSs in a unified way by introducing physical rebecs as an extension of software rebecs with real-valued variables and modes in which the physical dynamics are specified. These modes resemble the location of Hybrid automata. To compute all reachable states over a bounded time horizon and finitely many jumps for a Hybrid Rebeca model with linear dynamics, first a monolithic hybrid automaton is derived from the model. To verify the safety properties of the Hybrid Rebeca model, we conduct a reachability analysis on its corresponding Hybrid automata to inspect whether an unsafe state. It is shown that modeling a system in Hybrid Rebeca is more efficient for analysis than modeling in hybrid automata [16]. In this approach, the reachability analysis of a Hybrid Rebeca model depends on the derivation of its corresponding hybrid automaton. The number of locations in the derived automata increases exponentially as the number of discrete variables in the software rebecs or the size of the rebec mailbox increases. This makes it infeasible to verify complex systems. We remark that the reachability analysis of a hybrid automaton is generally time-bounded and the computation of all locations may not be needed as they may not be reached within the given time-bound. In our new approach, we propose a reachability analysis algorithm on Hybrid Rebeca models directly, with no need to compute hybrid automation as an intermediate model. We revise Hybrid Rebeca in both modeling and analysis aspects. For modeling a wide range of CPSs, supporting non-deterministic time behavior is required. For example, the delay of communication or completion of a cyber computation has non-deterministic time behavior. Furthermore, physical rebecs may have non-deterministic behavior due to imprecision in measuring values that affect their behavior (this is modeled through non-deterministic behavior on staying in a mode or leaving it when a guard holds). For instance, we can model the behavior of a smart sensor to non-deterministically increase the temperature or decrease when it exceeds a limit. We extend Hybrid Rebeca to support modeling non-deterministic time behaviors, realized by the notion of Time Intervals, and allowing non-deterministic behavior for physical rebecs (whether staying or exiting a mode). For the analysis, instead of generating hybrid automata and then computing their reachable states, we compute the reachable states of a Rebeca model directly. As it is well-known the problem of computing the reachable states of a hybrid automaton is undecidable [3] as the non-linear differential equations governing the dynamics of real-valued variables can not be solved. There are many algorithms that approximately solve such equations and compute an over-approximation for the reachable state set in a bounded time interval. If the over-approximated set does not contain any unsafe state, then we can conclude that the system is safe. Most of these algorithms follow a scheme called flowpipe construction [30]. Given a bounded time horizon [0,Î”]0Î”[0,\Delta][ 0 , roman_Î” ], an over-approximation of the reachable set in [0,Î”]0Î”[0,\Delta][ 0 , roman_Î” ] is iteratively computed as sets of â„±1,â€¦,â„±Nsubscriptâ„±1â€¦subscriptâ„±ð‘\mathcal{F}_{1},\ldots,\mathcal{F}_{N}caligraphic_F start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , â€¦ , caligraphic_F start_POSTSUBSCRIPT italic_N end_POSTSUBSCRIPT such that â„±isubscriptâ„±ð‘–\mathcal{F}_{i}caligraphic_F start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT for each 1â‰¤iâ‰¤N1ð‘–ð‘1\leq i\leq N1 â‰¤ italic_i â‰¤ italic_N is an over-approximation of the reachable set over [0,Î”]0Î”[0,\Delta][ 0 , roman_Î” ]. Given a Hybrid Rebeca model, we seek to over-approximate the set of the states that is reachable in a bounded time horizon [0,Î”]0Î”[0,\Delta][ 0 , roman_Î” ] and with at most Jð½Jitalic_J depth of the semantic model, where Î”Î”\Deltaroman_Î” and Jð½Jitalic_J are user-specified. The bound on the depth is needed when there are many state changes in a small time interval. We first give the semantic model of the extended Hybrid Rebeca in terms of Timed Transition System (TTS) with immediate transitions (taken in zero time) and time-progressing transitions. Then, we adapt the reachability analysis of Hybrid automata [6] to handle the time-progressing transitions. When time progresses, the real-valued variables of physical rebecs should be approximately computed employing the flowpipe construction algorithm of hybrid automata of [6]. The termination of the algorithm is ensured since we bound the time horizon as well as the jump depth. We define the semantic model of extended Hybrid Rebeca based on the standard semantics of Timed-Rebeca, i.e., TTSs. The global states of a model are defined by the local states of software and physical rebecs and the global time. The local states of rebecs are defined based on their local variable values and message queues. Furthermore, the local states of physical rebecs contain a mode that specifies differential equations, invariant, and a guard. The invariant of a mode indicates how long a physical rebec remains in a mode while a guard expresses the condition for changing the mode. We can abstract away the concrete values of real values from the local states by considering the mode of physical rebecs. Such abstraction allows us to consider the local states of physical rebecs equal when they only differ in their variable values. We merge those states so that the local states of their rebecs are equal but the global time is different by converting the global time into an interval and associating an interval to the real variables based on the global time interval. We represent all messages that a physical rebec can send within an interval with different real-valued parameters by one message by aggregating their parameter and arrival times into intervals. We provide a set of operational semantic rules that derive TTSs with appropriate interval values. The proposed rules are designed based on the occurrences of events leading to state changes such as taking a message from a mailbox by a rebec or executing statements for processing messages. Our contributions are summarised as follows: â€¢ extending Hybrid Rebeca with time non-deterministic behavior by allowing non-deterministic delay on computation, network communication, or physical mode management; â€¢ providing a semantic model based on the Timed Transition system in which states that only differ by their global time and real-valued variables are merged (while these continuous values are handled by intervals of values); â€¢ Providing the algorithm and tool for state-space generation of Hybrid Rebeca models using existing tools for the reachability analysis of hybrid automata; â€¢ illustrating the applicability of our approach through a case study."
https://arxiv.org/html/2411.02386v1,Reachability in One-Dimensional Pushdown Vector Addition Systems is Decidable,"We consider the model of one-dimensional Pushdown Vector Addition Systems (1-PVAS), a fundamental computational model simulating both recursive and concurrent behaviours. Our main result is decidability of the reachability problem for 1-PVAS, an important open problem investigated for at least a decade. In the algorithm we actually consider an equivalent model of Grammar Vector Addition Systems (GVAS). We prove the main result by showing that for every one-dimensional GVAS (1-GVAS) one can compute another 1-GVAS, which has the same reachability relation as the original one and additionally has the so-called thin property. Due to the work of Atig and Ganty from 2011, thin 1-GVAS have decidable reachability problem, therefore our construction implies decidability of the problem for all 1-GVAS. Moreover, we also show that if reachability in thin 1-GVAS can be decided in elementary time then also reachability in all 1-GVAS can be decided in elementary time.","Automata extended with counters or with a pushdown are one of the most fundamental computational models with countless applications in both theory and practice (see [Sch16b, BEM97, EN94]). In turn, one of the most natural decision problems for a computational model is the emptiness problem asking whether its language is empty or, equivalently, the reachability problem asking whether there exists a run of this model between given source and target configurations. It is a folklore that the reachability problem becomes undecidable for automata with two pushdowns and even with nonnegative integer counters equipped with zero-tests. This last model is also often called the Minsky machines, as the undecidability was shown by Marvin Minsky in 1967 [Min67]. The proof essentially shows that automata with two zero-tested counters are Turing powerful and the result follows from the undecidability of the halting problem for Turing machines. Since so seemingly simple models already have undecidable reachability problems, the community has been exploring various simpler models for decades, notably a two classical models, which in very natural ways simulate recursion and concurrency. The first prominent example is the pushdown automaton, which is a fundamental model for simulating recursion. The reachability problem for pushdown automata can be rather easily shown to be in polynomial time [HU79] and many techniques are developed for various algorithmic problems for pushdown automata. The second very widely investigated model is automata with nonnegative integer counters, but without the possibility of zero-testing them. These are Vector Addition Systems with States (VASS) and is essentially equivalent to Petri nets, which are popular for modelling concurrent processes [vdA98]. Algorithmic properties of VASS together with its central reachability problem are studied for decades, however the complexity of the reachability problem was established only recently. The problem is known to be decidable in Ackermann [LS19] and also Ackermann-hard [Ler21, CO21], which implies Ackermann-completeness. Despite the fact that the complexity of the reachability problem is settled, many related questions are still open, for example the complexity of the problem for fixed number of counters. Thus, one may say that there is already some understanding of how to solve algorithmic problems for VASS, a fundamental model for concurrent programs. However, the picture is much less clear if we would like to model recursion and concurrency together. One such model is automaton with two resources: one pushdown and many counters, it is called Pushdown Vector Addition System (PVAS). Decidability of the reachability problem for that model is open for a long time and has been unofficially conjectured to be decidable. It was called a long-standing open problem already in 2011 (see the abstract of [AG11]). The reachability problem for PVAS was mentioned and researched a lot in the last decade [LPS14, LT17, Laz19]. Importantly, even for the one-dimensional case the coverability, reachability and related problems were investigated [LST15a, LST15b, EHL+21] and notably, this investigation led to an important progress on the VASS reachability problem [CLL+19] (see the explanation here [Laz19]). Despite of all of that efforts, decidability of the reachability problem for one-dimensional PVAS still remains a stubborn obstacle for a progress in this area. It seems that in automata theory, there are well-developed techniques for handling pushdown (i.e., recursion), some methods for managing multiple counters (i.e., concurrency), but there exist no matured techniques for dealing with both pushdown and counters (or both recursion and concurrency) at the same time. Perhaps surprisingly, there is no strong evidence that these problems are extremely hard computationally, the best known lower complexity bound for the reachability problem for the one-dimensional PVAS is PSpace-hardness [BFG+15]. The big gap in the known complexity bounds suggests that quite possibly some insightful techniques still wait for being invented and explored, which motivates our search in this direction. Related research Even though decidability of the reachability problem for PVAS is still open, even in dimension one, some progress has been made towards it. Most of the existing results rely on the fact that the class of languages of PVAS is equal to the class of languages of Grammar Vector Addition Systems (GVAS) and the transformations in both ways are effective [LST15b] (similarly as for languages of pushdown automata and languages of context-free grammars). A dð‘‘ditalic_d-dimensional GVAS (d-GVAS) is just a context-free grammar, where the terminals are vectors in â„¤dsuperscriptâ„¤ð‘‘\mathbb{Z}^{d}blackboard_Z start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT. A derivation of a d-GVAS is a valid derivation from a vector sâˆˆâ„•dð‘ superscriptâ„•ð‘‘s\in\mathbb{N}^{d}italic_s âˆˆ blackboard_N start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT to a vector tâˆˆâ„•dð‘¡superscriptâ„•ð‘‘t\in\mathbb{N}^{d}italic_t âˆˆ blackboard_N start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT if starting at sð‘ sitalic_s and adding up consecutive vectors from the yield of the derivation we never go below zero on any dimension, and at the end reach vector tð‘¡titalic_t. The GVAS are often much more convenient than PVAS for designing algorithms, thus majority of the results focus on this model. We also formulate our results using the terminology of GVAS. In 2011 Atig and Ganty have proven decidability of GVAS emptiness in the special case when the input GVAS has a finite-index [AG11], we show that finite-index GVAS are actually equivalent to thin GVAS. The class is quite restricted, however it contains for example linear grammars. We build our contribution on the work of Atig and Ganty. In [LPS14] Leroux, Praveen and Sutre showed that if the reachability set of a PVAS is finite than it is of size at most hyper-Ackermannian, which immediately implies decidability of the boundedness problem, asking whether the reachability set is finite. Interestingly the bound is tight and the hyper-Ackermannian size of the reachability sets can indeed be obtained as shown in the same paper [LPS14]. This suggests that the reachability problem for PVAS might be HyperAckermann-hard, but no results of this kind have been obtained and the best complexity lower bound for the problem is still the Ackermann-hardness inherited from Vector Addition Systems [Ler21, CO21]. Further progress on the boundedness problem for 1-GVAS was achieved by Leroux, Sutre and Totzke in [LST15a], however it does improve the complexity of this problem. In [LST15b] the same authors have proven that the coverability problem, asking whether a given configuration can be covered, is decidable for 1-GVAS. Moreover, at the end of their paper, they remark that the given algorithm works in exponential space. Interestingly, for PVAS the reachability and the coverability problem are interreducible (to our best knowledge it is first mentioned in [Laz13], but without a proof), in a sheer contrast to Vector Addition Systems, where the coverability problem is ExpSpace-complete [Lip76, Rac78], while the reachability problem is Ackermann-complete [LS19, Ler21, CO21]. The reduction of the coverability problem for of dð‘‘ditalic_d-dimensional PVAS (d-PVAS) to the reachability problem for d-PVAS is immediate. On the other hand the reachability problem for d-PVAS can be reduced to the coverability problem for (d+1)ð‘‘1(d+1)( italic_d + 1 )-PVAS by a simple, but clever construction: the additional (d+1)ð‘‘1(d+1)( italic_d + 1 )-th counter is used to keep the sum of the counters constant along the run; its initial value is guessed at the beginning of the run, remembered at the bottom of the stack and checked at the end of the run. Therefore, there is hierarchy of problems of increasing hardness for PVAS: coverability for 1-PVAS, reachability for 1-PVAS, coverability for 2-PVAS, reachability for 2-PVAS, etc. As the coverability problem is known to be decidable for 1-PVAS the next natural next step towards understanding the reachability-type problems for PVAS seems to be solving the reachability problem for 1-PVAS, which is the topic of this paper. There is also a lot of research on the models related to PVAS, which does not directly motivate our direction, but gives a broader view on the area and witnesses a vivid interest of the community in this kind of problems. The investigated models are often a slight relaxations of PVAS, for which decidability results about the reachability problem are known. A special case of a pushdown is a counter, which can be zero tested. It is known that the reachability problem is decidable for VASS with one zero-test (one counter allowed to be zero-tested) [Rei08, Bon11] and even with hierarchical zero-tests [Rei08, Gut24]. In dimension two even more is known. For 2-VASS with one zero-test in [LS20] it is shown that similarly as for 2-VASS the reachability relation is semilinear and the reachability problem is PSpace-complete, thus in this case the zero-test is practically for free. The reachability problem is decidable even for 2-VASS with one zero-test and one reset [FLS18]. If we allow counters of PVAS to drop below zero we obtain a model of â„¤â„¤\mathbb{Z}blackboard_Z-PVAS. For â„¤â„¤\mathbb{Z}blackboard_Z-PVAS it is known that the reachability relation is semilinear [HIKS02] and the reachability problem is decidable [HIKS02] and even NP-complete [HL11]. Another recently studied model related to PVAS is a bidirected PVAS: we demand that for each transition in a PVAS there exists another transition, which reverses the effect of the first one. Ganardi et al. show in [GMZ22] that the reachability problem in bidirected PVAS is decidable in Ackermann and is Tower-hard. Moreover they prove that in each fixed dimension it is primitive recursive and in dimension one it is in PSpace. However, the techniques from many above mentioned papers, like [FLS18, HL11, GMZ22] cannot be directly of use, as they rely on the fact that the reachability relation in 2-VASS with zero-test and reset, in â„¤â„¤\mathbb{Z}blackboard_Z-PVAS and in bidirected PVAS, respectively, is semilinear (in other words Presburger definable). This is unfortunately not the case already for 1-PVAS, which is rather easy to show (see Example 2.1. in [LPSS19]). Our contribution The main contribution of this paper is the following theorem. Theorem 1. The reachability problem for one-dimensional Grammar Vector Addition Systems is decidable. The proof strongly relies on our conceptual contribution of partitioning the nonterminals of 1-GVAS into thin and branching ones, and treat them differently. This division can actually be defined for any context-free grammar, regardless of whether the terminals are integers (as in 1-GVAS), vectors in â„¤dsuperscriptâ„¤ð‘‘\mathbb{Z}^{d}blackboard_Z start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT (as in d-GVAS), or letters from a finite alphabet. We say that a nonterminal Xð‘‹Xitalic_X is branching if, intuitively, it can create two copies of itself; specifically, this means there is a derivation of the form Xâ‡’Î±â¢Xâ¢Î²â¢Xâ¢Î³â‡’ð‘‹ð›¼ð‘‹ð›½ð‘‹ð›¾X\Rightarrow\alpha X\beta X\gammaitalic_X â‡’ italic_Î± italic_X italic_Î² italic_X italic_Î³ for some sequences Î±ð›¼\alphaitalic_Î±, Î²ð›½\betaitalic_Î² and Î³ð›¾\gammaitalic_Î³ of nonterminals and terminals. Otherwise, for any derivation Xâ‡’Î±â¢Xâ¢Î²â‡’ð‘‹ð›¼ð‘‹ð›½X\Rightarrow\alpha X\betaitalic_X â‡’ italic_Î± italic_X italic_Î², no nonterminal from Î±ð›¼\alphaitalic_Î± or Î²ð›½\betaitalic_Î² can generate Xð‘‹Xitalic_X, and Xð‘‹Xitalic_X is said to be thin. We call a GVAS thin if all its nonterminals are thin. It turns out that both thin and branching nonterminals have nice properties, but these properties are useful in very different situations. Therefore the partition of nonterminals into thin and branching is very helpful for the analysis of 1-GVAS, and potentially, may be helpful also for future research on higher dimensional GVAS. We strongly rely on the work of Atig and Ganty, who showed in [AG11] that the reachability problem is decidable for a subclass of GVAS called finite-index GVAS. They are equivalent to thin GVAS. Therefore, to show Theorem 1 it is enough to eliminate branching nonterminals from a 1-GVAS. This is indeed possible, as shown in the core of our technical contribution, the following theorem. Theorem 2. There is an algorithm, which given a 1-GVAS GðºGitalic_G produces a thin 1-GVAS Hð»Hitalic_H with the same reachability relation. Moreover, the size of the produced thin 1-GVAS Hð»Hitalic_H is bounded by s=fâ¢(sizeâ¢(G))ð‘ ð‘“sizeðºs=f(\textup{size}(G))italic_s = italic_f ( size ( italic_G ) ) for some triply-exponential function fð‘“fitalic_f and the construction works in time sâ‹…gâ¢(s)â‹…ð‘ ð‘”ð‘ s\cdot g(s)italic_s â‹… italic_g ( italic_s ), where gð‘”gitalic_g is the time complexity of the reachability problem for thin 1-GVAS. It is not clear how to obtain function fð‘“fitalic_f in Theorem 2 smaller than triply-exponential (see Remark 9). Therefore, even if the complexity of reachability for thin 1-GVAS is very low we cannot get a very low complexity for 1-GVAS using Theorem 2 directly. However, it is natural to conjecture that the complexity of reachability for 1-GVAS is elementary. We leave this problem open, but we notice that Theorem 2 immediately implies the following corollary, which makes designing an elementary algorithm for 1-GVAS easier. Corollary 3. If the complexity of the reachability problem for thin 1-GVAS is elementary then the complexity of the reachability problem for 1-GVAS is elementary (without the thinness assumption). The rest of the paper is organised as follows. In Section 2 we introduce preliminary notions. Then, in Section 3 we give an intuitive overview on the main ideas behind our contribution, formulate key Lemmas 10, 11 and 12 and show how they imply Theorem 2. In the following sections we prove the auxiliary lemmas. In Section 4 we show Lemma 10. Next, in Section 5 we provide the most challenging proof of Lemma 11. Further, in Section 6 we prove Lemma 12. Finally, in Section 7 we discuss possible interesting future research directions."
https://arxiv.org/html/2411.00205v1,Compositional Automata Embeddings for Goal-Conditioned Reinforcement Learning,"Goal-conditioned reinforcement learning is a powerful way to control an AI agentâ€™s behavior at runtime. That said, popular goal representations, e.g., target states or natural language, are either limited to Markovian tasks or rely on ambiguous task semantics. We propose representing temporal goals using compositions of deterministic finite automata (cDFAs) and use cDFAs to guide RL agents. cDFAs balance the need for formal temporal semantics with ease of interpretation: if one can understand a flow chart, one can understand a cDFA. On the other hand, cDFAs form a countably infinite concept class with Boolean semantics, and subtle changes to the automaton can result in very different tasks, making them difficult to condition agent behavior on. To address this, we observe that all paths through a DFA correspond to a series of reach-avoid tasks and propose pre-training graph neural network embeddings on â€œreach-avoid derivedâ€ DFAs. Through empirical evaluation, we demonstrate that the proposed pre-training method enables zero-shot generalization to various cDFA task classes and accelerated policy specialization without the myopic suboptimality of hierarchical methods.","Goal-conditioned reinforcement learning (RL) [33] has proven to be a powerful way to create AI agents whose task (or goal) can be specified (conditioned on) at runtime. In practice, this is done by learning a goal encoder, i.e., a mapping to dense vectors, and passing the encoded goals as inputs to a policy, e.g., a feedforward neural network. This expressive framework enables the development of flexible agents that can be deployed in a priori unknown ways, e.g., visiting states never targeted during training. The rise of large language models has popularized leveraging natural language as an ergonomic means to specify a task, e.g., â€œpick up the onions, chop them, and take them to stove.â€ While incredibly powerful, tasks specified by target states or natural language have a number of shortcomings. First and foremost, target states are necessarily limited to non-temporal tasks. On the other hand, natural language is, by definition, ambiguous, providing little in the way of formal guarantees or analysis of what task is being asked of the AI agent. To this end, we consider conditioning on tasks in the form of Boolean combinations of deterministic finite automata (DFAs). We refer to this concept class as compositional DFAs (cDFAs). The choice of cDFAs as the concept class is motivated by three observations. First and foremost, DFAs offer simple and intuitive semantics that require only a cursory familiarity with formal languagesâ€“if one can understand a flow chart, one can understand a DFA. Moreover, recent works have demonstrated that DFA and cDFA can be learned in a few shot manner from expert demonstrations and natural language descriptions [41]. As such, DFAs offer a balance between the accessibility of natural language and rigid formal semantics. The addition of Boolean combinations to cDFA, e.g., perform task 1 AND task 2 AND task 3, provides a simple mechanism to build complicated tasks from smaller ones. Second, DFAs represent temporal tasks that become Markovian by augmenting the state-space with finite memory. Further, they are the â€œsimplestâ€ family to do so since their finite states are equivalent to having a finite number of sub-tasks, formally Nerode congruences [19]. This is particularly important for goal-conditioned RL which necessarily treats temporal tasks differently than traditional RL. For traditional RL, because the task is fixed, one can simply augment the state space with the corresponding memory to make the task Markovian. In goal-conditioned RL, this is not, in general, possible as it is unclear what history will be important until the task is provided. Instead, the encoded task must relay to the policy this temporal information. Third, existing formulations like temporal logics over finite traces and series of reach-avoid tasks are regular languages and thus are expressible as DFAs [11]. This makes DFAs a natural target for conditioning an RL policy on temporal tasks. The expressivity of DFAs introduces a number of challenges for goal-conditioned RL. First, DFAs form a countably infinite and exponentially growing concept class where subtle changes in the DFA can result in large changes in an agentâ€™s behavior. Notably, this means that any distribution over DFAs is necessarily biased with many â€œsimilarâ€ DFAs having drastically different probability. Thus, to generally work with DFAs, one cannot simply match finite patterns, but need to learn to encode details necessary for planning. Second, as with traditional goal-based objectives, DFAs provide a very sparse binary reward signalâ€“did you reach the accepting state or not? Together with non-trivial dynamics, naÃ¯ve applications of RL become infeasible due to the lack of dense reward signal. Finally, the exponentially-expanding concept class presents computational limitations for encoding. For example, many interesting DFAs may be too large to be feasibly processed by a graph neural network. To address these issues of reward sparsity and the need to encode planning, we introduce a distribution of DFAs, called reach-avoid derived (RAD). This concept class is inspired by the observation that all paths through a DFA correspond to a series of (local) reach-avoid problems. We argue in Section 4 that RAD encourages learning to navigate a DFAâ€™s structure. Our first key result is that pre-training DFA encoders on RAD DFAs enables zero-shot generalization to other DFAs. Next, we treat the problem of DFA size. Many problems are naturally expressed compositionally, e.g., a sequence of rules that must all hold or a set of tasks of which at least one must be accomplished. Due to their Boolean semantics, i.e., did you reach the accepting state or not, DFAs offer well-defined semantics under Boolean compositions. Our second key insight is to encode conjunctions111With negations and disjunctions omitted as straightforward extensions. of DFAs (called cDFAs). This is done by using a graph attention network [9] (GATv2) to encode the individual DFA graph structure as well as the conjunction (AND) relationships between a collection of tasks. Recalling that the conjunction of any two DFAs grows (worst-case) quadratically, we observe that cDFAs offer an exponential reduction in the size of temporal tasks passed to GATv2. 1.1 Contributions Our main contributions are: (1) we propose compositional DFAs (cDFAs), which balance formal semantics, accessibility, and expressivity, as a goal representation for temporal tasks in goal-conditioned RL; (2) we propose encoding cDFAs using graph attention networks (GATv2); (3) we propose pre-training the cDFA encoder on reach-avoid derived (RAD) DFAs, and (4) we perform experiments demonstrating strong zero-shot generalization of pre-training on RAD DFAs. 1.2 Related Work Our work explores a temporal variant of goal-conditioned RL [33] where goals are represented as automata. While traditionally focused on goals as future target states, this has since been extended to tasks such as natural language [7, 21, 26, 37] and temporal logic [38]. While not as expressive as natural language, we believe cDFAs offer a balance between the ergonomics of language while maintaining unambiguous semanticsâ€“something of increasing importance due to the seemingly inevitable proliferation of AI agents to safety-critical systems. Moreover, DFA inference has a rich literature [6, 15, 17, 24, 27, 28, 45] with recent works have even shown the ability to learn DFA and cDFA from natural language and expert demonstrationsâ€“bridging the gap even more between natural language and automata specified goals [41, 42, 43]. Operating in a similar space, previous work, LTL2Action [38], has shown success with using (finite) linear temporal logic (LTL), a modal extension of propositional logic, to condition RL policies on. In fact, the pre-training and test domains used in this paper are directly derived from that work. Our choice to focus on DFA rather than LTL is two-fold. First and foremost, over finite traces, LTL is strictly less expressive than DFA. For example, LTL cannot express tasks such as â€œthe number of times the light switch is toggled should be even.â€ Second, like DFA, LTL tasks constitute a countably infinite set of tasks. This again means that any distribution over LTL is necessarily biased to certain subclasses. On the one hand, the syntactic structure makes separation of subclasses very easy. On the other, it remains unclear how to generalize to â€œcommonâ€ LTL formula. By contrast, we argue that the local reach-avoid structure of DFAs offers a direct mechanism for generalization. Finally, we note that while LTL is exponentially more succinct than DFA, this is largely mitigated by supporting boolean combinations of DFAs (cDFAs). Moving away from goal-conditioned RL, recent works have proposed performing symbolic planning on the DFA and cleverly stringing together policies to realize proposed paths [16, 22, 23, 30]. However, their method can still suffer from sub-optimality due to their goal-conditioned value functions being myopic. Specifically, if there are multiple ways to reach the next sub-goal of a temporal task, the optimality of the next action depends on the entire plan, not just the next sub-goalâ€“destroying the compositional structure used for planning. For example, Figure 4 shows a simple example in which hierarchical approaches will find a suboptimal solution due to their myopia. In contrast, conditioning on cDFA embeddings allows our policies to account for the entire task. On the single-task LTL-constrained policy optimization side, several works have tackled the problem in varying settings [10, 13, 36, 44]. Adjacent to these efforts, various approaches have explored LTL specifications and automaton-like models as objectives in RL [2, 3, 8, 12, 14, 20, 29, 32, 46, 48]. A different line of work considers leveraging quantitative semantics of specifications to shape the reward [1, 22, 25, 36]. However, all of these lines of work are limited to learning a single, fixed goal. Finally, in our previous work [47], we used hindsight experience replay [5] to solve the reward sparsity problem for DFA-conditioned off-policy learning of DFA task classes. We observe that our RAD pre-training pipeline has similar sample efficiency while generalizing to larger classes of DFAs."
https://arxiv.org/html/2411.00117v1,Openness and Partial Adjacency in One Variable TPTL.,"Metric Temporal Logic (MTL) and Timed Propositional Temporal Logic (TPTL) are prominent real-time extensions of Linear Temporal Logic (LTL). MTL extends LTL modalities, Until, ð–´ð–´\>\mathsf{U}sansserif_U and Since, ð–²ð–²\>\mathsf{S}sansserif_S to family of modalities ð–´Isubscriptð–´ð¼\>\mathsf{U}_{I}sansserif_U start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT and ð–²Isubscriptð–²ð¼\>\mathsf{S}_{I}sansserif_S start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT, respectively, where Ið¼Iitalic_I is an interval of the form âŸ¨l,uâŸ©ð‘™ð‘¢\langle l,u\rangleâŸ¨ italic_l , italic_u âŸ© to express real-time constraints. On the contrary, TPTL extends LTL by real-valued freeze quantification, and constraints over those freeze variables to do the same. It is well known that one variable fragment of TPTL is strictly more expressive than MTL. In general, the satisfiability checking problem for both MTL and TPTL is undecidable. MTL enjoys the benefits of relaxing punctuality. That is, satisfiability checking for Metric Interval Temporal Logic (MITL), a subclass of MTL where the intervals are restricted to be of the form âŸ¨l,uâŸ©ð‘™ð‘¢\langle l,u\rangleâŸ¨ italic_l , italic_u âŸ© where l<uð‘™ð‘¢l<uitalic_l < italic_u, is decidable with elementary complexity (EXPSPACE complete). Moreover, Partially Punctual Metric Temporal Logic (PMTL), a subclass of MTL where punctual intervals are only allowed in either ð–´ð–´\>\mathsf{U}sansserif_U modalities or ð–²ð–²\>\mathsf{S}sansserif_S modalities, but not both, is also decidable over finite timed words with non-primitive recursive complexity.In case of TPTL, punctuality can be trivially recovered due to freeze quantifiers and boolean over guards. Hence, we study a more restrictive version of non-punctuality, called Openness. Intuitively, this restriction only allows a property to be specified within timing intervals which are topologically open. We show that even with this restriction, 1-TPTL is undecidable. Our results make a case for a the new refined notion of non-adjacency by Krishna et. al. for getting a decidable fragment of 1-TPTL, called non-adjacency. We extend the notion of non-adjacency to partial adjacency, where the restriction is only applicable in either past or future but not in both directions. We show that partially adjacent 1- TPTL (PA-1-TPTL) is decidable over finite timed words. Moreover, it is strictly more expressive than PMTL, making it the most expressive boolean closed decidable timed logic known in the literature.","Metric Temporal Logic ð–¬ð–³ð–«â¢[ð–´I,ð–²I]ð–¬ð–³ð–«subscriptð–´ð¼subscriptð–²ð¼\mathsf{MTL}[\>\mathsf{U}_{I},\>\mathsf{S}_{I}]sansserif_MTL [ sansserif_U start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT , sansserif_S start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT ] is a well established logic useful for specifying quantitative properties of real-time systems. The main modalities of ð–¬ð–³ð–«ð–¬ð–³ð–«\mathsf{MTL}sansserif_MTL are ð–´Isubscriptð–´ð¼\>\mathsf{U}_{I}sansserif_U start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT (read â€œuntil Ið¼Iitalic_Iâ€) and ð–²Isubscriptð–²ð¼\>\mathsf{S}_{I}sansserif_S start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT (read â€œsince Ið¼Iitalic_Iâ€), where Ið¼Iitalic_I is a time interval with endpoints in â„•â„•\mathbb{N}blackboard_N. These formulae are interpreted over timed behaviours or timed words. For example, a formula aâ¢ð–´[2,3]â¢bð‘Žsubscriptð–´23ð‘a\>\mathsf{U}_{[2,3]}bitalic_a sansserif_U start_POSTSUBSCRIPT [ 2 , 3 ] end_POSTSUBSCRIPT italic_b is satisfied by a position ið‘–iitalic_i of a timed word ÏðœŒ\rhoitalic_Ï if and only if there is a position jð‘—jitalic_j strictly in the future of ið‘–iitalic_i where bð‘bitalic_b is true, and at all intermediate positions between ið‘–iitalic_i and jð‘—jitalic_j, að‘Žaitalic_a is true; moreover, the difference in the timestamps of ið‘–iitalic_i and jð‘—jitalic_j must lie in the interval [2,3]23[2,3][ 2 , 3 ]. Similarly, aâ¢ð–²[2,3]â¢bð‘Žsubscriptð–²23ð‘a\>\mathsf{S}_{[2,3]}bitalic_a sansserif_S start_POSTSUBSCRIPT [ 2 , 3 ] end_POSTSUBSCRIPT italic_b is true at a point ið‘–iitalic_i if and only if there is a position jð‘—jitalic_j strictly in the past of ið‘–iitalic_i where bð‘bitalic_b is true, and at all intermediate positions between ið‘–iitalic_i and jð‘—jitalic_j, að‘Žaitalic_a is true; further, the difference in the timestamps between ið‘–iitalic_i and jð‘—jitalic_j lie in the interval [2,3]23[2,3][ 2 , 3 ]. In their seminal paper, Alur and Henzinger [4] showed that the satisfiability of full ð–¬ð–³ð–«ð–¬ð–³ð–«\mathsf{MTL}sansserif_MTL, with until and since modalities is undecidable even over finite words. This ability to encode undecidable problems is due to the presence of punctual intervals, i.e., intervals of the form [x,x]ð‘¥ð‘¥[x,x][ italic_x , italic_x ]. This allows the logic to specify constraints like â€œan event að‘Žaitalic_a occurs exactly after 5 time units, âŠ¤ð–´[5,5]â¢atopsubscriptð–´55ð‘Ž\top\>\mathsf{U}_{[5,5]}aâŠ¤ sansserif_U start_POSTSUBSCRIPT [ 5 , 5 ] end_POSTSUBSCRIPT italic_a.â€ In practice, such exact constraints are not used extensively. Hence, Alur et al. studied the non-punctual fragment of MTL called Metric Interval Temporal Logic (MITL) in [2] [1] where the time intervals used in the until, since modalities are non-punctual, i.e. of the form âŸ¨x,yâŸ©ð‘¥ð‘¦\langle x,y\rangleâŸ¨ italic_x , italic_y âŸ© where x<yð‘¥ð‘¦x<yitalic_x < italic_y. They show that the satisfiability becomes decidable over finite as well as infinite timed words with EXPSPACE complexity. The satisfiability of the future only fragment of ð–¬ð–³ð–«ð–¬ð–³ð–«\mathsf{MTL}sansserif_MTL, where since modalities are not used (MTL[ð–´Isubscriptð–´ð¼\>\mathsf{U}_{I}sansserif_U start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT]), was open for a long time. Ouaknine and Worrell [16] showed its decidability via a reduction to 1-clock Alternating Timed Automata over finite timed words. A natural extension to both these problems studied in [1][2] [16] is to ask what happens to the decidability and expressiveness of ð–¬ð–³ð–«â¢[ð–´I,ð–²nâ¢p]ð–¬ð–³ð–«subscriptð–´ð¼subscriptð–²ð‘›ð‘\mathsf{MTL}[\>\mathsf{U}_{I},\>\mathsf{S}_{np}]sansserif_MTL [ sansserif_U start_POSTSUBSCRIPT italic_I end_POSTSUBSCRIPT , sansserif_S start_POSTSUBSCRIPT italic_n italic_p end_POSTSUBSCRIPT ], subclass of MTL where ð–²ð–²\>\mathsf{S}sansserif_S modalities are non-punctual, when interpreted over finite timed words. This was resolved by Krishna et. al. in [9]. Timed Propositional Temporal Logic (TPTL) extends LTL with freeze quantifiers. A freeze quantifier [3][5] has the form x.Ï†formulae-sequenceð‘¥ðœ‘x.\varphiitalic_x . italic_Ï† with freeze variable xð‘¥xitalic_x (also called a clock [6][18]). When it is evaluated at a point ið‘–iitalic_i on a timed word, the time stamp of ið‘–iitalic_i (say Ï„isubscriptðœð‘–\tau_{i}italic_Ï„ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT) is frozen or registered in xð‘¥xitalic_x, and the formula Ï†ðœ‘\varphiitalic_Ï† is evaluated using this value for xð‘¥xitalic_x. Variable xð‘¥xitalic_x is used in Ï†ðœ‘\varphiitalic_Ï† in a constraint of the form Tâˆ’xâˆˆIð‘‡ð‘¥ð¼T-x\in Iitalic_T - italic_x âˆˆ italic_I; this constraint, when evaluated at a point jð‘—jitalic_j, checks if Ï„jâˆ’Ï„iâˆˆIsubscriptðœð‘—subscriptðœð‘–ð¼\tau_{j}-\tau_{i}\in Iitalic_Ï„ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT - italic_Ï„ start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT âˆˆ italic_I, where Ï„jsubscriptðœð‘—\tau_{j}italic_Ï„ start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT is the time stamp at point jð‘—jitalic_j. Here Tð‘‡Titalic_T can be seen as a special variable giving the timestamp of the present point. For example, the formula Ï†=â—‡â¢x.(aâˆ§â—‡â¢(bâˆ§Tâˆ’xâˆˆ[1,2]âˆ§â—‡â¢(câˆ§Tâˆ’xâˆˆ[1,2])))formulae-sequenceðœ‘â—‡ð‘¥ð‘Žâ—‡ð‘ð‘‡ð‘¥12â—‡ð‘ð‘‡ð‘¥12\varphi=\Diamond x.(a\wedge\Diamond(b\wedge T-x\in[1,2]\wedge\Diamond(c\wedge T% -x\in[1,2])))italic_Ï† = â—‡ italic_x . ( italic_a âˆ§ â—‡ ( italic_b âˆ§ italic_T - italic_x âˆˆ [ 1 , 2 ] âˆ§ â—‡ ( italic_c âˆ§ italic_T - italic_x âˆˆ [ 1 , 2 ] ) ) ) asserts that there is a point ið‘–iitalic_i in the future where að‘Žaitalic_a holds and in its future there is a bð‘bitalic_b within interval [1,2]12[1,2][ 1 , 2 ] followed by a cð‘citalic_c within interval [1,2]12[1,2][ 1 , 2 ] from ið‘–iitalic_i. The contributions of this paper are two fold: (1) We study the satisfiability checking problem for a restricted fragment of the TPTL that can only specify properties within topologically open timing intervals. We call this fragment as Open TPTL (denoted by ð–®ð—‰ð–³ð–¯ð–³ð–«1superscriptð–®ð—‰ð–³ð–¯ð–³ð–«1\mathsf{OpTPTL}^{1}sansserif_OpTPTL start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT). Notice that the restriction of openness is more restrictive than that of non-punctuality, and with openness punctual guards can not be simulated even with the use of freeze quantifiers and boolean operators. In spite of such a restriction, we show that satisfiability checking of ð–®ð—‰ð–³ð–¯ð–³ð–«1superscriptð–®ð—‰ð–³ð–¯ð–³ð–«1\mathsf{OpTPTL}^{1}sansserif_OpTPTL start_POSTSUPERSCRIPT 1 end_POSTSUPERSCRIPT is as hard as that of 1-ð–³ð–¯ð–³ð–«ð–³ð–¯ð–³ð–«\mathsf{TPTL}sansserif_TPTL (i.e. undecidable on infinite words, and decidable with non-primitive recursive lower bound for finite words). This implies that it is something more subtle than just the presence of punctual guards that makes the satisfiability checking problem hard for 1-ð–³ð–¯ð–³ð–«ð–³ð–¯ð–³ð–«\mathsf{TPTL}sansserif_TPTL. This makes a strong case for studying non-adjacency of ð–³ð–¯ð–³ð–«ð–³ð–¯ð–³ð–«\mathsf{TPTL}sansserif_TPTL. (2) We define the notion of partial adjacency, generalizing the notion of non-adjacency. Here, we allow adjacent guards but only in one direction. We show that Partially Punctual One variable Timed Propositional Temporal Logic (ð–¯ð– â¢-â¢ðŸ£â¢-â¢ð–³ð–¯ð–³ð–«ð–¯ð– -1-ð–³ð–¯ð–³ð–«\mathsf{PA\text{-}1\text{-}TPTL}sansserif_PA - sansserif_1 - sansserif_TPTL) is decidable over finite timed words. Moreover, this logic is the most expressive known decidable subclass of the logic known till date."
